#include "tensorflow/cc/ops/const_op.h"
#include "generated.h"

GcsConfigureBlockCache::GcsConfigureBlockCache(tensorflow::Scope& scope, 
           tensorflow::Input max_cache_size, 
           tensorflow::Input block_size, 
           tensorflow::Input max_staleness) {
      if (!scope.ok())
          return;
      auto _max_cache_size = ::tensorflow::ops::AsNodeOut(scope, max_cache_size);
      if (!scope.ok())
          return;
      auto _block_size = ::tensorflow::ops::AsNodeOut(scope, block_size);
      if (!scope.ok())
          return;
      auto _max_staleness = ::tensorflow::ops::AsNodeOut(scope, max_staleness);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GcsConfigureBlockCache");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GcsConfigureBlockCache")
                                   .Input(_max_cache_size)
                                   .Input(_block_size)
                                   .Input(_max_staleness)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

GenerateBigQueryReaderPartitions::GenerateBigQueryReaderPartitions(tensorflow::Scope& scope, 
           tensorflow::string project_id, 
           tensorflow::string dataset_id, 
           tensorflow::string table_id, 
           tensorflow::gtl::ArraySlice<tensorflow::string> columns, 
           tensorflow::string test_end_point, 
           int64_t timestamp_millis, 
           int64_t num_partitions) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GenerateBigQueryReaderPartitions");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GenerateBigQueryReaderPartitions")
                                   .Attr("project_id", project_id)
                                   .Attr("dataset_id", dataset_id)
                                   .Attr("table_id", table_id)
                                   .Attr("columns", columns)
                                   .Attr("test_end_point", test_end_point)
                                   .Attr("timestamp_millis", timestamp_millis)
                                   .Attr("num_partitions", num_partitions)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Fact::Fact(tensorflow::Scope& scope) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Fact");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Fact")
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyAddSign::ResourceApplyAddSign(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input lr, 
           tensorflow::Input alpha, 
           tensorflow::Input sign_decay, 
           tensorflow::Input beta, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _sign_decay = ::tensorflow::ops::AsNodeOut(scope, sign_decay);
      if (!scope.ok())
          return;
      auto _beta = ::tensorflow::ops::AsNodeOut(scope, beta);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAddSign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAddSign")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_lr)
                                   .Input(_alpha)
                                   .Input(_sign_decay)
                                   .Input(_beta)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceSparseApplyRMSProp::ResourceSparseApplyRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyRMSProp")
                                   .Input(_var)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceSparseApplyCenteredRMSProp::ResourceSparseApplyCenteredRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input mg, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _mg = ::tensorflow::ops::AsNodeOut(scope, mg);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyCenteredRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyCenteredRMSProp")
                                   .Input(_var)
                                   .Input(_mg)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SparseApplyCenteredRMSProp::SparseApplyCenteredRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input mg, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _mg = ::tensorflow::ops::AsNodeOut(scope, mg);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyCenteredRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyCenteredRMSProp")
                                   .Input(_var)
                                   .Input(_mg)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseApplyRMSProp::SparseApplyRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyRMSProp")
                                   .Input(_var)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyRMSProp::ApplyRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyRMSProp")
                                   .Input(_var)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyAdaMax::ResourceApplyAdaMax(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input beta1_power, 
           tensorflow::Input lr, 
           tensorflow::Input beta1, 
           tensorflow::Input beta2, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _beta1_power = ::tensorflow::ops::AsNodeOut(scope, beta1_power);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _beta1 = ::tensorflow::ops::AsNodeOut(scope, beta1);
      if (!scope.ok())
          return;
      auto _beta2 = ::tensorflow::ops::AsNodeOut(scope, beta2);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAdaMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAdaMax")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_beta1_power)
                                   .Input(_lr)
                                   .Input(_beta1)
                                   .Input(_beta2)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ApplyAdaMax::ApplyAdaMax(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input beta1_power, 
           tensorflow::Input lr, 
           tensorflow::Input beta1, 
           tensorflow::Input beta2, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _beta1_power = ::tensorflow::ops::AsNodeOut(scope, beta1_power);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _beta1 = ::tensorflow::ops::AsNodeOut(scope, beta1);
      if (!scope.ok())
          return;
      auto _beta2 = ::tensorflow::ops::AsNodeOut(scope, beta2);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyAdaMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyAdaMax")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_beta1_power)
                                   .Input(_lr)
                                   .Input(_beta1)
                                   .Input(_beta2)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyAdam::ApplyAdam(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input beta1_power, 
           tensorflow::Input beta2_power, 
           tensorflow::Input lr, 
           tensorflow::Input beta1, 
           tensorflow::Input beta2, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _beta1_power = ::tensorflow::ops::AsNodeOut(scope, beta1_power);
      if (!scope.ok())
          return;
      auto _beta2_power = ::tensorflow::ops::AsNodeOut(scope, beta2_power);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _beta1 = ::tensorflow::ops::AsNodeOut(scope, beta1);
      if (!scope.ok())
          return;
      auto _beta2 = ::tensorflow::ops::AsNodeOut(scope, beta2);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyAdam");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyAdam")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_beta1_power)
                                   .Input(_beta2_power)
                                   .Input(_lr)
                                   .Input(_beta1)
                                   .Input(_beta2)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceSparseApplyKerasMomentum::ResourceSparseApplyKerasMomentum(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input momentum, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyKerasMomentum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyKerasMomentum")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_momentum)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceApplyKerasMomentum::ResourceApplyKerasMomentum(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input momentum, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyKerasMomentum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyKerasMomentum")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_momentum)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceSparseApplyMomentum::ResourceSparseApplyMomentum(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input momentum, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyMomentum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyMomentum")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_momentum)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceApplyMomentum::ResourceApplyMomentum(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input momentum, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyMomentum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyMomentum")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_momentum)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceSparseApplyFtrlV2::ResourceSparseApplyFtrlV2(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input l2_shrinkage, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _l2_shrinkage = ::tensorflow::ops::AsNodeOut(scope, l2_shrinkage);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyFtrlV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyFtrlV2")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_l2_shrinkage)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceSparseApplyFtrl::ResourceSparseApplyFtrl(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyFtrl");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyFtrl")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SparseApplyFtrl::SparseApplyFtrl(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyFtrl");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyFtrl")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyFtrl::ApplyFtrl(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyFtrl");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyFtrl")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceSparseApplyAdagradDA::ResourceSparseApplyAdagradDA(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input gradient_accumulator, 
           tensorflow::Input gradient_squared_accumulator, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input global_step, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _gradient_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_accumulator);
      if (!scope.ok())
          return;
      auto _gradient_squared_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_squared_accumulator);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _global_step = ::tensorflow::ops::AsNodeOut(scope, global_step);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyAdagradDA");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyAdagradDA")
                                   .Input(_var)
                                   .Input(_gradient_accumulator)
                                   .Input(_gradient_squared_accumulator)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_global_step)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SparseApplyProximalAdagrad::SparseApplyProximalAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyProximalAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyProximalAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseApplyAdagradDA::SparseApplyAdagradDA(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input gradient_accumulator, 
           tensorflow::Input gradient_squared_accumulator, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input global_step, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _gradient_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_accumulator);
      if (!scope.ok())
          return;
      auto _gradient_squared_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_squared_accumulator);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _global_step = ::tensorflow::ops::AsNodeOut(scope, global_step);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyAdagradDA");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyAdagradDA")
                                   .Input(_var)
                                   .Input(_gradient_accumulator)
                                   .Input(_gradient_squared_accumulator)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_global_step)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyAdagradDA::ApplyAdagradDA(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input gradient_accumulator, 
           tensorflow::Input gradient_squared_accumulator, 
           tensorflow::Input grad, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input global_step, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _gradient_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_accumulator);
      if (!scope.ok())
          return;
      auto _gradient_squared_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_squared_accumulator);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _global_step = ::tensorflow::ops::AsNodeOut(scope, global_step);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyAdagradDA");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyAdagradDA")
                                   .Input(_var)
                                   .Input(_gradient_accumulator)
                                   .Input(_gradient_squared_accumulator)
                                   .Input(_grad)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_global_step)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceSparseApplyAdagrad::ResourceSparseApplyAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool update_slots, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("update_slots", update_slots)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SparseApplyAdagrad::SparseApplyAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool update_slots, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("update_slots", update_slots)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyAdagrad::ResourceApplyAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           bool update_slots, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Attr("update_slots", update_slots)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ApplyAdagrad::ApplyAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           bool update_slots, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Attr("update_slots", update_slots)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseApplyAdadelta::SparseApplyAdadelta(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input accum_update, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _accum_update = ::tensorflow::ops::AsNodeOut(scope, accum_update);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyAdadelta");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyAdadelta")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_accum_update)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyAdadelta::ApplyAdadelta(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input accum_update, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _accum_update = ::tensorflow::ops::AsNodeOut(scope, accum_update);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyAdadelta");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyAdadelta")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_accum_update)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceSparseApplyProximalGradientDescent::ResourceSparseApplyProximalGradientDescent(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input alpha, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyProximalGradientDescent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyProximalGradientDescent")
                                   .Input(_var)
                                   .Input(_alpha)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceApplyProximalGradientDescent::ResourceApplyProximalGradientDescent(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input alpha, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input delta, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyProximalGradientDescent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyProximalGradientDescent")
                                   .Input(_var)
                                   .Input(_alpha)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_delta)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ApplyProximalGradientDescent::ApplyProximalGradientDescent(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input alpha, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input delta, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyProximalGradientDescent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyProximalGradientDescent")
                                   .Input(_var)
                                   .Input(_alpha)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_delta)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnicodeDecodeWithOffsets::UnicodeDecodeWithOffsets(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string input_encoding, 
           tensorflow::string errors, 
           int64_t replacement_char, 
           bool replace_control_characters) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnicodeDecodeWithOffsets");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnicodeDecodeWithOffsets")
                                   .Input(_input)
                                   .Attr("input_encoding", input_encoding)
                                   .Attr("errors", errors)
                                   .Attr("replacement_char", replacement_char)
                                   .Attr("replace_control_characters", replace_control_characters)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnicodeTranscode::UnicodeTranscode(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string input_encoding, 
           tensorflow::string output_encoding, 
           tensorflow::string errors, 
           int64_t replacement_char, 
           bool replace_control_characters) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnicodeTranscode");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnicodeTranscode")
                                   .Input(_input)
                                   .Attr("input_encoding", input_encoding)
                                   .Attr("output_encoding", output_encoding)
                                   .Attr("errors", errors)
                                   .Attr("replacement_char", replacement_char)
                                   .Attr("replace_control_characters", replace_control_characters)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Substr::Substr(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input pos, 
           tensorflow::Input len, 
           tensorflow::string unit) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _pos = ::tensorflow::ops::AsNodeOut(scope, pos);
      if (!scope.ok())
          return;
      auto _len = ::tensorflow::ops::AsNodeOut(scope, len);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Substr");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Substr")
                                   .Input(_input)
                                   .Input(_pos)
                                   .Input(_len)
                                   .Attr("unit", unit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeBase64::DecodeBase64(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeBase64");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeBase64")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EncodeBase64::EncodeBase64(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool pad) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EncodeBase64");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EncodeBase64")
                                   .Input(_input)
                                   .Attr("pad", pad)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringSplit::StringSplit(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input delimiter, 
           bool skip_empty) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _delimiter = ::tensorflow::ops::AsNodeOut(scope, delimiter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringSplit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringSplit")
                                   .Input(_input)
                                   .Input(_delimiter)
                                   .Attr("skip_empty", skip_empty)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringJoin::StringJoin(tensorflow::Scope& scope, 
           tensorflow::InputList inputs, 
           tensorflow::string separator) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringJoin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringJoin")
                                   .Input(_inputs)
                                   .Attr("separator", separator)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReduceJoin::ReduceJoin(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::Input reduction_indices, 
           tensorflow::string separator, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReduceJoin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReduceJoin")
                                   .Input(_inputs)
                                   .Input(_reduction_indices)
                                   .Attr("separator", separator)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringToHashBucketFast::StringToHashBucketFast(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           int64_t num_buckets) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringToHashBucketFast");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringToHashBucketFast")
                                   .Input(_input)
                                   .Attr("num_buckets", num_buckets)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StaticRegexReplace::StaticRegexReplace(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string pattern, 
           tensorflow::string rewrite, 
           bool replace_global) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StaticRegexReplace");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StaticRegexReplace")
                                   .Input(_input)
                                   .Attr("pattern", pattern)
                                   .Attr("rewrite", rewrite)
                                   .Attr("replace_global", replace_global)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RegexReplace::RegexReplace(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input pattern, 
           tensorflow::Input rewrite, 
           bool replace_global) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _pattern = ::tensorflow::ops::AsNodeOut(scope, pattern);
      if (!scope.ok())
          return;
      auto _rewrite = ::tensorflow::ops::AsNodeOut(scope, rewrite);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RegexReplace");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RegexReplace")
                                   .Input(_input)
                                   .Input(_pattern)
                                   .Input(_rewrite)
                                   .Attr("replace_global", replace_global)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessMultinomial::StatelessMultinomial(tensorflow::Scope& scope, 
           tensorflow::Input logits, 
           tensorflow::Input num_samples, 
           tensorflow::Input seed) {
      if (!scope.ok())
          return;
      auto _logits = ::tensorflow::ops::AsNodeOut(scope, logits);
      if (!scope.ok())
          return;
      auto _num_samples = ::tensorflow::ops::AsNodeOut(scope, num_samples);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessMultinomial");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessMultinomial")
                                   .Input(_logits)
                                   .Input(_num_samples)
                                   .Input(_seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessRandomUniformInt::StatelessRandomUniformInt(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input seed, 
           tensorflow::Input minval, 
           tensorflow::Input maxval, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      if (!scope.ok())
          return;
      auto _minval = ::tensorflow::ops::AsNodeOut(scope, minval);
      if (!scope.ok())
          return;
      auto _maxval = ::tensorflow::ops::AsNodeOut(scope, maxval);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessRandomUniformInt");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessRandomUniformInt")
                                   .Input(_shape)
                                   .Input(_seed)
                                   .Input(_minval)
                                   .Input(_maxval)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessRandomNormal::StatelessRandomNormal(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input seed, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessRandomNormal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessRandomNormal")
                                   .Input(_shape)
                                   .Input(_seed)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessRandomUniform::StatelessRandomUniform(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input seed, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessRandomUniform");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessRandomUniform")
                                   .Input(_shape)
                                   .Input(_seed)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CountUpTo::CountUpTo(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           int64_t limit) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CountUpTo");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CountUpTo")
                                   .Input(_ref)
                                   .Attr("limit", limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceScatterNdUpdate::ResourceScatterNdUpdate(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterNdUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterNdUpdate")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ScatterNdUpdate::ScatterNdUpdate(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterNdUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterNdUpdate")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterMax::ScatterMax(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterMax")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterMul::ScatterMul(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterMul")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterSub::ScatterSub(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterSub")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterAdd::ScatterAdd(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterAdd")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterUpdate::ScatterUpdate(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterUpdate")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AssignSub::AssignSub(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input value, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AssignSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AssignSub")
                                   .Input(_ref)
                                   .Input(_value)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Assign::Assign(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input value, 
           bool use_locking, 
           bool validate_shape) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Assign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Assign")
                                   .Input(_ref)
                                   .Input(_value)
                                   .Attr("use_locking", use_locking)
                                   .Attr("validate_shape", validate_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DestroyTemporaryVariable::DestroyTemporaryVariable(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::string var_name) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DestroyTemporaryVariable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DestroyTemporaryVariable")
                                   .Input(_ref)
                                   .Attr("var_name", var_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TemporaryVariable::TemporaryVariable(tensorflow::Scope& scope, 
           tensorflow::string var_name, 
           tensorflow::PartialTensorShape shape, 
           tensorflow::DataType dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TemporaryVariable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TemporaryVariable")
                                   .Attr("var_name", var_name)
                                   .Attr("shape", shape)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IsVariableInitialized::IsVariableInitialized(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IsVariableInitialized");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IsVariableInitialized")
                                   .Input(_ref)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

VariableV2::VariableV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::PartialTensorShape shape, 
           tensorflow::DataType dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("VariableV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "VariableV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("shape", shape)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchFFT2D::BatchFFT2D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchFFT2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchFFT2D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchFFT::BatchFFT(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchFFT");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchFFT")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IRFFT3D::IRFFT3D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input fft_length) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _fft_length = ::tensorflow::ops::AsNodeOut(scope, fft_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IRFFT3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IRFFT3D")
                                   .Input(_input)
                                   .Input(_fft_length)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IRFFT2D::IRFFT2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input fft_length) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _fft_length = ::tensorflow::ops::AsNodeOut(scope, fft_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IRFFT2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IRFFT2D")
                                   .Input(_input)
                                   .Input(_fft_length)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RFFT2D::RFFT2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input fft_length) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _fft_length = ::tensorflow::ops::AsNodeOut(scope, fft_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RFFT2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RFFT2D")
                                   .Input(_input)
                                   .Input(_fft_length)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IRFFT::IRFFT(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input fft_length) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _fft_length = ::tensorflow::ops::AsNodeOut(scope, fft_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IRFFT");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IRFFT")
                                   .Input(_input)
                                   .Input(_fft_length)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RFFT::RFFT(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input fft_length) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _fft_length = ::tensorflow::ops::AsNodeOut(scope, fft_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RFFT");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RFFT")
                                   .Input(_input)
                                   .Input(_fft_length)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FFT3D::FFT3D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FFT3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FFT3D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IFFT2D::IFFT2D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IFFT2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IFFT2D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FFT2D::FFT2D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FFT2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FFT2D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IFFT::IFFT(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IFFT");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IFFT")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FFT::FFT(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FFT");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FFT")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteScalarSummary::WriteScalarSummary(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input step, 
           tensorflow::Input tag, 
           tensorflow::Input value) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteScalarSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteScalarSummary")
                                   .Input(_writer)
                                   .Input(_step)
                                   .Input(_tag)
                                   .Input(_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

CloseSummaryWriter::CloseSummaryWriter(tensorflow::Scope& scope, 
           tensorflow::Input writer) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CloseSummaryWriter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CloseSummaryWriter")
                                   .Input(_writer)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

FlushSummaryWriter::FlushSummaryWriter(tensorflow::Scope& scope, 
           tensorflow::Input writer) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FlushSummaryWriter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FlushSummaryWriter")
                                   .Input(_writer)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

CreateSummaryDbWriter::CreateSummaryDbWriter(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input db_uri, 
           tensorflow::Input experiment_name, 
           tensorflow::Input run_name, 
           tensorflow::Input user_name) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _db_uri = ::tensorflow::ops::AsNodeOut(scope, db_uri);
      if (!scope.ok())
          return;
      auto _experiment_name = ::tensorflow::ops::AsNodeOut(scope, experiment_name);
      if (!scope.ok())
          return;
      auto _run_name = ::tensorflow::ops::AsNodeOut(scope, run_name);
      if (!scope.ok())
          return;
      auto _user_name = ::tensorflow::ops::AsNodeOut(scope, user_name);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CreateSummaryDbWriter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CreateSummaryDbWriter")
                                   .Input(_writer)
                                   .Input(_db_uri)
                                   .Input(_experiment_name)
                                   .Input(_run_name)
                                   .Input(_user_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SummaryWriter::SummaryWriter(tensorflow::Scope& scope, 
           tensorflow::string shared_name, 
           tensorflow::string container) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SummaryWriter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SummaryWriter")
                                   .Attr("shared_name", shared_name)
                                   .Attr("container", container)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseFillEmptyRowsGrad::SparseFillEmptyRowsGrad(tensorflow::Scope& scope, 
           tensorflow::Input reverse_index_map, 
           tensorflow::Input grad_values) {
      if (!scope.ok())
          return;
      auto _reverse_index_map = ::tensorflow::ops::AsNodeOut(scope, reverse_index_map);
      if (!scope.ok())
          return;
      auto _grad_values = ::tensorflow::ops::AsNodeOut(scope, grad_values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseFillEmptyRowsGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseFillEmptyRowsGrad")
                                   .Input(_reverse_index_map)
                                   .Input(_grad_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseFillEmptyRows::SparseFillEmptyRows(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::Input values, 
           tensorflow::Input dense_shape, 
           tensorflow::Input default_value) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      if (!scope.ok())
          return;
      auto _dense_shape = ::tensorflow::ops::AsNodeOut(scope, dense_shape);
      if (!scope.ok())
          return;
      auto _default_value = ::tensorflow::ops::AsNodeOut(scope, default_value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseFillEmptyRows");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseFillEmptyRows")
                                   .Input(_indices)
                                   .Input(_values)
                                   .Input(_dense_shape)
                                   .Input(_default_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSparseMinimum::SparseSparseMinimum(tensorflow::Scope& scope, 
           tensorflow::Input a_indices, 
           tensorflow::Input a_values, 
           tensorflow::Input a_shape, 
           tensorflow::Input b_indices, 
           tensorflow::Input b_values, 
           tensorflow::Input b_shape) {
      if (!scope.ok())
          return;
      auto _a_indices = ::tensorflow::ops::AsNodeOut(scope, a_indices);
      if (!scope.ok())
          return;
      auto _a_values = ::tensorflow::ops::AsNodeOut(scope, a_values);
      if (!scope.ok())
          return;
      auto _a_shape = ::tensorflow::ops::AsNodeOut(scope, a_shape);
      if (!scope.ok())
          return;
      auto _b_indices = ::tensorflow::ops::AsNodeOut(scope, b_indices);
      if (!scope.ok())
          return;
      auto _b_values = ::tensorflow::ops::AsNodeOut(scope, b_values);
      if (!scope.ok())
          return;
      auto _b_shape = ::tensorflow::ops::AsNodeOut(scope, b_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSparseMinimum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSparseMinimum")
                                   .Input(_a_indices)
                                   .Input(_a_values)
                                   .Input(_a_shape)
                                   .Input(_b_indices)
                                   .Input(_b_values)
                                   .Input(_b_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSparseMaximum::SparseSparseMaximum(tensorflow::Scope& scope, 
           tensorflow::Input a_indices, 
           tensorflow::Input a_values, 
           tensorflow::Input a_shape, 
           tensorflow::Input b_indices, 
           tensorflow::Input b_values, 
           tensorflow::Input b_shape) {
      if (!scope.ok())
          return;
      auto _a_indices = ::tensorflow::ops::AsNodeOut(scope, a_indices);
      if (!scope.ok())
          return;
      auto _a_values = ::tensorflow::ops::AsNodeOut(scope, a_values);
      if (!scope.ok())
          return;
      auto _a_shape = ::tensorflow::ops::AsNodeOut(scope, a_shape);
      if (!scope.ok())
          return;
      auto _b_indices = ::tensorflow::ops::AsNodeOut(scope, b_indices);
      if (!scope.ok())
          return;
      auto _b_values = ::tensorflow::ops::AsNodeOut(scope, b_values);
      if (!scope.ok())
          return;
      auto _b_shape = ::tensorflow::ops::AsNodeOut(scope, b_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSparseMaximum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSparseMaximum")
                                   .Input(_a_indices)
                                   .Input(_a_values)
                                   .Input(_a_shape)
                                   .Input(_b_indices)
                                   .Input(_b_values)
                                   .Input(_b_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSoftmax::SparseSoftmax(tensorflow::Scope& scope, 
           tensorflow::Input sp_indices, 
           tensorflow::Input sp_values, 
           tensorflow::Input sp_shape) {
      if (!scope.ok())
          return;
      auto _sp_indices = ::tensorflow::ops::AsNodeOut(scope, sp_indices);
      if (!scope.ok())
          return;
      auto _sp_values = ::tensorflow::ops::AsNodeOut(scope, sp_values);
      if (!scope.ok())
          return;
      auto _sp_shape = ::tensorflow::ops::AsNodeOut(scope, sp_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSoftmax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSoftmax")
                                   .Input(_sp_indices)
                                   .Input(_sp_values)
                                   .Input(_sp_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseDenseCwiseAdd::SparseDenseCwiseAdd(tensorflow::Scope& scope, 
           tensorflow::Input sp_indices, 
           tensorflow::Input sp_values, 
           tensorflow::Input sp_shape, 
           tensorflow::Input dense) {
      if (!scope.ok())
          return;
      auto _sp_indices = ::tensorflow::ops::AsNodeOut(scope, sp_indices);
      if (!scope.ok())
          return;
      auto _sp_values = ::tensorflow::ops::AsNodeOut(scope, sp_values);
      if (!scope.ok())
          return;
      auto _sp_shape = ::tensorflow::ops::AsNodeOut(scope, sp_shape);
      if (!scope.ok())
          return;
      auto _dense = ::tensorflow::ops::AsNodeOut(scope, dense);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseDenseCwiseAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseDenseCwiseAdd")
                                   .Input(_sp_indices)
                                   .Input(_sp_values)
                                   .Input(_sp_shape)
                                   .Input(_dense)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseDenseCwiseDiv::SparseDenseCwiseDiv(tensorflow::Scope& scope, 
           tensorflow::Input sp_indices, 
           tensorflow::Input sp_values, 
           tensorflow::Input sp_shape, 
           tensorflow::Input dense) {
      if (!scope.ok())
          return;
      auto _sp_indices = ::tensorflow::ops::AsNodeOut(scope, sp_indices);
      if (!scope.ok())
          return;
      auto _sp_values = ::tensorflow::ops::AsNodeOut(scope, sp_values);
      if (!scope.ok())
          return;
      auto _sp_shape = ::tensorflow::ops::AsNodeOut(scope, sp_shape);
      if (!scope.ok())
          return;
      auto _dense = ::tensorflow::ops::AsNodeOut(scope, dense);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseDenseCwiseDiv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseDenseCwiseDiv")
                                   .Input(_sp_indices)
                                   .Input(_sp_values)
                                   .Input(_sp_shape)
                                   .Input(_dense)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseReduceMax::SparseReduceMax(tensorflow::Scope& scope, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_values, 
           tensorflow::Input input_shape, 
           tensorflow::Input reduction_axes, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_values = ::tensorflow::ops::AsNodeOut(scope, input_values);
      if (!scope.ok())
          return;
      auto _input_shape = ::tensorflow::ops::AsNodeOut(scope, input_shape);
      if (!scope.ok())
          return;
      auto _reduction_axes = ::tensorflow::ops::AsNodeOut(scope, reduction_axes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseReduceMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseReduceMax")
                                   .Input(_input_indices)
                                   .Input(_input_values)
                                   .Input(_input_shape)
                                   .Input(_reduction_axes)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseReshape::SparseReshape(tensorflow::Scope& scope, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_shape, 
           tensorflow::Input new_shape) {
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_shape = ::tensorflow::ops::AsNodeOut(scope, input_shape);
      if (!scope.ok())
          return;
      auto _new_shape = ::tensorflow::ops::AsNodeOut(scope, new_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseReshape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseReshape")
                                   .Input(_input_indices)
                                   .Input(_input_shape)
                                   .Input(_new_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseReorder::SparseReorder(tensorflow::Scope& scope, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_values, 
           tensorflow::Input input_shape) {
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_values = ::tensorflow::ops::AsNodeOut(scope, input_values);
      if (!scope.ok())
          return;
      auto _input_shape = ::tensorflow::ops::AsNodeOut(scope, input_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseReorder");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseReorder")
                                   .Input(_input_indices)
                                   .Input(_input_values)
                                   .Input(_input_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSlice::SparseSlice(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::Input values, 
           tensorflow::Input shape, 
           tensorflow::Input start, 
           tensorflow::Input size) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _start = ::tensorflow::ops::AsNodeOut(scope, start);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSlice");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSlice")
                                   .Input(_indices)
                                   .Input(_values)
                                   .Input(_shape)
                                   .Input(_start)
                                   .Input(_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSliceGrad::SparseSliceGrad(tensorflow::Scope& scope, 
           tensorflow::Input backprop_val_grad, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_start, 
           tensorflow::Input output_indices) {
      if (!scope.ok())
          return;
      auto _backprop_val_grad = ::tensorflow::ops::AsNodeOut(scope, backprop_val_grad);
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_start = ::tensorflow::ops::AsNodeOut(scope, input_start);
      if (!scope.ok())
          return;
      auto _output_indices = ::tensorflow::ops::AsNodeOut(scope, output_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSliceGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSliceGrad")
                                   .Input(_backprop_val_grad)
                                   .Input(_input_indices)
                                   .Input(_input_start)
                                   .Input(_output_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseCross::SparseCross(tensorflow::Scope& scope, 
           tensorflow::InputList indices, 
           tensorflow::Input values, 
           tensorflow::InputList shapes, 
           tensorflow::Input dense_inputs, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dense_types, 
           bool hashed_output, 
           int64_t num_buckets, 
           int64_t hash_key, 
           tensorflow::DataType out_type, 
           tensorflow::DataType internal_type) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOutList(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      if (!scope.ok())
          return;
      auto _shapes = ::tensorflow::ops::AsNodeOutList(scope, shapes);
      if (!scope.ok())
          return;
      auto _dense_inputs = ::tensorflow::ops::AsNodeOut(scope, dense_inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseCross");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseCross")
                                   .Input(_indices)
                                   .Input(_values)
                                   .Input(_shapes)
                                   .Input(_dense_inputs)
                                   .Attr("sparse_types", sparse_types)
                                   .Attr("dense_types", dense_types)
                                   .Attr("hashed_output", hashed_output)
                                   .Attr("num_buckets", num_buckets)
                                   .Attr("hash_key", hash_key)
                                   .Attr("out_type", out_type)
                                   .Attr("internal_type", internal_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseConcat::SparseConcat(tensorflow::Scope& scope, 
           tensorflow::InputList indices, 
           tensorflow::InputList values, 
           tensorflow::InputList shapes, 
           int64_t concat_dim) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOutList(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOutList(scope, values);
      if (!scope.ok())
          return;
      auto _shapes = ::tensorflow::ops::AsNodeOutList(scope, shapes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseConcat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseConcat")
                                   .Input(_indices)
                                   .Input(_values)
                                   .Input(_shapes)
                                   .Attr("concat_dim", concat_dim)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DeserializeManySparse::DeserializeManySparse(tensorflow::Scope& scope, 
           tensorflow::Input serialized_sparse, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _serialized_sparse = ::tensorflow::ops::AsNodeOut(scope, serialized_sparse);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DeserializeManySparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DeserializeManySparse")
                                   .Input(_serialized_sparse)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SerializeManySparse::SerializeManySparse(tensorflow::Scope& scope, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input sparse_values, 
           tensorflow::Input sparse_shape) {
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _sparse_values = ::tensorflow::ops::AsNodeOut(scope, sparse_values);
      if (!scope.ok())
          return;
      auto _sparse_shape = ::tensorflow::ops::AsNodeOut(scope, sparse_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SerializeManySparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SerializeManySparse")
                                   .Input(_sparse_indices)
                                   .Input(_sparse_values)
                                   .Input(_sparse_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SerializeSparse::SerializeSparse(tensorflow::Scope& scope, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input sparse_values, 
           tensorflow::Input sparse_shape) {
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _sparse_values = ::tensorflow::ops::AsNodeOut(scope, sparse_values);
      if (!scope.ok())
          return;
      auto _sparse_shape = ::tensorflow::ops::AsNodeOut(scope, sparse_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SerializeSparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SerializeSparse")
                                   .Input(_sparse_indices)
                                   .Input(_sparse_values)
                                   .Input(_sparse_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseAddGrad::SparseAddGrad(tensorflow::Scope& scope, 
           tensorflow::Input backprop_val_grad, 
           tensorflow::Input a_indices, 
           tensorflow::Input b_indices, 
           tensorflow::Input sum_indices) {
      if (!scope.ok())
          return;
      auto _backprop_val_grad = ::tensorflow::ops::AsNodeOut(scope, backprop_val_grad);
      if (!scope.ok())
          return;
      auto _a_indices = ::tensorflow::ops::AsNodeOut(scope, a_indices);
      if (!scope.ok())
          return;
      auto _b_indices = ::tensorflow::ops::AsNodeOut(scope, b_indices);
      if (!scope.ok())
          return;
      auto _sum_indices = ::tensorflow::ops::AsNodeOut(scope, sum_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseAddGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseAddGrad")
                                   .Input(_backprop_val_grad)
                                   .Input(_a_indices)
                                   .Input(_b_indices)
                                   .Input(_sum_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseToSparseSetOperation::SparseToSparseSetOperation(tensorflow::Scope& scope, 
           tensorflow::Input set1_indices, 
           tensorflow::Input set1_values, 
           tensorflow::Input set1_shape, 
           tensorflow::Input set2_indices, 
           tensorflow::Input set2_values, 
           tensorflow::Input set2_shape, 
           tensorflow::string set_operation, 
           bool validate_indices) {
      if (!scope.ok())
          return;
      auto _set1_indices = ::tensorflow::ops::AsNodeOut(scope, set1_indices);
      if (!scope.ok())
          return;
      auto _set1_values = ::tensorflow::ops::AsNodeOut(scope, set1_values);
      if (!scope.ok())
          return;
      auto _set1_shape = ::tensorflow::ops::AsNodeOut(scope, set1_shape);
      if (!scope.ok())
          return;
      auto _set2_indices = ::tensorflow::ops::AsNodeOut(scope, set2_indices);
      if (!scope.ok())
          return;
      auto _set2_values = ::tensorflow::ops::AsNodeOut(scope, set2_values);
      if (!scope.ok())
          return;
      auto _set2_shape = ::tensorflow::ops::AsNodeOut(scope, set2_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseToSparseSetOperation");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseToSparseSetOperation")
                                   .Input(_set1_indices)
                                   .Input(_set1_values)
                                   .Input(_set1_shape)
                                   .Input(_set2_indices)
                                   .Input(_set2_values)
                                   .Input(_set2_shape)
                                   .Attr("set_operation", set_operation)
                                   .Attr("validate_indices", validate_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DenseToDenseSetOperation::DenseToDenseSetOperation(tensorflow::Scope& scope, 
           tensorflow::Input set1, 
           tensorflow::Input set2, 
           tensorflow::string set_operation, 
           bool validate_indices) {
      if (!scope.ok())
          return;
      auto _set1 = ::tensorflow::ops::AsNodeOut(scope, set1);
      if (!scope.ok())
          return;
      auto _set2 = ::tensorflow::ops::AsNodeOut(scope, set2);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DenseToDenseSetOperation");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DenseToDenseSetOperation")
                                   .Input(_set1)
                                   .Input(_set2)
                                   .Attr("set_operation", set_operation)
                                   .Attr("validate_indices", validate_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_Recv::_Recv(tensorflow::Scope& scope, 
           tensorflow::string tensor_name, 
           tensorflow::string send_device, 
           tensorflow::string recv_device, 
           bool client_terminated, 
           int64_t send_device_incarnation) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_Recv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_Recv")
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("send_device", send_device)
                                   .Attr("recv_device", recv_device)
                                   .Attr("client_terminated", client_terminated)
                                   .Attr("send_device_incarnation", send_device_incarnation)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_Send::_Send(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::string tensor_name, 
           tensorflow::string send_device, 
           tensorflow::string recv_device, 
           bool client_terminated, 
           int64_t send_device_incarnation) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_Send");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_Send")
                                   .Input(_tensor)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("send_device", send_device)
                                   .Attr("recv_device", recv_device)
                                   .Attr("client_terminated", client_terminated)
                                   .Attr("send_device_incarnation", send_device_incarnation)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SdcaFprint::SdcaFprint(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SdcaFprint");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SdcaFprint")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SdcaShrinkL1::SdcaShrinkL1(tensorflow::Scope& scope, 
           tensorflow::Input weights, 
           int64_t num_features, 
           float l1, 
           float l2) {
      if (!scope.ok())
          return;
      auto _weights = ::tensorflow::ops::AsNodeOut(scope, weights);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SdcaShrinkL1");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SdcaShrinkL1")
                                   .Input(_weights)
                                   .Attr("num_features", num_features)
                                   .Attr("l1", l1)
                                   .Attr("l2", l2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SdcaOptimizerV2::SdcaOptimizerV2(tensorflow::Scope& scope, 
           tensorflow::Input sparse_example_indices, 
           tensorflow::Input sparse_feature_indices, 
           tensorflow::Input sparse_feature_values, 
           tensorflow::Input dense_features, 
           tensorflow::Input example_weights, 
           tensorflow::Input example_labels, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input sparse_weights, 
           tensorflow::Input dense_weights, 
           tensorflow::Input example_state_data, 
           tensorflow::string loss_type, 
           bool adaptive, 
           int64_t num_sparse_features, 
           int64_t num_sparse_features_with_values, 
           int64_t num_dense_features, 
           float l1, 
           float l2, 
           int64_t num_loss_partitions, 
           int64_t num_inner_iterations) {
      if (!scope.ok())
          return;
      auto _sparse_example_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_example_indices);
      if (!scope.ok())
          return;
      auto _sparse_feature_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_feature_indices);
      if (!scope.ok())
          return;
      auto _sparse_feature_values = ::tensorflow::ops::AsNodeOut(scope, sparse_feature_values);
      if (!scope.ok())
          return;
      auto _dense_features = ::tensorflow::ops::AsNodeOut(scope, dense_features);
      if (!scope.ok())
          return;
      auto _example_weights = ::tensorflow::ops::AsNodeOut(scope, example_weights);
      if (!scope.ok())
          return;
      auto _example_labels = ::tensorflow::ops::AsNodeOut(scope, example_labels);
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _sparse_weights = ::tensorflow::ops::AsNodeOut(scope, sparse_weights);
      if (!scope.ok())
          return;
      auto _dense_weights = ::tensorflow::ops::AsNodeOut(scope, dense_weights);
      if (!scope.ok())
          return;
      auto _example_state_data = ::tensorflow::ops::AsNodeOut(scope, example_state_data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SdcaOptimizerV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SdcaOptimizerV2")
                                   .Input(_sparse_example_indices)
                                   .Input(_sparse_feature_indices)
                                   .Input(_sparse_feature_values)
                                   .Input(_dense_features)
                                   .Input(_example_weights)
                                   .Input(_example_labels)
                                   .Input(_sparse_indices)
                                   .Input(_sparse_weights)
                                   .Input(_dense_weights)
                                   .Input(_example_state_data)
                                   .Attr("loss_type", loss_type)
                                   .Attr("adaptive", adaptive)
                                   .Attr("num_sparse_features", num_sparse_features)
                                   .Attr("num_sparse_features_with_values", num_sparse_features_with_values)
                                   .Attr("num_dense_features", num_dense_features)
                                   .Attr("l1", l1)
                                   .Attr("l2", l2)
                                   .Attr("num_loss_partitions", num_loss_partitions)
                                   .Attr("num_inner_iterations", num_inner_iterations)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SdcaOptimizer::SdcaOptimizer(tensorflow::Scope& scope, 
           tensorflow::Input sparse_example_indices, 
           tensorflow::Input sparse_feature_indices, 
           tensorflow::Input sparse_feature_values, 
           tensorflow::Input dense_features, 
           tensorflow::Input example_weights, 
           tensorflow::Input example_labels, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input sparse_weights, 
           tensorflow::Input dense_weights, 
           tensorflow::Input example_state_data, 
           tensorflow::string loss_type, 
           bool adaptative, 
           int64_t num_sparse_features, 
           int64_t num_sparse_features_with_values, 
           int64_t num_dense_features, 
           float l1, 
           float l2, 
           int64_t num_loss_partitions, 
           int64_t num_inner_iterations) {
      if (!scope.ok())
          return;
      auto _sparse_example_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_example_indices);
      if (!scope.ok())
          return;
      auto _sparse_feature_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_feature_indices);
      if (!scope.ok())
          return;
      auto _sparse_feature_values = ::tensorflow::ops::AsNodeOut(scope, sparse_feature_values);
      if (!scope.ok())
          return;
      auto _dense_features = ::tensorflow::ops::AsNodeOut(scope, dense_features);
      if (!scope.ok())
          return;
      auto _example_weights = ::tensorflow::ops::AsNodeOut(scope, example_weights);
      if (!scope.ok())
          return;
      auto _example_labels = ::tensorflow::ops::AsNodeOut(scope, example_labels);
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _sparse_weights = ::tensorflow::ops::AsNodeOut(scope, sparse_weights);
      if (!scope.ok())
          return;
      auto _dense_weights = ::tensorflow::ops::AsNodeOut(scope, dense_weights);
      if (!scope.ok())
          return;
      auto _example_state_data = ::tensorflow::ops::AsNodeOut(scope, example_state_data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SdcaOptimizer");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SdcaOptimizer")
                                   .Input(_sparse_example_indices)
                                   .Input(_sparse_feature_indices)
                                   .Input(_sparse_feature_values)
                                   .Input(_dense_features)
                                   .Input(_example_weights)
                                   .Input(_example_labels)
                                   .Input(_sparse_indices)
                                   .Input(_sparse_weights)
                                   .Input(_dense_weights)
                                   .Input(_example_state_data)
                                   .Attr("loss_type", loss_type)
                                   .Attr("adaptative", adaptative)
                                   .Attr("num_sparse_features", num_sparse_features)
                                   .Attr("num_sparse_features_with_values", num_sparse_features_with_values)
                                   .Attr("num_dense_features", num_dense_features)
                                   .Attr("l1", l1)
                                   .Attr("l2", l2)
                                   .Attr("num_loss_partitions", num_loss_partitions)
                                   .Attr("num_inner_iterations", num_inner_iterations)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EagerPyFunc::EagerPyFunc(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string token, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EagerPyFunc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EagerPyFunc")
                                   .Input(_input)
                                   .Attr("token", token)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PyFuncStateless::PyFuncStateless(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string token, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PyFuncStateless");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PyFuncStateless")
                                   .Input(_input)
                                   .Attr("token", token)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_ScopedAllocatorSplit::_ScopedAllocatorSplit(tensorflow::Scope& scope, 
           tensorflow::Input concat, 
           tensorflow::InputList split, 
           tensorflow::string sa_name, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           int64_t id) {
      if (!scope.ok())
          return;
      auto _concat = ::tensorflow::ops::AsNodeOut(scope, concat);
      if (!scope.ok())
          return;
      auto _split = ::tensorflow::ops::AsNodeOutList(scope, split);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ScopedAllocatorSplit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ScopedAllocatorSplit")
                                   .Input(_concat)
                                   .Input(_split)
                                   .Attr("sa_name", sa_name)
                                   .Attr("shapes", shapes)
                                   .Attr("id", id)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      for (tensorflow::int32 i = 0; i < ret->num_outputs(); ++i)
          this->output.push_back(tensorflow::Output(ret, i));
}

_ScopedAllocator::_ScopedAllocator(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string sa_name, 
           tensorflow::PartialTensorShape shape, 
           int64_t expected_call_count, 
           int64_t id) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ScopedAllocator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ScopedAllocator")
                                   .Attr("shapes", shapes)
                                   .Attr("sa_name", sa_name)
                                   .Attr("shape", shape)
                                   .Attr("expected_call_count", expected_call_count)
                                   .Attr("id", id)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ConsumeMutexLock::ConsumeMutexLock(tensorflow::Scope& scope, 
           tensorflow::Input mutex_lock) {
      if (!scope.ok())
          return;
      auto _mutex_lock = ::tensorflow::ops::AsNodeOut(scope, mutex_lock);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ConsumeMutexLock");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ConsumeMutexLock")
                                   .Input(_mutex_lock)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MutexLock::MutexLock(tensorflow::Scope& scope, 
           tensorflow::Input mutex) {
      if (!scope.ok())
          return;
      auto _mutex = ::tensorflow::ops::AsNodeOut(scope, mutex);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutexLock");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutexLock")
                                   .Input(_mutex)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MutexV2::MutexV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutexV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutexV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceScatterUpdate::ResourceScatterUpdate(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterUpdate")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceScatterMin::ResourceScatterMin(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterMin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterMin")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceScatterAdd::ResourceScatterAdd(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterAdd")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

VariableShape::VariableShape(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("VariableShape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "VariableShape")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RemoteFusedGraphExecute::RemoteFusedGraphExecute(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tinputs, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Toutputs, 
           tensorflow::string serialized_remote_fused_graph_execute_info) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RemoteFusedGraphExecute");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RemoteFusedGraphExecute")
                                   .Input(_inputs)
                                   .Attr("Tinputs", Tinputs)
                                   .Attr("Toutputs", Toutputs)
                                   .Attr("serialized_remote_fused_graph_execute_info", serialized_remote_fused_graph_execute_info)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomPoissonV2::RandomPoissonV2(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input rate, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _rate = ::tensorflow::ops::AsNodeOut(scope, rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomPoissonV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomPoissonV2")
                                   .Input(_shape)
                                   .Input(_rate)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomPoisson::RandomPoisson(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input rate, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _rate = ::tensorflow::ops::AsNodeOut(scope, rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomPoisson");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomPoisson")
                                   .Input(_shape)
                                   .Input(_rate)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomGammaGrad::RandomGammaGrad(tensorflow::Scope& scope, 
           tensorflow::Input alpha, 
           tensorflow::Input sample) {
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _sample = ::tensorflow::ops::AsNodeOut(scope, sample);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomGammaGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomGammaGrad")
                                   .Input(_alpha)
                                   .Input(_sample)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Multinomial::Multinomial(tensorflow::Scope& scope, 
           tensorflow::Input logits, 
           tensorflow::Input num_samples, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _logits = ::tensorflow::ops::AsNodeOut(scope, logits);
      if (!scope.ok())
          return;
      auto _num_samples = ::tensorflow::ops::AsNodeOut(scope, num_samples);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Multinomial");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Multinomial")
                                   .Input(_logits)
                                   .Input(_num_samples)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomShuffle::RandomShuffle(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomShuffle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomShuffle")
                                   .Input(_value)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParameterizedTruncatedNormal::ParameterizedTruncatedNormal(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input means, 
           tensorflow::Input stdevs, 
           tensorflow::Input minvals, 
           tensorflow::Input maxvals, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _means = ::tensorflow::ops::AsNodeOut(scope, means);
      if (!scope.ok())
          return;
      auto _stdevs = ::tensorflow::ops::AsNodeOut(scope, stdevs);
      if (!scope.ok())
          return;
      auto _minvals = ::tensorflow::ops::AsNodeOut(scope, minvals);
      if (!scope.ok())
          return;
      auto _maxvals = ::tensorflow::ops::AsNodeOut(scope, maxvals);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParameterizedTruncatedNormal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParameterizedTruncatedNormal")
                                   .Input(_shape)
                                   .Input(_means)
                                   .Input(_stdevs)
                                   .Input(_minvals)
                                   .Input(_maxvals)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomUniformInt::RandomUniformInt(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input minval, 
           tensorflow::Input maxval, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _minval = ::tensorflow::ops::AsNodeOut(scope, minval);
      if (!scope.ok())
          return;
      auto _maxval = ::tensorflow::ops::AsNodeOut(scope, maxval);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomUniformInt");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomUniformInt")
                                   .Input(_shape)
                                   .Input(_minval)
                                   .Input(_maxval)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomUniform::RandomUniform(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomUniform");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomUniform")
                                   .Input(_shape)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RaggedGather::RaggedGather(tensorflow::Scope& scope, 
           tensorflow::Input params_nested_splits, 
           tensorflow::Input params_dense_values, 
           tensorflow::Input indices, 
           int64_t OUTPUT_RAGGED_RANK, 
           int64_t PARAMS_RAGGED_RANK) {
      if (!scope.ok())
          return;
      auto _params_nested_splits = ::tensorflow::ops::AsNodeOut(scope, params_nested_splits);
      if (!scope.ok())
          return;
      auto _params_dense_values = ::tensorflow::ops::AsNodeOut(scope, params_dense_values);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RaggedGather");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RaggedGather")
                                   .Input(_params_nested_splits)
                                   .Input(_params_dense_values)
                                   .Input(_indices)
                                   .Attr("OUTPUT_RAGGED_RANK", OUTPUT_RAGGED_RANK)
                                   .Attr("PARAMS_RAGGED_RANK", PARAMS_RAGGED_RANK)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchIFFT2D::BatchIFFT2D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchIFFT2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchIFFT2D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringToNumber::StringToNumber(tensorflow::Scope& scope, 
           tensorflow::Input string_tensor) {
      if (!scope.ok())
          return;
      auto _string_tensor = ::tensorflow::ops::AsNodeOut(scope, string_tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringToNumber");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringToNumber")
                                   .Input(_string_tensor)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeJSONExample::DecodeJSONExample(tensorflow::Scope& scope, 
           tensorflow::Input json_examples) {
      if (!scope.ok())
          return;
      auto _json_examples = ::tensorflow::ops::AsNodeOut(scope, json_examples);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeJSONExample");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeJSONExample")
                                   .Input(_json_examples)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SerializeTensor::SerializeTensor(tensorflow::Scope& scope, 
           tensorflow::Input tensor) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SerializeTensor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SerializeTensor")
                                   .Input(_tensor)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParseTensor::ParseTensor(tensorflow::Scope& scope, 
           tensorflow::Input serialized) {
      if (!scope.ok())
          return;
      auto _serialized = ::tensorflow::ops::AsNodeOut(scope, serialized);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParseTensor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParseTensor")
                                   .Input(_serialized)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParseSequenceExample::ParseSequenceExample(tensorflow::Scope& scope, 
           tensorflow::Input serialized, 
           tensorflow::Input debug_name, 
           tensorflow::Input context_dense_defaults, 
           tensorflow::gtl::ArraySlice<tensorflow::string> feature_list_dense_missing_assumed_empty, 
           tensorflow::gtl::ArraySlice<tensorflow::string> context_sparse_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::string> context_dense_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::string> feature_list_sparse_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::string> feature_list_dense_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> context_sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcontext_dense, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> feature_list_dense_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> context_dense_shapes, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> feature_list_sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> feature_list_dense_shapes, 
           int64_t Ncontext_sparse, 
           int64_t Ncontext_dense, 
           int64_t Nfeature_list_sparse, 
           int64_t Nfeature_list_dense) {
      if (!scope.ok())
          return;
      auto _serialized = ::tensorflow::ops::AsNodeOut(scope, serialized);
      if (!scope.ok())
          return;
      auto _debug_name = ::tensorflow::ops::AsNodeOut(scope, debug_name);
      if (!scope.ok())
          return;
      auto _context_dense_defaults = ::tensorflow::ops::AsNodeOut(scope, context_dense_defaults);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParseSequenceExample");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParseSequenceExample")
                                   .Input(_serialized)
                                   .Input(_debug_name)
                                   .Input(_context_dense_defaults)
                                   .Attr("feature_list_dense_missing_assumed_empty", feature_list_dense_missing_assumed_empty)
                                   .Attr("context_sparse_keys", context_sparse_keys)
                                   .Attr("context_dense_keys", context_dense_keys)
                                   .Attr("feature_list_sparse_keys", feature_list_sparse_keys)
                                   .Attr("feature_list_dense_keys", feature_list_dense_keys)
                                   .Attr("context_sparse_types", context_sparse_types)
                                   .Attr("Tcontext_dense", Tcontext_dense)
                                   .Attr("feature_list_dense_types", feature_list_dense_types)
                                   .Attr("context_dense_shapes", context_dense_shapes)
                                   .Attr("feature_list_sparse_types", feature_list_sparse_types)
                                   .Attr("feature_list_dense_shapes", feature_list_dense_shapes)
                                   .Attr("Ncontext_sparse", Ncontext_sparse)
                                   .Attr("Ncontext_dense", Ncontext_dense)
                                   .Attr("Nfeature_list_sparse", Nfeature_list_sparse)
                                   .Attr("Nfeature_list_dense", Nfeature_list_dense)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParseExample::ParseExample(tensorflow::Scope& scope, 
           tensorflow::Input serialized, 
           tensorflow::Input names, 
           tensorflow::Input sparse_keys, 
           tensorflow::Input dense_keys, 
           tensorflow::Input dense_defaults, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tdense, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> dense_shapes, 
           int64_t Nsparse, 
           int64_t Ndense) {
      if (!scope.ok())
          return;
      auto _serialized = ::tensorflow::ops::AsNodeOut(scope, serialized);
      if (!scope.ok())
          return;
      auto _names = ::tensorflow::ops::AsNodeOut(scope, names);
      if (!scope.ok())
          return;
      auto _sparse_keys = ::tensorflow::ops::AsNodeOut(scope, sparse_keys);
      if (!scope.ok())
          return;
      auto _dense_keys = ::tensorflow::ops::AsNodeOut(scope, dense_keys);
      if (!scope.ok())
          return;
      auto _dense_defaults = ::tensorflow::ops::AsNodeOut(scope, dense_defaults);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParseExample");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParseExample")
                                   .Input(_serialized)
                                   .Input(_names)
                                   .Input(_sparse_keys)
                                   .Input(_dense_keys)
                                   .Input(_dense_defaults)
                                   .Attr("sparse_types", sparse_types)
                                   .Attr("Tdense", Tdense)
                                   .Attr("dense_shapes", dense_shapes)
                                   .Attr("Nsparse", Nsparse)
                                   .Attr("Ndense", Ndense)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeCompressed::DecodeCompressed(tensorflow::Scope& scope, 
           tensorflow::Input bytes, 
           tensorflow::string compression_type) {
      if (!scope.ok())
          return;
      auto _bytes = ::tensorflow::ops::AsNodeOut(scope, bytes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeCompressed");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeCompressed")
                                   .Input(_bytes)
                                   .Attr("compression_type", compression_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedBatchNormWithGlobalNormalization::QuantizedBatchNormWithGlobalNormalization(tensorflow::Scope& scope, 
           tensorflow::Input t, 
           tensorflow::Input t_min, 
           tensorflow::Input t_max, 
           tensorflow::Input m, 
           tensorflow::Input m_min, 
           tensorflow::Input m_max, 
           tensorflow::Input v, 
           tensorflow::Input v_min, 
           tensorflow::Input v_max, 
           tensorflow::Input beta, 
           tensorflow::Input beta_min, 
           tensorflow::Input beta_max, 
           tensorflow::Input gamma, 
           tensorflow::Input gamma_min, 
           tensorflow::Input gamma_max, 
           bool scale_after_normalization, 
           float variance_epsilon) {
      if (!scope.ok())
          return;
      auto _t = ::tensorflow::ops::AsNodeOut(scope, t);
      if (!scope.ok())
          return;
      auto _t_min = ::tensorflow::ops::AsNodeOut(scope, t_min);
      if (!scope.ok())
          return;
      auto _t_max = ::tensorflow::ops::AsNodeOut(scope, t_max);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _m_min = ::tensorflow::ops::AsNodeOut(scope, m_min);
      if (!scope.ok())
          return;
      auto _m_max = ::tensorflow::ops::AsNodeOut(scope, m_max);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _v_min = ::tensorflow::ops::AsNodeOut(scope, v_min);
      if (!scope.ok())
          return;
      auto _v_max = ::tensorflow::ops::AsNodeOut(scope, v_max);
      if (!scope.ok())
          return;
      auto _beta = ::tensorflow::ops::AsNodeOut(scope, beta);
      if (!scope.ok())
          return;
      auto _beta_min = ::tensorflow::ops::AsNodeOut(scope, beta_min);
      if (!scope.ok())
          return;
      auto _beta_max = ::tensorflow::ops::AsNodeOut(scope, beta_max);
      if (!scope.ok())
          return;
      auto _gamma = ::tensorflow::ops::AsNodeOut(scope, gamma);
      if (!scope.ok())
          return;
      auto _gamma_min = ::tensorflow::ops::AsNodeOut(scope, gamma_min);
      if (!scope.ok())
          return;
      auto _gamma_max = ::tensorflow::ops::AsNodeOut(scope, gamma_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedBatchNormWithGlobalNormalization");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedBatchNormWithGlobalNormalization")
                                   .Input(_t)
                                   .Input(_t_min)
                                   .Input(_t_max)
                                   .Input(_m)
                                   .Input(_m_min)
                                   .Input(_m_max)
                                   .Input(_v)
                                   .Input(_v_min)
                                   .Input(_v_max)
                                   .Input(_beta)
                                   .Input(_beta_min)
                                   .Input(_beta_max)
                                   .Input(_gamma)
                                   .Input(_gamma_min)
                                   .Input(_gamma_max)
                                   .Attr("scale_after_normalization", scale_after_normalization)
                                   .Attr("variance_epsilon", variance_epsilon)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedReluX::QuantizedReluX(tensorflow::Scope& scope, 
           tensorflow::Input features, 
           tensorflow::Input max_value, 
           tensorflow::Input min_features, 
           tensorflow::Input max_features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      if (!scope.ok())
          return;
      auto _max_value = ::tensorflow::ops::AsNodeOut(scope, max_value);
      if (!scope.ok())
          return;
      auto _min_features = ::tensorflow::ops::AsNodeOut(scope, min_features);
      if (!scope.ok())
          return;
      auto _max_features = ::tensorflow::ops::AsNodeOut(scope, max_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedReluX");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedReluX")
                                   .Input(_features)
                                   .Input(_max_value)
                                   .Input(_min_features)
                                   .Input(_max_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedRelu::QuantizedRelu(tensorflow::Scope& scope, 
           tensorflow::Input features, 
           tensorflow::Input min_features, 
           tensorflow::Input max_features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      if (!scope.ok())
          return;
      auto _min_features = ::tensorflow::ops::AsNodeOut(scope, min_features);
      if (!scope.ok())
          return;
      auto _max_features = ::tensorflow::ops::AsNodeOut(scope, max_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedRelu");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedRelu")
                                   .Input(_features)
                                   .Input(_min_features)
                                   .Input(_max_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterNdSub::ScatterNdSub(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterNdSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterNdSub")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedConv2D::QuantizedConv2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::Input min_input, 
           tensorflow::Input max_input, 
           tensorflow::Input min_filter, 
           tensorflow::Input max_filter, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _min_input = ::tensorflow::ops::AsNodeOut(scope, min_input);
      if (!scope.ok())
          return;
      auto _max_input = ::tensorflow::ops::AsNodeOut(scope, max_input);
      if (!scope.ok())
          return;
      auto _min_filter = ::tensorflow::ops::AsNodeOut(scope, min_filter);
      if (!scope.ok())
          return;
      auto _max_filter = ::tensorflow::ops::AsNodeOut(scope, max_filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedConv2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedConv2D")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Input(_min_input)
                                   .Input(_max_input)
                                   .Input(_min_filter)
                                   .Input(_max_filter)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Reciprocal::Reciprocal(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Reciprocal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Reciprocal")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FractionalMaxPool::FractionalMaxPool(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::gtl::ArraySlice<float> pooling_ratio, 
           bool pseudo_random, 
           bool overlapping, 
           bool deterministic, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FractionalMaxPool");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FractionalMaxPool")
                                   .Input(_value)
                                   .Attr("pooling_ratio", pooling_ratio)
                                   .Attr("pseudo_random", pseudo_random)
                                   .Attr("overlapping", overlapping)
                                   .Attr("deterministic", deterministic)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NthElement::NthElement(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input n, 
           bool reverse) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _n = ::tensorflow::ops::AsNodeOut(scope, n);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NthElement");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NthElement")
                                   .Input(_input)
                                   .Input(_n)
                                   .Attr("reverse", reverse)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InTopKV2::InTopKV2(tensorflow::Scope& scope, 
           tensorflow::Input predictions, 
           tensorflow::Input targets, 
           tensorflow::Input k) {
      if (!scope.ok())
          return;
      auto _predictions = ::tensorflow::ops::AsNodeOut(scope, predictions);
      if (!scope.ok())
          return;
      auto _targets = ::tensorflow::ops::AsNodeOut(scope, targets);
      if (!scope.ok())
          return;
      auto _k = ::tensorflow::ops::AsNodeOut(scope, k);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InTopKV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InTopKV2")
                                   .Input(_predictions)
                                   .Input(_targets)
                                   .Input(_k)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Sub::Sub(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sub")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InTopK::InTopK(tensorflow::Scope& scope, 
           tensorflow::Input predictions, 
           tensorflow::Input targets, 
           int64_t k) {
      if (!scope.ok())
          return;
      auto _predictions = ::tensorflow::ops::AsNodeOut(scope, predictions);
      if (!scope.ok())
          return;
      auto _targets = ::tensorflow::ops::AsNodeOut(scope, targets);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InTopK");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InTopK")
                                   .Input(_predictions)
                                   .Input(_targets)
                                   .Attr("k", k)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DatasetToSingleElement::DatasetToSingleElement(tensorflow::Scope& scope, 
           tensorflow::Input dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _dataset = ::tensorflow::ops::AsNodeOut(scope, dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DatasetToSingleElement");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DatasetToSingleElement")
                                   .Input(_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SoftmaxCrossEntropyWithLogits::SoftmaxCrossEntropyWithLogits(tensorflow::Scope& scope, 
           tensorflow::Input features, 
           tensorflow::Input labels) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      if (!scope.ok())
          return;
      auto _labels = ::tensorflow::ops::AsNodeOut(scope, labels);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SoftmaxCrossEntropyWithLogits");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SoftmaxCrossEntropyWithLogits")
                                   .Input(_features)
                                   .Input(_labels)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LogSoftmax::LogSoftmax(tensorflow::Scope& scope, 
           tensorflow::Input logits) {
      if (!scope.ok())
          return;
      auto _logits = ::tensorflow::ops::AsNodeOut(scope, logits);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LogSoftmax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LogSoftmax")
                                   .Input(_logits)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MutableHashTableV2::MutableHashTableV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           tensorflow::DataType key_dtype, 
           tensorflow::DataType value_dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutableHashTableV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutableHashTableV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("key_dtype", key_dtype)
                                   .Attr("value_dtype", value_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Softplus::Softplus(tensorflow::Scope& scope, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Softplus");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Softplus")
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Selu::Selu(tensorflow::Scope& scope, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Selu");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Selu")
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EluGrad::EluGrad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input outputs) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _outputs = ::tensorflow::ops::AsNodeOut(scope, outputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EluGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EluGrad")
                                   .Input(_gradients)
                                   .Input(_outputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LeakyReluGrad::LeakyReluGrad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input features, 
           float alpha) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LeakyReluGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LeakyReluGrad")
                                   .Input(_gradients)
                                   .Input(_features)
                                   .Attr("alpha", alpha)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StackPush::StackPush(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input elem, 
           bool swap_memory) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _elem = ::tensorflow::ops::AsNodeOut(scope, elem);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackPush");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackPush")
                                   .Input(_handle)
                                   .Input(_elem)
                                   .Attr("swap_memory", swap_memory)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LeakyRelu::LeakyRelu(tensorflow::Scope& scope, 
           tensorflow::Input features, 
           float alpha) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LeakyRelu");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LeakyRelu")
                                   .Input(_features)
                                   .Attr("alpha", alpha)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSplit::SparseSplit(tensorflow::Scope& scope, 
           tensorflow::Input split_dim, 
           tensorflow::Input indices, 
           tensorflow::Input values, 
           tensorflow::Input shape, 
           int64_t num_split) {
      if (!scope.ok())
          return;
      auto _split_dim = ::tensorflow::ops::AsNodeOut(scope, split_dim);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSplit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSplit")
                                   .Input(_split_dim)
                                   .Input(_indices)
                                   .Input(_values)
                                   .Input(_shape)
                                   .Attr("num_split", num_split)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RaggedRange::RaggedRange(tensorflow::Scope& scope, 
           tensorflow::Input starts, 
           tensorflow::Input limits, 
           tensorflow::Input deltas) {
      if (!scope.ok())
          return;
      auto _starts = ::tensorflow::ops::AsNodeOut(scope, starts);
      if (!scope.ok())
          return;
      auto _limits = ::tensorflow::ops::AsNodeOut(scope, limits);
      if (!scope.ok())
          return;
      auto _deltas = ::tensorflow::ops::AsNodeOut(scope, deltas);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RaggedRange");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RaggedRange")
                                   .Input(_starts)
                                   .Input(_limits)
                                   .Input(_deltas)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderSerializeStateV2::ReaderSerializeStateV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderSerializeStateV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderSerializeStateV2")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Relu6::Relu6(tensorflow::Scope& scope, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Relu6");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Relu6")
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReluGrad::ReluGrad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReluGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReluGrad")
                                   .Input(_gradients)
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

All::All(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("All");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "All")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Dilation2DBackpropInput::Dilation2DBackpropInput(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::gtl::ArraySlice<int64_t> rates, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Dilation2DBackpropInput");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Dilation2DBackpropInput")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("rates", rates)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolGradWithArgmax::MaxPoolGradWithArgmax(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input grad, 
           tensorflow::Input argmax, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _argmax = ::tensorflow::ops::AsNodeOut(scope, argmax);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolGradWithArgmax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolGradWithArgmax")
                                   .Input(_input)
                                   .Input(_grad)
                                   .Input(_argmax)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolGradGradV2::MaxPoolGradGradV2(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input grad, 
           tensorflow::Input ksize, 
           tensorflow::Input strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _ksize = ::tensorflow::ops::AsNodeOut(scope, ksize);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolGradGradV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolGradGradV2")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_grad)
                                   .Input(_ksize)
                                   .Input(_strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolGradV2::MaxPoolGradV2(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input grad, 
           tensorflow::Input ksize, 
           tensorflow::Input strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _ksize = ::tensorflow::ops::AsNodeOut(scope, ksize);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolGradV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolGradV2")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_grad)
                                   .Input(_ksize)
                                   .Input(_strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Roll::Roll(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input shift, 
           tensorflow::Input axis) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _shift = ::tensorflow::ops::AsNodeOut(scope, shift);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Roll");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Roll")
                                   .Input(_input)
                                   .Input(_shift)
                                   .Input(_axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolGrad::MaxPoolGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input grad, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolGrad")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_grad)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LRNGrad::LRNGrad(tensorflow::Scope& scope, 
           tensorflow::Input input_grads, 
           tensorflow::Input input_image, 
           tensorflow::Input output_image, 
           int64_t depth_radius, 
           float bias, 
           float alpha, 
           float beta) {
      if (!scope.ok())
          return;
      auto _input_grads = ::tensorflow::ops::AsNodeOut(scope, input_grads);
      if (!scope.ok())
          return;
      auto _input_image = ::tensorflow::ops::AsNodeOut(scope, input_image);
      if (!scope.ok())
          return;
      auto _output_image = ::tensorflow::ops::AsNodeOut(scope, output_image);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LRNGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LRNGrad")
                                   .Input(_input_grads)
                                   .Input(_input_image)
                                   .Input(_output_image)
                                   .Attr("depth_radius", depth_radius)
                                   .Attr("bias", bias)
                                   .Attr("alpha", alpha)
                                   .Attr("beta", beta)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPool3DGradGrad::MaxPool3DGradGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input grad, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPool3DGradGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPool3DGradGrad")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_grad)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv3DBackpropFilter::Conv3DBackpropFilter(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv3DBackpropFilter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv3DBackpropFilter")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv3D::Conv3D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv3D")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CropAndResize::CropAndResize(tensorflow::Scope& scope, 
           tensorflow::Input image, 
           tensorflow::Input boxes, 
           tensorflow::Input box_ind, 
           tensorflow::Input crop_size, 
           float extrapolation_value, 
           tensorflow::string method) {
      if (!scope.ok())
          return;
      auto _image = ::tensorflow::ops::AsNodeOut(scope, image);
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _box_ind = ::tensorflow::ops::AsNodeOut(scope, box_ind);
      if (!scope.ok())
          return;
      auto _crop_size = ::tensorflow::ops::AsNodeOut(scope, crop_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CropAndResize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CropAndResize")
                                   .Input(_image)
                                   .Input(_boxes)
                                   .Input(_box_ind)
                                   .Input(_crop_size)
                                   .Attr("extrapolation_value", extrapolation_value)
                                   .Attr("method", method)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DepthwiseConv2dNativeBackpropFilter::DepthwiseConv2dNativeBackpropFilter(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter_sizes, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter_sizes = ::tensorflow::ops::AsNodeOut(scope, filter_sizes);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DepthwiseConv2dNativeBackpropFilter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DepthwiseConv2dNativeBackpropFilter")
                                   .Input(_input)
                                   .Input(_filter_sizes)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Expm1::Expm1(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Expm1");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Expm1")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv2DBackpropInput::Conv2DBackpropInput(tensorflow::Scope& scope, 
           tensorflow::Input input_sizes, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           bool use_cudnn_on_gpu, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input_sizes = ::tensorflow::ops::AsNodeOut(scope, input_sizes);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv2DBackpropInput");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv2DBackpropInput")
                                   .Input(_input_sizes)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_NcclReduceRecv::_NcclReduceRecv(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string reduction, 
           tensorflow::string shared_name, 
           int64_t num_devices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_NcclReduceRecv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_NcclReduceRecv")
                                   .Input(_input)
                                   .Attr("reduction", reduction)
                                   .Attr("shared_name", shared_name)
                                   .Attr("num_devices", num_devices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv2D::Conv2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           bool use_cudnn_on_gpu, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv2D")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Sin::Sin(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sin")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FusedBatchNormV2::FusedBatchNormV2(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input scale, 
           tensorflow::Input offset, 
           tensorflow::Input mean, 
           tensorflow::Input variance, 
           bool is_training, 
           tensorflow::string data_format, 
           float epsilon) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _scale = ::tensorflow::ops::AsNodeOut(scope, scale);
      if (!scope.ok())
          return;
      auto _offset = ::tensorflow::ops::AsNodeOut(scope, offset);
      if (!scope.ok())
          return;
      auto _mean = ::tensorflow::ops::AsNodeOut(scope, mean);
      if (!scope.ok())
          return;
      auto _variance = ::tensorflow::ops::AsNodeOut(scope, variance);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FusedBatchNormV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FusedBatchNormV2")
                                   .Input(_x)
                                   .Input(_scale)
                                   .Input(_offset)
                                   .Input(_mean)
                                   .Input(_variance)
                                   .Attr("is_training", is_training)
                                   .Attr("data_format", data_format)
                                   .Attr("epsilon", epsilon)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseMatMul::SparseMatMul(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input b, 
           bool transpose_a, 
           bool transpose_b, 
           bool a_is_sparse, 
           bool b_is_sparse) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseMatMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseMatMul")
                                   .Input(_a)
                                   .Input(_b)
                                   .Attr("transpose_a", transpose_a)
                                   .Attr("transpose_b", transpose_b)
                                   .Attr("a_is_sparse", a_is_sparse)
                                   .Attr("b_is_sparse", b_is_sparse)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FusedBatchNorm::FusedBatchNorm(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input scale, 
           tensorflow::Input offset, 
           tensorflow::Input mean, 
           tensorflow::Input variance, 
           bool is_training, 
           float epsilon, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _scale = ::tensorflow::ops::AsNodeOut(scope, scale);
      if (!scope.ok())
          return;
      auto _offset = ::tensorflow::ops::AsNodeOut(scope, offset);
      if (!scope.ok())
          return;
      auto _mean = ::tensorflow::ops::AsNodeOut(scope, mean);
      if (!scope.ok())
          return;
      auto _variance = ::tensorflow::ops::AsNodeOut(scope, variance);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FusedBatchNorm");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FusedBatchNorm")
                                   .Input(_x)
                                   .Input(_scale)
                                   .Input(_offset)
                                   .Input(_mean)
                                   .Input(_variance)
                                   .Attr("is_training", is_training)
                                   .Attr("epsilon", epsilon)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReduceDataset::ReduceDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input initial_state, 
           tensorflow::Input other_arguments, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tstate, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool use_inter_op_parallelism) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _initial_state = ::tensorflow::ops::AsNodeOut(scope, initial_state);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReduceDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReduceDataset")
                                   .Input(_input_dataset)
                                   .Input(_initial_state)
                                   .Input(_other_arguments)
                                   .Attr("f", f)
                                   .Attr("Tstate", Tstate)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("use_inter_op_parallelism", use_inter_op_parallelism)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQuantWithMinMaxArgs::FakeQuantWithMinMaxArgs(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           float min, 
           float max, 
           int64_t num_bits, 
           bool narrow_range) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQuantWithMinMaxArgs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQuantWithMinMaxArgs")
                                   .Input(_inputs)
                                   .Attr("min", min)
                                   .Attr("max", max)
                                   .Attr("num_bits", num_bits)
                                   .Attr("narrow_range", narrow_range)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchNormWithGlobalNormalization::BatchNormWithGlobalNormalization(tensorflow::Scope& scope, 
           tensorflow::Input t, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input beta, 
           tensorflow::Input gamma, 
           bool scale_after_normalization, 
           float variance_epsilon) {
      if (!scope.ok())
          return;
      auto _t = ::tensorflow::ops::AsNodeOut(scope, t);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _beta = ::tensorflow::ops::AsNodeOut(scope, beta);
      if (!scope.ok())
          return;
      auto _gamma = ::tensorflow::ops::AsNodeOut(scope, gamma);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchNormWithGlobalNormalization");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchNormWithGlobalNormalization")
                                   .Input(_t)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_beta)
                                   .Input(_gamma)
                                   .Attr("scale_after_normalization", scale_after_normalization)
                                   .Attr("variance_epsilon", variance_epsilon)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyFtrlV2::ApplyFtrlV2(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input l2_shrinkage, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _l2_shrinkage = ::tensorflow::ops::AsNodeOut(scope, l2_shrinkage);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyFtrlV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyFtrlV2")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_l2_shrinkage)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Where::Where(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Where");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Where")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_NcclReduceSend::_NcclReduceSend(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string reduction, 
           tensorflow::string shared_name, 
           int64_t num_devices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_NcclReduceSend");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_NcclReduceSend")
                                   .Input(_input)
                                   .Attr("reduction", reduction)
                                   .Attr("shared_name", shared_name)
                                   .Attr("num_devices", num_devices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

GetSessionTensor::GetSessionTensor(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GetSessionTensor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GetSessionTensor")
                                   .Input(_handle)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Min::Min(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Min");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Min")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NcclAllReduce::NcclAllReduce(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string reduction, 
           tensorflow::string shared_name, 
           int64_t num_devices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NcclAllReduce");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NcclAllReduce")
                                   .Input(_input)
                                   .Attr("reduction", reduction)
                                   .Attr("shared_name", shared_name)
                                   .Attr("num_devices", num_devices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReadVariableOp::ReadVariableOp(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReadVariableOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReadVariableOp")
                                   .Input(_resource)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Lgamma::Lgamma(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Lgamma");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Lgamma")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RequantizationRange::RequantizationRange(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_min, 
           tensorflow::Input input_max) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_min = ::tensorflow::ops::AsNodeOut(scope, input_min);
      if (!scope.ok())
          return;
      auto _input_max = ::tensorflow::ops::AsNodeOut(scope, input_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RequantizationRange");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RequantizationRange")
                                   .Input(_input)
                                   .Input(_input_min)
                                   .Input(_input_max)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CompareAndBitpack::CompareAndBitpack(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input threshold) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _threshold = ::tensorflow::ops::AsNodeOut(scope, threshold);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CompareAndBitpack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CompareAndBitpack")
                                   .Input(_input)
                                   .Input(_threshold)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizeDownAndShrinkRange::QuantizeDownAndShrinkRange(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_min, 
           tensorflow::Input input_max) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_min = ::tensorflow::ops::AsNodeOut(scope, input_min);
      if (!scope.ok())
          return;
      auto _input_max = ::tensorflow::ops::AsNodeOut(scope, input_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizeDownAndShrinkRange");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizeDownAndShrinkRange")
                                   .Input(_input)
                                   .Input(_input_min)
                                   .Input(_input_max)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedMatMul::QuantizedMatMul(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input b, 
           tensorflow::Input min_a, 
           tensorflow::Input max_a, 
           tensorflow::Input min_b, 
           tensorflow::Input max_b, 
           tensorflow::DataType Tactivation, 
           bool transpose_b, 
           bool transpose_a) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      if (!scope.ok())
          return;
      auto _min_a = ::tensorflow::ops::AsNodeOut(scope, min_a);
      if (!scope.ok())
          return;
      auto _max_a = ::tensorflow::ops::AsNodeOut(scope, max_a);
      if (!scope.ok())
          return;
      auto _min_b = ::tensorflow::ops::AsNodeOut(scope, min_b);
      if (!scope.ok())
          return;
      auto _max_b = ::tensorflow::ops::AsNodeOut(scope, max_b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedMatMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedMatMul")
                                   .Input(_a)
                                   .Input(_b)
                                   .Input(_min_a)
                                   .Input(_max_a)
                                   .Input(_min_b)
                                   .Input(_max_b)
                                   .Attr("Tactivation", Tactivation)
                                   .Attr("transpose_b", transpose_b)
                                   .Attr("transpose_a", transpose_a)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchNormWithGlobalNormalizationGrad::BatchNormWithGlobalNormalizationGrad(tensorflow::Scope& scope, 
           tensorflow::Input t, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input gamma, 
           tensorflow::Input backprop, 
           bool scale_after_normalization, 
           float variance_epsilon) {
      if (!scope.ok())
          return;
      auto _t = ::tensorflow::ops::AsNodeOut(scope, t);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _gamma = ::tensorflow::ops::AsNodeOut(scope, gamma);
      if (!scope.ok())
          return;
      auto _backprop = ::tensorflow::ops::AsNodeOut(scope, backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchNormWithGlobalNormalizationGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchNormWithGlobalNormalizationGrad")
                                   .Input(_t)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_gamma)
                                   .Input(_backprop)
                                   .Attr("scale_after_normalization", scale_after_normalization)
                                   .Attr("variance_epsilon", variance_epsilon)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Bincount::Bincount(tensorflow::Scope& scope, 
           tensorflow::Input arr, 
           tensorflow::Input size, 
           tensorflow::Input weights) {
      if (!scope.ok())
          return;
      auto _arr = ::tensorflow::ops::AsNodeOut(scope, arr);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      if (!scope.ok())
          return;
      auto _weights = ::tensorflow::ops::AsNodeOut(scope, weights);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Bincount");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Bincount")
                                   .Input(_arr)
                                   .Input(_size)
                                   .Input(_weights)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DestroyResourceOp::DestroyResourceOp(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           bool ignore_lookup_error) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DestroyResourceOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DestroyResourceOp")
                                   .Input(_resource)
                                   .Attr("ignore_lookup_error", ignore_lookup_error)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

HistogramFixedWidth::HistogramFixedWidth(tensorflow::Scope& scope, 
           tensorflow::Input values, 
           tensorflow::Input value_range, 
           tensorflow::Input nbins, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      if (!scope.ok())
          return;
      auto _value_range = ::tensorflow::ops::AsNodeOut(scope, value_range);
      if (!scope.ok())
          return;
      auto _nbins = ::tensorflow::ops::AsNodeOut(scope, nbins);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("HistogramFixedWidth");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "HistogramFixedWidth")
                                   .Input(_values)
                                   .Input(_value_range)
                                   .Input(_nbins)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchSelfAdjointEigV2::BatchSelfAdjointEigV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool compute_v) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchSelfAdjointEigV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchSelfAdjointEigV2")
                                   .Input(_input)
                                   .Attr("compute_v", compute_v)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NcclBroadcast::NcclBroadcast(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::PartialTensorShape shape) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NcclBroadcast");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NcclBroadcast")
                                   .Input(_input)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cross::Cross(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input b) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cross");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cross")
                                   .Input(_a)
                                   .Input(_b)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conj::Conj(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conj");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conj")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalSleepDataset::ExperimentalSleepDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input sleep_microseconds, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _sleep_microseconds = ::tensorflow::ops::AsNodeOut(scope, sleep_microseconds);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalSleepDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalSleepDataset")
                                   .Input(_input_dataset)
                                   .Input(_sleep_microseconds)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_MklAdd::_MklAdd(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input mkl_x, 
           tensorflow::Input mkl_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _mkl_x = ::tensorflow::ops::AsNodeOut(scope, mkl_x);
      if (!scope.ok())
          return;
      auto _mkl_y = ::tensorflow::ops::AsNodeOut(scope, mkl_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_MklAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_MklAdd")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_mkl_x)
                                   .Input(_mkl_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Real::Real(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Real");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Real")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Dequantize::Dequantize(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input min_range, 
           tensorflow::Input max_range, 
           tensorflow::string mode) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _min_range = ::tensorflow::ops::AsNodeOut(scope, min_range);
      if (!scope.ok())
          return;
      auto _max_range = ::tensorflow::ops::AsNodeOut(scope, max_range);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Dequantize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Dequantize")
                                   .Input(_input)
                                   .Input(_min_range)
                                   .Input(_max_range)
                                   .Attr("mode", mode)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Complex::Complex(tensorflow::Scope& scope, 
           tensorflow::Input real, 
           tensorflow::Input imag) {
      if (!scope.ok())
          return;
      auto _real = ::tensorflow::ops::AsNodeOut(scope, real);
      if (!scope.ok())
          return;
      auto _imag = ::tensorflow::ops::AsNodeOut(scope, imag);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Complex");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Complex")
                                   .Input(_real)
                                   .Input(_imag)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSoftmaxCrossEntropyWithLogits::SparseSoftmaxCrossEntropyWithLogits(tensorflow::Scope& scope, 
           tensorflow::Input features, 
           tensorflow::Input labels) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      if (!scope.ok())
          return;
      auto _labels = ::tensorflow::ops::AsNodeOut(scope, labels);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSoftmaxCrossEntropyWithLogits");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSoftmaxCrossEntropyWithLogits")
                                   .Input(_features)
                                   .Input(_labels)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cholesky::Cholesky(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cholesky");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cholesky")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentSqrtNWithNumSegments::SparseSegmentSqrtNWithNumSegments(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentSqrtNWithNumSegments");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentSqrtNWithNumSegments")
                                   .Input(_data)
                                   .Input(_indices)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentMean::SparseSegmentMean(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentMean");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentMean")
                                   .Input(_data)
                                   .Input(_indices)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentSumWithNumSegments::SparseSegmentSumWithNumSegments(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentSumWithNumSegments");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentSumWithNumSegments")
                                   .Input(_data)
                                   .Input(_indices)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnsortedSegmentProd::UnsortedSegmentProd(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnsortedSegmentProd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnsortedSegmentProd")
                                   .Input(_data)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnsortedSegmentSum::UnsortedSegmentSum(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnsortedSegmentSum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnsortedSegmentSum")
                                   .Input(_data)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_ReadVariablesOp::_ReadVariablesOp(tensorflow::Scope& scope, 
           tensorflow::InputList resources, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes) {
      if (!scope.ok())
          return;
      auto _resources = ::tensorflow::ops::AsNodeOutList(scope, resources);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ReadVariablesOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ReadVariablesOp")
                                   .Input(_resources)
                                   .Attr("dtypes", dtypes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

L2Loss::L2Loss(tensorflow::Scope& scope, 
           tensorflow::Input t) {
      if (!scope.ok())
          return;
      auto _t = ::tensorflow::ops::AsNodeOut(scope, t);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("L2Loss");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "L2Loss")
                                   .Input(_t)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cast::Cast(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           bool Truncate) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cast");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cast")
                                   .Input(_x)
                                   .Attr("Truncate", Truncate)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SegmentMax::SegmentMax(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SegmentMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SegmentMax")
                                   .Input(_data)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Atan2::Atan2(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Atan2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Atan2")
                                   .Input(_y)
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SegmentProd::SegmentProd(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SegmentProd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SegmentProd")
                                   .Input(_data)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ArgMin::ArgMin(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input dimension) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _dimension = ::tensorflow::ops::AsNodeOut(scope, dimension);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ArgMin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ArgMin")
                                   .Input(_input)
                                   .Input(_dimension)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResizeBilinearGrad::ResizeBilinearGrad(tensorflow::Scope& scope, 
           tensorflow::Input grads, 
           tensorflow::Input original_image, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _grads = ::tensorflow::ops::AsNodeOut(scope, grads);
      if (!scope.ok())
          return;
      auto _original_image = ::tensorflow::ops::AsNodeOut(scope, original_image);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeBilinearGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeBilinearGrad")
                                   .Input(_grads)
                                   .Input(_original_image)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Max::Max(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Max");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Max")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AccumulatorApplyGradient::AccumulatorApplyGradient(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input local_step, 
           tensorflow::Input gradient, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _local_step = ::tensorflow::ops::AsNodeOut(scope, local_step);
      if (!scope.ok())
          return;
      auto _gradient = ::tensorflow::ops::AsNodeOut(scope, gradient);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AccumulatorApplyGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AccumulatorApplyGradient")
                                   .Input(_handle)
                                   .Input(_local_step)
                                   .Input(_gradient)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SampleDistortedBoundingBoxV2::SampleDistortedBoundingBoxV2(tensorflow::Scope& scope, 
           tensorflow::Input image_size, 
           tensorflow::Input bounding_boxes, 
           tensorflow::Input min_object_covered, 
           bool use_image_if_no_bounding_boxes, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::gtl::ArraySlice<float> aspect_ratio_range, 
           tensorflow::gtl::ArraySlice<float> area_range, 
           int64_t max_attempts) {
      if (!scope.ok())
          return;
      auto _image_size = ::tensorflow::ops::AsNodeOut(scope, image_size);
      if (!scope.ok())
          return;
      auto _bounding_boxes = ::tensorflow::ops::AsNodeOut(scope, bounding_boxes);
      if (!scope.ok())
          return;
      auto _min_object_covered = ::tensorflow::ops::AsNodeOut(scope, min_object_covered);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SampleDistortedBoundingBoxV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SampleDistortedBoundingBoxV2")
                                   .Input(_image_size)
                                   .Input(_bounding_boxes)
                                   .Input(_min_object_covered)
                                   .Attr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("aspect_ratio_range", aspect_ratio_range)
                                   .Attr("area_range", area_range)
                                   .Attr("max_attempts", max_attempts)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Prod::Prod(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Prod");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Prod")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Sum::Sum(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sum")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SeluGrad::SeluGrad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input outputs) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _outputs = ::tensorflow::ops::AsNodeOut(scope, outputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SeluGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SeluGrad")
                                   .Input(_gradients)
                                   .Input(_outputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Select::Select(tensorflow::Scope& scope, 
           tensorflow::Input condition, 
           tensorflow::Input t, 
           tensorflow::Input e) {
      if (!scope.ok())
          return;
      auto _condition = ::tensorflow::ops::AsNodeOut(scope, condition);
      if (!scope.ok())
          return;
      auto _t = ::tensorflow::ops::AsNodeOut(scope, t);
      if (!scope.ok())
          return;
      auto _e = ::tensorflow::ops::AsNodeOut(scope, e);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Select");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Select")
                                   .Input(_condition)
                                   .Input(_t)
                                   .Input(_e)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CollectiveBcastSend::CollectiveBcastSend(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::PartialTensorShape shape, 
           int64_t group_size, 
           int64_t group_key, 
           int64_t instance_key) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CollectiveBcastSend");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CollectiveBcastSend")
                                   .Input(_input)
                                   .Attr("shape", shape)
                                   .Attr("group_size", group_size)
                                   .Attr("group_key", group_key)
                                   .Attr("instance_key", instance_key)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LogicalAnd::LogicalAnd(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LogicalAnd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LogicalAnd")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteGraphSummary::WriteGraphSummary(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input step, 
           tensorflow::Input tensor) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteGraphSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteGraphSummary")
                                   .Input(_writer)
                                   .Input(_step)
                                   .Input(_tensor)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ApproximateEqual::ApproximateEqual(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           float tolerance) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApproximateEqual");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApproximateEqual")
                                   .Input(_x)
                                   .Input(_y)
                                   .Attr("tolerance", tolerance)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Equal::Equal(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Equal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Equal")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizeV2::QuantizeV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input min_range, 
           tensorflow::Input max_range, 
           tensorflow::string round_mode, 
           tensorflow::string mode) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _min_range = ::tensorflow::ops::AsNodeOut(scope, min_range);
      if (!scope.ok())
          return;
      auto _max_range = ::tensorflow::ops::AsNodeOut(scope, max_range);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizeV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizeV2")
                                   .Input(_input)
                                   .Input(_min_range)
                                   .Input(_max_range)
                                   .Attr("round_mode", round_mode)
                                   .Attr("mode", mode)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GreaterEqual::GreaterEqual(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GreaterEqual");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GreaterEqual")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceScatterMax::ResourceScatterMax(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterMax")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Betainc::Betainc(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input b, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Betainc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Betainc")
                                   .Input(_a)
                                   .Input(_b)
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Polygamma::Polygamma(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Polygamma");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Polygamma")
                                   .Input(_a)
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Assert::Assert(tensorflow::Scope& scope, 
           tensorflow::Input condition, 
           tensorflow::Input data, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           int64_t summarize) {
      if (!scope.ok())
          return;
      auto _condition = ::tensorflow::ops::AsNodeOut(scope, condition);
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Assert");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Assert")
                                   .Input(_condition)
                                   .Input(_data)
                                   .Attr("T", T)
                                   .Attr("summarize", summarize)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Transpose::Transpose(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input perm) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _perm = ::tensorflow::ops::AsNodeOut(scope, perm);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Transpose");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Transpose")
                                   .Input(_x)
                                   .Input(_perm)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IgammaGradA::IgammaGradA(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IgammaGradA");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IgammaGradA")
                                   .Input(_a)
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringSplitV2::StringSplitV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input sep, 
           int64_t maxsplit) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _sep = ::tensorflow::ops::AsNodeOut(scope, sep);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringSplitV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringSplitV2")
                                   .Input(_input)
                                   .Input(_sep)
                                   .Attr("maxsplit", maxsplit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ImportEvent::ImportEvent(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input event) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _event = ::tensorflow::ops::AsNodeOut(scope, event);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ImportEvent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ImportEvent")
                                   .Input(_writer)
                                   .Input(_event)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Igamma::Igamma(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Igamma");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Igamma")
                                   .Input(_a)
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Igammac::Igammac(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Igammac");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Igammac")
                                   .Input(_a)
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Mod::Mod(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Mod");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Mod")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Maximum::Maximum(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Maximum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Maximum")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Xlogy::Xlogy(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Xlogy");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Xlogy")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SquaredDifference::SquaredDifference(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SquaredDifference");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SquaredDifference")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceCountUpTo::ResourceCountUpTo(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           int64_t limit) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceCountUpTo");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceCountUpTo")
                                   .Input(_resource)
                                   .Attr("limit", limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RealDiv::RealDiv(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RealDiv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RealDiv")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TruncateDiv::TruncateDiv(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TruncateDiv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TruncateDiv")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringToHashBucketStrong::StringToHashBucketStrong(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> key, 
           int64_t num_buckets) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringToHashBucketStrong");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringToHashBucketStrong")
                                   .Input(_input)
                                   .Attr("key", key)
                                   .Attr("num_buckets", num_buckets)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueEnqueue::QueueEnqueue(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcomponents, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueEnqueue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueEnqueue")
                                   .Input(_handle)
                                   .Input(_components)
                                   .Attr("Tcomponents", Tcomponents)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

_MklSub::_MklSub(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input mkl_x, 
           tensorflow::Input mkl_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _mkl_x = ::tensorflow::ops::AsNodeOut(scope, mkl_x);
      if (!scope.ok())
          return;
      auto _mkl_y = ::tensorflow::ops::AsNodeOut(scope, mkl_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_MklSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_MklSub")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_mkl_x)
                                   .Input(_mkl_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AsString::AsString(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string fill, 
           int64_t width, 
           int64_t precision, 
           bool scientific, 
           bool shortest) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AsString");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AsString")
                                   .Input(_input)
                                   .Attr("fill", fill)
                                   .Attr("width", width)
                                   .Attr("precision", precision)
                                   .Attr("scientific", scientific)
                                   .Attr("shortest", shortest)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv3DBackpropFilterV2::Conv3DBackpropFilterV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter_sizes, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter_sizes = ::tensorflow::ops::AsNodeOut(scope, filter_sizes);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv3DBackpropFilterV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv3DBackpropFilterV2")
                                   .Input(_input)
                                   .Input(_filter_sizes)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AddV2::AddV2(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AddV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AddV2")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TryRpc::TryRpc(tensorflow::Scope& scope, 
           tensorflow::Input address, 
           tensorflow::Input method, 
           tensorflow::Input request, 
           tensorflow::string protocol, 
           bool fail_fast, 
           int64_t timeout_in_ms) {
      if (!scope.ok())
          return;
      auto _address = ::tensorflow::ops::AsNodeOut(scope, address);
      if (!scope.ok())
          return;
      auto _method = ::tensorflow::ops::AsNodeOut(scope, method);
      if (!scope.ok())
          return;
      auto _request = ::tensorflow::ops::AsNodeOut(scope, request);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TryRpc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TryRpc")
                                   .Input(_address)
                                   .Input(_method)
                                   .Input(_request)
                                   .Attr("protocol", protocol)
                                   .Attr("fail_fast", fail_fast)
                                   .Attr("timeout_in_ms", timeout_in_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceGather::ResourceGather(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           bool validate_indices, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceGather");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceGather")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Attr("validate_indices", validate_indices)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UniformCandidateSampler::UniformCandidateSampler(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           int64_t num_true, 
           int64_t num_sampled, 
           bool unique, 
           int64_t range_max, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UniformCandidateSampler");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UniformCandidateSampler")
                                   .Input(_true_classes)
                                   .Attr("num_true", num_true)
                                   .Attr("num_sampled", num_sampled)
                                   .Attr("unique", unique)
                                   .Attr("range_max", range_max)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Add::Add(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Add");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Add")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Floor::Floor(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Floor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Floor")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Ceil::Ceil(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Ceil");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Ceil")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IsFinite::IsFinite(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IsFinite");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IsFinite")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPool3D::MaxPool3D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPool3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPool3D")
                                   .Input(_input)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IsInf::IsInf(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IsInf");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IsInf")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cumsum::Cumsum(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input axis, 
           bool exclusive, 
           bool reverse) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cumsum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cumsum")
                                   .Input(_x)
                                   .Input(_axis)
                                   .Attr("exclusive", exclusive)
                                   .Attr("reverse", reverse)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BesselI1e::BesselI1e(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BesselI1e");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BesselI1e")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BesselI0e::BesselI0e(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BesselI0e");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BesselI0e")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BiasAddGrad::BiasAddGrad(tensorflow::Scope& scope, 
           tensorflow::Input out_backprop, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BiasAddGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BiasAddGrad")
                                   .Input(_out_backprop)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteHistogramSummary::WriteHistogramSummary(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input step, 
           tensorflow::Input tag, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteHistogramSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteHistogramSummary")
                                   .Input(_writer)
                                   .Input(_step)
                                   .Input(_tag)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Tan::Tan(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Tan");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Tan")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TopKV2::TopKV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input k, 
           bool sorted) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _k = ::tensorflow::ops::AsNodeOut(scope, k);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TopKV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TopKV2")
                                   .Input(_input)
                                   .Input(_k)
                                   .Attr("sorted", sorted)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PadV2::PadV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input paddings, 
           tensorflow::Input constant_values) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      if (!scope.ok())
          return;
      auto _constant_values = ::tensorflow::ops::AsNodeOut(scope, constant_values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PadV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PadV2")
                                   .Input(_input)
                                   .Input(_paddings)
                                   .Input(_constant_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cos::Cos(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cos");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cos")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Erfc::Erfc(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Erfc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Erfc")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Digamma::Digamma(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Digamma");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Digamma")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesSerializeEnsemble::BoostedTreesSerializeEnsemble(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesSerializeEnsemble");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesSerializeEnsemble")
                                   .Input(_tree_ensemble_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Acosh::Acosh(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Acosh");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Acosh")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cosh::Cosh(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cosh");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cosh")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyProximalAdagrad::ResourceApplyProximalAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyProximalAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyProximalAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceScatterDiv::ResourceScatterDiv(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterDiv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterDiv")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Asin::Asin(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Asin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Asin")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_HostRecv::_HostRecv(tensorflow::Scope& scope, 
           tensorflow::string tensor_name, 
           tensorflow::string send_device, 
           tensorflow::string recv_device, 
           bool client_terminated, 
           int64_t send_device_incarnation) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_HostRecv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_HostRecv")
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("send_device", send_device)
                                   .Attr("recv_device", recv_device)
                                   .Attr("client_terminated", client_terminated)
                                   .Attr("send_device_incarnation", send_device_incarnation)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalScanDataset::ExperimentalScanDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input initial_state, 
           tensorflow::Input other_arguments, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tstate, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool preserve_cardinality) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _initial_state = ::tensorflow::ops::AsNodeOut(scope, initial_state);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalScanDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalScanDataset")
                                   .Input(_input_dataset)
                                   .Input(_initial_state)
                                   .Input(_other_arguments)
                                   .Attr("f", f)
                                   .Attr("Tstate", Tstate)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("preserve_cardinality", preserve_cardinality)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Log1p::Log1p(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Log1p");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Log1p")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArraySize::TensorArraySize(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArraySize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArraySize")
                                   .Input(_handle)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Requantize::Requantize(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_min, 
           tensorflow::Input input_max, 
           tensorflow::Input requested_output_min, 
           tensorflow::Input requested_output_max) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_min = ::tensorflow::ops::AsNodeOut(scope, input_min);
      if (!scope.ok())
          return;
      auto _input_max = ::tensorflow::ops::AsNodeOut(scope, input_max);
      if (!scope.ok())
          return;
      auto _requested_output_min = ::tensorflow::ops::AsNodeOut(scope, requested_output_min);
      if (!scope.ok())
          return;
      auto _requested_output_max = ::tensorflow::ops::AsNodeOut(scope, requested_output_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Requantize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Requantize")
                                   .Input(_input)
                                   .Input(_input_min)
                                   .Input(_input_max)
                                   .Input(_requested_output_min)
                                   .Input(_requested_output_max)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Exp::Exp(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Exp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Exp")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterNdAdd::ScatterNdAdd(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterNdAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterNdAdd")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MutableHashTableOfTensors::MutableHashTableOfTensors(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           tensorflow::DataType key_dtype, 
           tensorflow::DataType value_dtype, 
           tensorflow::PartialTensorShape value_shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutableHashTableOfTensors");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutableHashTableOfTensors")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("key_dtype", key_dtype)
                                   .Attr("value_dtype", value_dtype)
                                   .Attr("value_shape", value_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Dilation2D::Dilation2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::gtl::ArraySlice<int64_t> rates, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Dilation2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Dilation2D")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Attr("strides", strides)
                                   .Attr("rates", rates)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DeserializeIterator::DeserializeIterator(tensorflow::Scope& scope, 
           tensorflow::Input resource_handle, 
           tensorflow::Input serialized) {
      if (!scope.ok())
          return;
      auto _resource_handle = ::tensorflow::ops::AsNodeOut(scope, resource_handle);
      if (!scope.ok())
          return;
      auto _serialized = ::tensorflow::ops::AsNodeOut(scope, serialized);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DeserializeIterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DeserializeIterator")
                                   .Input(_resource_handle)
                                   .Input(_serialized)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

RsqrtGrad::RsqrtGrad(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input dy) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RsqrtGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RsqrtGrad")
                                   .Input(_y)
                                   .Input(_dy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedInstanceNorm::QuantizedInstanceNorm(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input x_min, 
           tensorflow::Input x_max, 
           float min_separation, 
           bool output_range_given, 
           float given_y_min, 
           float given_y_max, 
           float variance_epsilon) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _x_min = ::tensorflow::ops::AsNodeOut(scope, x_min);
      if (!scope.ok())
          return;
      auto _x_max = ::tensorflow::ops::AsNodeOut(scope, x_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedInstanceNorm");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedInstanceNorm")
                                   .Input(_x)
                                   .Input(_x_min)
                                   .Input(_x_max)
                                   .Attr("min_separation", min_separation)
                                   .Attr("output_range_given", output_range_given)
                                   .Attr("given_y_min", given_y_min)
                                   .Attr("given_y_max", given_y_max)
                                   .Attr("variance_epsilon", variance_epsilon)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Rsqrt::Rsqrt(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Rsqrt");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Rsqrt")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InitializeTableFromTextFile::InitializeTableFromTextFile(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input filename, 
           int64_t key_index, 
           int64_t value_index, 
           int64_t vocab_size, 
           tensorflow::string delimiter) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InitializeTableFromTextFile");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InitializeTableFromTextFile")
                                   .Input(_table_handle)
                                   .Input(_filename)
                                   .Attr("key_index", key_index)
                                   .Attr("value_index", value_index)
                                   .Attr("vocab_size", vocab_size)
                                   .Attr("delimiter", delimiter)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SqrtGrad::SqrtGrad(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input dy) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SqrtGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SqrtGrad")
                                   .Input(_y)
                                   .Input(_dy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentSqrtN::SparseSegmentSqrtN(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentSqrtN");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentSqrtN")
                                   .Input(_data)
                                   .Input(_indices)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_MklMaximum::_MklMaximum(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input mkl_x, 
           tensorflow::Input mkl_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _mkl_x = ::tensorflow::ops::AsNodeOut(scope, mkl_x);
      if (!scope.ok())
          return;
      auto _mkl_y = ::tensorflow::ops::AsNodeOut(scope, mkl_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_MklMaximum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_MklMaximum")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_mkl_x)
                                   .Input(_mkl_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Sqrt::Sqrt(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sqrt");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sqrt")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InvGrad::InvGrad(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input dy) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InvGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InvGrad")
                                   .Input(_y)
                                   .Input(_dy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Inv::Inv(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Inv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Inv")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalStatsAggregatorSummary::ExperimentalStatsAggregatorSummary(tensorflow::Scope& scope, 
           tensorflow::Input iterator) {
      if (!scope.ok())
          return;
      auto _iterator = ::tensorflow::ops::AsNodeOut(scope, iterator);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalStatsAggregatorSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalStatsAggregatorSummary")
                                   .Input(_iterator)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_HostCast::_HostCast(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           bool Truncate) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_HostCast");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_HostCast")
                                   .Input(_x)
                                   .Attr("Truncate", Truncate)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatMul::BatchMatMul(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           bool adj_y, 
           bool adj_x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatMul")
                                   .Input(_x)
                                   .Input(_y)
                                   .Attr("adj_y", adj_y)
                                   .Attr("adj_x", adj_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AccumulateNV2::AccumulateNV2(tensorflow::Scope& scope, 
           tensorflow::InputList inputs, 
           tensorflow::PartialTensorShape shape) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AccumulateNV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AccumulateNV2")
                                   .Input(_inputs)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InitializeTableFromTextFileV2::InitializeTableFromTextFileV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input filename, 
           int64_t key_index, 
           int64_t value_index, 
           int64_t vocab_size, 
           tensorflow::string delimiter) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InitializeTableFromTextFileV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InitializeTableFromTextFileV2")
                                   .Input(_table_handle)
                                   .Input(_filename)
                                   .Attr("key_index", key_index)
                                   .Attr("value_index", value_index)
                                   .Attr("vocab_size", vocab_size)
                                   .Attr("delimiter", delimiter)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

InitializeTable::InitializeTable(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InitializeTable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InitializeTable")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

FractionalAvgPoolGrad::FractionalAvgPoolGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input_tensor_shape, 
           tensorflow::Input out_backprop, 
           tensorflow::Input row_pooling_sequence, 
           tensorflow::Input col_pooling_sequence, 
           bool overlapping) {
      if (!scope.ok())
          return;
      auto _orig_input_tensor_shape = ::tensorflow::ops::AsNodeOut(scope, orig_input_tensor_shape);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      if (!scope.ok())
          return;
      auto _row_pooling_sequence = ::tensorflow::ops::AsNodeOut(scope, row_pooling_sequence);
      if (!scope.ok())
          return;
      auto _col_pooling_sequence = ::tensorflow::ops::AsNodeOut(scope, col_pooling_sequence);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FractionalAvgPoolGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FractionalAvgPoolGrad")
                                   .Input(_orig_input_tensor_shape)
                                   .Input(_out_backprop)
                                   .Input(_row_pooling_sequence)
                                   .Input(_col_pooling_sequence)
                                   .Attr("overlapping", overlapping)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MutableDenseHashTableV2::MutableDenseHashTableV2(tensorflow::Scope& scope, 
           tensorflow::Input empty_key, 
           tensorflow::Input deleted_key, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           float max_load_factor, 
           tensorflow::DataType value_dtype, 
           tensorflow::PartialTensorShape value_shape, 
           int64_t initial_num_buckets) {
      if (!scope.ok())
          return;
      auto _empty_key = ::tensorflow::ops::AsNodeOut(scope, empty_key);
      if (!scope.ok())
          return;
      auto _deleted_key = ::tensorflow::ops::AsNodeOut(scope, deleted_key);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutableDenseHashTableV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutableDenseHashTableV2")
                                   .Input(_empty_key)
                                   .Input(_deleted_key)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("max_load_factor", max_load_factor)
                                   .Attr("value_dtype", value_dtype)
                                   .Attr("value_shape", value_shape)
                                   .Attr("initial_num_buckets", initial_num_buckets)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MutableHashTable::MutableHashTable(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           tensorflow::DataType key_dtype, 
           tensorflow::DataType value_dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutableHashTable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutableHashTable")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("key_dtype", key_dtype)
                                   .Attr("value_dtype", value_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesCenterBias::BoostedTreesCenterBias(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input mean_gradients, 
           tensorflow::Input mean_hessians, 
           tensorflow::Input l1, 
           tensorflow::Input l2) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _mean_gradients = ::tensorflow::ops::AsNodeOut(scope, mean_gradients);
      if (!scope.ok())
          return;
      auto _mean_hessians = ::tensorflow::ops::AsNodeOut(scope, mean_hessians);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesCenterBias");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesCenterBias")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_mean_gradients)
                                   .Input(_mean_hessians)
                                   .Input(_l1)
                                   .Input(_l2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

HashTableV2::HashTableV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           tensorflow::DataType key_dtype, 
           tensorflow::DataType value_dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("HashTableV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "HashTableV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("key_dtype", key_dtype)
                                   .Attr("value_dtype", value_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

HashTable::HashTable(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           tensorflow::DataType key_dtype, 
           tensorflow::DataType value_dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("HashTable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "HashTable")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("key_dtype", key_dtype)
                                   .Attr("value_dtype", value_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableImportV2::LookupTableImportV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableImportV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableImportV2")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

RegexFullMatch::RegexFullMatch(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input pattern) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _pattern = ::tensorflow::ops::AsNodeOut(scope, pattern);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RegexFullMatch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RegexFullMatch")
                                   .Input(_input)
                                   .Input(_pattern)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableImport::LookupTableImport(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableImport");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableImport")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

NonMaxSuppressionWithOverlaps::NonMaxSuppressionWithOverlaps(tensorflow::Scope& scope, 
           tensorflow::Input overlaps, 
           tensorflow::Input scores, 
           tensorflow::Input max_output_size, 
           tensorflow::Input overlap_threshold, 
           tensorflow::Input score_threshold) {
      if (!scope.ok())
          return;
      auto _overlaps = ::tensorflow::ops::AsNodeOut(scope, overlaps);
      if (!scope.ok())
          return;
      auto _scores = ::tensorflow::ops::AsNodeOut(scope, scores);
      if (!scope.ok())
          return;
      auto _max_output_size = ::tensorflow::ops::AsNodeOut(scope, max_output_size);
      if (!scope.ok())
          return;
      auto _overlap_threshold = ::tensorflow::ops::AsNodeOut(scope, overlap_threshold);
      if (!scope.ok())
          return;
      auto _score_threshold = ::tensorflow::ops::AsNodeOut(scope, score_threshold);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NonMaxSuppressionWithOverlaps");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NonMaxSuppressionWithOverlaps")
                                   .Input(_overlaps)
                                   .Input(_scores)
                                   .Input(_max_output_size)
                                   .Input(_overlap_threshold)
                                   .Input(_score_threshold)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableExportV2::LookupTableExportV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::DataType Tvalues) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableExportV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableExportV2")
                                   .Input(_table_handle)
                                   .Attr("Tvalues", Tvalues)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AssignVariableOp::AssignVariableOp(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input value, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AssignVariableOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AssignVariableOp")
                                   .Input(_resource)
                                   .Input(_value)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

LookupTableSize::LookupTableSize(tensorflow::Scope& scope, 
           tensorflow::Input table_handle) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableSize")
                                   .Input(_table_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PaddingFIFOQueueV2::PaddingFIFOQueueV2(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PaddingFIFOQueueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PaddingFIFOQueueV2")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableFind::LookupTableFind(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input default_value) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _default_value = ::tensorflow::ops::AsNodeOut(scope, default_value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableFind");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableFind")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_default_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LessEqual::LessEqual(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LessEqual");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LessEqual")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Timestamp::Timestamp(tensorflow::Scope& scope) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Timestamp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Timestamp")
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MergeSummary::MergeSummary(tensorflow::Scope& scope, 
           tensorflow::InputList inputs) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MergeSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MergeSummary")
                                   .Input(_inputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AvgPool::AvgPool(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AvgPool");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AvgPool")
                                   .Input(_value)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AudioSummaryV2::AudioSummaryV2(tensorflow::Scope& scope, 
           tensorflow::Input tag, 
           tensorflow::Input tensor, 
           tensorflow::Input sample_rate, 
           int64_t max_outputs) {
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _sample_rate = ::tensorflow::ops::AsNodeOut(scope, sample_rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AudioSummaryV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AudioSummaryV2")
                                   .Input(_tag)
                                   .Input(_tensor)
                                   .Input(_sample_rate)
                                   .Attr("max_outputs", max_outputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

HistogramSummary::HistogramSummary(tensorflow::Scope& scope, 
           tensorflow::Input tag, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("HistogramSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "HistogramSummary")
                                   .Input(_tag)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListScatter::TensorListScatter(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input indices, 
           tensorflow::Input element_shape) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _element_shape = ::tensorflow::ops::AsNodeOut(scope, element_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListScatter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListScatter")
                                   .Input(_tensor)
                                   .Input(_indices)
                                   .Input(_element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListSetItem::TensorListSetItem(tensorflow::Scope& scope, 
           tensorflow::Input input_handle, 
           tensorflow::Input index, 
           tensorflow::Input item) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _item = ::tensorflow::ops::AsNodeOut(scope, item);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListSetItem");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListSetItem")
                                   .Input(_input_handle)
                                   .Input(_index)
                                   .Input(_item)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ClipByValue::ClipByValue(tensorflow::Scope& scope, 
           tensorflow::Input t, 
           tensorflow::Input clip_value_min, 
           tensorflow::Input clip_value_max) {
      if (!scope.ok())
          return;
      auto _t = ::tensorflow::ops::AsNodeOut(scope, t);
      if (!scope.ok())
          return;
      auto _clip_value_min = ::tensorflow::ops::AsNodeOut(scope, clip_value_min);
      if (!scope.ok())
          return;
      auto _clip_value_max = ::tensorflow::ops::AsNodeOut(scope, clip_value_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ClipByValue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ClipByValue")
                                   .Input(_t)
                                   .Input(_clip_value_min)
                                   .Input(_clip_value_max)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListReserve::TensorListReserve(tensorflow::Scope& scope, 
           tensorflow::Input element_shape, 
           tensorflow::Input num_elements, 
           tensorflow::DataType element_dtype) {
      if (!scope.ok())
          return;
      auto _element_shape = ::tensorflow::ops::AsNodeOut(scope, element_shape);
      if (!scope.ok())
          return;
      auto _num_elements = ::tensorflow::ops::AsNodeOut(scope, num_elements);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListReserve");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListReserve")
                                   .Input(_element_shape)
                                   .Input(_num_elements)
                                   .Attr("element_dtype", element_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalThreadPoolHandle::ExperimentalThreadPoolHandle(tensorflow::Scope& scope, 
           tensorflow::string display_name, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t num_threads, 
           int64_t max_intra_op_parallelism) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalThreadPoolHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalThreadPoolHandle")
                                   .Attr("display_name", display_name)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("num_threads", num_threads)
                                   .Attr("max_intra_op_parallelism", max_intra_op_parallelism)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListFromTensor::TensorListFromTensor(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input element_shape) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _element_shape = ::tensorflow::ops::AsNodeOut(scope, element_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListFromTensor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListFromTensor")
                                   .Input(_tensor)
                                   .Input(_element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListStack::TensorListStack(tensorflow::Scope& scope, 
           tensorflow::Input input_handle, 
           int64_t num_elements) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListStack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListStack")
                                   .Input(_input_handle)
                                   .Attr("num_elements", num_elements)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_MklMul::_MklMul(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input mkl_x, 
           tensorflow::Input mkl_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _mkl_x = ::tensorflow::ops::AsNodeOut(scope, mkl_x);
      if (!scope.ok())
          return;
      auto _mkl_y = ::tensorflow::ops::AsNodeOut(scope, mkl_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_MklMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_MklMul")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_mkl_x)
                                   .Input(_mkl_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorScatterUpdate::TensorScatterUpdate(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input indices, 
           tensorflow::Input updates) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorScatterUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorScatterUpdate")
                                   .Input(_tensor)
                                   .Input(_indices)
                                   .Input(_updates)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TakeDataset::TakeDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input count, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _count = ::tensorflow::ops::AsNodeOut(scope, count);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TakeDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TakeDataset")
                                   .Input(_input_dataset)
                                   .Input(_count)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListPopBack::TensorListPopBack(tensorflow::Scope& scope, 
           tensorflow::Input input_handle, 
           tensorflow::DataType element_dtype) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListPopBack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListPopBack")
                                   .Input(_input_handle)
                                   .Attr("element_dtype", element_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListLength::TensorListLength(tensorflow::Scope& scope, 
           tensorflow::Input input_handle) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListLength");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListLength")
                                   .Input(_input_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalIndexedDatasetGet::ExperimentalIndexedDatasetGet(tensorflow::Scope& scope, 
           tensorflow::Input materialized, 
           tensorflow::Input index, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _materialized = ::tensorflow::ops::AsNodeOut(scope, materialized);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalIndexedDatasetGet");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalIndexedDatasetGet")
                                   .Input(_materialized)
                                   .Input(_index)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListPushBackBatch::TensorListPushBackBatch(tensorflow::Scope& scope, 
           tensorflow::Input input_handles, 
           tensorflow::Input tensor) {
      if (!scope.ok())
          return;
      auto _input_handles = ::tensorflow::ops::AsNodeOut(scope, input_handles);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListPushBackBatch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListPushBackBatch")
                                   .Input(_input_handles)
                                   .Input(_tensor)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EmptyTensorList::EmptyTensorList(tensorflow::Scope& scope, 
           tensorflow::Input element_shape, 
           tensorflow::Input max_num_elements, 
           tensorflow::DataType element_dtype) {
      if (!scope.ok())
          return;
      auto _element_shape = ::tensorflow::ops::AsNodeOut(scope, element_shape);
      if (!scope.ok())
          return;
      auto _max_num_elements = ::tensorflow::ops::AsNodeOut(scope, max_num_elements);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EmptyTensorList");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EmptyTensorList")
                                   .Input(_element_shape)
                                   .Input(_max_num_elements)
                                   .Attr("element_dtype", element_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomStandardNormal::RandomStandardNormal(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomStandardNormal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomStandardNormal")
                                   .Input(_shape)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Erf::Erf(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Erf");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Erf")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Mean::Mean(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Mean");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Mean")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixTriangularSolve::BatchMatrixTriangularSolve(tensorflow::Scope& scope, 
           tensorflow::Input matrix, 
           tensorflow::Input rhs, 
           bool lower, 
           bool adjoint) {
      if (!scope.ok())
          return;
      auto _matrix = ::tensorflow::ops::AsNodeOut(scope, matrix);
      if (!scope.ok())
          return;
      auto _rhs = ::tensorflow::ops::AsNodeOut(scope, rhs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixTriangularSolve");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixTriangularSolve")
                                   .Input(_matrix)
                                   .Input(_rhs)
                                   .Attr("lower", lower)
                                   .Attr("adjoint", adjoint)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixSolve::BatchMatrixSolve(tensorflow::Scope& scope, 
           tensorflow::Input matrix, 
           tensorflow::Input rhs, 
           bool adjoint) {
      if (!scope.ok())
          return;
      auto _matrix = ::tensorflow::ops::AsNodeOut(scope, matrix);
      if (!scope.ok())
          return;
      auto _rhs = ::tensorflow::ops::AsNodeOut(scope, rhs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixSolve");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixSolve")
                                   .Input(_matrix)
                                   .Input(_rhs)
                                   .Attr("adjoint", adjoint)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedBiasAdd::QuantizedBiasAdd(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input bias, 
           tensorflow::Input min_input, 
           tensorflow::Input max_input, 
           tensorflow::Input min_bias, 
           tensorflow::Input max_bias) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _bias = ::tensorflow::ops::AsNodeOut(scope, bias);
      if (!scope.ok())
          return;
      auto _min_input = ::tensorflow::ops::AsNodeOut(scope, min_input);
      if (!scope.ok())
          return;
      auto _max_input = ::tensorflow::ops::AsNodeOut(scope, max_input);
      if (!scope.ok())
          return;
      auto _min_bias = ::tensorflow::ops::AsNodeOut(scope, min_bias);
      if (!scope.ok())
          return;
      auto _max_bias = ::tensorflow::ops::AsNodeOut(scope, max_bias);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedBiasAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedBiasAdd")
                                   .Input(_input)
                                   .Input(_bias)
                                   .Input(_min_input)
                                   .Input(_max_input)
                                   .Input(_min_bias)
                                   .Input(_max_bias)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DataFormatVecPermute::DataFormatVecPermute(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::string dst_format, 
           tensorflow::string src_format) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DataFormatVecPermute");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DataFormatVecPermute")
                                   .Input(_x)
                                   .Attr("dst_format", dst_format)
                                   .Attr("src_format", src_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchCholeskyGrad::BatchCholeskyGrad(tensorflow::Scope& scope, 
           tensorflow::Input l, 
           tensorflow::Input grad) {
      if (!scope.ok())
          return;
      auto _l = ::tensorflow::ops::AsNodeOut(scope, l);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchCholeskyGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchCholeskyGrad")
                                   .Input(_l)
                                   .Input(_grad)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixInverse::BatchMatrixInverse(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool adjoint) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixInverse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixInverse")
                                   .Input(_input)
                                   .Attr("adjoint", adjoint)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DebugNumericSummary::DebugNumericSummary(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string device_name, 
           tensorflow::string tensor_name, 
           tensorflow::gtl::ArraySlice<tensorflow::string> debug_urls, 
           bool gated_grpc, 
           float lower_bound, 
           float upper_bound, 
           bool mute_if_healthy) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DebugNumericSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DebugNumericSummary")
                                   .Input(_input)
                                   .Attr("device_name", device_name)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("debug_urls", debug_urls)
                                   .Attr("gated_grpc", gated_grpc)
                                   .Attr("lower_bound", lower_bound)
                                   .Attr("upper_bound", upper_bound)
                                   .Attr("mute_if_healthy", mute_if_healthy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchSelfAdjointEig::BatchSelfAdjointEig(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchSelfAdjointEig");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchSelfAdjointEig")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableFindV2::LookupTableFindV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input default_value) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _default_value = ::tensorflow::ops::AsNodeOut(scope, default_value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableFindV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableFindV2")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_default_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Asinh::Asinh(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Asinh");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Asinh")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CollectiveBcastRecv::CollectiveBcastRecv(tensorflow::Scope& scope, 
           tensorflow::PartialTensorShape shape, 
           int64_t group_size, 
           int64_t group_key, 
           int64_t instance_key) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CollectiveBcastRecv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CollectiveBcastRecv")
                                   .Attr("shape", shape)
                                   .Attr("group_size", group_size)
                                   .Attr("group_key", group_key)
                                   .Attr("instance_key", instance_key)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayScatterV3::TensorArrayScatterV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input indices, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayScatterV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayScatterV3")
                                   .Input(_handle)
                                   .Input(_indices)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixSquareRoot::MatrixSquareRoot(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixSquareRoot");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixSquareRoot")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixTriangularSolve::MatrixTriangularSolve(tensorflow::Scope& scope, 
           tensorflow::Input matrix, 
           tensorflow::Input rhs, 
           bool lower, 
           bool adjoint) {
      if (!scope.ok())
          return;
      auto _matrix = ::tensorflow::ops::AsNodeOut(scope, matrix);
      if (!scope.ok())
          return;
      auto _rhs = ::tensorflow::ops::AsNodeOut(scope, rhs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixTriangularSolve");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixTriangularSolve")
                                   .Input(_matrix)
                                   .Input(_rhs)
                                   .Attr("lower", lower)
                                   .Attr("adjoint", adjoint)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SelfAdjointEig::SelfAdjointEig(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SelfAdjointEig");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SelfAdjointEig")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Reshape::Reshape(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input shape) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Reshape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Reshape")
                                   .Input(_tensor)
                                   .Input(_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ArgMax::ArgMax(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input dimension) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _dimension = ::tensorflow::ops::AsNodeOut(scope, dimension);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ArgMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ArgMax")
                                   .Input(_input)
                                   .Input(_dimension)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CholeskyGrad::CholeskyGrad(tensorflow::Scope& scope, 
           tensorflow::Input l, 
           tensorflow::Input grad) {
      if (!scope.ok())
          return;
      auto _l = ::tensorflow::ops::AsNodeOut(scope, l);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CholeskyGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CholeskyGrad")
                                   .Input(_l)
                                   .Input(_grad)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StaticRegexFullMatch::StaticRegexFullMatch(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string pattern) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StaticRegexFullMatch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StaticRegexFullMatch")
                                   .Input(_input)
                                   .Attr("pattern", pattern)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParseSingleSequenceExample::ParseSingleSequenceExample(tensorflow::Scope& scope, 
           tensorflow::Input serialized, 
           tensorflow::Input feature_list_dense_missing_assumed_empty, 
           tensorflow::Input context_sparse_keys, 
           tensorflow::Input context_dense_keys, 
           tensorflow::Input feature_list_sparse_keys, 
           tensorflow::Input feature_list_dense_keys, 
           tensorflow::Input context_dense_defaults, 
           tensorflow::Input debug_name, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> context_sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcontext_dense, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> feature_list_dense_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> context_dense_shapes, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> feature_list_sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> feature_list_dense_shapes, 
           int64_t Ncontext_sparse, 
           int64_t Ncontext_dense, 
           int64_t Nfeature_list_sparse, 
           int64_t Nfeature_list_dense) {
      if (!scope.ok())
          return;
      auto _serialized = ::tensorflow::ops::AsNodeOut(scope, serialized);
      if (!scope.ok())
          return;
      auto _feature_list_dense_missing_assumed_empty = ::tensorflow::ops::AsNodeOut(scope, feature_list_dense_missing_assumed_empty);
      if (!scope.ok())
          return;
      auto _context_sparse_keys = ::tensorflow::ops::AsNodeOut(scope, context_sparse_keys);
      if (!scope.ok())
          return;
      auto _context_dense_keys = ::tensorflow::ops::AsNodeOut(scope, context_dense_keys);
      if (!scope.ok())
          return;
      auto _feature_list_sparse_keys = ::tensorflow::ops::AsNodeOut(scope, feature_list_sparse_keys);
      if (!scope.ok())
          return;
      auto _feature_list_dense_keys = ::tensorflow::ops::AsNodeOut(scope, feature_list_dense_keys);
      if (!scope.ok())
          return;
      auto _context_dense_defaults = ::tensorflow::ops::AsNodeOut(scope, context_dense_defaults);
      if (!scope.ok())
          return;
      auto _debug_name = ::tensorflow::ops::AsNodeOut(scope, debug_name);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParseSingleSequenceExample");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParseSingleSequenceExample")
                                   .Input(_serialized)
                                   .Input(_feature_list_dense_missing_assumed_empty)
                                   .Input(_context_sparse_keys)
                                   .Input(_context_dense_keys)
                                   .Input(_feature_list_sparse_keys)
                                   .Input(_feature_list_dense_keys)
                                   .Input(_context_dense_defaults)
                                   .Input(_debug_name)
                                   .Attr("context_sparse_types", context_sparse_types)
                                   .Attr("Tcontext_dense", Tcontext_dense)
                                   .Attr("feature_list_dense_types", feature_list_dense_types)
                                   .Attr("context_dense_shapes", context_dense_shapes)
                                   .Attr("feature_list_sparse_types", feature_list_sparse_types)
                                   .Attr("feature_list_dense_shapes", feature_list_dense_shapes)
                                   .Attr("Ncontext_sparse", Ncontext_sparse)
                                   .Attr("Ncontext_dense", Ncontext_dense)
                                   .Attr("Nfeature_list_sparse", Nfeature_list_sparse)
                                   .Attr("Nfeature_list_dense", Nfeature_list_dense)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableExport::LookupTableExport(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::DataType Tvalues) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableExport");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableExport")
                                   .Input(_table_handle)
                                   .Attr("Tvalues", Tvalues)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueDequeue::QueueDequeue(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueDequeue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueDequeue")
                                   .Input(_handle)
                                   .Attr("component_types", component_types)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListSplit::TensorListSplit(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input element_shape, 
           tensorflow::Input lengths) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _element_shape = ::tensorflow::ops::AsNodeOut(scope, element_shape);
      if (!scope.ok())
          return;
      auto _lengths = ::tensorflow::ops::AsNodeOut(scope, lengths);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListSplit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListSplit")
                                   .Input(_tensor)
                                   .Input(_element_shape)
                                   .Input(_lengths)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixSolveLs::BatchMatrixSolveLs(tensorflow::Scope& scope, 
           tensorflow::Input matrix, 
           tensorflow::Input rhs, 
           tensorflow::Input l2_regularizer, 
           bool fast) {
      if (!scope.ok())
          return;
      auto _matrix = ::tensorflow::ops::AsNodeOut(scope, matrix);
      if (!scope.ok())
          return;
      auto _rhs = ::tensorflow::ops::AsNodeOut(scope, rhs);
      if (!scope.ok())
          return;
      auto _l2_regularizer = ::tensorflow::ops::AsNodeOut(scope, l2_regularizer);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixSolveLs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixSolveLs")
                                   .Input(_matrix)
                                   .Input(_rhs)
                                   .Input(_l2_regularizer)
                                   .Attr("fast", fast)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixDeterminant::MatrixDeterminant(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixDeterminant");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixDeterminant")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FloorMod::FloorMod(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FloorMod");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FloorMod")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatchingFiles::MatchingFiles(tensorflow::Scope& scope, 
           tensorflow::Input pattern) {
      if (!scope.ok())
          return;
      auto _pattern = ::tensorflow::ops::AsNodeOut(scope, pattern);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatchingFiles");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatchingFiles")
                                   .Input(_pattern)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteImageSummary::WriteImageSummary(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input step, 
           tensorflow::Input tag, 
           tensorflow::Input tensor, 
           tensorflow::Input bad_color, 
           int64_t max_images) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _bad_color = ::tensorflow::ops::AsNodeOut(scope, bad_color);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteImageSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteImageSummary")
                                   .Input(_writer)
                                   .Input(_step)
                                   .Input(_tag)
                                   .Input(_tensor)
                                   .Input(_bad_color)
                                   .Attr("max_images", max_images)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MatrixSolve::MatrixSolve(tensorflow::Scope& scope, 
           tensorflow::Input matrix, 
           tensorflow::Input rhs, 
           bool adjoint) {
      if (!scope.ok())
          return;
      auto _matrix = ::tensorflow::ops::AsNodeOut(scope, matrix);
      if (!scope.ok())
          return;
      auto _rhs = ::tensorflow::ops::AsNodeOut(scope, rhs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixSolve");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixSolve")
                                   .Input(_matrix)
                                   .Input(_rhs)
                                   .Attr("adjoint", adjoint)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayConcatV2::TensorArrayConcatV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape_except0) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayConcatV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayConcatV2")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape_except0", element_shape_except0)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteFile::WriteFile(tensorflow::Scope& scope, 
           tensorflow::Input filename, 
           tensorflow::Input contents) {
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteFile");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteFile")
                                   .Input(_filename)
                                   .Input(_contents)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

TruncatedNormal::TruncatedNormal(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           int64_t seed, 
           int64_t seed2, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TruncatedNormal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TruncatedNormal")
                                   .Input(_shape)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReadFile::ReadFile(tensorflow::Scope& scope, 
           tensorflow::Input filename) {
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReadFile");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReadFile")
                                   .Input(_filename)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQuantWithMinMaxVarsPerChannelGradient::FakeQuantWithMinMaxVarsPerChannelGradient(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input inputs, 
           tensorflow::Input min, 
           tensorflow::Input max, 
           int64_t num_bits, 
           bool narrow_range) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _min = ::tensorflow::ops::AsNodeOut(scope, min);
      if (!scope.ok())
          return;
      auto _max = ::tensorflow::ops::AsNodeOut(scope, max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQuantWithMinMaxVarsPerChannelGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQuantWithMinMaxVarsPerChannelGradient")
                                   .Input(_gradients)
                                   .Input(_inputs)
                                   .Input(_min)
                                   .Input(_max)
                                   .Attr("num_bits", num_bits)
                                   .Attr("narrow_range", narrow_range)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PrintV2::PrintV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string output_stream) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PrintV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PrintV2")
                                   .Input(_input)
                                   .Attr("output_stream", output_stream)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ReaderResetV2::ReaderResetV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderResetV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderResetV2")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ReaderSerializeState::ReaderSerializeState(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderSerializeState");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderSerializeState")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderNumWorkUnitsCompletedV2::ReaderNumWorkUnitsCompletedV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderNumWorkUnitsCompletedV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderNumWorkUnitsCompletedV2")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LowerBound::LowerBound(tensorflow::Scope& scope, 
           tensorflow::Input sorted_inputs, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _sorted_inputs = ::tensorflow::ops::AsNodeOut(scope, sorted_inputs);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LowerBound");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LowerBound")
                                   .Input(_sorted_inputs)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Greater::Greater(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Greater");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Greater")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderNumWorkUnitsCompleted::ReaderNumWorkUnitsCompleted(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderNumWorkUnitsCompleted");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderNumWorkUnitsCompleted")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeRaw::DecodeRaw(tensorflow::Scope& scope, 
           tensorflow::Input bytes, 
           bool little_endian) {
      if (!scope.ok())
          return;
      auto _bytes = ::tensorflow::ops::AsNodeOut(scope, bytes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeRaw");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeRaw")
                                   .Input(_bytes)
                                   .Attr("little_endian", little_endian)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderNumRecordsProducedV2::ReaderNumRecordsProducedV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderNumRecordsProducedV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderNumRecordsProducedV2")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Cumprod::Cumprod(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input axis, 
           bool exclusive, 
           bool reverse) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Cumprod");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Cumprod")
                                   .Input(_x)
                                   .Input(_axis)
                                   .Attr("exclusive", exclusive)
                                   .Attr("reverse", reverse)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderReadV2::ReaderReadV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle, 
           tensorflow::Input queue_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      if (!scope.ok())
          return;
      auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderReadV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderReadV2")
                                   .Input(_reader_handle)
                                   .Input(_queue_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Square::Square(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Square");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Square")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IdentityReader::IdentityReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IdentityReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IdentityReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Slice::Slice(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input begin, 
           tensorflow::Input size) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _begin = ::tensorflow::ops::AsNodeOut(scope, begin);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Slice");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Slice")
                                   .Input(_input)
                                   .Input(_begin)
                                   .Input(_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LMDBReader::LMDBReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LMDBReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LMDBReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TFRecordReaderV2::TFRecordReaderV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::string compression_type) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TFRecordReaderV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TFRecordReaderV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("compression_type", compression_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TFRecordReader::TFRecordReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::string compression_type) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TFRecordReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TFRecordReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("compression_type", compression_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FixedLengthRecordReaderV2::FixedLengthRecordReaderV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::string encoding, 
           int64_t header_bytes, 
           int64_t record_bytes, 
           int64_t footer_bytes, 
           int64_t hop_bytes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FixedLengthRecordReaderV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FixedLengthRecordReaderV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("encoding", encoding)
                                   .Attr("header_bytes", header_bytes)
                                   .Attr("record_bytes", record_bytes)
                                   .Attr("footer_bytes", footer_bytes)
                                   .Attr("hop_bytes", hop_bytes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IdentityReaderV2::IdentityReaderV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IdentityReaderV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IdentityReaderV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TextLineReaderV2::TextLineReaderV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t skip_header_lines) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TextLineReaderV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TextLineReaderV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("skip_header_lines", skip_header_lines)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ShardedFilename::ShardedFilename(tensorflow::Scope& scope, 
           tensorflow::Input basename, 
           tensorflow::Input shard, 
           tensorflow::Input num_shards) {
      if (!scope.ok())
          return;
      auto _basename = ::tensorflow::ops::AsNodeOut(scope, basename);
      if (!scope.ok())
          return;
      auto _shard = ::tensorflow::ops::AsNodeOut(scope, shard);
      if (!scope.ok())
          return;
      auto _num_shards = ::tensorflow::ops::AsNodeOut(scope, num_shards);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ShardedFilename");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ShardedFilename")
                                   .Input(_basename)
                                   .Input(_shard)
                                   .Input(_num_shards)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RestoreSlice::RestoreSlice(tensorflow::Scope& scope, 
           tensorflow::Input file_pattern, 
           tensorflow::Input tensor_name, 
           tensorflow::Input shape_and_slice, 
           int64_t preferred_shard) {
      if (!scope.ok())
          return;
      auto _file_pattern = ::tensorflow::ops::AsNodeOut(scope, file_pattern);
      if (!scope.ok())
          return;
      auto _tensor_name = ::tensorflow::ops::AsNodeOut(scope, tensor_name);
      if (!scope.ok())
          return;
      auto _shape_and_slice = ::tensorflow::ops::AsNodeOut(scope, shape_and_slice);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RestoreSlice");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RestoreSlice")
                                   .Input(_file_pattern)
                                   .Input(_tensor_name)
                                   .Input(_shape_and_slice)
                                   .Attr("preferred_shard", preferred_shard)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Restore::Restore(tensorflow::Scope& scope, 
           tensorflow::Input file_pattern, 
           tensorflow::Input tensor_name, 
           int64_t preferred_shard) {
      if (!scope.ok())
          return;
      auto _file_pattern = ::tensorflow::ops::AsNodeOut(scope, file_pattern);
      if (!scope.ok())
          return;
      auto _tensor_name = ::tensorflow::ops::AsNodeOut(scope, tensor_name);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Restore");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Restore")
                                   .Input(_file_pattern)
                                   .Input(_tensor_name)
                                   .Attr("preferred_shard", preferred_shard)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SaveSlices::SaveSlices(tensorflow::Scope& scope, 
           tensorflow::Input filename, 
           tensorflow::Input tensor_names, 
           tensorflow::Input shapes_and_slices, 
           tensorflow::Input data, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T) {
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      if (!scope.ok())
          return;
      auto _tensor_names = ::tensorflow::ops::AsNodeOut(scope, tensor_names);
      if (!scope.ok())
          return;
      auto _shapes_and_slices = ::tensorflow::ops::AsNodeOut(scope, shapes_and_slices);
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SaveSlices");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SaveSlices")
                                   .Input(_filename)
                                   .Input(_tensor_names)
                                   .Input(_shapes_and_slices)
                                   .Input(_data)
                                   .Attr("T", T)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Save::Save(tensorflow::Scope& scope, 
           tensorflow::Input filename, 
           tensorflow::Input tensor_names, 
           tensorflow::Input data, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T) {
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      if (!scope.ok())
          return;
      auto _tensor_names = ::tensorflow::ops::AsNodeOut(scope, tensor_names);
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Save");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Save")
                                   .Input(_filename)
                                   .Input(_tensor_names)
                                   .Input(_data)
                                   .Attr("T", T)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MergeV2Checkpoints::MergeV2Checkpoints(tensorflow::Scope& scope, 
           tensorflow::Input checkpoint_prefixes, 
           tensorflow::Input destination_prefix, 
           bool delete_old_dirs) {
      if (!scope.ok())
          return;
      auto _checkpoint_prefixes = ::tensorflow::ops::AsNodeOut(scope, checkpoint_prefixes);
      if (!scope.ok())
          return;
      auto _destination_prefix = ::tensorflow::ops::AsNodeOut(scope, destination_prefix);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MergeV2Checkpoints");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MergeV2Checkpoints")
                                   .Input(_checkpoint_prefixes)
                                   .Input(_destination_prefix)
                                   .Attr("delete_old_dirs", delete_old_dirs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

NonMaxSuppressionV2::NonMaxSuppressionV2(tensorflow::Scope& scope, 
           tensorflow::Input boxes, 
           tensorflow::Input scores, 
           tensorflow::Input max_output_size, 
           tensorflow::Input iou_threshold) {
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _scores = ::tensorflow::ops::AsNodeOut(scope, scores);
      if (!scope.ok())
          return;
      auto _max_output_size = ::tensorflow::ops::AsNodeOut(scope, max_output_size);
      if (!scope.ok())
          return;
      auto _iou_threshold = ::tensorflow::ops::AsNodeOut(scope, iou_threshold);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NonMaxSuppressionV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NonMaxSuppressionV2")
                                   .Input(_boxes)
                                   .Input(_scores)
                                   .Input(_max_output_size)
                                   .Input(_iou_threshold)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefExit::RefExit(tensorflow::Scope& scope, 
           tensorflow::Input data) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefExit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefExit")
                                   .Input(_data)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NotEqual::NotEqual(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NotEqual");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NotEqual")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableRemoveV2::LookupTableRemoveV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableRemoveV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableRemoveV2")
                                   .Input(_table_handle)
                                   .Input(_keys)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

NonMaxSuppression::NonMaxSuppression(tensorflow::Scope& scope, 
           tensorflow::Input boxes, 
           tensorflow::Input scores, 
           tensorflow::Input max_output_size, 
           float iou_threshold) {
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _scores = ::tensorflow::ops::AsNodeOut(scope, scores);
      if (!scope.ok())
          return;
      auto _max_output_size = ::tensorflow::ops::AsNodeOut(scope, max_output_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NonMaxSuppression");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NonMaxSuppression")
                                   .Input(_boxes)
                                   .Input(_scores)
                                   .Input(_max_output_size)
                                   .Attr("iou_threshold", iou_threshold)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Tanh::Tanh(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Tanh");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Tanh")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CropAndResizeGradImage::CropAndResizeGradImage(tensorflow::Scope& scope, 
           tensorflow::Input grads, 
           tensorflow::Input boxes, 
           tensorflow::Input box_ind, 
           tensorflow::Input image_size, 
           tensorflow::string method) {
      if (!scope.ok())
          return;
      auto _grads = ::tensorflow::ops::AsNodeOut(scope, grads);
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _box_ind = ::tensorflow::ops::AsNodeOut(scope, box_ind);
      if (!scope.ok())
          return;
      auto _image_size = ::tensorflow::ops::AsNodeOut(scope, image_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CropAndResizeGradImage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CropAndResizeGradImage")
                                   .Input(_grads)
                                   .Input(_boxes)
                                   .Input(_box_ind)
                                   .Input(_image_size)
                                   .Attr("method", method)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AdjustSaturation::AdjustSaturation(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input scale) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _scale = ::tensorflow::ops::AsNodeOut(scope, scale);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AdjustSaturation");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AdjustSaturation")
                                   .Input(_images)
                                   .Input(_scale)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyPowerSign::ApplyPowerSign(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input lr, 
           tensorflow::Input logbase, 
           tensorflow::Input sign_decay, 
           tensorflow::Input beta, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _logbase = ::tensorflow::ops::AsNodeOut(scope, logbase);
      if (!scope.ok())
          return;
      auto _sign_decay = ::tensorflow::ops::AsNodeOut(scope, sign_decay);
      if (!scope.ok())
          return;
      auto _beta = ::tensorflow::ops::AsNodeOut(scope, beta);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyPowerSign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyPowerSign")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_lr)
                                   .Input(_logbase)
                                   .Input(_sign_decay)
                                   .Input(_beta)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedAvgPool::QuantizedAvgPool(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input min_input, 
           tensorflow::Input max_input, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _min_input = ::tensorflow::ops::AsNodeOut(scope, min_input);
      if (!scope.ok())
          return;
      auto _max_input = ::tensorflow::ops::AsNodeOut(scope, max_input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedAvgPool");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedAvgPool")
                                   .Input(_input)
                                   .Input(_min_input)
                                   .Input(_max_input)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AdjustContrastv2::AdjustContrastv2(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input contrast_factor) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _contrast_factor = ::tensorflow::ops::AsNodeOut(scope, contrast_factor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AdjustContrastv2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AdjustContrastv2")
                                   .Input(_images)
                                   .Input(_contrast_factor)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Rank::Rank(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Rank");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Rank")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EncodeJpeg::EncodeJpeg(tensorflow::Scope& scope, 
           tensorflow::Input image, 
           tensorflow::string format, 
           tensorflow::string xmp_metadata, 
           int64_t quality, 
           bool progressive, 
           bool optimize_size, 
           bool chroma_downsampling, 
           tensorflow::string density_unit, 
           int64_t x_density, 
           int64_t y_density) {
      if (!scope.ok())
          return;
      auto _image = ::tensorflow::ops::AsNodeOut(scope, image);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EncodeJpeg");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EncodeJpeg")
                                   .Input(_image)
                                   .Attr("format", format)
                                   .Attr("xmp_metadata", xmp_metadata)
                                   .Attr("quality", quality)
                                   .Attr("progressive", progressive)
                                   .Attr("optimize_size", optimize_size)
                                   .Attr("chroma_downsampling", chroma_downsampling)
                                   .Attr("density_unit", density_unit)
                                   .Attr("x_density", x_density)
                                   .Attr("y_density", y_density)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayConcat::TensorArrayConcat(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape_except0) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayConcat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayConcat")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape_except0", element_shape_except0)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeAndCropJpeg::DecodeAndCropJpeg(tensorflow::Scope& scope, 
           tensorflow::Input contents, 
           tensorflow::Input crop_window, 
           tensorflow::string dct_method, 
           int64_t channels, 
           int64_t ratio, 
           bool fancy_upscaling, 
           bool try_recover_truncated, 
           float acceptable_fraction) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      if (!scope.ok())
          return;
      auto _crop_window = ::tensorflow::ops::AsNodeOut(scope, crop_window);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeAndCropJpeg");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeAndCropJpeg")
                                   .Input(_contents)
                                   .Input(_crop_window)
                                   .Attr("dct_method", dct_method)
                                   .Attr("channels", channels)
                                   .Attr("ratio", ratio)
                                   .Attr("fancy_upscaling", fancy_upscaling)
                                   .Attr("try_recover_truncated", try_recover_truncated)
                                   .Attr("acceptable_fraction", acceptable_fraction)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeJpeg::DecodeJpeg(tensorflow::Scope& scope, 
           tensorflow::Input contents, 
           tensorflow::string dct_method, 
           int64_t channels, 
           int64_t ratio, 
           bool fancy_upscaling, 
           bool try_recover_truncated, 
           float acceptable_fraction) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeJpeg");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeJpeg")
                                   .Input(_contents)
                                   .Attr("dct_method", dct_method)
                                   .Attr("channels", channels)
                                   .Attr("ratio", ratio)
                                   .Attr("fancy_upscaling", fancy_upscaling)
                                   .Attr("try_recover_truncated", try_recover_truncated)
                                   .Attr("acceptable_fraction", acceptable_fraction)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomCrop::RandomCrop(tensorflow::Scope& scope, 
           tensorflow::Input image, 
           tensorflow::Input size, 
           int64_t seed2, 
           int64_t seed) {
      if (!scope.ok())
          return;
      auto _image = ::tensorflow::ops::AsNodeOut(scope, image);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomCrop");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomCrop")
                                   .Input(_image)
                                   .Input(_size)
                                   .Attr("seed2", seed2)
                                   .Attr("seed", seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BigQueryReader::BigQueryReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::string project_id, 
           tensorflow::string dataset_id, 
           tensorflow::string table_id, 
           tensorflow::gtl::ArraySlice<tensorflow::string> columns, 
           tensorflow::string test_end_point, 
           int64_t timestamp_millis) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BigQueryReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BigQueryReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("project_id", project_id)
                                   .Attr("dataset_id", dataset_id)
                                   .Attr("table_id", table_id)
                                   .Attr("columns", columns)
                                   .Attr("test_end_point", test_end_point)
                                   .Attr("timestamp_millis", timestamp_millis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResizeNearestNeighborGrad::ResizeNearestNeighborGrad(tensorflow::Scope& scope, 
           tensorflow::Input grads, 
           tensorflow::Input size, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _grads = ::tensorflow::ops::AsNodeOut(scope, grads);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeNearestNeighborGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeNearestNeighborGrad")
                                   .Input(_grads)
                                   .Input(_size)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LRN::LRN(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           int64_t depth_radius, 
           float bias, 
           float alpha, 
           float beta) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LRN");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LRN")
                                   .Input(_input)
                                   .Attr("depth_radius", depth_radius)
                                   .Attr("bias", bias)
                                   .Attr("alpha", alpha)
                                   .Attr("beta", beta)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv3DBackpropInputV2::Conv3DBackpropInputV2(tensorflow::Scope& scope, 
           tensorflow::Input input_sizes, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input_sizes = ::tensorflow::ops::AsNodeOut(scope, input_sizes);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv3DBackpropInputV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv3DBackpropInputV2")
                                   .Input(_input_sizes)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResizeBilinear::ResizeBilinear(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input size, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeBilinear");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeBilinear")
                                   .Input(_images)
                                   .Input(_size)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AssignAddVariableOp::AssignAddVariableOp(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input value, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AssignAddVariableOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AssignAddVariableOp")
                                   .Input(_resource)
                                   .Input(_value)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

DepthwiseConv2dNativeBackpropInput::DepthwiseConv2dNativeBackpropInput(tensorflow::Scope& scope, 
           tensorflow::Input input_sizes, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input_sizes = ::tensorflow::ops::AsNodeOut(scope, input_sizes);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DepthwiseConv2dNativeBackpropInput");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DepthwiseConv2dNativeBackpropInput")
                                   .Input(_input_sizes)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IsNan::IsNan(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IsNan");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IsNan")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListPushBack::TensorListPushBack(tensorflow::Scope& scope, 
           tensorflow::Input input_handle, 
           tensorflow::Input tensor) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListPushBack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListPushBack")
                                   .Input(_input_handle)
                                   .Input(_tensor)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseApplyMomentum::SparseApplyMomentum(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input momentum, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyMomentum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyMomentum")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_momentum)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UniqueWithCounts::UniqueWithCounts(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::DataType out_idx) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UniqueWithCounts");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UniqueWithCounts")
                                   .Input(_x)
                                   .Attr("out_idx", out_idx)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResizeBicubicGrad::ResizeBicubicGrad(tensorflow::Scope& scope, 
           tensorflow::Input grads, 
           tensorflow::Input original_image, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _grads = ::tensorflow::ops::AsNodeOut(scope, grads);
      if (!scope.ok())
          return;
      auto _original_image = ::tensorflow::ops::AsNodeOut(scope, original_image);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeBicubicGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeBicubicGrad")
                                   .Input(_grads)
                                   .Input(_original_image)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

HSVToRGB::HSVToRGB(tensorflow::Scope& scope, 
           tensorflow::Input images) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("HSVToRGB");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "HSVToRGB")
                                   .Input(_images)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentMeanWithNumSegments::SparseSegmentMeanWithNumSegments(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentMeanWithNumSegments");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentMeanWithNumSegments")
                                   .Input(_data)
                                   .Input(_indices)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResizeBicubic::ResizeBicubic(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input size, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeBicubic");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeBicubic")
                                   .Input(_images)
                                   .Input(_size)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderRestoreState::ReaderRestoreState(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle, 
           tensorflow::Input state) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      if (!scope.ok())
          return;
      auto _state = ::tensorflow::ops::AsNodeOut(scope, state);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderRestoreState");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderRestoreState")
                                   .Input(_reader_handle)
                                   .Input(_state)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResizeArea::ResizeArea(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input size, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeArea");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeArea")
                                   .Input(_images)
                                   .Input(_size)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterMin::ScatterMin(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterMin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterMin")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeParam::FakeParam(tensorflow::Scope& scope, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeParam");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeParam")
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Pow::Pow(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Pow");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Pow")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PartitionedCall::PartitionedCall(tensorflow::Scope& scope, 
           tensorflow::Input args, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList f, 
           tensorflow::string config, 
           tensorflow::string config_proto, 
           tensorflow::string executor_type) {
      if (!scope.ok())
          return;
      auto _args = ::tensorflow::ops::AsNodeOut(scope, args);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PartitionedCall");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PartitionedCall")
                                   .Input(_args)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("f", f)
                                   .Attr("config", config)
                                   .Attr("config_proto", config_proto)
                                   .Attr("executor_type", executor_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Sign::Sign(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sign")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

While::While(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           tensorflow::NameAttrList cond, 
           tensorflow::NameAttrList body, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("While");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "While")
                                   .Input(_input)
                                   .Attr("T", T)
                                   .Attr("cond", cond)
                                   .Attr("body", body)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Log::Log(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Log");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Log")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_While::_While(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           tensorflow::NameAttrList cond, 
           tensorflow::NameAttrList body) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_While");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_While")
                                   .Input(_input)
                                   .Attr("T", T)
                                   .Attr("cond", cond)
                                   .Attr("body", body)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AddManySparseToTensorsMap::AddManySparseToTensorsMap(tensorflow::Scope& scope, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input sparse_values, 
           tensorflow::Input sparse_shape, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _sparse_values = ::tensorflow::ops::AsNodeOut(scope, sparse_values);
      if (!scope.ok())
          return;
      auto _sparse_shape = ::tensorflow::ops::AsNodeOut(scope, sparse_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AddManySparseToTensorsMap");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AddManySparseToTensorsMap")
                                   .Input(_sparse_indices)
                                   .Input(_sparse_values)
                                   .Input(_sparse_shape)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FlatMapDataset::FlatMapDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FlatMapDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FlatMapDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessIf::StatelessIf(tensorflow::Scope& scope, 
           tensorflow::Input cond, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList then_branch, 
           tensorflow::NameAttrList else_branch) {
      if (!scope.ok())
          return;
      auto _cond = ::tensorflow::ops::AsNodeOut(scope, cond);
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessIf");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessIf")
                                   .Input(_cond)
                                   .Input(_input)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("then_branch", then_branch)
                                   .Attr("else_branch", else_branch)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Angle::Angle(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Angle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Angle")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RemoteCall::RemoteCall(tensorflow::Scope& scope, 
           tensorflow::Input target, 
           tensorflow::Input args, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList f) {
      if (!scope.ok())
          return;
      auto _target = ::tensorflow::ops::AsNodeOut(scope, target);
      if (!scope.ok())
          return;
      auto _args = ::tensorflow::ops::AsNodeOut(scope, args);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RemoteCall");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RemoteCall")
                                   .Input(_target)
                                   .Input(_args)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("f", f)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalMapAndBatchDataset::ExperimentalMapAndBatchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::Input batch_size, 
           tensorflow::Input num_parallel_calls, 
           tensorflow::Input drop_remainder, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool preserve_cardinality) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      if (!scope.ok())
          return;
      auto _num_parallel_calls = ::tensorflow::ops::AsNodeOut(scope, num_parallel_calls);
      if (!scope.ok())
          return;
      auto _drop_remainder = ::tensorflow::ops::AsNodeOut(scope, drop_remainder);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalMapAndBatchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalMapAndBatchDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Input(_batch_size)
                                   .Input(_num_parallel_calls)
                                   .Input(_drop_remainder)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("preserve_cardinality", preserve_cardinality)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SymbolicGradient::SymbolicGradient(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList f) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SymbolicGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SymbolicGradient")
                                   .Input(_input)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("f", f)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_ArrayToList::_ArrayToList(tensorflow::Scope& scope, 
           tensorflow::InputList input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> out_types) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOutList(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ArrayToList");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ArrayToList")
                                   .Input(_input)
                                   .Attr("out_types", out_types)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_ListToArray::_ListToArray(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ListToArray");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ListToArray")
                                   .Input(_input)
                                   .Attr("Tin", Tin)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      for (tensorflow::int32 i = 0; i < ret->num_outputs(); ++i)
          this->output.push_back(tensorflow::Output(ret, i));
}

_Arg::_Arg(tensorflow::Scope& scope, 
           int64_t index) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_Arg");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_Arg")
                                   .Attr("index", index)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderRead::ReaderRead(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle, 
           tensorflow::Input queue_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      if (!scope.ok())
          return;
      auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderRead");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderRead")
                                   .Input(_reader_handle)
                                   .Input(_queue_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MirrorPad::MirrorPad(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input paddings, 
           tensorflow::string mode) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MirrorPad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MirrorPad")
                                   .Input(_input)
                                   .Input(_paddings)
                                   .Attr("mode", mode)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayV3::TensorArrayV3(tensorflow::Scope& scope, 
           tensorflow::Input size, 
           tensorflow::string tensor_array_name, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape, 
           bool dynamic_size, 
           bool clear_after_read, 
           bool identical_element_shapes) {
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayV3")
                                   .Input(_size)
                                   .Attr("tensor_array_name", tensor_array_name)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape", element_shape)
                                   .Attr("dynamic_size", dynamic_size)
                                   .Attr("clear_after_read", clear_after_read)
                                   .Attr("identical_element_shapes", identical_element_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixSolveLs::MatrixSolveLs(tensorflow::Scope& scope, 
           tensorflow::Input matrix, 
           tensorflow::Input rhs, 
           tensorflow::Input l2_regularizer, 
           bool fast) {
      if (!scope.ok())
          return;
      auto _matrix = ::tensorflow::ops::AsNodeOut(scope, matrix);
      if (!scope.ok())
          return;
      auto _rhs = ::tensorflow::ops::AsNodeOut(scope, rhs);
      if (!scope.ok())
          return;
      auto _l2_regularizer = ::tensorflow::ops::AsNodeOut(scope, l2_regularizer);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixSolveLs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixSolveLs")
                                   .Input(_matrix)
                                   .Input(_rhs)
                                   .Input(_l2_regularizer)
                                   .Attr("fast", fast)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalIdentityIndexedDataset::ExperimentalIdentityIndexedDataset(tensorflow::Scope& scope, 
           tensorflow::Input size) {
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalIdentityIndexedDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalIdentityIndexedDataset")
                                   .Input(_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Sinh::Sinh(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sinh");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sinh")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalAssertNextDataset::ExperimentalAssertNextDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input transformations, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _transformations = ::tensorflow::ops::AsNodeOut(scope, transformations);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalAssertNextDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalAssertNextDataset")
                                   .Input(_input_dataset)
                                   .Input(_transformations)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseReduceSumSparse::SparseReduceSumSparse(tensorflow::Scope& scope, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_values, 
           tensorflow::Input input_shape, 
           tensorflow::Input reduction_axes, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_values = ::tensorflow::ops::AsNodeOut(scope, input_values);
      if (!scope.ok())
          return;
      auto _input_shape = ::tensorflow::ops::AsNodeOut(scope, input_shape);
      if (!scope.ok())
          return;
      auto _reduction_axes = ::tensorflow::ops::AsNodeOut(scope, reduction_axes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseReduceSumSparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseReduceSumSparse")
                                   .Input(_input_indices)
                                   .Input(_input_values)
                                   .Input(_input_shape)
                                   .Input(_reduction_axes)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Relu::Relu(tensorflow::Scope& scope, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Relu");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Relu")
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatMul::MatMul(tensorflow::Scope& scope, 
           tensorflow::Input a, 
           tensorflow::Input b, 
           bool transpose_a, 
           bool transpose_b) {
      if (!scope.ok())
          return;
      auto _a = ::tensorflow::ops::AsNodeOut(scope, a);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatMul")
                                   .Input(_a)
                                   .Input(_b)
                                   .Attr("transpose_a", transpose_a)
                                   .Attr("transpose_b", transpose_b)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalThreadPoolDataset::ExperimentalThreadPoolDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input thread_pool, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _thread_pool = ::tensorflow::ops::AsNodeOut(scope, thread_pool);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalThreadPoolDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalThreadPoolDataset")
                                   .Input(_input_dataset)
                                   .Input(_thread_pool)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SoftplusGrad::SoftplusGrad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SoftplusGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SoftplusGrad")
                                   .Input(_gradients)
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalIndexedDatasetMaterialize::ExperimentalIndexedDatasetMaterialize(tensorflow::Scope& scope, 
           tensorflow::Input dataset, 
           tensorflow::Input materialized) {
      if (!scope.ok())
          return;
      auto _dataset = ::tensorflow::ops::AsNodeOut(scope, dataset);
      if (!scope.ok())
          return;
      auto _materialized = ::tensorflow::ops::AsNodeOut(scope, materialized);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalIndexedDatasetMaterialize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalIndexedDatasetMaterialize")
                                   .Input(_dataset)
                                   .Input(_materialized)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

QuantizeAndDequantizeV3::QuantizeAndDequantizeV3(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_min, 
           tensorflow::Input input_max, 
           tensorflow::Input num_bits, 
           bool signed_input, 
           bool range_given) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_min = ::tensorflow::ops::AsNodeOut(scope, input_min);
      if (!scope.ok())
          return;
      auto _input_max = ::tensorflow::ops::AsNodeOut(scope, input_max);
      if (!scope.ok())
          return;
      auto _num_bits = ::tensorflow::ops::AsNodeOut(scope, num_bits);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizeAndDequantizeV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizeAndDequantizeV3")
                                   .Input(_input)
                                   .Input(_input_min)
                                   .Input(_input_max)
                                   .Input(_num_bits)
                                   .Attr("signed_input", signed_input)
                                   .Attr("range_given", range_given)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Mul::Mul(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Mul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Mul")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchToSpace::BatchToSpace(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input crops, 
           int64_t block_size) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _crops = ::tensorflow::ops::AsNodeOut(scope, crops);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchToSpace");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchToSpace")
                                   .Input(_input)
                                   .Input(_crops)
                                   .Attr("block_size", block_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalPrivateThreadPoolDataset::ExperimentalPrivateThreadPoolDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input num_threads, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _num_threads = ::tensorflow::ops::AsNodeOut(scope, num_threads);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalPrivateThreadPoolDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalPrivateThreadPoolDataset")
                                   .Input(_input_dataset)
                                   .Input(_num_threads)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AddSparseToTensorsMap::AddSparseToTensorsMap(tensorflow::Scope& scope, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input sparse_values, 
           tensorflow::Input sparse_shape, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _sparse_values = ::tensorflow::ops::AsNodeOut(scope, sparse_values);
      if (!scope.ok())
          return;
      auto _sparse_shape = ::tensorflow::ops::AsNodeOut(scope, sparse_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AddSparseToTensorsMap");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AddSparseToTensorsMap")
                                   .Input(_sparse_indices)
                                   .Input(_sparse_values)
                                   .Input(_sparse_shape)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Elu::Elu(tensorflow::Scope& scope, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Elu");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Elu")
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalBytesProducedStatsDataset::ExperimentalBytesProducedStatsDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input tag, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalBytesProducedStatsDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalBytesProducedStatsDataset")
                                   .Input(_input_dataset)
                                   .Input(_tag)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalIteratorGetDevice::ExperimentalIteratorGetDevice(tensorflow::Scope& scope, 
           tensorflow::Input resource) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalIteratorGetDevice");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalIteratorGetDevice")
                                   .Input(_resource)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringFormat::StringFormat(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           tensorflow::string ctemplate, 
           tensorflow::string placeholder, 
           int64_t summarize) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringFormat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringFormat")
                                   .Input(_inputs)
                                   .Attr("T", T)
                                   .Attr("template", ctemplate)
                                   .Attr("placeholder", placeholder)
                                   .Attr("summarize", summarize)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalUniqueDataset::ExperimentalUniqueDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalUniqueDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalUniqueDataset")
                                   .Input(_input_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalUnbatchDataset::ExperimentalUnbatchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalUnbatchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalUnbatchDataset")
                                   .Input(_input_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayPack::TensorArrayPack(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayPack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayPack")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape", element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalStatsAggregatorHandle::ExperimentalStatsAggregatorHandle(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalStatsAggregatorHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalStatsAggregatorHandle")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableSizeV2::LookupTableSizeV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableSizeV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableSizeV2")
                                   .Input(_table_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalSqlDataset::ExperimentalSqlDataset(tensorflow::Scope& scope, 
           tensorflow::Input driver_name, 
           tensorflow::Input data_source_name, 
           tensorflow::Input query, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _driver_name = ::tensorflow::ops::AsNodeOut(scope, driver_name);
      if (!scope.ok())
          return;
      auto _data_source_name = ::tensorflow::ops::AsNodeOut(scope, data_source_name);
      if (!scope.ok())
          return;
      auto _query = ::tensorflow::ops::AsNodeOut(scope, query);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalSqlDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalSqlDataset")
                                   .Input(_driver_name)
                                   .Input(_data_source_name)
                                   .Input(_query)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayUnpack::TensorArrayUnpack(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayUnpack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayUnpack")
                                   .Input(_handle)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalSetStatsAggregatorDataset::ExperimentalSetStatsAggregatorDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input stats_aggregator, 
           tensorflow::Input tag, 
           tensorflow::Input counter_prefix, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _stats_aggregator = ::tensorflow::ops::AsNodeOut(scope, stats_aggregator);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _counter_prefix = ::tensorflow::ops::AsNodeOut(scope, counter_prefix);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalSetStatsAggregatorDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalSetStatsAggregatorDataset")
                                   .Input(_input_dataset)
                                   .Input(_stats_aggregator)
                                   .Input(_tag)
                                   .Input(_counter_prefix)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IFFT3D::IFFT3D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IFFT3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IFFT3D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_UnaryOpsComposition::_UnaryOpsComposition(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::gtl::ArraySlice<tensorflow::string> op_names) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_UnaryOpsComposition");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_UnaryOpsComposition")
                                   .Input(_x)
                                   .Attr("op_names", op_names)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixDeterminant::BatchMatrixDeterminant(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixDeterminant");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixDeterminant")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalIgnoreErrorsDataset::ExperimentalIgnoreErrorsDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalIgnoreErrorsDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalIgnoreErrorsDataset")
                                   .Input(_input_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalRandomDataset::ExperimentalRandomDataset(tensorflow::Scope& scope, 
           tensorflow::Input seed, 
           tensorflow::Input seed2, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      if (!scope.ok())
          return;
      auto _seed2 = ::tensorflow::ops::AsNodeOut(scope, seed2);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalRandomDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalRandomDataset")
                                   .Input(_seed)
                                   .Input(_seed2)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PriorityQueue::PriorityQueue(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PriorityQueue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PriorityQueue")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

For::For(tensorflow::Scope& scope, 
           tensorflow::Input start, 
           tensorflow::Input limit, 
           tensorflow::Input delta, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           tensorflow::NameAttrList body) {
      if (!scope.ok())
          return;
      auto _start = ::tensorflow::ops::AsNodeOut(scope, start);
      if (!scope.ok())
          return;
      auto _limit = ::tensorflow::ops::AsNodeOut(scope, limit);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("For");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "For")
                                   .Input(_start)
                                   .Input(_limit)
                                   .Input(_delta)
                                   .Input(_input)
                                   .Attr("T", T)
                                   .Attr("body", body)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalParallelInterleaveDataset::ExperimentalParallelInterleaveDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::Input cycle_length, 
           tensorflow::Input block_length, 
           tensorflow::Input sloppy, 
           tensorflow::Input buffer_output_elements, 
           tensorflow::Input prefetch_input_elements, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      if (!scope.ok())
          return;
      auto _cycle_length = ::tensorflow::ops::AsNodeOut(scope, cycle_length);
      if (!scope.ok())
          return;
      auto _block_length = ::tensorflow::ops::AsNodeOut(scope, block_length);
      if (!scope.ok())
          return;
      auto _sloppy = ::tensorflow::ops::AsNodeOut(scope, sloppy);
      if (!scope.ok())
          return;
      auto _buffer_output_elements = ::tensorflow::ops::AsNodeOut(scope, buffer_output_elements);
      if (!scope.ok())
          return;
      auto _prefetch_input_elements = ::tensorflow::ops::AsNodeOut(scope, prefetch_input_elements);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalParallelInterleaveDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalParallelInterleaveDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Input(_cycle_length)
                                   .Input(_block_length)
                                   .Input(_sloppy)
                                   .Input(_buffer_output_elements)
                                   .Input(_prefetch_input_elements)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Skipgram::Skipgram(tensorflow::Scope& scope, 
           tensorflow::string filename, 
           int64_t batch_size, 
           int64_t window_size, 
           int64_t min_count, 
           float subsample) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Skipgram");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Skipgram")
                                   .Attr("filename", filename)
                                   .Attr("batch_size", batch_size)
                                   .Attr("window_size", window_size)
                                   .Attr("min_count", min_count)
                                   .Attr("subsample", subsample)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalMatchingFilesDataset::ExperimentalMatchingFilesDataset(tensorflow::Scope& scope, 
           tensorflow::Input patterns) {
      if (!scope.ok())
          return;
      auto _patterns = ::tensorflow::ops::AsNodeOut(scope, patterns);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalMatchingFilesDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalMatchingFilesDataset")
                                   .Input(_patterns)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StageClear::StageClear(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StageClear");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StageClear")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ExperimentalMapDataset::ExperimentalMapDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool use_inter_op_parallelism, 
           bool preserve_cardinality) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalMapDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalMapDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("use_inter_op_parallelism", use_inter_op_parallelism)
                                   .Attr("preserve_cardinality", preserve_cardinality)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BiasAdd::BiasAdd(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::Input bias, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _bias = ::tensorflow::ops::AsNodeOut(scope, bias);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BiasAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BiasAdd")
                                   .Input(_value)
                                   .Input(_bias)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalGroupByReducerDataset::ExperimentalGroupByReducerDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input key_func_other_arguments, 
           tensorflow::Input init_func_other_arguments, 
           tensorflow::Input reduce_func_other_arguments, 
           tensorflow::Input finalize_func_other_arguments, 
           tensorflow::NameAttrList key_func, 
           tensorflow::NameAttrList init_func, 
           tensorflow::NameAttrList reduce_func, 
           tensorflow::NameAttrList finalize_func, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tkey_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tinit_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Treduce_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tfinalize_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _key_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, key_func_other_arguments);
      if (!scope.ok())
          return;
      auto _init_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, init_func_other_arguments);
      if (!scope.ok())
          return;
      auto _reduce_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, reduce_func_other_arguments);
      if (!scope.ok())
          return;
      auto _finalize_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, finalize_func_other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalGroupByReducerDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalGroupByReducerDataset")
                                   .Input(_input_dataset)
                                   .Input(_key_func_other_arguments)
                                   .Input(_init_func_other_arguments)
                                   .Input(_reduce_func_other_arguments)
                                   .Input(_finalize_func_other_arguments)
                                   .Attr("key_func", key_func)
                                   .Attr("init_func", init_func)
                                   .Attr("reduce_func", reduce_func)
                                   .Attr("finalize_func", finalize_func)
                                   .Attr("Tkey_func_other_arguments", Tkey_func_other_arguments)
                                   .Attr("Tinit_func_other_arguments", Tinit_func_other_arguments)
                                   .Attr("Treduce_func_other_arguments", Treduce_func_other_arguments)
                                   .Attr("Tfinalize_func_other_arguments", Tfinalize_func_other_arguments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CropAndResizeGradBoxes::CropAndResizeGradBoxes(tensorflow::Scope& scope, 
           tensorflow::Input grads, 
           tensorflow::Input image, 
           tensorflow::Input boxes, 
           tensorflow::Input box_ind, 
           tensorflow::string method) {
      if (!scope.ok())
          return;
      auto _grads = ::tensorflow::ops::AsNodeOut(scope, grads);
      if (!scope.ok())
          return;
      auto _image = ::tensorflow::ops::AsNodeOut(scope, image);
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _box_ind = ::tensorflow::ops::AsNodeOut(scope, box_ind);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CropAndResizeGradBoxes");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CropAndResizeGradBoxes")
                                   .Input(_grads)
                                   .Input(_image)
                                   .Input(_boxes)
                                   .Input(_box_ind)
                                   .Attr("method", method)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FIFOQueueV2::FIFOQueueV2(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FIFOQueueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FIFOQueueV2")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchToSpaceND::BatchToSpaceND(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input block_shape, 
           tensorflow::Input crops) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _block_shape = ::tensorflow::ops::AsNodeOut(scope, block_shape);
      if (!scope.ok())
          return;
      auto _crops = ::tensorflow::ops::AsNodeOut(scope, crops);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchToSpaceND");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchToSpaceND")
                                   .Input(_input)
                                   .Input(_block_shape)
                                   .Input(_crops)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AccumulatorSetGlobalStep::AccumulatorSetGlobalStep(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input new_global_step) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _new_global_step = ::tensorflow::ops::AsNodeOut(scope, new_global_step);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AccumulatorSetGlobalStep");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AccumulatorSetGlobalStep")
                                   .Input(_handle)
                                   .Input(_new_global_step)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ExperimentalDatasetCardinality::ExperimentalDatasetCardinality(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalDatasetCardinality");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalDatasetCardinality")
                                   .Input(_input_dataset)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_DeviceRetval::_DeviceRetval(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           int64_t index) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_DeviceRetval");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_DeviceRetval")
                                   .Input(_input)
                                   .Attr("index", index)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

LogUniformCandidateSampler::LogUniformCandidateSampler(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           int64_t num_true, 
           int64_t num_sampled, 
           bool unique, 
           int64_t range_max, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LogUniformCandidateSampler");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LogUniformCandidateSampler")
                                   .Input(_true_classes)
                                   .Attr("num_true", num_true)
                                   .Attr("num_sampled", num_sampled)
                                   .Attr("unique", unique)
                                   .Attr("range_max", range_max)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapDefun::MapDefun(tensorflow::Scope& scope, 
           tensorflow::Input arguments, 
           tensorflow::Input captured_inputs, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcaptured, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           tensorflow::NameAttrList f) {
      if (!scope.ok())
          return;
      auto _arguments = ::tensorflow::ops::AsNodeOut(scope, arguments);
      if (!scope.ok())
          return;
      auto _captured_inputs = ::tensorflow::ops::AsNodeOut(scope, captured_inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapDefun");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapDefun")
                                   .Input(_arguments)
                                   .Input(_captured_inputs)
                                   .Attr("Targuments", Targuments)
                                   .Attr("Tcaptured", Tcaptured)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("f", f)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalCSVDataset::ExperimentalCSVDataset(tensorflow::Scope& scope, 
           tensorflow::Input filenames, 
           tensorflow::Input compression_type, 
           tensorflow::Input buffer_size, 
           tensorflow::Input header, 
           tensorflow::Input field_delim, 
           tensorflow::Input use_quote_delim, 
           tensorflow::Input na_value, 
           tensorflow::Input select_cols, 
           tensorflow::Input record_defaults, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _filenames = ::tensorflow::ops::AsNodeOut(scope, filenames);
      if (!scope.ok())
          return;
      auto _compression_type = ::tensorflow::ops::AsNodeOut(scope, compression_type);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      if (!scope.ok())
          return;
      auto _header = ::tensorflow::ops::AsNodeOut(scope, header);
      if (!scope.ok())
          return;
      auto _field_delim = ::tensorflow::ops::AsNodeOut(scope, field_delim);
      if (!scope.ok())
          return;
      auto _use_quote_delim = ::tensorflow::ops::AsNodeOut(scope, use_quote_delim);
      if (!scope.ok())
          return;
      auto _na_value = ::tensorflow::ops::AsNodeOut(scope, na_value);
      if (!scope.ok())
          return;
      auto _select_cols = ::tensorflow::ops::AsNodeOut(scope, select_cols);
      if (!scope.ok())
          return;
      auto _record_defaults = ::tensorflow::ops::AsNodeOut(scope, record_defaults);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalCSVDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalCSVDataset")
                                   .Input(_filenames)
                                   .Input(_compression_type)
                                   .Input(_buffer_size)
                                   .Input(_header)
                                   .Input(_field_delim)
                                   .Input(_use_quote_delim)
                                   .Input(_na_value)
                                   .Input(_select_cols)
                                   .Input(_record_defaults)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnsortedSegmentMin::UnsortedSegmentMin(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnsortedSegmentMin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnsortedSegmentMin")
                                   .Input(_data)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SegmentMin::SegmentMin(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SegmentMin");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SegmentMin")
                                   .Input(_data)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorForestTreePredict::TensorForestTreePredict(tensorflow::Scope& scope, 
           tensorflow::Input tree_handle, 
           tensorflow::Input dense_features, 
           int64_t logits_dimension) {
      if (!scope.ok())
          return;
      auto _tree_handle = ::tensorflow::ops::AsNodeOut(scope, tree_handle);
      if (!scope.ok())
          return;
      auto _dense_features = ::tensorflow::ops::AsNodeOut(scope, dense_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestTreePredict");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestTreePredict")
                                   .Input(_tree_handle)
                                   .Input(_dense_features)
                                   .Attr("logits_dimension", logits_dimension)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EncodeProto::EncodeProto(tensorflow::Scope& scope, 
           tensorflow::Input sizes, 
           tensorflow::Input values, 
           tensorflow::gtl::ArraySlice<tensorflow::string> field_names, 
           tensorflow::string message_type, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tinput_types, 
           tensorflow::string descriptor_source) {
      if (!scope.ok())
          return;
      auto _sizes = ::tensorflow::ops::AsNodeOut(scope, sizes);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EncodeProto");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EncodeProto")
                                   .Input(_sizes)
                                   .Input(_values)
                                   .Attr("field_names", field_names)
                                   .Attr("message_type", message_type)
                                   .Attr("Tinput_types", Tinput_types)
                                   .Attr("descriptor_source", descriptor_source)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalDirectedInterleaveDataset::ExperimentalDirectedInterleaveDataset(tensorflow::Scope& scope, 
           tensorflow::Input selector_input_dataset, 
           tensorflow::InputList data_input_datasets, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _selector_input_dataset = ::tensorflow::ops::AsNodeOut(scope, selector_input_dataset);
      if (!scope.ok())
          return;
      auto _data_input_datasets = ::tensorflow::ops::AsNodeOutList(scope, data_input_datasets);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalDirectedInterleaveDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalDirectedInterleaveDataset")
                                   .Input(_selector_input_dataset)
                                   .Input(_data_input_datasets)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Minimum::Minimum(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Minimum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Minimum")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnicodeDecode::UnicodeDecode(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string input_encoding, 
           tensorflow::string errors, 
           int64_t replacement_char, 
           bool replace_control_characters) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnicodeDecode");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnicodeDecode")
                                   .Input(_input)
                                   .Attr("input_encoding", input_encoding)
                                   .Attr("errors", errors)
                                   .Attr("replacement_char", replacement_char)
                                   .Attr("replace_control_characters", replace_control_characters)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteSummary::WriteSummary(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input step, 
           tensorflow::Input tensor, 
           tensorflow::Input tag, 
           tensorflow::Input summary_metadata) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _summary_metadata = ::tensorflow::ops::AsNodeOut(scope, summary_metadata);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteSummary")
                                   .Input(_writer)
                                   .Input(_step)
                                   .Input(_tensor)
                                   .Input(_tag)
                                   .Input(_summary_metadata)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Batch::Batch(tensorflow::Scope& scope, 
           tensorflow::Input in_tensors, 
           tensorflow::gtl::ArraySlice<int64_t> allowed_batch_sizes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::string batching_queue, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           int64_t num_batch_threads, 
           int64_t max_batch_size, 
           int64_t max_enqueued_batches, 
           int64_t batch_timeout_micros, 
           int64_t grad_timeout_micros) {
      if (!scope.ok())
          return;
      auto _in_tensors = ::tensorflow::ops::AsNodeOut(scope, in_tensors);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Batch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Batch")
                                   .Input(_in_tensors)
                                   .Attr("allowed_batch_sizes", allowed_batch_sizes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("batching_queue", batching_queue)
                                   .Attr("T", T)
                                   .Attr("num_batch_threads", num_batch_threads)
                                   .Attr("max_batch_size", max_batch_size)
                                   .Attr("max_enqueued_batches", max_enqueued_batches)
                                   .Attr("batch_timeout_micros", batch_timeout_micros)
                                   .Attr("grad_timeout_micros", grad_timeout_micros)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParallelInterleaveDatasetV2::ParallelInterleaveDatasetV2(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::Input cycle_length, 
           tensorflow::Input block_length, 
           tensorflow::Input num_parallel_calls, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool sloppy) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      if (!scope.ok())
          return;
      auto _cycle_length = ::tensorflow::ops::AsNodeOut(scope, cycle_length);
      if (!scope.ok())
          return;
      auto _block_length = ::tensorflow::ops::AsNodeOut(scope, block_length);
      if (!scope.ok())
          return;
      auto _num_parallel_calls = ::tensorflow::ops::AsNodeOut(scope, num_parallel_calls);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParallelInterleaveDatasetV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParallelInterleaveDatasetV2")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Input(_cycle_length)
                                   .Input(_block_length)
                                   .Input(_num_parallel_calls)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("sloppy", sloppy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueIsClosed::QueueIsClosed(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueIsClosed");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueIsClosed")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MultiDeviceIteratorFromStringHandle::MultiDeviceIteratorFromStringHandle(tensorflow::Scope& scope, 
           tensorflow::Input string_handle, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _string_handle = ::tensorflow::ops::AsNodeOut(scope, string_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MultiDeviceIteratorFromStringHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MultiDeviceIteratorFromStringHandle")
                                   .Input(_string_handle)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolGradGrad::MaxPoolGradGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input grad, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolGradGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolGradGrad")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_grad)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnwrapDatasetVariant::UnwrapDatasetVariant(tensorflow::Scope& scope, 
           tensorflow::Input input_handle) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnwrapDatasetVariant");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnwrapDatasetVariant")
                                   .Input(_input_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WrapDatasetVariant::WrapDatasetVariant(tensorflow::Scope& scope, 
           tensorflow::Input input_handle) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WrapDatasetVariant");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WrapDatasetVariant")
                                   .Input(_input_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Stage::Stage(tensorflow::Scope& scope, 
           tensorflow::Input values, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Stage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Stage")
                                   .Input(_values)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

IdentityN::IdentityN(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IdentityN");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IdentityN")
                                   .Input(_input)
                                   .Attr("T", T)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OptionalHasValue::OptionalHasValue(tensorflow::Scope& scope, 
           tensorflow::Input optional) {
      if (!scope.ok())
          return;
      auto _optional = ::tensorflow::ops::AsNodeOut(scope, optional);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OptionalHasValue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OptionalHasValue")
                                   .Input(_optional)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Qr::Qr(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool full_matrices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Qr");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Qr")
                                   .Input(_input)
                                   .Attr("full_matrices", full_matrices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatefulPartitionedCall::StatefulPartitionedCall(tensorflow::Scope& scope, 
           tensorflow::Input args, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList f, 
           tensorflow::string config, 
           tensorflow::string config_proto, 
           tensorflow::string executor_type) {
      if (!scope.ok())
          return;
      auto _args = ::tensorflow::ops::AsNodeOut(scope, args);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatefulPartitionedCall");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatefulPartitionedCall")
                                   .Input(_args)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("f", f)
                                   .Attr("config", config)
                                   .Attr("config_proto", config_proto)
                                   .Attr("executor_type", executor_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OptionalFromValue::OptionalFromValue(tensorflow::Scope& scope, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Toutput_types) {
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OptionalFromValue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OptionalFromValue")
                                   .Input(_components)
                                   .Attr("Toutput_types", Toutput_types)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DatasetToGraph::DatasetToGraph(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DatasetToGraph");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DatasetToGraph")
                                   .Input(_input_dataset)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExtractGlimpse::ExtractGlimpse(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input size, 
           tensorflow::Input offsets, 
           bool centered, 
           bool normalized, 
           bool uniform_noise) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      if (!scope.ok())
          return;
      auto _offsets = ::tensorflow::ops::AsNodeOut(scope, offsets);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExtractGlimpse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExtractGlimpse")
                                   .Input(_input)
                                   .Input(_size)
                                   .Input(_offsets)
                                   .Attr("centered", centered)
                                   .Attr("normalized", normalized)
                                   .Attr("uniform_noise", uniform_noise)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalDatasetToTFRecord::ExperimentalDatasetToTFRecord(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input filename, 
           tensorflow::Input compression_type) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      if (!scope.ok())
          return;
      auto _compression_type = ::tensorflow::ops::AsNodeOut(scope, compression_type);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalDatasetToTFRecord");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalDatasetToTFRecord")
                                   .Input(_input_dataset)
                                   .Input(_filename)
                                   .Input(_compression_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ShardedFilespec::ShardedFilespec(tensorflow::Scope& scope, 
           tensorflow::Input basename, 
           tensorflow::Input num_shards) {
      if (!scope.ok())
          return;
      auto _basename = ::tensorflow::ops::AsNodeOut(scope, basename);
      if (!scope.ok())
          return;
      auto _num_shards = ::tensorflow::ops::AsNodeOut(scope, num_shards);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ShardedFilespec");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ShardedFilespec")
                                   .Input(_basename)
                                   .Input(_num_shards)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyCenteredRMSProp::ResourceApplyCenteredRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input mg, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _mg = ::tensorflow::ops::AsNodeOut(scope, mg);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyCenteredRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyCenteredRMSProp")
                                   .Input(_var)
                                   .Input(_mg)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SerializeIterator::SerializeIterator(tensorflow::Scope& scope, 
           tensorflow::Input resource_handle) {
      if (!scope.ok())
          return;
      auto _resource_handle = ::tensorflow::ops::AsNodeOut(scope, resource_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SerializeIterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SerializeIterator")
                                   .Input(_resource_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentSqrtNGrad::SparseSegmentSqrtNGrad(tensorflow::Scope& scope, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids, 
           tensorflow::Input output_dim0) {
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _output_dim0 = ::tensorflow::ops::AsNodeOut(scope, output_dim0);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentSqrtNGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentSqrtNGrad")
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_segment_ids)
                                   .Input(_output_dim0)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

VarIsInitializedOp::VarIsInitializedOp(tensorflow::Scope& scope, 
           tensorflow::Input resource) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("VarIsInitializedOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "VarIsInitializedOp")
                                   .Input(_resource)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQuantWithMinMaxVarsPerChannel::FakeQuantWithMinMaxVarsPerChannel(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::Input min, 
           tensorflow::Input max, 
           int64_t num_bits, 
           bool narrow_range) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _min = ::tensorflow::ops::AsNodeOut(scope, min);
      if (!scope.ok())
          return;
      auto _max = ::tensorflow::ops::AsNodeOut(scope, max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQuantWithMinMaxVarsPerChannel");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQuantWithMinMaxVarsPerChannel")
                                   .Input(_inputs)
                                   .Input(_min)
                                   .Input(_max)
                                   .Attr("num_bits", num_bits)
                                   .Attr("narrow_range", narrow_range)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WriteAudioSummary::WriteAudioSummary(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input step, 
           tensorflow::Input tag, 
           tensorflow::Input tensor, 
           tensorflow::Input sample_rate, 
           int64_t max_outputs) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _sample_rate = ::tensorflow::ops::AsNodeOut(scope, sample_rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WriteAudioSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WriteAudioSummary")
                                   .Input(_writer)
                                   .Input(_step)
                                   .Input(_tag)
                                   .Input(_tensor)
                                   .Input(_sample_rate)
                                   .Attr("max_outputs", max_outputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

IteratorFromStringHandle::IteratorFromStringHandle(tensorflow::Scope& scope, 
           tensorflow::Input string_handle, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _string_handle = ::tensorflow::ops::AsNodeOut(scope, string_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorFromStringHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorFromStringHandle")
                                   .Input(_string_handle)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CheckNumerics::CheckNumerics(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::string message) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CheckNumerics");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CheckNumerics")
                                   .Input(_tensor)
                                   .Attr("message", message)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BroadcastTo::BroadcastTo(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input shape) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BroadcastTo");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BroadcastTo")
                                   .Input(_input)
                                   .Input(_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IteratorToStringHandle::IteratorToStringHandle(tensorflow::Scope& scope, 
           tensorflow::Input resource_handle) {
      if (!scope.ok())
          return;
      auto _resource_handle = ::tensorflow::ops::AsNodeOut(scope, resource_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorToStringHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorToStringHandle")
                                   .Input(_resource_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Atanh::Atanh(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Atanh");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Atanh")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MakeIterator::MakeIterator(tensorflow::Scope& scope, 
           tensorflow::Input dataset, 
           tensorflow::Input iterator) {
      if (!scope.ok())
          return;
      auto _dataset = ::tensorflow::ops::AsNodeOut(scope, dataset);
      if (!scope.ok())
          return;
      auto _iterator = ::tensorflow::ops::AsNodeOut(scope, iterator);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MakeIterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MakeIterator")
                                   .Input(_dataset)
                                   .Input(_iterator)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

UniqueWithCountsV2::UniqueWithCountsV2(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input axis, 
           tensorflow::DataType out_idx) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UniqueWithCountsV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UniqueWithCountsV2")
                                   .Input(_x)
                                   .Input(_axis)
                                   .Attr("out_idx", out_idx)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AnonymousIterator::AnonymousIterator(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AnonymousIterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AnonymousIterator")
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DebugGradientRefIdentity::DebugGradientRefIdentity(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DebugGradientRefIdentity");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DebugGradientRefIdentity")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IteratorV2::IteratorV2(tensorflow::Scope& scope, 
           tensorflow::string shared_name, 
           tensorflow::string container, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorV2")
                                   .Attr("shared_name", shared_name)
                                   .Attr("container", container)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ImmutableConst::ImmutableConst(tensorflow::Scope& scope, 
           tensorflow::string memory_region_name, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ImmutableConst");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ImmutableConst")
                                   .Attr("memory_region_name", memory_region_name)
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesQuantileStreamResourceAddSummaries::BoostedTreesQuantileStreamResourceAddSummaries(tensorflow::Scope& scope, 
           tensorflow::Input quantile_stream_resource_handle, 
           tensorflow::Input summaries, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _quantile_stream_resource_handle = ::tensorflow::ops::AsNodeOut(scope, quantile_stream_resource_handle);
      if (!scope.ok())
          return;
      auto _summaries = ::tensorflow::ops::AsNodeOut(scope, summaries);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesQuantileStreamResourceAddSummaries");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesQuantileStreamResourceAddSummaries")
                                   .Input(_quantile_stream_resource_handle)
                                   .Input(_summaries)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Iterator::Iterator(tensorflow::Scope& scope, 
           tensorflow::string shared_name, 
           tensorflow::string container, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Iterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Iterator")
                                   .Attr("shared_name", shared_name)
                                   .Attr("container", container)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Rpc::Rpc(tensorflow::Scope& scope, 
           tensorflow::Input address, 
           tensorflow::Input method, 
           tensorflow::Input request, 
           tensorflow::string protocol, 
           bool fail_fast, 
           int64_t timeout_in_ms) {
      if (!scope.ok())
          return;
      auto _address = ::tensorflow::ops::AsNodeOut(scope, address);
      if (!scope.ok())
          return;
      auto _method = ::tensorflow::ops::AsNodeOut(scope, method);
      if (!scope.ok())
          return;
      auto _request = ::tensorflow::ops::AsNodeOut(scope, request);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Rpc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Rpc")
                                   .Input(_address)
                                   .Input(_method)
                                   .Input(_request)
                                   .Attr("protocol", protocol)
                                   .Attr("fail_fast", fail_fast)
                                   .Attr("timeout_in_ms", timeout_in_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TFRecordDataset::TFRecordDataset(tensorflow::Scope& scope, 
           tensorflow::Input filenames, 
           tensorflow::Input compression_type, 
           tensorflow::Input buffer_size) {
      if (!scope.ok())
          return;
      auto _filenames = ::tensorflow::ops::AsNodeOut(scope, filenames);
      if (!scope.ok())
          return;
      auto _compression_type = ::tensorflow::ops::AsNodeOut(scope, compression_type);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TFRecordDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TFRecordDataset")
                                   .Input(_filenames)
                                   .Input(_compression_type)
                                   .Input(_buffer_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseReduceMaxSparse::SparseReduceMaxSparse(tensorflow::Scope& scope, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_values, 
           tensorflow::Input input_shape, 
           tensorflow::Input reduction_axes, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_values = ::tensorflow::ops::AsNodeOut(scope, input_values);
      if (!scope.ok())
          return;
      auto _input_shape = ::tensorflow::ops::AsNodeOut(scope, input_shape);
      if (!scope.ok())
          return;
      auto _reduction_axes = ::tensorflow::ops::AsNodeOut(scope, reduction_axes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseReduceMaxSparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseReduceMaxSparse")
                                   .Input(_input_indices)
                                   .Input(_input_values)
                                   .Input(_input_shape)
                                   .Input(_reduction_axes)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CacheDataset::CacheDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input filename, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _filename = ::tensorflow::ops::AsNodeOut(scope, filename);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CacheDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CacheDataset")
                                   .Input(_input_dataset)
                                   .Input(_filename)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolV2::MaxPoolV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input ksize, 
           tensorflow::Input strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _ksize = ::tensorflow::ops::AsNodeOut(scope, ksize);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolV2")
                                   .Input(_input)
                                   .Input(_ksize)
                                   .Input(_strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedMul::QuantizedMul(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input min_x, 
           tensorflow::Input max_x, 
           tensorflow::Input min_y, 
           tensorflow::Input max_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _min_x = ::tensorflow::ops::AsNodeOut(scope, min_x);
      if (!scope.ok())
          return;
      auto _max_x = ::tensorflow::ops::AsNodeOut(scope, max_x);
      if (!scope.ok())
          return;
      auto _min_y = ::tensorflow::ops::AsNodeOut(scope, min_y);
      if (!scope.ok())
          return;
      auto _max_y = ::tensorflow::ops::AsNodeOut(scope, max_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedMul")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_min_x)
                                   .Input(_max_x)
                                   .Input(_min_y)
                                   .Input(_max_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ShuffleAndRepeatDataset::ShuffleAndRepeatDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input buffer_size, 
           tensorflow::Input seed, 
           tensorflow::Input seed2, 
           tensorflow::Input count, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      if (!scope.ok())
          return;
      auto _seed2 = ::tensorflow::ops::AsNodeOut(scope, seed2);
      if (!scope.ok())
          return;
      auto _count = ::tensorflow::ops::AsNodeOut(scope, count);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ShuffleAndRepeatDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ShuffleAndRepeatDataset")
                                   .Input(_input_dataset)
                                   .Input(_buffer_size)
                                   .Input(_seed)
                                   .Input(_seed2)
                                   .Input(_count)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_NcclBroadcastSend::_NcclBroadcastSend(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string shared_name, 
           int64_t num_devices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_NcclBroadcastSend");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_NcclBroadcastSend")
                                   .Input(_input)
                                   .Attr("shared_name", shared_name)
                                   .Attr("num_devices", num_devices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

CudnnRNN::CudnnRNN(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_h, 
           tensorflow::Input input_c, 
           tensorflow::Input params, 
           bool is_training, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_h = ::tensorflow::ops::AsNodeOut(scope, input_h);
      if (!scope.ok())
          return;
      auto _input_c = ::tensorflow::ops::AsNodeOut(scope, input_c);
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNN");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNN")
                                   .Input(_input)
                                   .Input(_input_h)
                                   .Input(_input_c)
                                   .Input(_params)
                                   .Attr("is_training", is_training)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchDataset::BatchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input batch_size, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchDataset")
                                   .Input(_input_dataset)
                                   .Input(_batch_size)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SoftsignGrad::SoftsignGrad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SoftsignGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SoftsignGrad")
                                   .Input(_gradients)
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SetSize::SetSize(tensorflow::Scope& scope, 
           tensorflow::Input set_indices, 
           tensorflow::Input set_values, 
           tensorflow::Input set_shape, 
           bool validate_indices) {
      if (!scope.ok())
          return;
      auto _set_indices = ::tensorflow::ops::AsNodeOut(scope, set_indices);
      if (!scope.ok())
          return;
      auto _set_values = ::tensorflow::ops::AsNodeOut(scope, set_values);
      if (!scope.ok())
          return;
      auto _set_shape = ::tensorflow::ops::AsNodeOut(scope, set_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SetSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SetSize")
                                   .Input(_set_indices)
                                   .Input(_set_values)
                                   .Input(_set_shape)
                                   .Attr("validate_indices", validate_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WindowDataset::WindowDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input size, 
           tensorflow::Input shift, 
           tensorflow::Input stride, 
           tensorflow::Input drop_remainder, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      if (!scope.ok())
          return;
      auto _shift = ::tensorflow::ops::AsNodeOut(scope, shift);
      if (!scope.ok())
          return;
      auto _stride = ::tensorflow::ops::AsNodeOut(scope, stride);
      if (!scope.ok())
          return;
      auto _drop_remainder = ::tensorflow::ops::AsNodeOut(scope, drop_remainder);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WindowDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WindowDataset")
                                   .Input(_input_dataset)
                                   .Input(_size)
                                   .Input(_shift)
                                   .Input(_stride)
                                   .Input(_drop_remainder)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyRMSProp::ResourceApplyRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyRMSProp")
                                   .Input(_var)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MaxPool3DGrad::MaxPool3DGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input grad, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPool3DGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPool3DGrad")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_grad)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InterleaveDataset::InterleaveDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::Input cycle_length, 
           tensorflow::Input block_length, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      if (!scope.ok())
          return;
      auto _cycle_length = ::tensorflow::ops::AsNodeOut(scope, cycle_length);
      if (!scope.ok())
          return;
      auto _block_length = ::tensorflow::ops::AsNodeOut(scope, block_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InterleaveDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InterleaveDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Input(_cycle_length)
                                   .Input(_block_length)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TanhGrad::TanhGrad(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input dy) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TanhGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TanhGrad")
                                   .Input(_y)
                                   .Input(_dy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesTrainingPredict::BoostedTreesTrainingPredict(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input cached_tree_ids, 
           tensorflow::Input cached_node_ids, 
           tensorflow::Input bucketized_features, 
           int64_t num_bucketized_features, 
           int64_t logits_dimension) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _cached_tree_ids = ::tensorflow::ops::AsNodeOut(scope, cached_tree_ids);
      if (!scope.ok())
          return;
      auto _cached_node_ids = ::tensorflow::ops::AsNodeOut(scope, cached_node_ids);
      if (!scope.ok())
          return;
      auto _bucketized_features = ::tensorflow::ops::AsNodeOut(scope, bucketized_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesTrainingPredict");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesTrainingPredict")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_cached_tree_ids)
                                   .Input(_cached_node_ids)
                                   .Input(_bucketized_features)
                                   .Attr("num_bucketized_features", num_bucketized_features)
                                   .Attr("logits_dimension", logits_dimension)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LoopCond::LoopCond(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LoopCond");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LoopCond")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParallelMapDataset::ParallelMapDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::Input num_parallel_calls, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool use_inter_op_parallelism, 
           bool sloppy, 
           bool preserve_cardinality) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      if (!scope.ok())
          return;
      auto _num_parallel_calls = ::tensorflow::ops::AsNodeOut(scope, num_parallel_calls);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParallelMapDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParallelMapDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Input(_num_parallel_calls)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("use_inter_op_parallelism", use_inter_op_parallelism)
                                   .Attr("sloppy", sloppy)
                                   .Attr("preserve_cardinality", preserve_cardinality)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReciprocalGrad::ReciprocalGrad(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input dy) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReciprocalGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReciprocalGrad")
                                   .Input(_y)
                                   .Input(_dy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedReshape::QuantizedReshape(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input shape, 
           tensorflow::Input input_min, 
           tensorflow::Input input_max) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _input_min = ::tensorflow::ops::AsNodeOut(scope, input_min);
      if (!scope.ok())
          return;
      auto _input_max = ::tensorflow::ops::AsNodeOut(scope, input_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedReshape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedReshape")
                                   .Input(_tensor)
                                   .Input(_shape)
                                   .Input(_input_min)
                                   .Input(_input_max)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapDataset::MapDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool use_inter_op_parallelism, 
           bool preserve_cardinality) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("use_inter_op_parallelism", use_inter_op_parallelism)
                                   .Attr("preserve_cardinality", preserve_cardinality)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SkipDataset::SkipDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input count, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _count = ::tensorflow::ops::AsNodeOut(scope, count);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SkipDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SkipDataset")
                                   .Input(_input_dataset)
                                   .Input(_count)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv2DBackpropFilter::Conv2DBackpropFilter(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter_sizes, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           bool use_cudnn_on_gpu, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter_sizes = ::tensorflow::ops::AsNodeOut(scope, filter_sizes);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv2DBackpropFilter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv2DBackpropFilter")
                                   .Input(_input)
                                   .Input(_filter_sizes)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IteratorGetNextSync::IteratorGetNextSync(tensorflow::Scope& scope, 
           tensorflow::Input iterator, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _iterator = ::tensorflow::ops::AsNodeOut(scope, iterator);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorGetNextSync");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorGetNextSync")
                                   .Input(_iterator)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderNumRecordsProduced::ReaderNumRecordsProduced(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderNumRecordsProduced");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderNumRecordsProduced")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ModelDataset::ModelDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ModelDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ModelDataset")
                                   .Input(_input_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderReadUpToV2::ReaderReadUpToV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle, 
           tensorflow::Input queue_handle, 
           tensorflow::Input num_records) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      if (!scope.ok())
          return;
      auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);
      if (!scope.ok())
          return;
      auto _num_records = ::tensorflow::ops::AsNodeOut(scope, num_records);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderReadUpToV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderReadUpToV2")
                                   .Input(_reader_handle)
                                   .Input(_queue_handle)
                                   .Input(_num_records)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueDequeueV2::QueueDequeueV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueDequeueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueDequeueV2")
                                   .Input(_handle)
                                   .Attr("component_types", component_types)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderReadUpTo::ReaderReadUpTo(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle, 
           tensorflow::Input queue_handle, 
           tensorflow::Input num_records) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      if (!scope.ok())
          return;
      auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);
      if (!scope.ok())
          return;
      auto _num_records = ::tensorflow::ops::AsNodeOut(scope, num_records);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderReadUpTo");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderReadUpTo")
                                   .Input(_reader_handle)
                                   .Input(_queue_handle)
                                   .Input(_num_records)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Unpack::Unpack(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           int64_t num, 
           int64_t axis) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Unpack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Unpack")
                                   .Input(_value)
                                   .Attr("num", num)
                                   .Attr("axis", axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ConcatenateDataset::ConcatenateDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input another_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _another_dataset = ::tensorflow::ops::AsNodeOut(scope, another_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ConcatenateDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ConcatenateDataset")
                                   .Input(_input_dataset)
                                   .Input(_another_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PlaceholderV2::PlaceholderV2(tensorflow::Scope& scope, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PlaceholderV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PlaceholderV2")
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GeneratorDataset::GeneratorDataset(tensorflow::Scope& scope, 
           tensorflow::Input init_func_other_args, 
           tensorflow::Input next_func_other_args, 
           tensorflow::Input finalize_func_other_args, 
           tensorflow::NameAttrList init_func, 
           tensorflow::NameAttrList next_func, 
           tensorflow::NameAttrList finalize_func, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tinit_func_args, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tnext_func_args, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tfinalize_func_args, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _init_func_other_args = ::tensorflow::ops::AsNodeOut(scope, init_func_other_args);
      if (!scope.ok())
          return;
      auto _next_func_other_args = ::tensorflow::ops::AsNodeOut(scope, next_func_other_args);
      if (!scope.ok())
          return;
      auto _finalize_func_other_args = ::tensorflow::ops::AsNodeOut(scope, finalize_func_other_args);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GeneratorDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GeneratorDataset")
                                   .Input(_init_func_other_args)
                                   .Input(_next_func_other_args)
                                   .Input(_finalize_func_other_args)
                                   .Attr("init_func", init_func)
                                   .Attr("next_func", next_func)
                                   .Attr("finalize_func", finalize_func)
                                   .Attr("Tinit_func_args", Tinit_func_args)
                                   .Attr("Tnext_func_args", Tnext_func_args)
                                   .Attr("Tfinalize_func_args", Tfinalize_func_args)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorSliceDataset::TensorSliceDataset(tensorflow::Scope& scope, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Toutput_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorSliceDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorSliceDataset")
                                   .Input(_components)
                                   .Attr("Toutput_types", Toutput_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringToHashBucket::StringToHashBucket(tensorflow::Scope& scope, 
           tensorflow::Input string_tensor, 
           int64_t num_buckets) {
      if (!scope.ok())
          return;
      auto _string_tensor = ::tensorflow::ops::AsNodeOut(scope, string_tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringToHashBucket");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringToHashBucket")
                                   .Input(_string_tensor)
                                   .Attr("num_buckets", num_buckets)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Softsign::Softsign(tensorflow::Scope& scope, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Softsign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Softsign")
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedAdd::QuantizedAdd(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input min_x, 
           tensorflow::Input max_x, 
           tensorflow::Input min_y, 
           tensorflow::Input max_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _min_x = ::tensorflow::ops::AsNodeOut(scope, min_x);
      if (!scope.ok())
          return;
      auto _max_x = ::tensorflow::ops::AsNodeOut(scope, max_x);
      if (!scope.ok())
          return;
      auto _min_y = ::tensorflow::ops::AsNodeOut(scope, min_y);
      if (!scope.ok())
          return;
      auto _max_y = ::tensorflow::ops::AsNodeOut(scope, max_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedAdd")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_min_x)
                                   .Input(_max_x)
                                   .Input(_min_y)
                                   .Input(_max_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomShuffleQueueV2::RandomShuffleQueueV2(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t min_after_dequeue, 
           int64_t seed, 
           int64_t seed2) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomShuffleQueueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomShuffleQueueV2")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("min_after_dequeue", min_after_dequeue)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseTensorSliceDataset::SparseTensorSliceDataset(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::Input values, 
           tensorflow::Input dense_shape) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      if (!scope.ok())
          return;
      auto _dense_shape = ::tensorflow::ops::AsNodeOut(scope, dense_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseTensorSliceDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseTensorSliceDataset")
                                   .Input(_indices)
                                   .Input(_values)
                                   .Input(_dense_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorDataset::TensorDataset(tensorflow::Scope& scope, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Toutput_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorDataset")
                                   .Input(_components)
                                   .Attr("Toutput_types", Toutput_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListElementShape::TensorListElementShape(tensorflow::Scope& scope, 
           tensorflow::Input input_handle) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListElementShape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListElementShape")
                                   .Input(_input_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NcclReduce::NcclReduce(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string reduction, 
           int64_t num_devices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NcclReduce");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NcclReduce")
                                   .Input(_input)
                                   .Attr("reduction", reduction)
                                   .Attr("num_devices", num_devices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyProximalAdagrad::ApplyProximalAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyProximalAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyProximalAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Svd::Svd(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool compute_uv, 
           bool full_matrices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Svd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Svd")
                                   .Input(_input)
                                   .Attr("compute_uv", compute_uv)
                                   .Attr("full_matrices", full_matrices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentMeanGrad::SparseSegmentMeanGrad(tensorflow::Scope& scope, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids, 
           tensorflow::Input output_dim0) {
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _output_dim0 = ::tensorflow::ops::AsNodeOut(scope, output_dim0);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentMeanGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentMeanGrad")
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_segment_ids)
                                   .Input(_output_dim0)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixExponential::MatrixExponential(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixExponential");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixExponential")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GatherNd::GatherNd(tensorflow::Scope& scope, 
           tensorflow::Input params, 
           tensorflow::Input indices) {
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GatherNd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GatherNd")
                                   .Input(_params)
                                   .Input(_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueCloseV2::QueueCloseV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           bool cancel_pending_enqueues) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueCloseV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueCloseV2")
                                   .Input(_handle)
                                   .Attr("cancel_pending_enqueues", cancel_pending_enqueues)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MaxPool::MaxPool(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPool");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPool")
                                   .Input(_input)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OrderedMapClear::OrderedMapClear(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapClear");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapClear")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

OrderedMapSize::OrderedMapSize(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapSize")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayCloseV3::TensorArrayCloseV3(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayCloseV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayCloseV3")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SaveV2::SaveV2(tensorflow::Scope& scope, 
           tensorflow::Input prefix, 
           tensorflow::Input tensor_names, 
           tensorflow::Input shape_and_slices, 
           tensorflow::Input tensors, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes) {
      if (!scope.ok())
          return;
      auto _prefix = ::tensorflow::ops::AsNodeOut(scope, prefix);
      if (!scope.ok())
          return;
      auto _tensor_names = ::tensorflow::ops::AsNodeOut(scope, tensor_names);
      if (!scope.ok())
          return;
      auto _shape_and_slices = ::tensorflow::ops::AsNodeOut(scope, shape_and_slices);
      if (!scope.ok())
          return;
      auto _tensors = ::tensorflow::ops::AsNodeOut(scope, tensors);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SaveV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SaveV2")
                                   .Input(_prefix)
                                   .Input(_tensor_names)
                                   .Input(_shape_and_slices)
                                   .Input(_tensors)
                                   .Attr("dtypes", dtypes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

OrderedMapStage::OrderedMapStage(tensorflow::Scope& scope, 
           tensorflow::Input key, 
           tensorflow::Input indices, 
           tensorflow::Input values, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> fake_dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _key = ::tensorflow::ops::AsNodeOut(scope, key);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapStage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapStage")
                                   .Input(_key)
                                   .Input(_indices)
                                   .Input(_values)
                                   .Attr("dtypes", dtypes)
                                   .Attr("fake_dtypes", fake_dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

RandomGamma::RandomGamma(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input alpha, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomGamma");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomGamma")
                                   .Input(_shape)
                                   .Input(_alpha)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedResizeBilinear::QuantizedResizeBilinear(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input size, 
           tensorflow::Input min, 
           tensorflow::Input max, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      if (!scope.ok())
          return;
      auto _min = ::tensorflow::ops::AsNodeOut(scope, min);
      if (!scope.ok())
          return;
      auto _max = ::tensorflow::ops::AsNodeOut(scope, max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedResizeBilinear");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedResizeBilinear")
                                   .Input(_images)
                                   .Input(_size)
                                   .Input(_min)
                                   .Input(_max)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OrderedMapIncompleteSize::OrderedMapIncompleteSize(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapIncompleteSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapIncompleteSize")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapIncompleteSize::MapIncompleteSize(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapIncompleteSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapIncompleteSize")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixInverse::MatrixInverse(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool adjoint) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixInverse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixInverse")
                                   .Input(_input)
                                   .Attr("adjoint", adjoint)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyMomentum::ApplyMomentum(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input grad, 
           tensorflow::Input momentum, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyMomentum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyMomentum")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_grad)
                                   .Input(_momentum)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Acos::Acos(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Acos");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Acos")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalGroupByWindowDataset::ExperimentalGroupByWindowDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input key_func_other_arguments, 
           tensorflow::Input reduce_func_other_arguments, 
           tensorflow::Input window_size_func_other_arguments, 
           tensorflow::NameAttrList key_func, 
           tensorflow::NameAttrList reduce_func, 
           tensorflow::NameAttrList window_size_func, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tkey_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Treduce_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Twindow_size_func_other_arguments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _key_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, key_func_other_arguments);
      if (!scope.ok())
          return;
      auto _reduce_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, reduce_func_other_arguments);
      if (!scope.ok())
          return;
      auto _window_size_func_other_arguments = ::tensorflow::ops::AsNodeOut(scope, window_size_func_other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalGroupByWindowDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalGroupByWindowDataset")
                                   .Input(_input_dataset)
                                   .Input(_key_func_other_arguments)
                                   .Input(_reduce_func_other_arguments)
                                   .Input(_window_size_func_other_arguments)
                                   .Attr("key_func", key_func)
                                   .Attr("reduce_func", reduce_func)
                                   .Attr("window_size_func", window_size_func)
                                   .Attr("Tkey_func_other_arguments", Tkey_func_other_arguments)
                                   .Attr("Treduce_func_other_arguments", Treduce_func_other_arguments)
                                   .Attr("Twindow_size_func_other_arguments", Twindow_size_func_other_arguments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyAdamWithAmsgrad::ResourceApplyAdamWithAmsgrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input vhat, 
           tensorflow::Input beta1_power, 
           tensorflow::Input beta2_power, 
           tensorflow::Input lr, 
           tensorflow::Input beta1, 
           tensorflow::Input beta2, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _vhat = ::tensorflow::ops::AsNodeOut(scope, vhat);
      if (!scope.ok())
          return;
      auto _beta1_power = ::tensorflow::ops::AsNodeOut(scope, beta1_power);
      if (!scope.ok())
          return;
      auto _beta2_power = ::tensorflow::ops::AsNodeOut(scope, beta2_power);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _beta1 = ::tensorflow::ops::AsNodeOut(scope, beta1);
      if (!scope.ok())
          return;
      auto _beta2 = ::tensorflow::ops::AsNodeOut(scope, beta2);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAdamWithAmsgrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAdamWithAmsgrad")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_vhat)
                                   .Input(_beta1_power)
                                   .Input(_beta2_power)
                                   .Input(_lr)
                                   .Input(_beta1)
                                   .Input(_beta2)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

_NcclBroadcastRecv::_NcclBroadcastRecv(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::string shared_name, 
           int64_t num_devices) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_NcclBroadcastRecv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_NcclBroadcastRecv")
                                   .Input(_shape)
                                   .Attr("shared_name", shared_name)
                                   .Attr("num_devices", num_devices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SegmentSum::SegmentSum(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SegmentSum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SegmentSum")
                                   .Input(_data)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TextLineDataset::TextLineDataset(tensorflow::Scope& scope, 
           tensorflow::Input filenames, 
           tensorflow::Input compression_type, 
           tensorflow::Input buffer_size) {
      if (!scope.ok())
          return;
      auto _filenames = ::tensorflow::ops::AsNodeOut(scope, filenames);
      if (!scope.ok())
          return;
      auto _compression_type = ::tensorflow::ops::AsNodeOut(scope, compression_type);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TextLineDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TextLineDataset")
                                   .Input(_filenames)
                                   .Input(_compression_type)
                                   .Input(_buffer_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorSummaryV2::TensorSummaryV2(tensorflow::Scope& scope, 
           tensorflow::Input tag, 
           tensorflow::Input tensor, 
           tensorflow::Input serialized_summary_metadata) {
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _serialized_summary_metadata = ::tensorflow::ops::AsNodeOut(scope, serialized_summary_metadata);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorSummaryV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorSummaryV2")
                                   .Input(_tag)
                                   .Input(_tensor)
                                   .Input(_serialized_summary_metadata)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Unbatch::Unbatch(tensorflow::Scope& scope, 
           tensorflow::Input batched_tensor, 
           tensorflow::Input batch_index, 
           tensorflow::Input id, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t timeout_micros) {
      if (!scope.ok())
          return;
      auto _batched_tensor = ::tensorflow::ops::AsNodeOut(scope, batched_tensor);
      if (!scope.ok())
          return;
      auto _batch_index = ::tensorflow::ops::AsNodeOut(scope, batch_index);
      if (!scope.ok())
          return;
      auto _id = ::tensorflow::ops::AsNodeOut(scope, id);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Unbatch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Unbatch")
                                   .Input(_batched_tensor)
                                   .Input(_batch_index)
                                   .Input(_id)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("timeout_micros", timeout_micros)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapUnstage::MapUnstage(tensorflow::Scope& scope, 
           tensorflow::Input key, 
           tensorflow::Input indices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _key = ::tensorflow::ops::AsNodeOut(scope, key);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapUnstage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapUnstage")
                                   .Input(_key)
                                   .Input(_indices)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TopK::TopK(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           int64_t k, 
           bool sorted) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TopK");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TopK")
                                   .Input(_input)
                                   .Attr("k", k)
                                   .Attr("sorted", sorted)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ConjugateTranspose::ConjugateTranspose(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input perm) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _perm = ::tensorflow::ops::AsNodeOut(scope, perm);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ConjugateTranspose");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ConjugateTranspose")
                                   .Input(_x)
                                   .Input(_perm)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapPeek::MapPeek(tensorflow::Scope& scope, 
           tensorflow::Input key, 
           tensorflow::Input indices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _key = ::tensorflow::ops::AsNodeOut(scope, key);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapPeek");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapPeek")
                                   .Input(_key)
                                   .Input(_indices)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseTensorDenseMatMul::SparseTensorDenseMatMul(tensorflow::Scope& scope, 
           tensorflow::Input a_indices, 
           tensorflow::Input a_values, 
           tensorflow::Input a_shape, 
           tensorflow::Input b, 
           bool adjoint_a, 
           bool adjoint_b) {
      if (!scope.ok())
          return;
      auto _a_indices = ::tensorflow::ops::AsNodeOut(scope, a_indices);
      if (!scope.ok())
          return;
      auto _a_values = ::tensorflow::ops::AsNodeOut(scope, a_values);
      if (!scope.ok())
          return;
      auto _a_shape = ::tensorflow::ops::AsNodeOut(scope, a_shape);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseTensorDenseMatMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseTensorDenseMatMul")
                                   .Input(_a_indices)
                                   .Input(_a_values)
                                   .Input(_a_shape)
                                   .Input(_b)
                                   .Attr("adjoint_a", adjoint_a)
                                   .Attr("adjoint_b", adjoint_b)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FusedBatchNormGradV2::FusedBatchNormGradV2(tensorflow::Scope& scope, 
           tensorflow::Input y_backprop, 
           tensorflow::Input x, 
           tensorflow::Input scale, 
           tensorflow::Input reserve_space_1, 
           tensorflow::Input reserve_space_2, 
           bool is_training, 
           tensorflow::string data_format, 
           float epsilon) {
      if (!scope.ok())
          return;
      auto _y_backprop = ::tensorflow::ops::AsNodeOut(scope, y_backprop);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _scale = ::tensorflow::ops::AsNodeOut(scope, scale);
      if (!scope.ok())
          return;
      auto _reserve_space_1 = ::tensorflow::ops::AsNodeOut(scope, reserve_space_1);
      if (!scope.ok())
          return;
      auto _reserve_space_2 = ::tensorflow::ops::AsNodeOut(scope, reserve_space_2);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FusedBatchNormGradV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FusedBatchNormGradV2")
                                   .Input(_y_backprop)
                                   .Input(_x)
                                   .Input(_scale)
                                   .Input(_reserve_space_1)
                                   .Input(_reserve_space_2)
                                   .Attr("is_training", is_training)
                                   .Attr("data_format", data_format)
                                   .Attr("epsilon", epsilon)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BarrierReadySize::BarrierReadySize(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BarrierReadySize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BarrierReadySize")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapStage::MapStage(tensorflow::Scope& scope, 
           tensorflow::Input key, 
           tensorflow::Input indices, 
           tensorflow::Input values, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> fake_dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _key = ::tensorflow::ops::AsNodeOut(scope, key);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapStage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapStage")
                                   .Input(_key)
                                   .Input(_indices)
                                   .Input(_values)
                                   .Attr("dtypes", dtypes)
                                   .Attr("fake_dtypes", fake_dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Unstage::Unstage(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Unstage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Unstage")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Variable::Variable(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::PartialTensorShape shape, 
           tensorflow::DataType dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Variable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Variable")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("shape", shape)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArray::TensorArray(tensorflow::Scope& scope, 
           tensorflow::Input size, 
           tensorflow::string tensor_array_name, 
           tensorflow::DataType dtype, 
           bool dynamic_size, 
           bool clear_after_read, 
           tensorflow::PartialTensorShape element_shape) {
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArray");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArray")
                                   .Input(_size)
                                   .Attr("tensor_array_name", tensor_array_name)
                                   .Attr("dtype", dtype)
                                   .Attr("dynamic_size", dynamic_size)
                                   .Attr("clear_after_read", clear_after_read)
                                   .Attr("element_shape", element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SigmoidGrad::SigmoidGrad(tensorflow::Scope& scope, 
           tensorflow::Input y, 
           tensorflow::Input dy) {
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SigmoidGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SigmoidGrad")
                                   .Input(_y)
                                   .Input(_dy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListGather::TensorListGather(tensorflow::Scope& scope, 
           tensorflow::Input input_handle, 
           tensorflow::Input indices) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListGather");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListGather")
                                   .Input(_input_handle)
                                   .Input(_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DeleteSessionTensor::DeleteSessionTensor(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DeleteSessionTensor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DeleteSessionTensor")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceApplyAdam::ResourceApplyAdam(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input v, 
           tensorflow::Input beta1_power, 
           tensorflow::Input beta2_power, 
           tensorflow::Input lr, 
           tensorflow::Input beta1, 
           tensorflow::Input beta2, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_nesterov, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      if (!scope.ok())
          return;
      auto _beta1_power = ::tensorflow::ops::AsNodeOut(scope, beta1_power);
      if (!scope.ok())
          return;
      auto _beta2_power = ::tensorflow::ops::AsNodeOut(scope, beta2_power);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _beta1 = ::tensorflow::ops::AsNodeOut(scope, beta1);
      if (!scope.ok())
          return;
      auto _beta2 = ::tensorflow::ops::AsNodeOut(scope, beta2);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAdam");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAdam")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_v)
                                   .Input(_beta1_power)
                                   .Input(_beta2_power)
                                   .Input(_lr)
                                   .Input(_beta1)
                                   .Input(_beta2)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_nesterov", use_nesterov)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceSparseApplyAdadelta::ResourceSparseApplyAdadelta(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input accum_update, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _accum_update = ::tensorflow::ops::AsNodeOut(scope, accum_update);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyAdadelta");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyAdadelta")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_accum_update)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Sigmoid::Sigmoid(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Sigmoid");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Sigmoid")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyAdagradDA::ResourceApplyAdagradDA(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input gradient_accumulator, 
           tensorflow::Input gradient_squared_accumulator, 
           tensorflow::Input grad, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input global_step, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _gradient_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_accumulator);
      if (!scope.ok())
          return;
      auto _gradient_squared_accumulator = ::tensorflow::ops::AsNodeOut(scope, gradient_squared_accumulator);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _global_step = ::tensorflow::ops::AsNodeOut(scope, global_step);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAdagradDA");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAdagradDA")
                                   .Input(_var)
                                   .Input(_gradient_accumulator)
                                   .Input(_gradient_squared_accumulator)
                                   .Input(_grad)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_global_step)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SparseToDense::SparseToDense(tensorflow::Scope& scope, 
           tensorflow::Input sparse_indices, 
           tensorflow::Input output_shape, 
           tensorflow::Input sparse_values, 
           tensorflow::Input default_value, 
           bool validate_indices) {
      if (!scope.ok())
          return;
      auto _sparse_indices = ::tensorflow::ops::AsNodeOut(scope, sparse_indices);
      if (!scope.ok())
          return;
      auto _output_shape = ::tensorflow::ops::AsNodeOut(scope, output_shape);
      if (!scope.ok())
          return;
      auto _sparse_values = ::tensorflow::ops::AsNodeOut(scope, sparse_values);
      if (!scope.ok())
          return;
      auto _default_value = ::tensorflow::ops::AsNodeOut(scope, default_value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseToDense");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseToDense")
                                   .Input(_sparse_indices)
                                   .Input(_output_shape)
                                   .Input(_sparse_values)
                                   .Input(_default_value)
                                   .Attr("validate_indices", validate_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Bitcast::Bitcast(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Bitcast");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Bitcast")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GetSessionHandleV2::GetSessionHandleV2(tensorflow::Scope& scope, 
           tensorflow::Input value) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GetSessionHandleV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GetSessionHandleV2")
                                   .Input(_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQuantWithMinMaxVars::FakeQuantWithMinMaxVars(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::Input min, 
           tensorflow::Input max, 
           int64_t num_bits, 
           bool narrow_range) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _min = ::tensorflow::ops::AsNodeOut(scope, min);
      if (!scope.ok())
          return;
      auto _max = ::tensorflow::ops::AsNodeOut(scope, max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQuantWithMinMaxVars");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQuantWithMinMaxVars")
                                   .Input(_inputs)
                                   .Input(_min)
                                   .Input(_max)
                                   .Attr("num_bits", num_bits)
                                   .Attr("narrow_range", narrow_range)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BarrierIncompleteSize::BarrierIncompleteSize(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BarrierIncompleteSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BarrierIncompleteSize")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Any::Any(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input reduction_indices, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _reduction_indices = ::tensorflow::ops::AsNodeOut(scope, reduction_indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Any");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Any")
                                   .Input(_input)
                                   .Input(_reduction_indices)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorForestCreateTreeVariable::TensorForestCreateTreeVariable(tensorflow::Scope& scope, 
           tensorflow::Input tree_handle, 
           tensorflow::Input tree_config) {
      if (!scope.ok())
          return;
      auto _tree_handle = ::tensorflow::ops::AsNodeOut(scope, tree_handle);
      if (!scope.ok())
          return;
      auto _tree_config = ::tensorflow::ops::AsNodeOut(scope, tree_config);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestCreateTreeVariable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestCreateTreeVariable")
                                   .Input(_tree_handle)
                                   .Input(_tree_config)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

BatchFunction::BatchFunction(tensorflow::Scope& scope, 
           tensorflow::Input in_tensors, 
           tensorflow::Input captured_tensors, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<int64_t> allowed_batch_sizes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::string batching_queue, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcaptured, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           int64_t num_batch_threads, 
           int64_t max_batch_size, 
           int64_t batch_timeout_micros, 
           int64_t max_enqueued_batches) {
      if (!scope.ok())
          return;
      auto _in_tensors = ::tensorflow::ops::AsNodeOut(scope, in_tensors);
      if (!scope.ok())
          return;
      auto _captured_tensors = ::tensorflow::ops::AsNodeOut(scope, captured_tensors);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchFunction");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchFunction")
                                   .Input(_in_tensors)
                                   .Input(_captured_tensors)
                                   .Attr("f", f)
                                   .Attr("allowed_batch_sizes", allowed_batch_sizes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("batching_queue", batching_queue)
                                   .Attr("Tin", Tin)
                                   .Attr("Tcaptured", Tcaptured)
                                   .Attr("Tout", Tout)
                                   .Attr("num_batch_threads", num_batch_threads)
                                   .Attr("max_batch_size", max_batch_size)
                                   .Attr("batch_timeout_micros", batch_timeout_micros)
                                   .Attr("max_enqueued_batches", max_enqueued_batches)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchDatasetV2::BatchDatasetV2(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input batch_size, 
           tensorflow::Input drop_remainder, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      if (!scope.ok())
          return;
      auto _drop_remainder = ::tensorflow::ops::AsNodeOut(scope, drop_remainder);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchDatasetV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchDatasetV2")
                                   .Input(_input_dataset)
                                   .Input(_batch_size)
                                   .Input(_drop_remainder)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SelfAdjointEigV2::SelfAdjointEigV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool compute_v) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SelfAdjointEigV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SelfAdjointEigV2")
                                   .Input(_input)
                                   .Attr("compute_v", compute_v)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Pack::Pack(tensorflow::Scope& scope, 
           tensorflow::InputList values, 
           int64_t axis) {
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOutList(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Pack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Pack")
                                   .Input(_values)
                                   .Attr("axis", axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BarrierClose::BarrierClose(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           bool cancel_pending_enqueues) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BarrierClose");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BarrierClose")
                                   .Input(_handle)
                                   .Attr("cancel_pending_enqueues", cancel_pending_enqueues)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

PyFunc::PyFunc(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string token, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PyFunc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PyFunc")
                                   .Input(_input)
                                   .Attr("token", token)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AddN::AddN(tensorflow::Scope& scope, 
           tensorflow::InputList inputs) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AddN");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AddN")
                                   .Input(_inputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayV2::TensorArrayV2(tensorflow::Scope& scope, 
           tensorflow::Input size, 
           tensorflow::string tensor_array_name, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape, 
           bool dynamic_size, 
           bool clear_after_read) {
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayV2")
                                   .Input(_size)
                                   .Attr("tensor_array_name", tensor_array_name)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape", element_shape)
                                   .Attr("dynamic_size", dynamic_size)
                                   .Attr("clear_after_read", clear_after_read)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyGradientDescent::ResourceApplyGradientDescent(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input alpha, 
           tensorflow::Input delta, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyGradientDescent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyGradientDescent")
                                   .Input(_var)
                                   .Input(_alpha)
                                   .Input(_delta)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MatrixLogarithm::MatrixLogarithm(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixLogarithm");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixLogarithm")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BarrierTakeMany::BarrierTakeMany(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input num_elements, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           bool allow_small_batch, 
           bool wait_for_incomplete, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _num_elements = ::tensorflow::ops::AsNodeOut(scope, num_elements);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BarrierTakeMany");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BarrierTakeMany")
                                   .Input(_handle)
                                   .Input(_num_elements)
                                   .Attr("component_types", component_types)
                                   .Attr("allow_small_batch", allow_small_batch)
                                   .Attr("wait_for_incomplete", wait_for_incomplete)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceSparseApplyProximalAdagrad::ResourceSparseApplyProximalAdagrad(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceSparseApplyProximalAdagrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceSparseApplyProximalAdagrad")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Neg::Neg(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Neg");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Neg")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Barrier::Barrier(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Barrier");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Barrier")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Div::Div(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Div");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Div")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArraySizeV2::TensorArraySizeV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArraySizeV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArraySizeV2")
                                   .Input(_handle)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AdjustContrast::AdjustContrast(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input contrast_factor, 
           tensorflow::Input min_value, 
           tensorflow::Input max_value) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _contrast_factor = ::tensorflow::ops::AsNodeOut(scope, contrast_factor);
      if (!scope.ok())
          return;
      auto _min_value = ::tensorflow::ops::AsNodeOut(scope, min_value);
      if (!scope.ok())
          return;
      auto _max_value = ::tensorflow::ops::AsNodeOut(scope, max_value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AdjustContrast");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AdjustContrast")
                                   .Input(_images)
                                   .Input(_contrast_factor)
                                   .Input(_min_value)
                                   .Input(_max_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MultiDeviceIteratorInit::MultiDeviceIteratorInit(tensorflow::Scope& scope, 
           tensorflow::Input dataset, 
           tensorflow::Input multi_device_iterator, 
           tensorflow::Input max_buffer_size) {
      if (!scope.ok())
          return;
      auto _dataset = ::tensorflow::ops::AsNodeOut(scope, dataset);
      if (!scope.ok())
          return;
      auto _multi_device_iterator = ::tensorflow::ops::AsNodeOut(scope, multi_device_iterator);
      if (!scope.ok())
          return;
      auto _max_buffer_size = ::tensorflow::ops::AsNodeOut(scope, max_buffer_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MultiDeviceIteratorInit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MultiDeviceIteratorInit")
                                   .Input(_dataset)
                                   .Input(_multi_device_iterator)
                                   .Input(_max_buffer_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ComplexAbs::ComplexAbs(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ComplexAbs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ComplexAbs")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RGBToHSV::RGBToHSV(tensorflow::Scope& scope, 
           tensorflow::Input images) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RGBToHSV");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RGBToHSV")
                                   .Input(_images)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ListDiff::ListDiff(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::DataType out_idx) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ListDiff");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ListDiff")
                                   .Input(_x)
                                   .Input(_y)
                                   .Attr("out_idx", out_idx)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayScatterV2::TensorArrayScatterV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input indices, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayScatterV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayScatterV2")
                                   .Input(_handle)
                                   .Input(_indices)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RFFT3D::RFFT3D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input fft_length) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _fft_length = ::tensorflow::ops::AsNodeOut(scope, fft_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RFFT3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RFFT3D")
                                   .Input(_input)
                                   .Input(_fft_length)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGatherV2::TensorArrayGatherV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input indices, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGatherV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGatherV2")
                                   .Input(_handle)
                                   .Input(_indices)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape", element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderRestoreStateV2::ReaderRestoreStateV2(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle, 
           tensorflow::Input state) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      if (!scope.ok())
          return;
      auto _state = ::tensorflow::ops::AsNodeOut(scope, state);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderRestoreStateV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderRestoreStateV2")
                                   .Input(_reader_handle)
                                   .Input(_state)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

_DeviceArg::_DeviceArg(tensorflow::Scope& scope, 
           int64_t index) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_DeviceArg");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_DeviceArg")
                                   .Attr("index", index)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StagePeek::StagePeek(tensorflow::Scope& scope, 
           tensorflow::Input index, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StagePeek");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StagePeek")
                                   .Input(_index)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayReadV2::TensorArrayReadV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input index, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayReadV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayReadV2")
                                   .Input(_handle)
                                   .Input(_index)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AudioSpectrogram::AudioSpectrogram(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           int64_t window_size, 
           int64_t stride, 
           bool magnitude_squared) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AudioSpectrogram");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AudioSpectrogram")
                                   .Input(_input)
                                   .Attr("window_size", window_size)
                                   .Attr("stride", stride)
                                   .Attr("magnitude_squared", magnitude_squared)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayRead::TensorArrayRead(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input index, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayRead");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayRead")
                                   .Input(_handle)
                                   .Input(_index)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseAdd::SparseAdd(tensorflow::Scope& scope, 
           tensorflow::Input a_indices, 
           tensorflow::Input a_values, 
           tensorflow::Input a_shape, 
           tensorflow::Input b_indices, 
           tensorflow::Input b_values, 
           tensorflow::Input b_shape, 
           tensorflow::Input thresh) {
      if (!scope.ok())
          return;
      auto _a_indices = ::tensorflow::ops::AsNodeOut(scope, a_indices);
      if (!scope.ok())
          return;
      auto _a_values = ::tensorflow::ops::AsNodeOut(scope, a_values);
      if (!scope.ok())
          return;
      auto _a_shape = ::tensorflow::ops::AsNodeOut(scope, a_shape);
      if (!scope.ok())
          return;
      auto _b_indices = ::tensorflow::ops::AsNodeOut(scope, b_indices);
      if (!scope.ok())
          return;
      auto _b_values = ::tensorflow::ops::AsNodeOut(scope, b_values);
      if (!scope.ok())
          return;
      auto _b_shape = ::tensorflow::ops::AsNodeOut(scope, b_shape);
      if (!scope.ok())
          return;
      auto _thresh = ::tensorflow::ops::AsNodeOut(scope, thresh);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseAdd")
                                   .Input(_a_indices)
                                   .Input(_a_values)
                                   .Input(_a_shape)
                                   .Input(_b_indices)
                                   .Input(_b_values)
                                   .Input(_b_shape)
                                   .Input(_thresh)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BitwiseXor::BitwiseXor(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BitwiseXor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BitwiseXor")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DenseToSparseSetOperation::DenseToSparseSetOperation(tensorflow::Scope& scope, 
           tensorflow::Input set1, 
           tensorflow::Input set2_indices, 
           tensorflow::Input set2_values, 
           tensorflow::Input set2_shape, 
           tensorflow::string set_operation, 
           bool validate_indices) {
      if (!scope.ok())
          return;
      auto _set1 = ::tensorflow::ops::AsNodeOut(scope, set1);
      if (!scope.ok())
          return;
      auto _set2_indices = ::tensorflow::ops::AsNodeOut(scope, set2_indices);
      if (!scope.ok())
          return;
      auto _set2_values = ::tensorflow::ops::AsNodeOut(scope, set2_values);
      if (!scope.ok())
          return;
      auto _set2_shape = ::tensorflow::ops::AsNodeOut(scope, set2_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DenseToSparseSetOperation");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DenseToSparseSetOperation")
                                   .Input(_set1)
                                   .Input(_set2_indices)
                                   .Input(_set2_values)
                                   .Input(_set2_shape)
                                   .Attr("set_operation", set_operation)
                                   .Attr("validate_indices", validate_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayWriteV2::TensorArrayWriteV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input index, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayWriteV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayWriteV2")
                                   .Input(_handle)
                                   .Input(_index)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayWrite::TensorArrayWrite(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input index, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayWrite");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayWrite")
                                   .Input(_handle)
                                   .Input(_index)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReverseSequence::ReverseSequence(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input seq_lengths, 
           int64_t seq_dim, 
           int64_t batch_dim) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _seq_lengths = ::tensorflow::ops::AsNodeOut(scope, seq_lengths);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReverseSequence");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReverseSequence")
                                   .Input(_input)
                                   .Input(_seq_lengths)
                                   .Attr("seq_dim", seq_dim)
                                   .Attr("batch_dim", batch_dim)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGatherV3::TensorArrayGatherV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input indices, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGatherV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGatherV3")
                                   .Input(_handle)
                                   .Input(_indices)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape", element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FilterByLastComponentDataset::FilterByLastComponentDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FilterByLastComponentDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FilterByLastComponentDataset")
                                   .Input(_input_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ShuffleDataset::ShuffleDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input buffer_size, 
           tensorflow::Input seed, 
           tensorflow::Input seed2, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool reshuffle_each_iteration) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      if (!scope.ok())
          return;
      auto _seed2 = ::tensorflow::ops::AsNodeOut(scope, seed2);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ShuffleDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ShuffleDataset")
                                   .Input(_input_dataset)
                                   .Input(_buffer_size)
                                   .Input(_seed)
                                   .Input(_seed2)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("reshuffle_each_iteration", reshuffle_each_iteration)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DivNoNan::DivNoNan(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DivNoNan");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DivNoNan")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EditDistance::EditDistance(tensorflow::Scope& scope, 
           tensorflow::Input hypothesis_indices, 
           tensorflow::Input hypothesis_values, 
           tensorflow::Input hypothesis_shape, 
           tensorflow::Input truth_indices, 
           tensorflow::Input truth_values, 
           tensorflow::Input truth_shape, 
           bool normalize) {
      if (!scope.ok())
          return;
      auto _hypothesis_indices = ::tensorflow::ops::AsNodeOut(scope, hypothesis_indices);
      if (!scope.ok())
          return;
      auto _hypothesis_values = ::tensorflow::ops::AsNodeOut(scope, hypothesis_values);
      if (!scope.ok())
          return;
      auto _hypothesis_shape = ::tensorflow::ops::AsNodeOut(scope, hypothesis_shape);
      if (!scope.ok())
          return;
      auto _truth_indices = ::tensorflow::ops::AsNodeOut(scope, truth_indices);
      if (!scope.ok())
          return;
      auto _truth_values = ::tensorflow::ops::AsNodeOut(scope, truth_values);
      if (!scope.ok())
          return;
      auto _truth_shape = ::tensorflow::ops::AsNodeOut(scope, truth_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EditDistance");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EditDistance")
                                   .Input(_hypothesis_indices)
                                   .Input(_hypothesis_values)
                                   .Input(_hypothesis_shape)
                                   .Input(_truth_indices)
                                   .Input(_truth_values)
                                   .Input(_truth_shape)
                                   .Attr("normalize", normalize)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AvgPoolGrad::AvgPoolGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input_shape, 
           tensorflow::Input grad, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input_shape = ::tensorflow::ops::AsNodeOut(scope, orig_input_shape);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AvgPoolGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AvgPoolGrad")
                                   .Input(_orig_input_shape)
                                   .Input(_grad)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ParallelConcat::ParallelConcat(tensorflow::Scope& scope, 
           tensorflow::InputList values, 
           tensorflow::PartialTensorShape shape) {
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOutList(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParallelConcat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParallelConcat")
                                   .Input(_values)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RangeDataset::RangeDataset(tensorflow::Scope& scope, 
           tensorflow::Input start, 
           tensorflow::Input stop, 
           tensorflow::Input step, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _start = ::tensorflow::ops::AsNodeOut(scope, start);
      if (!scope.ok())
          return;
      auto _stop = ::tensorflow::ops::AsNodeOut(scope, stop);
      if (!scope.ok())
          return;
      auto _step = ::tensorflow::ops::AsNodeOut(scope, step);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RangeDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RangeDataset")
                                   .Input(_start)
                                   .Input(_stop)
                                   .Input(_step)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnsortedSegmentMax::UnsortedSegmentMax(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids, 
           tensorflow::Input num_segments) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      if (!scope.ok())
          return;
      auto _num_segments = ::tensorflow::ops::AsNodeOut(scope, num_segments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnsortedSegmentMax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnsortedSegmentMax")
                                   .Input(_data)
                                   .Input(_segment_ids)
                                   .Input(_num_segments)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGradWithShape::TensorArrayGradWithShape(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::Input shape_to_prepend, 
           tensorflow::string source) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      if (!scope.ok())
          return;
      auto _shape_to_prepend = ::tensorflow::ops::AsNodeOut(scope, shape_to_prepend);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGradWithShape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGradWithShape")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Input(_shape_to_prepend)
                                   .Attr("source", source)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MultiDeviceIteratorToStringHandle::MultiDeviceIteratorToStringHandle(tensorflow::Scope& scope, 
           tensorflow::Input multi_device_iterator) {
      if (!scope.ok())
          return;
      auto _multi_device_iterator = ::tensorflow::ops::AsNodeOut(scope, multi_device_iterator);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MultiDeviceIteratorToStringHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MultiDeviceIteratorToStringHandle")
                                   .Input(_multi_device_iterator)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGradV3::TensorArrayGradV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::string source) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGradV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGradV3")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("source", source)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseApplyFtrlV2::SparseApplyFtrlV2(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input l2_shrinkage, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _l2_shrinkage = ::tensorflow::ops::AsNodeOut(scope, l2_shrinkage);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyFtrlV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyFtrlV2")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_l2_shrinkage)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StackPop::StackPop(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackPop");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackPop")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Stack::Stack(tensorflow::Scope& scope, 
           tensorflow::string stack_name, 
           tensorflow::DataType elem_type) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Stack");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Stack")
                                   .Attr("stack_name", stack_name)
                                   .Attr("elem_type", elem_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Abs::Abs(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Abs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Abs")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Gather::Gather(tensorflow::Scope& scope, 
           tensorflow::Input params, 
           tensorflow::Input indices, 
           bool validate_indices) {
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Gather");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Gather")
                                   .Input(_params)
                                   .Input(_indices)
                                   .Attr("validate_indices", validate_indices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayReadV3::TensorArrayReadV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input index, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayReadV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayReadV3")
                                   .Input(_handle)
                                   .Input(_index)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AvgPool3DGrad::AvgPool3DGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input_shape, 
           tensorflow::Input grad, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _orig_input_shape = ::tensorflow::ops::AsNodeOut(scope, orig_input_shape);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AvgPool3DGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AvgPool3DGrad")
                                   .Input(_orig_input_shape)
                                   .Input(_grad)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayCloseV2::TensorArrayCloseV2(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayCloseV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayCloseV2")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ThreadUnsafeUnigramCandidateSampler::ThreadUnsafeUnigramCandidateSampler(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           int64_t num_true, 
           int64_t num_sampled, 
           bool unique, 
           int64_t range_max, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ThreadUnsafeUnigramCandidateSampler");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ThreadUnsafeUnigramCandidateSampler")
                                   .Input(_true_classes)
                                   .Attr("num_true", num_true)
                                   .Attr("num_sampled", num_sampled)
                                   .Attr("unique", unique)
                                   .Attr("range_max", range_max)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StackCloseV2::StackCloseV2(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackCloseV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackCloseV2")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

StackPopV2::StackPopV2(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackPopV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackPopV2")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StackPushV2::StackPushV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input elem, 
           bool swap_memory) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _elem = ::tensorflow::ops::AsNodeOut(scope, elem);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackPushV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackPushV2")
                                   .Input(_handle)
                                   .Input(_elem)
                                   .Attr("swap_memory", swap_memory)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TileGrad::TileGrad(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input multiples) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _multiples = ::tensorflow::ops::AsNodeOut(scope, multiples);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TileGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TileGrad")
                                   .Input(_input)
                                   .Input(_multiples)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueDequeueUpTo::QueueDequeueUpTo(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input n, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _n = ::tensorflow::ops::AsNodeOut(scope, n);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueDequeueUpTo");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueDequeueUpTo")
                                   .Input(_handle)
                                   .Input(_n)
                                   .Attr("component_types", component_types)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AudioSummary::AudioSummary(tensorflow::Scope& scope, 
           tensorflow::Input tag, 
           tensorflow::Input tensor, 
           float sample_rate, 
           int64_t max_outputs) {
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AudioSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AudioSummary")
                                   .Input(_tag)
                                   .Input(_tensor)
                                   .Attr("sample_rate", sample_rate)
                                   .Attr("max_outputs", max_outputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PaddedBatchDataset::PaddedBatchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input batch_size, 
           tensorflow::InputList padded_shapes, 
           tensorflow::Input padding_values, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Toutput_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      if (!scope.ok())
          return;
      auto _padded_shapes = ::tensorflow::ops::AsNodeOutList(scope, padded_shapes);
      if (!scope.ok())
          return;
      auto _padding_values = ::tensorflow::ops::AsNodeOut(scope, padding_values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PaddedBatchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PaddedBatchDataset")
                                   .Input(_input_dataset)
                                   .Input(_batch_size)
                                   .Input(_padded_shapes)
                                   .Input(_padding_values)
                                   .Attr("Toutput_types", Toutput_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StackV2::StackV2(tensorflow::Scope& scope, 
           tensorflow::Input max_size, 
           tensorflow::string stack_name, 
           tensorflow::DataType elem_type) {
      if (!scope.ok())
          return;
      auto _max_size = ::tensorflow::ops::AsNodeOut(scope, max_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackV2")
                                   .Input(_max_size)
                                   .Attr("stack_name", stack_name)
                                   .Attr("elem_type", elem_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseConditionalAccumulator::SparseConditionalAccumulator(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape, 
           tensorflow::string reduction_type) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseConditionalAccumulator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseConditionalAccumulator")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
                                   .Attr("reduction_type", reduction_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OrderedMapUnstage::OrderedMapUnstage(tensorflow::Scope& scope, 
           tensorflow::Input key, 
           tensorflow::Input indices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _key = ::tensorflow::ops::AsNodeOut(scope, key);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapUnstage");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapUnstage")
                                   .Input(_key)
                                   .Input(_indices)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_VarHandlesOp::_VarHandlesOp(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::string> containers, 
           tensorflow::gtl::ArraySlice<tensorflow::string> shared_names, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_VarHandlesOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_VarHandlesOp")
                                   .Attr("containers", containers)
                                   .Attr("shared_names", shared_names)
                                   .Attr("dtypes", dtypes)
                                   .Attr("shapes", shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      for (tensorflow::int32 i = 0; i < ret->num_outputs(); ++i)
          this->output.push_back(tensorflow::Output(ret, i));
}

TensorArraySplitV2::TensorArraySplitV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input value, 
           tensorflow::Input lengths, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _lengths = ::tensorflow::ops::AsNodeOut(scope, lengths);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArraySplitV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArraySplitV2")
                                   .Input(_handle)
                                   .Input(_value)
                                   .Input(_lengths)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AccumulatorTakeGradient::AccumulatorTakeGradient(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input num_required, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _num_required = ::tensorflow::ops::AsNodeOut(scope, num_required);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AccumulatorTakeGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AccumulatorTakeGradient")
                                   .Input(_handle)
                                   .Input(_num_required)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExtractJpegShape::ExtractJpegShape(tensorflow::Scope& scope, 
           tensorflow::Input contents) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExtractJpegShape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExtractJpegShape")
                                   .Input(_contents)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ConditionalAccumulator::ConditionalAccumulator(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape, 
           tensorflow::string reduction_type) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ConditionalAccumulator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ConditionalAccumulator")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
                                   .Attr("reduction_type", reduction_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AccumulatorNumAccumulated::AccumulatorNumAccumulated(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AccumulatorNumAccumulated");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AccumulatorNumAccumulated")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LogicalNot::LogicalNot(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LogicalNot");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LogicalNot")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Lu::Lu(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::DataType output_idx_type) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Lu");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Lu")
                                   .Input(_input)
                                   .Attr("output_idx_type", output_idx_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueSize::QueueSize(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueSize")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArraySplitV3::TensorArraySplitV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input value, 
           tensorflow::Input lengths, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _lengths = ::tensorflow::ops::AsNodeOut(scope, lengths);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArraySplitV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArraySplitV3")
                                   .Input(_handle)
                                   .Input(_value)
                                   .Input(_lengths)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IteratorGetNextAsOptional::IteratorGetNextAsOptional(tensorflow::Scope& scope, 
           tensorflow::Input iterator, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _iterator = ::tensorflow::ops::AsNodeOut(scope, iterator);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorGetNextAsOptional");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorGetNextAsOptional")
                                   .Input(_iterator)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GcsConfigureCredentials::GcsConfigureCredentials(tensorflow::Scope& scope, 
           tensorflow::Input json) {
      if (!scope.ok())
          return;
      auto _json = ::tensorflow::ops::AsNodeOut(scope, json);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GcsConfigureCredentials");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GcsConfigureCredentials")
                                   .Input(_json)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

QueueDequeueManyV2::QueueDequeueManyV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input n, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _n = ::tensorflow::ops::AsNodeOut(scope, n);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueDequeueManyV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueDequeueManyV2")
                                   .Input(_handle)
                                   .Input(_n)
                                   .Attr("component_types", component_types)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

VarHandleOp::VarHandleOp(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("VarHandleOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "VarHandleOp")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ComputeAccidentalHits::ComputeAccidentalHits(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           tensorflow::Input sampled_candidates, 
           int64_t num_true, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      if (!scope.ok())
          return;
      auto _sampled_candidates = ::tensorflow::ops::AsNodeOut(scope, sampled_candidates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ComputeAccidentalHits");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ComputeAccidentalHits")
                                   .Input(_true_classes)
                                   .Input(_sampled_candidates)
                                   .Attr("num_true", num_true)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueDequeueMany::QueueDequeueMany(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input n, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _n = ::tensorflow::ops::AsNodeOut(scope, n);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueDequeueMany");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueDequeueMany")
                                   .Input(_handle)
                                   .Input(_n)
                                   .Attr("component_types", component_types)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalMaxIntraOpParallelismDataset::ExperimentalMaxIntraOpParallelismDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input max_intra_op_parallelism, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _max_intra_op_parallelism = ::tensorflow::ops::AsNodeOut(scope, max_intra_op_parallelism);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalMaxIntraOpParallelismDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalMaxIntraOpParallelismDataset")
                                   .Input(_input_dataset)
                                   .Input(_max_intra_op_parallelism)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueEnqueueMany::QueueEnqueueMany(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcomponents, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueEnqueueMany");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueEnqueueMany")
                                   .Input(_handle)
                                   .Input(_components)
                                   .Attr("Tcomponents", Tcomponents)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

PaddingFIFOQueue::PaddingFIFOQueue(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PaddingFIFOQueue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PaddingFIFOQueue")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OrderedMapUnstageNoKey::OrderedMapUnstageNoKey(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapUnstageNoKey");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapUnstageNoKey")
                                   .Input(_indices)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorForestTreeResourceHandleOp::TensorForestTreeResourceHandleOp(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestTreeResourceHandleOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestTreeResourceHandleOp")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseSegmentSum::SparseSegmentSum(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input indices, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseSegmentSum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseSegmentSum")
                                   .Input(_data)
                                   .Input(_indices)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FIFOQueue::FIFOQueue(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FIFOQueue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FIFOQueue")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayWriteV3::TensorArrayWriteV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input index, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayWriteV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayWriteV3")
                                   .Input(_handle)
                                   .Input(_index)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefMerge::RefMerge(tensorflow::Scope& scope, 
           tensorflow::InputList inputs) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefMerge");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefMerge")
                                   .Input(_inputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BitwiseOr::BitwiseOr(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BitwiseOr");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BitwiseOr")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayScatter::TensorArrayScatter(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input indices, 
           tensorflow::Input value, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayScatter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayScatter")
                                   .Input(_handle)
                                   .Input(_indices)
                                   .Input(_value)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RestoreV2::RestoreV2(tensorflow::Scope& scope, 
           tensorflow::Input prefix, 
           tensorflow::Input tensor_names, 
           tensorflow::Input shape_and_slices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes) {
      if (!scope.ok())
          return;
      auto _prefix = ::tensorflow::ops::AsNodeOut(scope, prefix);
      if (!scope.ok())
          return;
      auto _tensor_names = ::tensorflow::ops::AsNodeOut(scope, tensor_names);
      if (!scope.ok())
          return;
      auto _shape_and_slices = ::tensorflow::ops::AsNodeOut(scope, shape_and_slices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RestoreV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RestoreV2")
                                   .Input(_prefix)
                                   .Input(_tensor_names)
                                   .Input(_shape_and_slices)
                                   .Attr("dtypes", dtypes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RandomShuffleQueue::RandomShuffleQueue(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t min_after_dequeue, 
           int64_t seed, 
           int64_t seed2) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RandomShuffleQueue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RandomShuffleQueue")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("min_after_dequeue", min_after_dequeue)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Invert::Invert(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Invert");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Invert")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodePng::DecodePng(tensorflow::Scope& scope, 
           tensorflow::Input contents, 
           int64_t channels, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodePng");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodePng")
                                   .Input(_contents)
                                   .Attr("channels", channels)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ControlTrigger::ControlTrigger(tensorflow::Scope& scope) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ControlTrigger");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ControlTrigger")
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ParallelDynamicStitch::ParallelDynamicStitch(tensorflow::Scope& scope, 
           tensorflow::InputList indices, 
           tensorflow::InputList data) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOutList(scope, indices);
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOutList(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParallelDynamicStitch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParallelDynamicStitch")
                                   .Input(_indices)
                                   .Input(_data)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapSize::MapSize(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapSize")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseReduceSum::SparseReduceSum(tensorflow::Scope& scope, 
           tensorflow::Input input_indices, 
           tensorflow::Input input_values, 
           tensorflow::Input input_shape, 
           tensorflow::Input reduction_axes, 
           bool keep_dims) {
      if (!scope.ok())
          return;
      auto _input_indices = ::tensorflow::ops::AsNodeOut(scope, input_indices);
      if (!scope.ok())
          return;
      auto _input_values = ::tensorflow::ops::AsNodeOut(scope, input_values);
      if (!scope.ok())
          return;
      auto _input_shape = ::tensorflow::ops::AsNodeOut(scope, input_shape);
      if (!scope.ok())
          return;
      auto _reduction_axes = ::tensorflow::ops::AsNodeOut(scope, reduction_axes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseReduceSum");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseReduceSum")
                                   .Input(_input_indices)
                                   .Input(_input_values)
                                   .Input(_input_shape)
                                   .Input(_reduction_axes)
                                   .Attr("keep_dims", keep_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Zeta::Zeta(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input q) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _q = ::tensorflow::ops::AsNodeOut(scope, q);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Zeta");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Zeta")
                                   .Input(_x)
                                   .Input(_q)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGradV2::TensorArrayGradV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::string source) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGradV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGradV2")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("source", source)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolGradGradWithArgmax::MaxPoolGradGradWithArgmax(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input grad, 
           tensorflow::Input argmax, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _argmax = ::tensorflow::ops::AsNodeOut(scope, argmax);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolGradGradWithArgmax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolGradGradWithArgmax")
                                   .Input(_input)
                                   .Input(_grad)
                                   .Input(_argmax)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Less::Less(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Less");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Less")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyGradientDescent::ApplyGradientDescent(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input alpha, 
           tensorflow::Input delta, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyGradientDescent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyGradientDescent")
                                   .Input(_var)
                                   .Input(_alpha)
                                   .Input(_delta)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CollectiveReduce::CollectiveReduce(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string merge_op, 
           tensorflow::string final_op, 
           tensorflow::gtl::ArraySlice<int64_t> subdiv_offsets, 
           int64_t instance_key, 
           int64_t group_size, 
           int64_t group_key) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CollectiveReduce");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CollectiveReduce")
                                   .Input(_input)
                                   .Attr("merge_op", merge_op)
                                   .Attr("final_op", final_op)
                                   .Attr("subdiv_offsets", subdiv_offsets)
                                   .Attr("instance_key", instance_key)
                                   .Attr("group_size", group_size)
                                   .Attr("group_key", group_key)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CreateSummaryFileWriter::CreateSummaryFileWriter(tensorflow::Scope& scope, 
           tensorflow::Input writer, 
           tensorflow::Input logdir, 
           tensorflow::Input max_queue, 
           tensorflow::Input flush_millis, 
           tensorflow::Input filename_suffix) {
      if (!scope.ok())
          return;
      auto _writer = ::tensorflow::ops::AsNodeOut(scope, writer);
      if (!scope.ok())
          return;
      auto _logdir = ::tensorflow::ops::AsNodeOut(scope, logdir);
      if (!scope.ok())
          return;
      auto _max_queue = ::tensorflow::ops::AsNodeOut(scope, max_queue);
      if (!scope.ok())
          return;
      auto _flush_millis = ::tensorflow::ops::AsNodeOut(scope, flush_millis);
      if (!scope.ok())
          return;
      auto _filename_suffix = ::tensorflow::ops::AsNodeOut(scope, filename_suffix);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CreateSummaryFileWriter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CreateSummaryFileWriter")
                                   .Input(_writer)
                                   .Input(_logdir)
                                   .Input(_max_queue)
                                   .Input(_flush_millis)
                                   .Input(_filename_suffix)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

QueueIsClosedV2::QueueIsClosedV2(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueIsClosedV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueIsClosedV2")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_ParallelConcatUpdate::_ParallelConcatUpdate(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::Input update, 
           int64_t loc) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _update = ::tensorflow::ops::AsNodeOut(scope, update);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ParallelConcatUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ParallelConcatUpdate")
                                   .Input(_value)
                                   .Input(_update)
                                   .Attr("loc", loc)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CudnnRNNCanonicalToParams::CudnnRNNCanonicalToParams(tensorflow::Scope& scope, 
           tensorflow::Input num_layers, 
           tensorflow::Input num_units, 
           tensorflow::Input input_size, 
           tensorflow::Input weights, 
           tensorflow::Input biases, 
           int64_t seed2, 
           int64_t num_params, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed) {
      if (!scope.ok())
          return;
      auto _num_layers = ::tensorflow::ops::AsNodeOut(scope, num_layers);
      if (!scope.ok())
          return;
      auto _num_units = ::tensorflow::ops::AsNodeOut(scope, num_units);
      if (!scope.ok())
          return;
      auto _input_size = ::tensorflow::ops::AsNodeOut(scope, input_size);
      if (!scope.ok())
          return;
      auto _weights = ::tensorflow::ops::AsNodeOut(scope, weights);
      if (!scope.ok())
          return;
      auto _biases = ::tensorflow::ops::AsNodeOut(scope, biases);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNNCanonicalToParams");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNNCanonicalToParams")
                                   .Input(_num_layers)
                                   .Input(_num_units)
                                   .Input(_input_size)
                                   .Input(_weights)
                                   .Input(_biases)
                                   .Attr("seed2", seed2)
                                   .Attr("num_params", num_params)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArraySizeV3::TensorArraySizeV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArraySizeV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArraySizeV3")
                                   .Input(_handle)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DiagPart::DiagPart(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DiagPart");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DiagPart")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CudnnRNNParamsToCanonical::CudnnRNNParamsToCanonical(tensorflow::Scope& scope, 
           tensorflow::Input num_layers, 
           tensorflow::Input num_units, 
           tensorflow::Input input_size, 
           tensorflow::Input params, 
           int64_t seed2, 
           int64_t num_params, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed) {
      if (!scope.ok())
          return;
      auto _num_layers = ::tensorflow::ops::AsNodeOut(scope, num_layers);
      if (!scope.ok())
          return;
      auto _num_units = ::tensorflow::ops::AsNodeOut(scope, num_units);
      if (!scope.ok())
          return;
      auto _input_size = ::tensorflow::ops::AsNodeOut(scope, input_size);
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNNParamsToCanonical");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNNParamsToCanonical")
                                   .Input(_num_layers)
                                   .Input(_num_units)
                                   .Input(_input_size)
                                   .Input(_params)
                                   .Attr("seed2", seed2)
                                   .Attr("num_params", num_params)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_ParallelConcatStart::_ParallelConcatStart(tensorflow::Scope& scope, 
           tensorflow::PartialTensorShape shape, 
           tensorflow::DataType dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ParallelConcatStart");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ParallelConcatStart")
                                   .Attr("shape", shape)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Size::Size(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Size");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Size")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQuantWithMinMaxVarsGradient::FakeQuantWithMinMaxVarsGradient(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input inputs, 
           tensorflow::Input min, 
           tensorflow::Input max, 
           int64_t num_bits, 
           bool narrow_range) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _min = ::tensorflow::ops::AsNodeOut(scope, min);
      if (!scope.ok())
          return;
      auto _max = ::tensorflow::ops::AsNodeOut(scope, max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQuantWithMinMaxVarsGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQuantWithMinMaxVarsGradient")
                                   .Input(_gradients)
                                   .Input(_inputs)
                                   .Input(_min)
                                   .Input(_max)
                                   .Attr("num_bits", num_bits)
                                   .Attr("narrow_range", narrow_range)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NonMaxSuppressionV4::NonMaxSuppressionV4(tensorflow::Scope& scope, 
           tensorflow::Input boxes, 
           tensorflow::Input scores, 
           tensorflow::Input max_output_size, 
           tensorflow::Input iou_threshold, 
           tensorflow::Input score_threshold, 
           bool pad_to_max_output_size) {
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _scores = ::tensorflow::ops::AsNodeOut(scope, scores);
      if (!scope.ok())
          return;
      auto _max_output_size = ::tensorflow::ops::AsNodeOut(scope, max_output_size);
      if (!scope.ok())
          return;
      auto _iou_threshold = ::tensorflow::ops::AsNodeOut(scope, iou_threshold);
      if (!scope.ok())
          return;
      auto _score_threshold = ::tensorflow::ops::AsNodeOut(scope, score_threshold);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NonMaxSuppressionV4");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NonMaxSuppressionV4")
                                   .Input(_boxes)
                                   .Input(_scores)
                                   .Input(_max_output_size)
                                   .Input(_iou_threshold)
                                   .Input(_score_threshold)
                                   .Attr("pad_to_max_output_size", pad_to_max_output_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CudnnRNNBackprop::CudnnRNNBackprop(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_h, 
           tensorflow::Input input_c, 
           tensorflow::Input params, 
           tensorflow::Input output, 
           tensorflow::Input output_h, 
           tensorflow::Input output_c, 
           tensorflow::Input output_backprop, 
           tensorflow::Input output_h_backprop, 
           tensorflow::Input output_c_backprop, 
           tensorflow::Input reserve_space, 
           int64_t seed2, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_h = ::tensorflow::ops::AsNodeOut(scope, input_h);
      if (!scope.ok())
          return;
      auto _input_c = ::tensorflow::ops::AsNodeOut(scope, input_c);
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      if (!scope.ok())
          return;
      auto _output = ::tensorflow::ops::AsNodeOut(scope, output);
      if (!scope.ok())
          return;
      auto _output_h = ::tensorflow::ops::AsNodeOut(scope, output_h);
      if (!scope.ok())
          return;
      auto _output_c = ::tensorflow::ops::AsNodeOut(scope, output_c);
      if (!scope.ok())
          return;
      auto _output_backprop = ::tensorflow::ops::AsNodeOut(scope, output_backprop);
      if (!scope.ok())
          return;
      auto _output_h_backprop = ::tensorflow::ops::AsNodeOut(scope, output_h_backprop);
      if (!scope.ok())
          return;
      auto _output_c_backprop = ::tensorflow::ops::AsNodeOut(scope, output_c_backprop);
      if (!scope.ok())
          return;
      auto _reserve_space = ::tensorflow::ops::AsNodeOut(scope, reserve_space);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNNBackprop");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNNBackprop")
                                   .Input(_input)
                                   .Input(_input_h)
                                   .Input(_input_c)
                                   .Input(_params)
                                   .Input(_output)
                                   .Input(_output_h)
                                   .Input(_output_c)
                                   .Input(_output_backprop)
                                   .Input(_output_h_backprop)
                                   .Input(_output_c_backprop)
                                   .Input(_reserve_space)
                                   .Attr("seed2", seed2)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Pad::Pad(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input paddings) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Pad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Pad")
                                   .Input(_input)
                                   .Input(_paddings)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CudnnRNNV2::CudnnRNNV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_h, 
           tensorflow::Input input_c, 
           tensorflow::Input params, 
           bool is_training, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_h = ::tensorflow::ops::AsNodeOut(scope, input_h);
      if (!scope.ok())
          return;
      auto _input_c = ::tensorflow::ops::AsNodeOut(scope, input_c);
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNNV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNNV2")
                                   .Input(_input)
                                   .Input(_input_h)
                                   .Input(_input_c)
                                   .Input(_params)
                                   .Attr("is_training", is_training)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DynamicStitch::DynamicStitch(tensorflow::Scope& scope, 
           tensorflow::InputList indices, 
           tensorflow::InputList data) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOutList(scope, indices);
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOutList(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DynamicStitch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DynamicStitch")
                                   .Input(_indices)
                                   .Input(_data)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_Retval::_Retval(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           int64_t index) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_Retval");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_Retval")
                                   .Input(_input)
                                   .Attr("index", index)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

CTCBeamSearchDecoder::CTCBeamSearchDecoder(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::Input sequence_length, 
           int64_t beam_width, 
           int64_t top_paths, 
           bool merge_repeated) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _sequence_length = ::tensorflow::ops::AsNodeOut(scope, sequence_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CTCBeamSearchDecoder");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CTCBeamSearchDecoder")
                                   .Input(_inputs)
                                   .Input(_sequence_length)
                                   .Attr("beam_width", beam_width)
                                   .Attr("top_paths", top_paths)
                                   .Attr("merge_repeated", merge_repeated)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OrderedMapPeek::OrderedMapPeek(tensorflow::Scope& scope, 
           tensorflow::Input key, 
           tensorflow::Input indices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _key = ::tensorflow::ops::AsNodeOut(scope, key);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OrderedMapPeek");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OrderedMapPeek")
                                   .Input(_key)
                                   .Input(_indices)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FusedResizeAndPadConv2D::FusedResizeAndPadConv2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input size, 
           tensorflow::Input paddings, 
           tensorflow::Input filter, 
           tensorflow::string mode, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           bool resize_align_corners) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FusedResizeAndPadConv2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FusedResizeAndPadConv2D")
                                   .Input(_input)
                                   .Input(_size)
                                   .Input(_paddings)
                                   .Input(_filter)
                                   .Attr("mode", mode)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("resize_align_corners", resize_align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Xdivy::Xdivy(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Xdivy");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Xdivy")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefNextIteration::RefNextIteration(tensorflow::Scope& scope, 
           tensorflow::Input data) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefNextIteration");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefNextIteration")
                                   .Input(_data)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LogMatrixDeterminant::LogMatrixDeterminant(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LogMatrixDeterminant");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LogMatrixDeterminant")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalNonSerializableDataset::ExperimentalNonSerializableDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalNonSerializableDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalNonSerializableDataset")
                                   .Input(_input_dataset)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Exit::Exit(tensorflow::Scope& scope, 
           tensorflow::Input data) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Exit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Exit")
                                   .Input(_data)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringStrip::StringStrip(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringStrip");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringStrip")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefSelect::RefSelect(tensorflow::Scope& scope, 
           tensorflow::Input index, 
           tensorflow::InputList inputs) {
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefSelect");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefSelect")
                                   .Input(_index)
                                   .Input(_inputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Softmax::Softmax(tensorflow::Scope& scope, 
           tensorflow::Input logits) {
      if (!scope.ok())
          return;
      auto _logits = ::tensorflow::ops::AsNodeOut(scope, logits);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Softmax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Softmax")
                                   .Input(_logits)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScalarSummary::ScalarSummary(tensorflow::Scope& scope, 
           tensorflow::Input tags, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _tags = ::tensorflow::ops::AsNodeOut(scope, tags);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScalarSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScalarSummary")
                                   .Input(_tags)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Identity::Identity(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Identity");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Identity")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReverseV2::ReverseV2(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input axis) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReverseV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReverseV2")
                                   .Input(_tensor)
                                   .Input(_axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefSwitch::RefSwitch(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input pred) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _pred = ::tensorflow::ops::AsNodeOut(scope, pred);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefSwitch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefSwitch")
                                   .Input(_data)
                                   .Input(_pred)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NoOp::NoOp(tensorflow::Scope& scope) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NoOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NoOp")
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

LoadAndRemapMatrix::LoadAndRemapMatrix(tensorflow::Scope& scope, 
           tensorflow::Input ckpt_path, 
           tensorflow::Input old_tensor_name, 
           tensorflow::Input row_remapping, 
           tensorflow::Input col_remapping, 
           tensorflow::Input initializing_values, 
           int64_t num_rows, 
           int64_t num_cols, 
           int64_t max_rows_in_memory) {
      if (!scope.ok())
          return;
      auto _ckpt_path = ::tensorflow::ops::AsNodeOut(scope, ckpt_path);
      if (!scope.ok())
          return;
      auto _old_tensor_name = ::tensorflow::ops::AsNodeOut(scope, old_tensor_name);
      if (!scope.ok())
          return;
      auto _row_remapping = ::tensorflow::ops::AsNodeOut(scope, row_remapping);
      if (!scope.ok())
          return;
      auto _col_remapping = ::tensorflow::ops::AsNodeOut(scope, col_remapping);
      if (!scope.ok())
          return;
      auto _initializing_values = ::tensorflow::ops::AsNodeOut(scope, initializing_values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LoadAndRemapMatrix");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LoadAndRemapMatrix")
                                   .Input(_ckpt_path)
                                   .Input(_old_tensor_name)
                                   .Input(_row_remapping)
                                   .Input(_col_remapping)
                                   .Input(_initializing_values)
                                   .Attr("num_rows", num_rows)
                                   .Attr("num_cols", num_cols)
                                   .Attr("max_rows_in_memory", max_rows_in_memory)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IteratorFromStringHandleV2::IteratorFromStringHandleV2(tensorflow::Scope& scope, 
           tensorflow::Input string_handle, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _string_handle = ::tensorflow::ops::AsNodeOut(scope, string_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorFromStringHandleV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorFromStringHandleV2")
                                   .Input(_string_handle)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GenerateVocabRemapping::GenerateVocabRemapping(tensorflow::Scope& scope, 
           tensorflow::Input new_vocab_file, 
           tensorflow::Input old_vocab_file, 
           int64_t new_vocab_offset, 
           int64_t num_new_vocab, 
           int64_t old_vocab_size) {
      if (!scope.ok())
          return;
      auto _new_vocab_file = ::tensorflow::ops::AsNodeOut(scope, new_vocab_file);
      if (!scope.ok())
          return;
      auto _old_vocab_file = ::tensorflow::ops::AsNodeOut(scope, old_vocab_file);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GenerateVocabRemapping");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GenerateVocabRemapping")
                                   .Input(_new_vocab_file)
                                   .Input(_old_vocab_file)
                                   .Attr("new_vocab_offset", new_vocab_offset)
                                   .Attr("num_new_vocab", num_new_vocab)
                                   .Attr("old_vocab_size", old_vocab_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

If::If(tensorflow::Scope& scope, 
           tensorflow::Input cond, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList then_branch, 
           tensorflow::NameAttrList else_branch, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _cond = ::tensorflow::ops::AsNodeOut(scope, cond);
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("If");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "If")
                                   .Input(_cond)
                                   .Input(_input)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("then_branch", then_branch)
                                   .Attr("else_branch", else_branch)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorForestTreeDeserialize::TensorForestTreeDeserialize(tensorflow::Scope& scope, 
           tensorflow::Input tree_handle, 
           tensorflow::Input tree_config) {
      if (!scope.ok())
          return;
      auto _tree_handle = ::tensorflow::ops::AsNodeOut(scope, tree_handle);
      if (!scope.ok())
          return;
      auto _tree_config = ::tensorflow::ops::AsNodeOut(scope, tree_config);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestTreeDeserialize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestTreeDeserialize")
                                   .Input(_tree_handle)
                                   .Input(_tree_config)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ResourceScatterNdAdd::ResourceScatterNdAdd(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterNdAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterNdAdd")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

BoostedTreesGetEnsembleStates::BoostedTreesGetEnsembleStates(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesGetEnsembleStates");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesGetEnsembleStates")
                                   .Input(_tree_ensemble_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorForestTreeSerialize::TensorForestTreeSerialize(tensorflow::Scope& scope, 
           tensorflow::Input tree_handle) {
      if (!scope.ok())
          return;
      auto _tree_handle = ::tensorflow::ops::AsNodeOut(scope, tree_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestTreeSerialize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestTreeSerialize")
                                   .Input(_tree_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MultiDeviceIterator::MultiDeviceIterator(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::string> devices, 
           tensorflow::string shared_name, 
           tensorflow::string container, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MultiDeviceIterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MultiDeviceIterator")
                                   .Attr("devices", devices)
                                   .Attr("shared_name", shared_name)
                                   .Attr("container", container)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CudnnRNNParamsSize::CudnnRNNParamsSize(tensorflow::Scope& scope, 
           tensorflow::Input num_layers, 
           tensorflow::Input num_units, 
           tensorflow::Input input_size, 
           tensorflow::DataType T, 
           int64_t seed2, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed) {
      if (!scope.ok())
          return;
      auto _num_layers = ::tensorflow::ops::AsNodeOut(scope, num_layers);
      if (!scope.ok())
          return;
      auto _num_units = ::tensorflow::ops::AsNodeOut(scope, num_units);
      if (!scope.ok())
          return;
      auto _input_size = ::tensorflow::ops::AsNodeOut(scope, input_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNNParamsSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNNParamsSize")
                                   .Input(_num_layers)
                                   .Input(_num_units)
                                   .Input(_input_size)
                                   .Attr("T", T)
                                   .Attr("seed2", seed2)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalDenseToSparseBatchDataset::ExperimentalDenseToSparseBatchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input batch_size, 
           tensorflow::Input row_shape, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      if (!scope.ok())
          return;
      auto _row_shape = ::tensorflow::ops::AsNodeOut(scope, row_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalDenseToSparseBatchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalDenseToSparseBatchDataset")
                                   .Input(_input_dataset)
                                   .Input(_batch_size)
                                   .Input(_row_shape)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InplaceAdd::InplaceAdd(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input i, 
           tensorflow::Input v) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _i = ::tensorflow::ops::AsNodeOut(scope, i);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InplaceAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InplaceAdd")
                                   .Input(_x)
                                   .Input(_i)
                                   .Input(_v)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EnsureShape::EnsureShape(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::PartialTensorShape shape) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EnsureShape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EnsureShape")
                                   .Input(_input)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorForestTreeIsInitializedOp::TensorForestTreeIsInitializedOp(tensorflow::Scope& scope, 
           tensorflow::Input tree_handle) {
      if (!scope.ok())
          return;
      auto _tree_handle = ::tensorflow::ops::AsNodeOut(scope, tree_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestTreeIsInitializedOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestTreeIsInitializedOp")
                                   .Input(_tree_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchSvd::BatchSvd(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool compute_uv, 
           bool full_matrices) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchSvd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchSvd")
                                   .Input(_input)
                                   .Attr("compute_uv", compute_uv)
                                   .Attr("full_matrices", full_matrices)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GatherV2::GatherV2(tensorflow::Scope& scope, 
           tensorflow::Input params, 
           tensorflow::Input indices, 
           tensorflow::Input axis) {
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GatherV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GatherV2")
                                   .Input(_params)
                                   .Input(_indices)
                                   .Input(_axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalParseExampleDataset::ExperimentalParseExampleDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input num_parallel_calls, 
           tensorflow::Input dense_defaults, 
           tensorflow::gtl::ArraySlice<tensorflow::string> sparse_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::string> dense_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tdense, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> dense_shapes, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool sloppy) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _num_parallel_calls = ::tensorflow::ops::AsNodeOut(scope, num_parallel_calls);
      if (!scope.ok())
          return;
      auto _dense_defaults = ::tensorflow::ops::AsNodeOut(scope, dense_defaults);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalParseExampleDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalParseExampleDataset")
                                   .Input(_input_dataset)
                                   .Input(_num_parallel_calls)
                                   .Input(_dense_defaults)
                                   .Attr("sparse_keys", sparse_keys)
                                   .Attr("dense_keys", dense_keys)
                                   .Attr("sparse_types", sparse_types)
                                   .Attr("Tdense", Tdense)
                                   .Attr("dense_shapes", dense_shapes)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("sloppy", sloppy)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesBucketize::BoostedTreesBucketize(tensorflow::Scope& scope, 
           tensorflow::Input float_values, 
           tensorflow::Input bucket_boundaries, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _float_values = ::tensorflow::ops::AsNodeOut(scope, float_values);
      if (!scope.ok())
          return;
      auto _bucket_boundaries = ::tensorflow::ops::AsNodeOut(scope, bucket_boundaries);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesBucketize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesBucketize")
                                   .Input(_float_values)
                                   .Input(_bucket_boundaries)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterNdNonAliasingAdd::ScatterNdNonAliasingAdd(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input indices, 
           tensorflow::Input updates) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterNdNonAliasingAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterNdNonAliasingAdd")
                                   .Input(_input)
                                   .Input(_indices)
                                   .Input(_updates)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesQuantileStreamResourceGetBucketBoundaries::BoostedTreesQuantileStreamResourceGetBucketBoundaries(tensorflow::Scope& scope, 
           tensorflow::Input quantile_stream_resource_handle, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _quantile_stream_resource_handle = ::tensorflow::ops::AsNodeOut(scope, quantile_stream_resource_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesQuantileStreamResourceGetBucketBoundaries");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesQuantileStreamResourceGetBucketBoundaries")
                                   .Input(_quantile_stream_resource_handle)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PopulationCount::PopulationCount(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PopulationCount");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PopulationCount")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

WholeFileReaderV2::WholeFileReaderV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WholeFileReaderV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WholeFileReaderV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesQuantileStreamResourceFlush::BoostedTreesQuantileStreamResourceFlush(tensorflow::Scope& scope, 
           tensorflow::Input quantile_stream_resource_handle, 
           tensorflow::Input num_buckets, 
           bool generate_quantiles) {
      if (!scope.ok())
          return;
      auto _quantile_stream_resource_handle = ::tensorflow::ops::AsNodeOut(scope, quantile_stream_resource_handle);
      if (!scope.ok())
          return;
      auto _num_buckets = ::tensorflow::ops::AsNodeOut(scope, num_buckets);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesQuantileStreamResourceFlush");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesQuantileStreamResourceFlush")
                                   .Input(_quantile_stream_resource_handle)
                                   .Input(_num_buckets)
                                   .Attr("generate_quantiles", generate_quantiles)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Atan::Atan(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Atan");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Atan")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQueue::FakeQueue(tensorflow::Scope& scope, 
           tensorflow::Input resource) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQueue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQueue")
                                   .Input(_resource)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesPredict::BoostedTreesPredict(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input bucketized_features, 
           int64_t num_bucketized_features, 
           int64_t logits_dimension) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _bucketized_features = ::tensorflow::ops::AsNodeOut(scope, bucketized_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesPredict");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesPredict")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_bucketized_features)
                                   .Attr("num_bucketized_features", num_bucketized_features)
                                   .Attr("logits_dimension", logits_dimension)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesMakeStatsSummary::BoostedTreesMakeStatsSummary(tensorflow::Scope& scope, 
           tensorflow::Input node_ids, 
           tensorflow::Input gradients, 
           tensorflow::Input hessians, 
           tensorflow::Input bucketized_features_list, 
           int64_t max_splits, 
           int64_t num_buckets, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _node_ids = ::tensorflow::ops::AsNodeOut(scope, node_ids);
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _hessians = ::tensorflow::ops::AsNodeOut(scope, hessians);
      if (!scope.ok())
          return;
      auto _bucketized_features_list = ::tensorflow::ops::AsNodeOut(scope, bucketized_features_list);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesMakeStatsSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesMakeStatsSummary")
                                   .Input(_node_ids)
                                   .Input(_gradients)
                                   .Input(_hessians)
                                   .Input(_bucketized_features_list)
                                   .Attr("max_splits", max_splits)
                                   .Attr("num_buckets", num_buckets)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BiasAddV1::BiasAddV1(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::Input bias) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _bias = ::tensorflow::ops::AsNodeOut(scope, bias);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BiasAddV1");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BiasAddV1")
                                   .Input(_value)
                                   .Input(_bias)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LogicalOr::LogicalOr(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LogicalOr");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LogicalOr")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesDeserializeEnsemble::BoostedTreesDeserializeEnsemble(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input stamp_token, 
           tensorflow::Input tree_ensemble_serialized) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _stamp_token = ::tensorflow::ops::AsNodeOut(scope, stamp_token);
      if (!scope.ok())
          return;
      auto _tree_ensemble_serialized = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_serialized);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesDeserializeEnsemble");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesDeserializeEnsemble")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_stamp_token)
                                   .Input(_tree_ensemble_serialized)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

NegTrain::NegTrain(tensorflow::Scope& scope, 
           tensorflow::Input w_in, 
           tensorflow::Input w_out, 
           tensorflow::Input examples, 
           tensorflow::Input labels, 
           tensorflow::Input lr, 
           tensorflow::gtl::ArraySlice<int64_t> vocab_count, 
           int64_t num_negative_samples) {
      if (!scope.ok())
          return;
      auto _w_in = ::tensorflow::ops::AsNodeOut(scope, w_in);
      if (!scope.ok())
          return;
      auto _w_out = ::tensorflow::ops::AsNodeOut(scope, w_out);
      if (!scope.ok())
          return;
      auto _examples = ::tensorflow::ops::AsNodeOut(scope, examples);
      if (!scope.ok())
          return;
      auto _labels = ::tensorflow::ops::AsNodeOut(scope, labels);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NegTrain");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NegTrain")
                                   .Input(_w_in)
                                   .Input(_w_out)
                                   .Input(_examples)
                                   .Input(_labels)
                                   .Input(_lr)
                                   .Attr("vocab_count", vocab_count)
                                   .Attr("num_negative_samples", num_negative_samples)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ConcatV2::ConcatV2(tensorflow::Scope& scope, 
           tensorflow::InputList values, 
           tensorflow::Input axis) {
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOutList(scope, values);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ConcatV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ConcatV2")
                                   .Input(_values)
                                   .Input(_axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ConcatOffset::ConcatOffset(tensorflow::Scope& scope, 
           tensorflow::Input concat_dim, 
           tensorflow::InputList shape) {
      if (!scope.ok())
          return;
      auto _concat_dim = ::tensorflow::ops::AsNodeOut(scope, concat_dim);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOutList(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ConcatOffset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ConcatOffset")
                                   .Input(_concat_dim)
                                   .Input(_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      for (tensorflow::int32 i = 0; i < ret->num_outputs(); ++i)
          this->output.push_back(tensorflow::Output(ret, i));
}

BoostedTreesExampleDebugOutputs::BoostedTreesExampleDebugOutputs(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input bucketized_features, 
           int64_t num_bucketized_features, 
           int64_t logits_dimension) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _bucketized_features = ::tensorflow::ops::AsNodeOut(scope, bucketized_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesExampleDebugOutputs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesExampleDebugOutputs")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_bucketized_features)
                                   .Attr("num_bucketized_features", num_bucketized_features)
                                   .Attr("logits_dimension", logits_dimension)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeGif::DecodeGif(tensorflow::Scope& scope, 
           tensorflow::Input contents) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeGif");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeGif")
                                   .Input(_contents)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesCalculateBestGainsPerFeature::BoostedTreesCalculateBestGainsPerFeature(tensorflow::Scope& scope, 
           tensorflow::Input node_id_range, 
           tensorflow::Input stats_summary_list, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input tree_complexity, 
           tensorflow::Input min_node_weight, 
           int64_t max_splits, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _node_id_range = ::tensorflow::ops::AsNodeOut(scope, node_id_range);
      if (!scope.ok())
          return;
      auto _stats_summary_list = ::tensorflow::ops::AsNodeOut(scope, stats_summary_list);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _tree_complexity = ::tensorflow::ops::AsNodeOut(scope, tree_complexity);
      if (!scope.ok())
          return;
      auto _min_node_weight = ::tensorflow::ops::AsNodeOut(scope, min_node_weight);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesCalculateBestGainsPerFeature");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesCalculateBestGainsPerFeature")
                                   .Input(_node_id_range)
                                   .Input(_stats_summary_list)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_tree_complexity)
                                   .Input(_min_node_weight)
                                   .Attr("max_splits", max_splits)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SampleDistortedBoundingBox::SampleDistortedBoundingBox(tensorflow::Scope& scope, 
           tensorflow::Input image_size, 
           tensorflow::Input bounding_boxes, 
           bool use_image_if_no_bounding_boxes, 
           int64_t seed, 
           int64_t seed2, 
           float min_object_covered, 
           tensorflow::gtl::ArraySlice<float> aspect_ratio_range, 
           tensorflow::gtl::ArraySlice<float> area_range, 
           int64_t max_attempts) {
      if (!scope.ok())
          return;
      auto _image_size = ::tensorflow::ops::AsNodeOut(scope, image_size);
      if (!scope.ok())
          return;
      auto _bounding_boxes = ::tensorflow::ops::AsNodeOut(scope, bounding_boxes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SampleDistortedBoundingBox");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SampleDistortedBoundingBox")
                                   .Input(_image_size)
                                   .Input(_bounding_boxes)
                                   .Attr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
                                   .Attr("min_object_covered", min_object_covered)
                                   .Attr("aspect_ratio_range", aspect_ratio_range)
                                   .Attr("area_range", area_range)
                                   .Attr("max_attempts", max_attempts)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeBmp::DecodeBmp(tensorflow::Scope& scope, 
           tensorflow::Input contents, 
           int64_t channels) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeBmp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeBmp")
                                   .Input(_contents)
                                   .Attr("channels", channels)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RightShift::RightShift(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RightShift");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RightShift")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Imag::Imag(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Imag");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Imag")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MutableDenseHashTable::MutableDenseHashTable(tensorflow::Scope& scope, 
           tensorflow::Input empty_key, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           float max_load_factor, 
           tensorflow::DataType value_dtype, 
           tensorflow::PartialTensorShape value_shape, 
           int64_t initial_num_buckets) {
      if (!scope.ok())
          return;
      auto _empty_key = ::tensorflow::ops::AsNodeOut(scope, empty_key);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutableDenseHashTable");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutableDenseHashTable")
                                   .Input(_empty_key)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("max_load_factor", max_load_factor)
                                   .Attr("value_dtype", value_dtype)
                                   .Attr("value_shape", value_shape)
                                   .Attr("initial_num_buckets", initial_num_buckets)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGrad::TensorArrayGrad(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::string source) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGrad")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("source", source)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_MklSquaredDifference::_MklSquaredDifference(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y, 
           tensorflow::Input mkl_x, 
           tensorflow::Input mkl_y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      if (!scope.ok())
          return;
      auto _mkl_x = ::tensorflow::ops::AsNodeOut(scope, mkl_x);
      if (!scope.ok())
          return;
      auto _mkl_y = ::tensorflow::ops::AsNodeOut(scope, mkl_y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_MklSquaredDifference");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_MklSquaredDifference")
                                   .Input(_x)
                                   .Input(_y)
                                   .Input(_mkl_x)
                                   .Input(_mkl_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnbatchGrad::UnbatchGrad(tensorflow::Scope& scope, 
           tensorflow::Input original_input, 
           tensorflow::Input batch_index, 
           tensorflow::Input grad, 
           tensorflow::Input id, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      if (!scope.ok())
          return;
      auto _original_input = ::tensorflow::ops::AsNodeOut(scope, original_input);
      if (!scope.ok())
          return;
      auto _batch_index = ::tensorflow::ops::AsNodeOut(scope, batch_index);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _id = ::tensorflow::ops::AsNodeOut(scope, id);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnbatchGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnbatchGrad")
                                   .Input(_original_input)
                                   .Input(_batch_index)
                                   .Input(_grad)
                                   .Input(_id)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Mfcc::Mfcc(tensorflow::Scope& scope, 
           tensorflow::Input spectrogram, 
           tensorflow::Input sample_rate, 
           float upper_frequency_limit, 
           float lower_frequency_limit, 
           int64_t filterbank_channel_count, 
           int64_t dct_coefficient_count) {
      if (!scope.ok())
          return;
      auto _spectrogram = ::tensorflow::ops::AsNodeOut(scope, spectrogram);
      if (!scope.ok())
          return;
      auto _sample_rate = ::tensorflow::ops::AsNodeOut(scope, sample_rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Mfcc");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Mfcc")
                                   .Input(_spectrogram)
                                   .Input(_sample_rate)
                                   .Attr("upper_frequency_limit", upper_frequency_limit)
                                   .Attr("lower_frequency_limit", lower_frequency_limit)
                                   .Attr("filterbank_channel_count", filterbank_channel_count)
                                   .Attr("dct_coefficient_count", dct_coefficient_count)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BroadcastGradientArgs::BroadcastGradientArgs(tensorflow::Scope& scope, 
           tensorflow::Input s0, 
           tensorflow::Input s1) {
      if (!scope.ok())
          return;
      auto _s0 = ::tensorflow::ops::AsNodeOut(scope, s0);
      if (!scope.ok())
          return;
      auto _s1 = ::tensorflow::ops::AsNodeOut(scope, s1);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BroadcastGradientArgs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BroadcastGradientArgs")
                                   .Input(_s0)
                                   .Input(_s1)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

NonMaxSuppressionV3::NonMaxSuppressionV3(tensorflow::Scope& scope, 
           tensorflow::Input boxes, 
           tensorflow::Input scores, 
           tensorflow::Input max_output_size, 
           tensorflow::Input iou_threshold, 
           tensorflow::Input score_threshold) {
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      if (!scope.ok())
          return;
      auto _scores = ::tensorflow::ops::AsNodeOut(scope, scores);
      if (!scope.ok())
          return;
      auto _max_output_size = ::tensorflow::ops::AsNodeOut(scope, max_output_size);
      if (!scope.ok())
          return;
      auto _iou_threshold = ::tensorflow::ops::AsNodeOut(scope, iou_threshold);
      if (!scope.ok())
          return;
      auto _score_threshold = ::tensorflow::ops::AsNodeOut(scope, score_threshold);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NonMaxSuppressionV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NonMaxSuppressionV3")
                                   .Input(_boxes)
                                   .Input(_scores)
                                   .Input(_max_output_size)
                                   .Input(_iou_threshold)
                                   .Input(_score_threshold)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_If::_If(tensorflow::Scope& scope, 
           tensorflow::Input cond, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tin, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tout, 
           tensorflow::NameAttrList then_branch, 
           tensorflow::NameAttrList else_branch) {
      if (!scope.ok())
          return;
      auto _cond = ::tensorflow::ops::AsNodeOut(scope, cond);
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_If");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_If")
                                   .Input(_cond)
                                   .Input(_input)
                                   .Attr("Tin", Tin)
                                   .Attr("Tout", Tout)
                                   .Attr("then_branch", then_branch)
                                   .Attr("else_branch", else_branch)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchIFFT::BatchIFFT(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchIFFT");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchIFFT")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueDequeueUpToV2::QueueDequeueUpToV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input n, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _n = ::tensorflow::ops::AsNodeOut(scope, n);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueDequeueUpToV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueDequeueUpToV2")
                                   .Input(_handle)
                                   .Input(_n)
                                   .Attr("component_types", component_types)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeWav::DecodeWav(tensorflow::Scope& scope, 
           tensorflow::Input contents, 
           int64_t desired_channels, 
           int64_t desired_samples) {
      if (!scope.ok())
          return;
      auto _contents = ::tensorflow::ops::AsNodeOut(scope, contents);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeWav");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeWav")
                                   .Input(_contents)
                                   .Attr("desired_channels", desired_channels)
                                   .Attr("desired_samples", desired_samples)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseAccumulatorApplyGradient::SparseAccumulatorApplyGradient(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input local_step, 
           tensorflow::Input gradient_indices, 
           tensorflow::Input gradient_values, 
           tensorflow::Input gradient_shape, 
           tensorflow::DataType dtype, 
           bool has_known_shape) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _local_step = ::tensorflow::ops::AsNodeOut(scope, local_step);
      if (!scope.ok())
          return;
      auto _gradient_indices = ::tensorflow::ops::AsNodeOut(scope, gradient_indices);
      if (!scope.ok())
          return;
      auto _gradient_values = ::tensorflow::ops::AsNodeOut(scope, gradient_values);
      if (!scope.ok())
          return;
      auto _gradient_shape = ::tensorflow::ops::AsNodeOut(scope, gradient_shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseAccumulatorApplyGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseAccumulatorApplyGradient")
                                   .Input(_handle)
                                   .Input(_local_step)
                                   .Input(_gradient_indices)
                                   .Input(_gradient_values)
                                   .Input(_gradient_shape)
                                   .Attr("dtype", dtype)
                                   .Attr("has_known_shape", has_known_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

AssignSubVariableOp::AssignSubVariableOp(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input value, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AssignSubVariableOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AssignSubVariableOp")
                                   .Input(_resource)
                                   .Input(_value)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

FusedBatchNormGrad::FusedBatchNormGrad(tensorflow::Scope& scope, 
           tensorflow::Input y_backprop, 
           tensorflow::Input x, 
           tensorflow::Input scale, 
           tensorflow::Input reserve_space_1, 
           tensorflow::Input reserve_space_2, 
           bool is_training, 
           float epsilon, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _y_backprop = ::tensorflow::ops::AsNodeOut(scope, y_backprop);
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _scale = ::tensorflow::ops::AsNodeOut(scope, scale);
      if (!scope.ok())
          return;
      auto _reserve_space_1 = ::tensorflow::ops::AsNodeOut(scope, reserve_space_1);
      if (!scope.ok())
          return;
      auto _reserve_space_2 = ::tensorflow::ops::AsNodeOut(scope, reserve_space_2);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FusedBatchNormGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FusedBatchNormGrad")
                                   .Input(_y_backprop)
                                   .Input(_x)
                                   .Input(_scale)
                                   .Input(_reserve_space_1)
                                   .Input(_reserve_space_2)
                                   .Attr("is_training", is_training)
                                   .Attr("epsilon", epsilon)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnravelIndex::UnravelIndex(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::Input dims) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _dims = ::tensorflow::ops::AsNodeOut(scope, dims);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnravelIndex");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnravelIndex")
                                   .Input(_indices)
                                   .Input(_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixBandPart::MatrixBandPart(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input num_lower, 
           tensorflow::Input num_upper) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _num_lower = ::tensorflow::ops::AsNodeOut(scope, num_lower);
      if (!scope.ok())
          return;
      auto _num_upper = ::tensorflow::ops::AsNodeOut(scope, num_upper);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixBandPart");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixBandPart")
                                   .Input(_input)
                                   .Input(_num_lower)
                                   .Input(_num_upper)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayClose::TensorArrayClose(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayClose");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayClose")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

BatchMatrixBandPart::BatchMatrixBandPart(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input num_lower, 
           tensorflow::Input num_upper) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _num_lower = ::tensorflow::ops::AsNodeOut(scope, num_lower);
      if (!scope.ok())
          return;
      auto _num_upper = ::tensorflow::ops::AsNodeOut(scope, num_upper);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixBandPart");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixBandPart")
                                   .Input(_input)
                                   .Input(_num_lower)
                                   .Input(_num_upper)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResizeNearestNeighbor::ResizeNearestNeighbor(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input size, 
           bool align_corners) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _size = ::tensorflow::ops::AsNodeOut(scope, size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResizeNearestNeighbor");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResizeNearestNeighbor")
                                   .Input(_images)
                                   .Input(_size)
                                   .Attr("align_corners", align_corners)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixDiagPart::BatchMatrixDiagPart(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixDiagPart");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixDiagPart")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixSetDiag::BatchMatrixSetDiag(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input diagonal) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _diagonal = ::tensorflow::ops::AsNodeOut(scope, diagonal);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixSetDiag");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixSetDiag")
                                   .Input(_input)
                                   .Input(_diagonal)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OnesLike::OnesLike(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OnesLike");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OnesLike")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EncodeWav::EncodeWav(tensorflow::Scope& scope, 
           tensorflow::Input audio, 
           tensorflow::Input sample_rate) {
      if (!scope.ok())
          return;
      auto _audio = ::tensorflow::ops::AsNodeOut(scope, audio);
      if (!scope.ok())
          return;
      auto _sample_rate = ::tensorflow::ops::AsNodeOut(scope, sample_rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EncodeWav");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EncodeWav")
                                   .Input(_audio)
                                   .Input(_sample_rate)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FixedLengthRecordDatasetV2::FixedLengthRecordDatasetV2(tensorflow::Scope& scope, 
           tensorflow::Input filenames, 
           tensorflow::Input header_bytes, 
           tensorflow::Input record_bytes, 
           tensorflow::Input footer_bytes, 
           tensorflow::Input buffer_size, 
           tensorflow::Input compression_type) {
      if (!scope.ok())
          return;
      auto _filenames = ::tensorflow::ops::AsNodeOut(scope, filenames);
      if (!scope.ok())
          return;
      auto _header_bytes = ::tensorflow::ops::AsNodeOut(scope, header_bytes);
      if (!scope.ok())
          return;
      auto _record_bytes = ::tensorflow::ops::AsNodeOut(scope, record_bytes);
      if (!scope.ok())
          return;
      auto _footer_bytes = ::tensorflow::ops::AsNodeOut(scope, footer_bytes);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      if (!scope.ok())
          return;
      auto _compression_type = ::tensorflow::ops::AsNodeOut(scope, compression_type);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FixedLengthRecordDatasetV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FixedLengthRecordDatasetV2")
                                   .Input(_filenames)
                                   .Input(_header_bytes)
                                   .Input(_record_bytes)
                                   .Input(_footer_bytes)
                                   .Input(_buffer_size)
                                   .Input(_compression_type)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IteratorGetNext::IteratorGetNext(tensorflow::Scope& scope, 
           tensorflow::Input iterator, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _iterator = ::tensorflow::ops::AsNodeOut(scope, iterator);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IteratorGetNext");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IteratorGetNext")
                                   .Input(_iterator)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FakeQuantWithMinMaxArgsGradient::FakeQuantWithMinMaxArgsGradient(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input inputs, 
           float min, 
           float max, 
           int64_t num_bits, 
           bool narrow_range) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FakeQuantWithMinMaxArgsGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FakeQuantWithMinMaxArgsGradient")
                                   .Input(_gradients)
                                   .Input(_inputs)
                                   .Attr("min", min)
                                   .Attr("max", max)
                                   .Attr("num_bits", num_bits)
                                   .Attr("narrow_range", narrow_range)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyAdadelta::ResourceApplyAdadelta(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input accum_update, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _accum_update = ::tensorflow::ops::AsNodeOut(scope, accum_update);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyAdadelta");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyAdadelta")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_accum_update)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

BoostedTreesQuantileStreamResourceDeserialize::BoostedTreesQuantileStreamResourceDeserialize(tensorflow::Scope& scope, 
           tensorflow::Input quantile_stream_resource_handle, 
           tensorflow::Input bucket_boundaries, 
           int64_t num_streams) {
      if (!scope.ok())
          return;
      auto _quantile_stream_resource_handle = ::tensorflow::ops::AsNodeOut(scope, quantile_stream_resource_handle);
      if (!scope.ok())
          return;
      auto _bucket_boundaries = ::tensorflow::ops::AsNodeOut(scope, bucket_boundaries);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesQuantileStreamResourceDeserialize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesQuantileStreamResourceDeserialize")
                                   .Input(_quantile_stream_resource_handle)
                                   .Input(_bucket_boundaries)
                                   .Attr("num_streams", num_streams)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

GetSessionHandle::GetSessionHandle(tensorflow::Scope& scope, 
           tensorflow::Input value) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GetSessionHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GetSessionHandle")
                                   .Input(_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListConcat::TensorListConcat(tensorflow::Scope& scope, 
           tensorflow::Input input_handle) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListConcat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListConcat")
                                   .Input(_input_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FixedLengthRecordReader::FixedLengthRecordReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t header_bytes, 
           int64_t record_bytes, 
           int64_t footer_bytes, 
           int64_t hop_bytes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FixedLengthRecordReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FixedLengthRecordReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("header_bytes", header_bytes)
                                   .Attr("record_bytes", record_bytes)
                                   .Attr("footer_bytes", footer_bytes)
                                   .Attr("hop_bytes", hop_bytes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AssignAdd::AssignAdd(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input value, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AssignAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AssignAdd")
                                   .Input(_ref)
                                   .Input(_value)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IsBoostedTreesQuantileStreamResourceInitialized::IsBoostedTreesQuantileStreamResourceInitialized(tensorflow::Scope& scope, 
           tensorflow::Input quantile_stream_resource_handle) {
      if (!scope.ok())
          return;
      auto _quantile_stream_resource_handle = ::tensorflow::ops::AsNodeOut(scope, quantile_stream_resource_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IsBoostedTreesQuantileStreamResourceInitialized");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IsBoostedTreesQuantileStreamResourceInitialized")
                                   .Input(_quantile_stream_resource_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LeftShift::LeftShift(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LeftShift");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LeftShift")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

EncodePng::EncodePng(tensorflow::Scope& scope, 
           tensorflow::Input image, 
           int64_t compression) {
      if (!scope.ok())
          return;
      auto _image = ::tensorflow::ops::AsNodeOut(scope, image);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("EncodePng");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "EncodePng")
                                   .Input(_image)
                                   .Attr("compression", compression)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Enter::Enter(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::string frame_name, 
           int64_t parallel_iterations, 
           bool is_constant) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Enter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Enter")
                                   .Input(_data)
                                   .Attr("frame_name", frame_name)
                                   .Attr("parallel_iterations", parallel_iterations)
                                   .Attr("is_constant", is_constant)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StageSize::StageSize(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StageSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StageSize")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RaggedTensorToSparse::RaggedTensorToSparse(tensorflow::Scope& scope, 
           tensorflow::Input rt_nested_splits, 
           tensorflow::Input rt_dense_values, 
           int64_t RAGGED_RANK) {
      if (!scope.ok())
          return;
      auto _rt_nested_splits = ::tensorflow::ops::AsNodeOut(scope, rt_nested_splits);
      if (!scope.ok())
          return;
      auto _rt_dense_values = ::tensorflow::ops::AsNodeOut(scope, rt_dense_values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RaggedTensorToSparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RaggedTensorToSparse")
                                   .Input(_rt_nested_splits)
                                   .Input(_rt_dense_values)
                                   .Attr("RAGGED_RANK", RAGGED_RANK)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Unique::Unique(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::DataType out_idx) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Unique");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Unique")
                                   .Input(_x)
                                   .Attr("out_idx", out_idx)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterNd::ScatterNd(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::Input shape) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterNd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterNd")
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Input(_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayConcatV3::TensorArrayConcatV3(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape_except0) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayConcatV3");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayConcatV3")
                                   .Input(_handle)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape_except0", element_shape_except0)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyFtrlV2::ResourceApplyFtrlV2(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input l2_shrinkage, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _l2_shrinkage = ::tensorflow::ops::AsNodeOut(scope, l2_shrinkage);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyFtrlV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyFtrlV2")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_l2_shrinkage)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

UpperBound::UpperBound(tensorflow::Scope& scope, 
           tensorflow::Input sorted_inputs, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _sorted_inputs = ::tensorflow::ops::AsNodeOut(scope, sorted_inputs);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UpperBound");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UpperBound")
                                   .Input(_sorted_inputs)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StridedSliceAssign::StridedSliceAssign(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input begin, 
           tensorflow::Input end, 
           tensorflow::Input strides, 
           tensorflow::Input value, 
           int64_t shrink_axis_mask, 
           int64_t new_axis_mask, 
           int64_t begin_mask, 
           int64_t end_mask, 
           int64_t ellipsis_mask) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _begin = ::tensorflow::ops::AsNodeOut(scope, begin);
      if (!scope.ok())
          return;
      auto _end = ::tensorflow::ops::AsNodeOut(scope, end);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StridedSliceAssign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StridedSliceAssign")
                                   .Input(_ref)
                                   .Input(_begin)
                                   .Input(_end)
                                   .Input(_strides)
                                   .Input(_value)
                                   .Attr("shrink_axis_mask", shrink_axis_mask)
                                   .Attr("new_axis_mask", new_axis_mask)
                                   .Attr("begin_mask", begin_mask)
                                   .Attr("end_mask", end_mask)
                                   .Attr("ellipsis_mask", ellipsis_mask)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedConcat::QuantizedConcat(tensorflow::Scope& scope, 
           tensorflow::Input concat_dim, 
           tensorflow::InputList values, 
           tensorflow::InputList input_mins, 
           tensorflow::InputList input_maxes) {
      if (!scope.ok())
          return;
      auto _concat_dim = ::tensorflow::ops::AsNodeOut(scope, concat_dim);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOutList(scope, values);
      if (!scope.ok())
          return;
      auto _input_mins = ::tensorflow::ops::AsNodeOutList(scope, input_mins);
      if (!scope.ok())
          return;
      auto _input_maxes = ::tensorflow::ops::AsNodeOutList(scope, input_maxes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedConcat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedConcat")
                                   .Input(_concat_dim)
                                   .Input(_values)
                                   .Input(_input_mins)
                                   .Input(_input_maxes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableInsert::LookupTableInsert(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableInsert");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableInsert")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ExtractVolumePatches::ExtractVolumePatches(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> ksizes, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExtractVolumePatches");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExtractVolumePatches")
                                   .Input(_input)
                                   .Attr("ksizes", ksizes)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FixedUnigramCandidateSampler::FixedUnigramCandidateSampler(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           tensorflow::string vocab_file, 
           tensorflow::gtl::ArraySlice<float> unigrams, 
           int64_t num_true, 
           int64_t num_sampled, 
           bool unique, 
           int64_t range_max, 
           float distortion, 
           int64_t num_reserved_ids, 
           int64_t num_shards, 
           int64_t shard, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FixedUnigramCandidateSampler");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FixedUnigramCandidateSampler")
                                   .Input(_true_classes)
                                   .Attr("vocab_file", vocab_file)
                                   .Attr("unigrams", unigrams)
                                   .Attr("num_true", num_true)
                                   .Attr("num_sampled", num_sampled)
                                   .Attr("unique", unique)
                                   .Attr("range_max", range_max)
                                   .Attr("distortion", distortion)
                                   .Attr("num_reserved_ids", num_reserved_ids)
                                   .Attr("num_shards", num_shards)
                                   .Attr("shard", shard)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Merge::Merge(tensorflow::Scope& scope, 
           tensorflow::InputList inputs) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Merge");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Merge")
                                   .Input(_inputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PaddedBatchDatasetV2::PaddedBatchDatasetV2(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input batch_size, 
           tensorflow::InputList padded_shapes, 
           tensorflow::Input padding_values, 
           tensorflow::Input drop_remainder, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Toutput_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      if (!scope.ok())
          return;
      auto _padded_shapes = ::tensorflow::ops::AsNodeOutList(scope, padded_shapes);
      if (!scope.ok())
          return;
      auto _padding_values = ::tensorflow::ops::AsNodeOut(scope, padding_values);
      if (!scope.ok())
          return;
      auto _drop_remainder = ::tensorflow::ops::AsNodeOut(scope, drop_remainder);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PaddedBatchDatasetV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PaddedBatchDatasetV2")
                                   .Input(_input_dataset)
                                   .Input(_batch_size)
                                   .Input(_padded_shapes)
                                   .Input(_padding_values)
                                   .Input(_drop_remainder)
                                   .Attr("Toutput_types", Toutput_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExtractImagePatches::ExtractImagePatches(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::gtl::ArraySlice<int64_t> ksizes, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::gtl::ArraySlice<int64_t> rates, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExtractImagePatches");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExtractImagePatches")
                                   .Input(_images)
                                   .Attr("ksizes", ksizes)
                                   .Attr("strides", strides)
                                   .Attr("rates", rates)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AllCandidateSampler::AllCandidateSampler(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           int64_t num_true, 
           int64_t num_sampled, 
           bool unique, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AllCandidateSampler");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AllCandidateSampler")
                                   .Input(_true_classes)
                                   .Attr("num_true", num_true)
                                   .Attr("num_sampled", num_sampled)
                                   .Attr("unique", unique)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DepthToSpace::DepthToSpace(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string data_format, 
           int64_t block_size) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DepthToSpace");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DepthToSpace")
                                   .Input(_input)
                                   .Attr("data_format", data_format)
                                   .Attr("block_size", block_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SpaceToDepth::SpaceToDepth(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string data_format, 
           int64_t block_size) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SpaceToDepth");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SpaceToDepth")
                                   .Input(_input)
                                   .Attr("data_format", data_format)
                                   .Attr("block_size", block_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InplaceSub::InplaceSub(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input i, 
           tensorflow::Input v) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _i = ::tensorflow::ops::AsNodeOut(scope, i);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InplaceSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InplaceSub")
                                   .Input(_x)
                                   .Input(_i)
                                   .Input(_v)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefIdentity::RefIdentity(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefIdentity");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefIdentity")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FilterDataset::FilterDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::NameAttrList predicate, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FilterDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FilterDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Attr("predicate", predicate)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DeserializeSparse::DeserializeSparse(tensorflow::Scope& scope, 
           tensorflow::Input serialized_sparse, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _serialized_sparse = ::tensorflow::ops::AsNodeOut(scope, serialized_sparse);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DeserializeSparse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DeserializeSparse")
                                   .Input(_serialized_sparse)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapClear::MapClear(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapClear");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapClear")
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

QuantizedRelu6::QuantizedRelu6(tensorflow::Scope& scope, 
           tensorflow::Input features, 
           tensorflow::Input min_features, 
           tensorflow::Input max_features) {
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      if (!scope.ok())
          return;
      auto _min_features = ::tensorflow::ops::AsNodeOut(scope, min_features);
      if (!scope.ok())
          return;
      auto _max_features = ::tensorflow::ops::AsNodeOut(scope, max_features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedRelu6");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedRelu6")
                                   .Input(_features)
                                   .Input(_min_features)
                                   .Input(_max_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceStridedSliceAssign::ResourceStridedSliceAssign(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input begin, 
           tensorflow::Input end, 
           tensorflow::Input strides, 
           tensorflow::Input value, 
           int64_t new_axis_mask, 
           int64_t shrink_axis_mask, 
           int64_t begin_mask, 
           int64_t end_mask, 
           int64_t ellipsis_mask) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _begin = ::tensorflow::ops::AsNodeOut(scope, begin);
      if (!scope.ok())
          return;
      auto _end = ::tensorflow::ops::AsNodeOut(scope, end);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceStridedSliceAssign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceStridedSliceAssign")
                                   .Input(_ref)
                                   .Input(_begin)
                                   .Input(_end)
                                   .Input(_strides)
                                   .Input(_value)
                                   .Attr("new_axis_mask", new_axis_mask)
                                   .Attr("shrink_axis_mask", shrink_axis_mask)
                                   .Attr("begin_mask", begin_mask)
                                   .Attr("end_mask", end_mask)
                                   .Attr("ellipsis_mask", ellipsis_mask)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Squeeze::Squeeze(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> squeeze_dims) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Squeeze");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Squeeze")
                                   .Input(_input)
                                   .Attr("squeeze_dims", squeeze_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InplaceUpdate::InplaceUpdate(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input i, 
           tensorflow::Input v) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _i = ::tensorflow::ops::AsNodeOut(scope, i);
      if (!scope.ok())
          return;
      auto _v = ::tensorflow::ops::AsNodeOut(scope, v);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InplaceUpdate");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InplaceUpdate")
                                   .Input(_x)
                                   .Input(_i)
                                   .Input(_v)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InitializeTableV2::InitializeTableV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InitializeTableV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InitializeTableV2")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

NextIteration::NextIteration(tensorflow::Scope& scope, 
           tensorflow::Input data) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("NextIteration");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "NextIteration")
                                   .Input(_data)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Copy::Copy(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string tensor_name, 
           tensorflow::gtl::ArraySlice<tensorflow::string> debug_ops_spec) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Copy");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Copy")
                                   .Input(_input)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("debug_ops_spec", debug_ops_spec)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StringLength::StringLength(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string unit) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StringLength");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StringLength")
                                   .Input(_input)
                                   .Attr("unit", unit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ScatterDiv::ScatterDiv(tensorflow::Scope& scope, 
           tensorflow::Input ref, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _ref = ::tensorflow::ops::AsNodeOut(scope, ref);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ScatterDiv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ScatterDiv")
                                   .Input(_ref)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorSummary::TensorSummary(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::string description, 
           tensorflow::gtl::ArraySlice<tensorflow::string> labels, 
           tensorflow::string display_name) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorSummary")
                                   .Input(_tensor)
                                   .Attr("description", description)
                                   .Attr("labels", labels)
                                   .Attr("display_name", display_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseApplyProximalGradientDescent::SparseApplyProximalGradientDescent(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input alpha, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input grad, 
           tensorflow::Input indices, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseApplyProximalGradientDescent");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseApplyProximalGradientDescent")
                                   .Input(_var)
                                   .Input(_alpha)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_grad)
                                   .Input(_indices)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Tile::Tile(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input multiples) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _multiples = ::tensorflow::ops::AsNodeOut(scope, multiples);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Tile");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Tile")
                                   .Input(_input)
                                   .Input(_multiples)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_HostSend::_HostSend(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::string tensor_name, 
           tensorflow::string send_device, 
           tensorflow::string recv_device, 
           bool client_terminated, 
           int64_t send_device_incarnation) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_HostSend");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_HostSend")
                                   .Input(_tensor)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("send_device", send_device)
                                   .Attr("recv_device", recv_device)
                                   .Attr("client_terminated", client_terminated)
                                   .Attr("send_device_incarnation", send_device_incarnation)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ExpandDims::ExpandDims(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input dim) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _dim = ::tensorflow::ops::AsNodeOut(scope, dim);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExpandDims");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExpandDims")
                                   .Input(_input)
                                   .Input(_dim)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SpaceToBatch::SpaceToBatch(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input paddings, 
           int64_t block_size) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SpaceToBatch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SpaceToBatch")
                                   .Input(_input)
                                   .Input(_paddings)
                                   .Attr("block_size", block_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MaxPoolWithArgmax::MaxPoolWithArgmax(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::DataType Targmax) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MaxPoolWithArgmax");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MaxPoolWithArgmax")
                                   .Input(_input)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("Targmax", Targmax)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RefEnter::RefEnter(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::string frame_name, 
           int64_t parallel_iterations, 
           bool is_constant) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RefEnter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RefEnter")
                                   .Input(_data)
                                   .Attr("frame_name", frame_name)
                                   .Attr("parallel_iterations", parallel_iterations)
                                   .Attr("is_constant", is_constant)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PriorityQueueV2::PriorityQueueV2(tensorflow::Scope& scope, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> component_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PriorityQueueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PriorityQueueV2")
                                   .Attr("component_types", component_types)
                                   .Attr("shapes", shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

IsBoostedTreesEnsembleInitialized::IsBoostedTreesEnsembleInitialized(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("IsBoostedTreesEnsembleInitialized");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "IsBoostedTreesEnsembleInitialized")
                                   .Input(_tree_ensemble_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RepeatDataset::RepeatDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input count, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _count = ::tensorflow::ops::AsNodeOut(scope, count);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RepeatDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RepeatDataset")
                                   .Input(_input_dataset)
                                   .Input(_count)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesCreateEnsemble::BoostedTreesCreateEnsemble(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input stamp_token, 
           tensorflow::Input tree_ensemble_serialized) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _stamp_token = ::tensorflow::ops::AsNodeOut(scope, stamp_token);
      if (!scope.ok())
          return;
      auto _tree_ensemble_serialized = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_serialized);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesCreateEnsemble");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesCreateEnsemble")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_stamp_token)
                                   .Input(_tree_ensemble_serialized)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Fill::Fill(tensorflow::Scope& scope, 
           tensorflow::Input dims, 
           tensorflow::Input value) {
      if (!scope.ok())
          return;
      auto _dims = ::tensorflow::ops::AsNodeOut(scope, dims);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Fill");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Fill")
                                   .Input(_dims)
                                   .Input(_value)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyCenteredRMSProp::ApplyCenteredRMSProp(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input mg, 
           tensorflow::Input ms, 
           tensorflow::Input mom, 
           tensorflow::Input lr, 
           tensorflow::Input rho, 
           tensorflow::Input momentum, 
           tensorflow::Input epsilon, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _mg = ::tensorflow::ops::AsNodeOut(scope, mg);
      if (!scope.ok())
          return;
      auto _ms = ::tensorflow::ops::AsNodeOut(scope, ms);
      if (!scope.ok())
          return;
      auto _mom = ::tensorflow::ops::AsNodeOut(scope, mom);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _rho = ::tensorflow::ops::AsNodeOut(scope, rho);
      if (!scope.ok())
          return;
      auto _momentum = ::tensorflow::ops::AsNodeOut(scope, momentum);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyCenteredRMSProp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyCenteredRMSProp")
                                   .Input(_var)
                                   .Input(_mg)
                                   .Input(_ms)
                                   .Input(_mom)
                                   .Input(_lr)
                                   .Input(_rho)
                                   .Input(_momentum)
                                   .Input(_epsilon)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Const::Const(tensorflow::Scope& scope, 
           tensorflow::Tensor value, 
           tensorflow::DataType dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Const");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Const")
                                   .Attr("value", value)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PlaceholderWithDefault::PlaceholderWithDefault(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PlaceholderWithDefault");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PlaceholderWithDefault")
                                   .Input(_input)
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Placeholder::Placeholder(tensorflow::Scope& scope, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Placeholder");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Placeholder")
                                   .Attr("dtype", dtype)
                                   .Attr("shape", shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueEnqueueManyV2::QueueEnqueueManyV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcomponents, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueEnqueueManyV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueEnqueueManyV2")
                                   .Input(_handle)
                                   .Input(_components)
                                   .Attr("Tcomponents", Tcomponents)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Shape::Shape(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Shape");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Shape")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Dilation2DBackpropFilter::Dilation2DBackpropFilter(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::gtl::ArraySlice<int64_t> rates, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Dilation2DBackpropFilter");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Dilation2DBackpropFilter")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("rates", rates)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchIFFT3D::BatchIFFT3D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchIFFT3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchIFFT3D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AvgPool3D::AvgPool3D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AvgPool3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AvgPool3D")
                                   .Input(_input)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DataFormatDimMap::DataFormatDimMap(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::string dst_format, 
           tensorflow::string src_format) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DataFormatDimMap");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DataFormatDimMap")
                                   .Input(_x)
                                   .Attr("dst_format", dst_format)
                                   .Attr("src_format", src_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StackClose::StackClose(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StackClose");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StackClose")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

QueueSizeV2::QueueSizeV2(tensorflow::Scope& scope, 
           tensorflow::Input handle) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueSizeV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueSizeV2")
                                   .Input(_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessWhile::StatelessWhile(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> T, 
           tensorflow::NameAttrList cond, 
           tensorflow::NameAttrList body) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessWhile");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessWhile")
                                   .Input(_input)
                                   .Attr("T", T)
                                   .Attr("cond", cond)
                                   .Attr("body", body)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixDiagPart::MatrixDiagPart(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixDiagPart");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixDiagPart")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeProtoV2::DecodeProtoV2(tensorflow::Scope& scope, 
           tensorflow::Input bytes, 
           tensorflow::string message_type, 
           tensorflow::gtl::ArraySlice<tensorflow::string> field_names, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::string descriptor_source, 
           tensorflow::string message_format, 
           bool sanitize) {
      if (!scope.ok())
          return;
      auto _bytes = ::tensorflow::ops::AsNodeOut(scope, bytes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeProtoV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeProtoV2")
                                   .Input(_bytes)
                                   .Attr("message_type", message_type)
                                   .Attr("field_names", field_names)
                                   .Attr("output_types", output_types)
                                   .Attr("descriptor_source", descriptor_source)
                                   .Attr("message_format", message_format)
                                   .Attr("sanitize", sanitize)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Print::Print(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input data, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> U, 
           tensorflow::string message, 
           int64_t summarize, 
           int64_t first_n) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Print");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Print")
                                   .Input(_input)
                                   .Input(_data)
                                   .Attr("U", U)
                                   .Attr("message", message)
                                   .Attr("summarize", summarize)
                                   .Attr("first_n", first_n)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizeAndDequantizeV2::QuantizeAndDequantizeV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_min, 
           tensorflow::Input input_max, 
           bool signed_input, 
           int64_t num_bits, 
           bool range_given, 
           tensorflow::string round_mode) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_min = ::tensorflow::ops::AsNodeOut(scope, input_min);
      if (!scope.ok())
          return;
      auto _input_max = ::tensorflow::ops::AsNodeOut(scope, input_max);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizeAndDequantizeV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizeAndDequantizeV2")
                                   .Input(_input)
                                   .Input(_input_min)
                                   .Input(_input_max)
                                   .Attr("signed_input", signed_input)
                                   .Attr("num_bits", num_bits)
                                   .Attr("range_given", range_given)
                                   .Attr("round_mode", round_mode)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FractionalAvgPool::FractionalAvgPool(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::gtl::ArraySlice<float> pooling_ratio, 
           bool pseudo_random, 
           bool overlapping, 
           bool deterministic, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FractionalAvgPool");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FractionalAvgPool")
                                   .Input(_value)
                                   .Attr("pooling_ratio", pooling_ratio)
                                   .Attr("pseudo_random", pseudo_random)
                                   .Attr("overlapping", overlapping)
                                   .Attr("deterministic", deterministic)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseAccumulatorTakeGradient::SparseAccumulatorTakeGradient(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input num_required, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _num_required = ::tensorflow::ops::AsNodeOut(scope, num_required);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseAccumulatorTakeGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseAccumulatorTakeGradient")
                                   .Input(_handle)
                                   .Input(_num_required)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TruncateMod::TruncateMod(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TruncateMod");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TruncateMod")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyFtrl::ResourceApplyFtrl(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input accum, 
           tensorflow::Input linear, 
           tensorflow::Input grad, 
           tensorflow::Input lr, 
           tensorflow::Input l1, 
           tensorflow::Input l2, 
           tensorflow::Input lr_power, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _accum = ::tensorflow::ops::AsNodeOut(scope, accum);
      if (!scope.ok())
          return;
      auto _linear = ::tensorflow::ops::AsNodeOut(scope, linear);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _l1 = ::tensorflow::ops::AsNodeOut(scope, l1);
      if (!scope.ok())
          return;
      auto _l2 = ::tensorflow::ops::AsNodeOut(scope, l2);
      if (!scope.ok())
          return;
      auto _lr_power = ::tensorflow::ops::AsNodeOut(scope, lr_power);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyFtrl");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyFtrl")
                                   .Input(_var)
                                   .Input(_accum)
                                   .Input(_linear)
                                   .Input(_grad)
                                   .Input(_lr)
                                   .Input(_l1)
                                   .Input(_l2)
                                   .Input(_lr_power)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

StridedSliceGrad::StridedSliceGrad(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input begin, 
           tensorflow::Input end, 
           tensorflow::Input strides, 
           tensorflow::Input dy, 
           int64_t new_axis_mask, 
           int64_t shrink_axis_mask, 
           int64_t begin_mask, 
           int64_t end_mask, 
           int64_t ellipsis_mask) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _begin = ::tensorflow::ops::AsNodeOut(scope, begin);
      if (!scope.ok())
          return;
      auto _end = ::tensorflow::ops::AsNodeOut(scope, end);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      if (!scope.ok())
          return;
      auto _dy = ::tensorflow::ops::AsNodeOut(scope, dy);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StridedSliceGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StridedSliceGrad")
                                   .Input(_shape)
                                   .Input(_begin)
                                   .Input(_end)
                                   .Input(_strides)
                                   .Input(_dy)
                                   .Attr("new_axis_mask", new_axis_mask)
                                   .Attr("shrink_axis_mask", shrink_axis_mask)
                                   .Attr("begin_mask", begin_mask)
                                   .Attr("end_mask", end_mask)
                                   .Attr("ellipsis_mask", ellipsis_mask)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizeAndDequantize::QuantizeAndDequantize(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           bool signed_input, 
           int64_t num_bits, 
           bool range_given, 
           float input_min, 
           float input_max) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizeAndDequantize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizeAndDequantize")
                                   .Input(_input)
                                   .Attr("signed_input", signed_input)
                                   .Attr("num_bits", num_bits)
                                   .Attr("range_given", range_given)
                                   .Attr("input_min", input_min)
                                   .Attr("input_max", input_max)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesUpdateEnsemble::BoostedTreesUpdateEnsemble(tensorflow::Scope& scope, 
           tensorflow::Input tree_ensemble_handle, 
           tensorflow::Input feature_ids, 
           tensorflow::Input node_ids, 
           tensorflow::Input gains, 
           tensorflow::Input thresholds, 
           tensorflow::Input left_node_contribs, 
           tensorflow::Input right_node_contribs, 
           tensorflow::Input max_depth, 
           tensorflow::Input learning_rate, 
           int64_t pruning_mode, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _tree_ensemble_handle = ::tensorflow::ops::AsNodeOut(scope, tree_ensemble_handle);
      if (!scope.ok())
          return;
      auto _feature_ids = ::tensorflow::ops::AsNodeOut(scope, feature_ids);
      if (!scope.ok())
          return;
      auto _node_ids = ::tensorflow::ops::AsNodeOut(scope, node_ids);
      if (!scope.ok())
          return;
      auto _gains = ::tensorflow::ops::AsNodeOut(scope, gains);
      if (!scope.ok())
          return;
      auto _thresholds = ::tensorflow::ops::AsNodeOut(scope, thresholds);
      if (!scope.ok())
          return;
      auto _left_node_contribs = ::tensorflow::ops::AsNodeOut(scope, left_node_contribs);
      if (!scope.ok())
          return;
      auto _right_node_contribs = ::tensorflow::ops::AsNodeOut(scope, right_node_contribs);
      if (!scope.ok())
          return;
      auto _max_depth = ::tensorflow::ops::AsNodeOut(scope, max_depth);
      if (!scope.ok())
          return;
      auto _learning_rate = ::tensorflow::ops::AsNodeOut(scope, learning_rate);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesUpdateEnsemble");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesUpdateEnsemble")
                                   .Input(_tree_ensemble_handle)
                                   .Input(_feature_ids)
                                   .Input(_node_ids)
                                   .Input(_gains)
                                   .Input(_thresholds)
                                   .Input(_left_node_contribs)
                                   .Input(_right_node_contribs)
                                   .Input(_max_depth)
                                   .Input(_learning_rate)
                                   .Attr("pruning_mode", pruning_mode)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Relu6Grad::Relu6Grad(tensorflow::Scope& scope, 
           tensorflow::Input gradients, 
           tensorflow::Input features) {
      if (!scope.ok())
          return;
      auto _gradients = ::tensorflow::ops::AsNodeOut(scope, gradients);
      if (!scope.ok())
          return;
      auto _features = ::tensorflow::ops::AsNodeOut(scope, features);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Relu6Grad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Relu6Grad")
                                   .Input(_gradients)
                                   .Input(_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Range::Range(tensorflow::Scope& scope, 
           tensorflow::Input start, 
           tensorflow::Input limit, 
           tensorflow::Input delta) {
      if (!scope.ok())
          return;
      auto _start = ::tensorflow::ops::AsNodeOut(scope, start);
      if (!scope.ok())
          return;
      auto _limit = ::tensorflow::ops::AsNodeOut(scope, limit);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Range");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Range")
                                   .Input(_start)
                                   .Input(_limit)
                                   .Input(_delta)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PrefetchDataset::PrefetchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input buffer_size, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PrefetchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PrefetchDataset")
                                   .Input(_input_dataset)
                                   .Input(_buffer_size)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DeepCopy::DeepCopy(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DeepCopy");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DeepCopy")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalLatencyStatsDataset::ExperimentalLatencyStatsDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input tag, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalLatencyStatsDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalLatencyStatsDataset")
                                   .Input(_input_dataset)
                                   .Input(_tag)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MultiDeviceIteratorGetNextFromShard::MultiDeviceIteratorGetNextFromShard(tensorflow::Scope& scope, 
           tensorflow::Input multi_device_iterator, 
           tensorflow::Input shard_num, 
           tensorflow::Input incarnation_id, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _multi_device_iterator = ::tensorflow::ops::AsNodeOut(scope, multi_device_iterator);
      if (!scope.ok())
          return;
      auto _shard_num = ::tensorflow::ops::AsNodeOut(scope, shard_num);
      if (!scope.ok())
          return;
      auto _incarnation_id = ::tensorflow::ops::AsNodeOut(scope, incarnation_id);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MultiDeviceIteratorGetNextFromShard");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MultiDeviceIteratorGetNextFromShard")
                                   .Input(_multi_device_iterator)
                                   .Input(_shard_num)
                                   .Input(_incarnation_id)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchCholesky::BatchCholesky(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchCholesky");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchCholesky")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArrayGather::TensorArrayGather(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input indices, 
           tensorflow::Input flow_in, 
           tensorflow::DataType dtype, 
           tensorflow::PartialTensorShape element_shape) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArrayGather");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArrayGather")
                                   .Input(_handle)
                                   .Input(_indices)
                                   .Input(_flow_in)
                                   .Attr("dtype", dtype)
                                   .Attr("element_shape", element_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Round::Round(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Round");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Round")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ZipDataset::ZipDataset(tensorflow::Scope& scope, 
           tensorflow::InputList input_datasets, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_datasets = ::tensorflow::ops::AsNodeOutList(scope, input_datasets);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ZipDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ZipDataset")
                                   .Input(_input_datasets)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueClose::QueueClose(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           bool cancel_pending_enqueues) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueClose");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueClose")
                                   .Input(_handle)
                                   .Attr("cancel_pending_enqueues", cancel_pending_enqueues)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SparseTensorDenseAdd::SparseTensorDenseAdd(tensorflow::Scope& scope, 
           tensorflow::Input a_indices, 
           tensorflow::Input a_values, 
           tensorflow::Input a_shape, 
           tensorflow::Input b) {
      if (!scope.ok())
          return;
      auto _a_indices = ::tensorflow::ops::AsNodeOut(scope, a_indices);
      if (!scope.ok())
          return;
      auto _a_values = ::tensorflow::ops::AsNodeOut(scope, a_values);
      if (!scope.ok())
          return;
      auto _a_shape = ::tensorflow::ops::AsNodeOut(scope, a_shape);
      if (!scope.ok())
          return;
      auto _b = ::tensorflow::ops::AsNodeOut(scope, b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseTensorDenseAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseTensorDenseAdd")
                                   .Input(_a_indices)
                                   .Input(_a_values)
                                   .Input(_a_shape)
                                   .Input(_b)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Snapshot::Snapshot(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Snapshot");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Snapshot")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UniqueV2::UniqueV2(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input axis, 
           tensorflow::DataType out_idx) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _axis = ::tensorflow::ops::AsNodeOut(scope, axis);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UniqueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UniqueV2")
                                   .Input(_x)
                                   .Input(_axis)
                                   .Attr("out_idx", out_idx)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CudnnRNNBackpropV2::CudnnRNNBackpropV2(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input input_h, 
           tensorflow::Input input_c, 
           tensorflow::Input params, 
           tensorflow::Input output, 
           tensorflow::Input output_h, 
           tensorflow::Input output_c, 
           tensorflow::Input output_backprop, 
           tensorflow::Input output_h_backprop, 
           tensorflow::Input output_c_backprop, 
           tensorflow::Input reserve_space, 
           tensorflow::Input host_reserved, 
           int64_t seed2, 
           tensorflow::string rnn_mode, 
           tensorflow::string input_mode, 
           tensorflow::string direction, 
           float dropout, 
           int64_t seed) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _input_h = ::tensorflow::ops::AsNodeOut(scope, input_h);
      if (!scope.ok())
          return;
      auto _input_c = ::tensorflow::ops::AsNodeOut(scope, input_c);
      if (!scope.ok())
          return;
      auto _params = ::tensorflow::ops::AsNodeOut(scope, params);
      if (!scope.ok())
          return;
      auto _output = ::tensorflow::ops::AsNodeOut(scope, output);
      if (!scope.ok())
          return;
      auto _output_h = ::tensorflow::ops::AsNodeOut(scope, output_h);
      if (!scope.ok())
          return;
      auto _output_c = ::tensorflow::ops::AsNodeOut(scope, output_c);
      if (!scope.ok())
          return;
      auto _output_backprop = ::tensorflow::ops::AsNodeOut(scope, output_backprop);
      if (!scope.ok())
          return;
      auto _output_h_backprop = ::tensorflow::ops::AsNodeOut(scope, output_h_backprop);
      if (!scope.ok())
          return;
      auto _output_c_backprop = ::tensorflow::ops::AsNodeOut(scope, output_c_backprop);
      if (!scope.ok())
          return;
      auto _reserve_space = ::tensorflow::ops::AsNodeOut(scope, reserve_space);
      if (!scope.ok())
          return;
      auto _host_reserved = ::tensorflow::ops::AsNodeOut(scope, host_reserved);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CudnnRNNBackpropV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CudnnRNNBackpropV2")
                                   .Input(_input)
                                   .Input(_input_h)
                                   .Input(_input_c)
                                   .Input(_params)
                                   .Input(_output)
                                   .Input(_output_h)
                                   .Input(_output_c)
                                   .Input(_output_backprop)
                                   .Input(_output_h_backprop)
                                   .Input(_output_c_backprop)
                                   .Input(_reserve_space)
                                   .Input(_host_reserved)
                                   .Attr("seed2", seed2)
                                   .Attr("rnn_mode", rnn_mode)
                                   .Attr("input_mode", input_mode)
                                   .Attr("direction", direction)
                                   .Attr("dropout", dropout)
                                   .Attr("seed", seed)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

InvertPermutation::InvertPermutation(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("InvertPermutation");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "InvertPermutation")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ReaderReset::ReaderReset(tensorflow::Scope& scope, 
           tensorflow::Input reader_handle) {
      if (!scope.ok())
          return;
      auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ReaderReset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ReaderReset")
                                   .Input(_reader_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

StopGradient::StopGradient(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StopGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StopGradient")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceScatterSub::ResourceScatterSub(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterSub")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

TensorForestTreeSize::TensorForestTreeSize(tensorflow::Scope& scope, 
           tensorflow::Input tree_handle) {
      if (!scope.ok())
          return;
      auto _tree_handle = ::tensorflow::ops::AsNodeOut(scope, tree_handle);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorForestTreeSize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorForestTreeSize")
                                   .Input(_tree_handle)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Rint::Rint(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Rint");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Rint")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Abort::Abort(tensorflow::Scope& scope, 
           tensorflow::string error_msg, 
           bool exit_without_error) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Abort");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Abort")
                                   .Attr("error_msg", error_msg)
                                   .Attr("exit_without_error", exit_without_error)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

MutableHashTableOfTensorsV2::MutableHashTableOfTensorsV2(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           bool use_node_name_sharing, 
           tensorflow::DataType key_dtype, 
           tensorflow::DataType value_dtype, 
           tensorflow::PartialTensorShape value_shape) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MutableHashTableOfTensorsV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MutableHashTableOfTensorsV2")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("use_node_name_sharing", use_node_name_sharing)
                                   .Attr("key_dtype", key_dtype)
                                   .Attr("value_dtype", value_dtype)
                                   .Attr("value_shape", value_shape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListConcatLists::TensorListConcatLists(tensorflow::Scope& scope, 
           tensorflow::Input input_a, 
           tensorflow::Input input_b, 
           tensorflow::DataType element_dtype) {
      if (!scope.ok())
          return;
      auto _input_a = ::tensorflow::ops::AsNodeOut(scope, input_a);
      if (!scope.ok())
          return;
      auto _input_b = ::tensorflow::ops::AsNodeOut(scope, input_b);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListConcatLists");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListConcatLists")
                                   .Input(_input_a)
                                   .Input(_input_b)
                                   .Attr("element_dtype", element_dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OneHot::OneHot(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::Input depth, 
           tensorflow::Input on_value, 
           tensorflow::Input off_value, 
           int64_t axis) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _depth = ::tensorflow::ops::AsNodeOut(scope, depth);
      if (!scope.ok())
          return;
      auto _on_value = ::tensorflow::ops::AsNodeOut(scope, on_value);
      if (!scope.ok())
          return;
      auto _off_value = ::tensorflow::ops::AsNodeOut(scope, off_value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OneHot");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OneHot")
                                   .Input(_indices)
                                   .Input(_depth)
                                   .Input(_on_value)
                                   .Input(_off_value)
                                   .Attr("axis", axis)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Reverse::Reverse(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input dims) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _dims = ::tensorflow::ops::AsNodeOut(scope, dims);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Reverse");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Reverse")
                                   .Input(_tensor)
                                   .Input(_dims)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesCreateQuantileStreamResource::BoostedTreesCreateQuantileStreamResource(tensorflow::Scope& scope, 
           tensorflow::Input quantile_stream_resource_handle, 
           tensorflow::Input epsilon, 
           tensorflow::Input num_streams, 
           int64_t max_elements) {
      if (!scope.ok())
          return;
      auto _quantile_stream_resource_handle = ::tensorflow::ops::AsNodeOut(scope, quantile_stream_resource_handle);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      if (!scope.ok())
          return;
      auto _num_streams = ::tensorflow::ops::AsNodeOut(scope, num_streams);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesCreateQuantileStreamResource");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesCreateQuantileStreamResource")
                                   .Input(_quantile_stream_resource_handle)
                                   .Input(_epsilon)
                                   .Input(_num_streams)
                                   .Attr("max_elements", max_elements)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

ParseSingleExample::ParseSingleExample(tensorflow::Scope& scope, 
           tensorflow::Input serialized, 
           tensorflow::Input dense_defaults, 
           tensorflow::gtl::ArraySlice<tensorflow::string> sparse_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::string> dense_keys, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> sparse_types, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tdense, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> dense_shapes, 
           int64_t num_sparse) {
      if (!scope.ok())
          return;
      auto _serialized = ::tensorflow::ops::AsNodeOut(scope, serialized);
      if (!scope.ok())
          return;
      auto _dense_defaults = ::tensorflow::ops::AsNodeOut(scope, dense_defaults);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ParseSingleExample");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ParseSingleExample")
                                   .Input(_serialized)
                                   .Input(_dense_defaults)
                                   .Attr("sparse_keys", sparse_keys)
                                   .Attr("dense_keys", dense_keys)
                                   .Attr("sparse_types", sparse_types)
                                   .Attr("Tdense", Tdense)
                                   .Attr("dense_shapes", dense_shapes)
                                   .Attr("num_sparse", num_sparse)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

GuaranteeConst::GuaranteeConst(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("GuaranteeConst");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "GuaranteeConst")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QueueEnqueueV2::QueueEnqueueV2(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input components, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Tcomponents, 
           int64_t timeout_ms) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _components = ::tensorflow::ops::AsNodeOut(scope, components);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QueueEnqueueV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QueueEnqueueV2")
                                   .Input(_handle)
                                   .Input(_components)
                                   .Attr("Tcomponents", Tcomponents)
                                   .Attr("timeout_ms", timeout_ms)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

_ScopedAllocatorConcat::_ScopedAllocatorConcat(tensorflow::Scope& scope, 
           tensorflow::Input backing, 
           tensorflow::InputList inputs, 
           tensorflow::string sa_name, 
           tensorflow::PartialTensorShape shape, 
           int64_t id, 
           bool reshape) {
      if (!scope.ok())
          return;
      auto _backing = ::tensorflow::ops::AsNodeOut(scope, backing);
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOutList(scope, inputs);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_ScopedAllocatorConcat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_ScopedAllocatorConcat")
                                   .Input(_backing)
                                   .Input(_inputs)
                                   .Attr("sa_name", sa_name)
                                   .Attr("shape", shape)
                                   .Attr("id", id)
                                   .Attr("reshape", reshape)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesQuantileStreamResourceHandleOp::BoostedTreesQuantileStreamResourceHandleOp(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesQuantileStreamResourceHandleOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesQuantileStreamResourceHandleOp")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StatelessTruncatedNormal::StatelessTruncatedNormal(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::Input seed, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      if (!scope.ok())
          return;
      auto _seed = ::tensorflow::ops::AsNodeOut(scope, seed);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StatelessTruncatedNormal");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StatelessTruncatedNormal")
                                   .Input(_shape)
                                   .Input(_seed)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixDiag::MatrixDiag(tensorflow::Scope& scope, 
           tensorflow::Input diagonal) {
      if (!scope.ok())
          return;
      auto _diagonal = ::tensorflow::ops::AsNodeOut(scope, diagonal);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixDiag");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixDiag")
                                   .Input(_diagonal)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorScatterSub::TensorScatterSub(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input indices, 
           tensorflow::Input updates) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorScatterSub");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorScatterSub")
                                   .Input(_tensor)
                                   .Input(_indices)
                                   .Input(_updates)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FloorDiv::FloorDiv(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FloorDiv");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FloorDiv")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

StridedSlice::StridedSlice(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input begin, 
           tensorflow::Input end, 
           tensorflow::Input strides, 
           int64_t shrink_axis_mask, 
           int64_t new_axis_mask, 
           int64_t begin_mask, 
           int64_t end_mask, 
           int64_t ellipsis_mask) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _begin = ::tensorflow::ops::AsNodeOut(scope, begin);
      if (!scope.ok())
          return;
      auto _end = ::tensorflow::ops::AsNodeOut(scope, end);
      if (!scope.ok())
          return;
      auto _strides = ::tensorflow::ops::AsNodeOut(scope, strides);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("StridedSlice");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "StridedSlice")
                                   .Input(_input)
                                   .Input(_begin)
                                   .Input(_end)
                                   .Input(_strides)
                                   .Attr("shrink_axis_mask", shrink_axis_mask)
                                   .Attr("new_axis_mask", new_axis_mask)
                                   .Attr("begin_mask", begin_mask)
                                   .Attr("end_mask", end_mask)
                                   .Attr("ellipsis_mask", ellipsis_mask)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

PreventGradient::PreventGradient(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string message) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("PreventGradient");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "PreventGradient")
                                   .Input(_input)
                                   .Attr("message", message)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SparseDenseCwiseMul::SparseDenseCwiseMul(tensorflow::Scope& scope, 
           tensorflow::Input sp_indices, 
           tensorflow::Input sp_values, 
           tensorflow::Input sp_shape, 
           tensorflow::Input dense) {
      if (!scope.ok())
          return;
      auto _sp_indices = ::tensorflow::ops::AsNodeOut(scope, sp_indices);
      if (!scope.ok())
          return;
      auto _sp_values = ::tensorflow::ops::AsNodeOut(scope, sp_values);
      if (!scope.ok())
          return;
      auto _sp_shape = ::tensorflow::ops::AsNodeOut(scope, sp_shape);
      if (!scope.ok())
          return;
      auto _dense = ::tensorflow::ops::AsNodeOut(scope, dense);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SparseDenseCwiseMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SparseDenseCwiseMul")
                                   .Input(_sp_indices)
                                   .Input(_sp_values)
                                   .Input(_sp_shape)
                                   .Input(_dense)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FusedPadConv2D::FusedPadConv2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input paddings, 
           tensorflow::Input filter, 
           tensorflow::string mode, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FusedPadConv2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FusedPadConv2D")
                                   .Input(_input)
                                   .Input(_paddings)
                                   .Input(_filter)
                                   .Attr("mode", mode)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LookupTableInsertV2::LookupTableInsertV2(tensorflow::Scope& scope, 
           tensorflow::Input table_handle, 
           tensorflow::Input keys, 
           tensorflow::Input values) {
      if (!scope.ok())
          return;
      auto _table_handle = ::tensorflow::ops::AsNodeOut(scope, table_handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LookupTableInsertV2");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LookupTableInsertV2")
                                   .Input(_table_handle)
                                   .Input(_keys)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

BarrierInsertMany::BarrierInsertMany(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input keys, 
           tensorflow::Input values, 
           int64_t component_index) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _keys = ::tensorflow::ops::AsNodeOut(scope, keys);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOut(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BarrierInsertMany");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BarrierInsertMany")
                                   .Input(_handle)
                                   .Input(_keys)
                                   .Input(_values)
                                   .Attr("component_index", component_index)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

SplitV::SplitV(tensorflow::Scope& scope, 
           tensorflow::Input value, 
           tensorflow::Input size_splits, 
           tensorflow::Input split_dim, 
           int64_t num_split) {
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _size_splits = ::tensorflow::ops::AsNodeOut(scope, size_splits);
      if (!scope.ok())
          return;
      auto _split_dim = ::tensorflow::ops::AsNodeOut(scope, split_dim);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SplitV");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SplitV")
                                   .Input(_value)
                                   .Input(_size_splits)
                                   .Input(_split_dim)
                                   .Attr("num_split", num_split)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchMatrixDiag::BatchMatrixDiag(tensorflow::Scope& scope, 
           tensorflow::Input diagonal) {
      if (!scope.ok())
          return;
      auto _diagonal = ::tensorflow::ops::AsNodeOut(scope, diagonal);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchMatrixDiag");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchMatrixDiag")
                                   .Input(_diagonal)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Bucketize::Bucketize(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::gtl::ArraySlice<float> boundaries) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Bucketize");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Bucketize")
                                   .Input(_input)
                                   .Attr("boundaries", boundaries)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DrawBoundingBoxes::DrawBoundingBoxes(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input boxes) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _boxes = ::tensorflow::ops::AsNodeOut(scope, boxes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DrawBoundingBoxes");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DrawBoundingBoxes")
                                   .Input(_images)
                                   .Input(_boxes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ZerosLike::ZerosLike(tensorflow::Scope& scope, 
           tensorflow::Input x) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ZerosLike");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ZerosLike")
                                   .Input(_x)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ImageSummary::ImageSummary(tensorflow::Scope& scope, 
           tensorflow::Input tag, 
           tensorflow::Input tensor, 
           int64_t max_images, 
           tensorflow::Tensor bad_color) {
      if (!scope.ok())
          return;
      auto _tag = ::tensorflow::ops::AsNodeOut(scope, tag);
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ImageSummary");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ImageSummary")
                                   .Input(_tag)
                                   .Input(_tensor)
                                   .Attr("max_images", max_images)
                                   .Attr("bad_color", bad_color)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ShapeN::ShapeN(tensorflow::Scope& scope, 
           tensorflow::InputList input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOutList(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ShapeN");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ShapeN")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      for (tensorflow::int32 i = 0; i < ret->num_outputs(); ++i)
          this->output.push_back(tensorflow::Output(ret, i));
}

HostConst::HostConst(tensorflow::Scope& scope, 
           tensorflow::Tensor value, 
           tensorflow::DataType dtype) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("HostConst");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "HostConst")
                                   .Attr("value", value)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Empty::Empty(tensorflow::Scope& scope, 
           tensorflow::Input shape, 
           tensorflow::DataType dtype, 
           bool init) {
      if (!scope.ok())
          return;
      auto _shape = ::tensorflow::ops::AsNodeOut(scope, shape);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Empty");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Empty")
                                   .Input(_shape)
                                   .Attr("dtype", dtype)
                                   .Attr("init", init)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Split::Split(tensorflow::Scope& scope, 
           tensorflow::Input split_dim, 
           tensorflow::Input value, 
           int64_t num_split) {
      if (!scope.ok())
          return;
      auto _split_dim = ::tensorflow::ops::AsNodeOut(scope, split_dim);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Split");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Split")
                                   .Input(_split_dim)
                                   .Input(_value)
                                   .Attr("num_split", num_split)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Conv3DBackpropInput::Conv3DBackpropInput(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::Input out_backprop, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Conv3DBackpropInput");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Conv3DBackpropInput")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Input(_out_backprop)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DepthwiseConv2dNative::DepthwiseConv2dNative(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<int64_t> dilations, 
           tensorflow::string data_format) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DepthwiseConv2dNative");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DepthwiseConv2dNative")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("dilations", dilations)
                                   .Attr("data_format", data_format)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LearnedUnigramCandidateSampler::LearnedUnigramCandidateSampler(tensorflow::Scope& scope, 
           tensorflow::Input true_classes, 
           int64_t num_true, 
           int64_t num_sampled, 
           bool unique, 
           int64_t range_max, 
           int64_t seed, 
           int64_t seed2) {
      if (!scope.ok())
          return;
      auto _true_classes = ::tensorflow::ops::AsNodeOut(scope, true_classes);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LearnedUnigramCandidateSampler");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LearnedUnigramCandidateSampler")
                                   .Input(_true_classes)
                                   .Attr("num_true", num_true)
                                   .Attr("num_sampled", num_sampled)
                                   .Attr("unique", unique)
                                   .Attr("range_max", range_max)
                                   .Attr("seed", seed)
                                   .Attr("seed2", seed2)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DebugNanCount::DebugNanCount(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string device_name, 
           tensorflow::string tensor_name, 
           tensorflow::gtl::ArraySlice<tensorflow::string> debug_urls, 
           bool gated_grpc) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DebugNanCount");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DebugNanCount")
                                   .Input(_input)
                                   .Attr("device_name", device_name)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("debug_urls", debug_urls)
                                   .Attr("gated_grpc", gated_grpc)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnicodeScript::UnicodeScript(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnicodeScript");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnicodeScript")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OptionalGetValue::OptionalGetValue(tensorflow::Scope& scope, 
           tensorflow::Input optional, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _optional = ::tensorflow::ops::AsNodeOut(scope, optional);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OptionalGetValue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OptionalGetValue")
                                   .Input(_optional)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorListGetItem::TensorListGetItem(tensorflow::Scope& scope, 
           tensorflow::Input input_handle, 
           tensorflow::Input index) {
      if (!scope.ok())
          return;
      auto _input_handle = ::tensorflow::ops::AsNodeOut(scope, input_handle);
      if (!scope.ok())
          return;
      auto _index = ::tensorflow::ops::AsNodeOut(scope, index);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorListGetItem");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorListGetItem")
                                   .Input(_input_handle)
                                   .Input(_index)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Diag::Diag(tensorflow::Scope& scope, 
           tensorflow::Input diagonal) {
      if (!scope.ok())
          return;
      auto _diagonal = ::tensorflow::ops::AsNodeOut(scope, diagonal);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Diag");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Diag")
                                   .Input(_diagonal)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OneShotIterator::OneShotIterator(tensorflow::Scope& scope, 
           tensorflow::NameAttrList dataset_factory, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OneShotIterator");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OneShotIterator")
                                   .Attr("dataset_factory", dataset_factory)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceApplyPowerSign::ResourceApplyPowerSign(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input lr, 
           tensorflow::Input logbase, 
           tensorflow::Input sign_decay, 
           tensorflow::Input beta, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _logbase = ::tensorflow::ops::AsNodeOut(scope, logbase);
      if (!scope.ok())
          return;
      auto _sign_decay = ::tensorflow::ops::AsNodeOut(scope, sign_decay);
      if (!scope.ok())
          return;
      auto _beta = ::tensorflow::ops::AsNodeOut(scope, beta);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceApplyPowerSign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceApplyPowerSign")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_lr)
                                   .Input(_logbase)
                                   .Input(_sign_decay)
                                   .Input(_beta)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

Concat::Concat(tensorflow::Scope& scope, 
           tensorflow::Input concat_dim, 
           tensorflow::InputList values) {
      if (!scope.ok())
          return;
      auto _concat_dim = ::tensorflow::ops::AsNodeOut(scope, concat_dim);
      if (!scope.ok())
          return;
      auto _values = ::tensorflow::ops::AsNodeOutList(scope, values);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Concat");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Concat")
                                   .Input(_concat_dim)
                                   .Input(_values)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TextLineReader::TextLineReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t skip_header_lines) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TextLineReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TextLineReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("skip_header_lines", skip_header_lines)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

RecordInput::RecordInput(tensorflow::Scope& scope, 
           tensorflow::string file_pattern, 
           tensorflow::string compression_type, 
           int64_t file_random_seed, 
           float file_shuffle_shift_ratio, 
           int64_t file_buffer_size, 
           int64_t file_parallelism, 
           int64_t batch_size) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("RecordInput");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "RecordInput")
                                   .Attr("file_pattern", file_pattern)
                                   .Attr("compression_type", compression_type)
                                   .Attr("file_random_seed", file_random_seed)
                                   .Attr("file_shuffle_shift_ratio", file_shuffle_shift_ratio)
                                   .Attr("file_buffer_size", file_buffer_size)
                                   .Attr("file_parallelism", file_parallelism)
                                   .Attr("batch_size", batch_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ApplyAddSign::ApplyAddSign(tensorflow::Scope& scope, 
           tensorflow::Input var, 
           tensorflow::Input m, 
           tensorflow::Input lr, 
           tensorflow::Input alpha, 
           tensorflow::Input sign_decay, 
           tensorflow::Input beta, 
           tensorflow::Input grad, 
           bool use_locking) {
      if (!scope.ok())
          return;
      auto _var = ::tensorflow::ops::AsNodeOut(scope, var);
      if (!scope.ok())
          return;
      auto _m = ::tensorflow::ops::AsNodeOut(scope, m);
      if (!scope.ok())
          return;
      auto _lr = ::tensorflow::ops::AsNodeOut(scope, lr);
      if (!scope.ok())
          return;
      auto _alpha = ::tensorflow::ops::AsNodeOut(scope, alpha);
      if (!scope.ok())
          return;
      auto _sign_decay = ::tensorflow::ops::AsNodeOut(scope, sign_decay);
      if (!scope.ok())
          return;
      auto _beta = ::tensorflow::ops::AsNodeOut(scope, beta);
      if (!scope.ok())
          return;
      auto _grad = ::tensorflow::ops::AsNodeOut(scope, grad);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ApplyAddSign");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ApplyAddSign")
                                   .Input(_var)
                                   .Input(_m)
                                   .Input(_lr)
                                   .Input(_alpha)
                                   .Input(_sign_decay)
                                   .Input(_beta)
                                   .Input(_grad)
                                   .Attr("use_locking", use_locking)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BitwiseAnd::BitwiseAnd(tensorflow::Scope& scope, 
           tensorflow::Input x, 
           tensorflow::Input y) {
      if (!scope.ok())
          return;
      auto _x = ::tensorflow::ops::AsNodeOut(scope, x);
      if (!scope.ok())
          return;
      auto _y = ::tensorflow::ops::AsNodeOut(scope, y);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BitwiseAnd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BitwiseAnd")
                                   .Input(_x)
                                   .Input(_y)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MatrixSetDiag::MatrixSetDiag(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input diagonal) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _diagonal = ::tensorflow::ops::AsNodeOut(scope, diagonal);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MatrixSetDiag");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MatrixSetDiag")
                                   .Input(_input)
                                   .Input(_diagonal)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

_FusedConv2D::_FusedConv2D(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input filter, 
           tensorflow::Input args, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding, 
           tensorflow::gtl::ArraySlice<tensorflow::string> fused_ops, 
           float epsilon, 
           int64_t num_args, 
           tensorflow::string data_format, 
           tensorflow::gtl::ArraySlice<int64_t> dilations) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _filter = ::tensorflow::ops::AsNodeOut(scope, filter);
      if (!scope.ok())
          return;
      auto _args = ::tensorflow::ops::AsNodeOut(scope, args);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("_FusedConv2D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "_FusedConv2D")
                                   .Input(_input)
                                   .Input(_filter)
                                   .Input(_args)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
                                   .Attr("fused_ops", fused_ops)
                                   .Attr("epsilon", epsilon)
                                   .Attr("num_args", num_args)
                                   .Attr("data_format", data_format)
                                   .Attr("dilations", dilations)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BatchFFT3D::BatchFFT3D(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BatchFFT3D");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BatchFFT3D")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

AdjustHue::AdjustHue(tensorflow::Scope& scope, 
           tensorflow::Input images, 
           tensorflow::Input delta) {
      if (!scope.ok())
          return;
      auto _images = ::tensorflow::ops::AsNodeOut(scope, images);
      if (!scope.ok())
          return;
      auto _delta = ::tensorflow::ops::AsNodeOut(scope, delta);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("AdjustHue");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "AdjustHue")
                                   .Input(_images)
                                   .Input(_delta)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SpaceToBatchND::SpaceToBatchND(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input block_shape, 
           tensorflow::Input paddings) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _block_shape = ::tensorflow::ops::AsNodeOut(scope, block_shape);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SpaceToBatchND");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SpaceToBatchND")
                                   .Input(_input)
                                   .Input(_block_shape)
                                   .Input(_paddings)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

QuantizedMaxPool::QuantizedMaxPool(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input min_input, 
           tensorflow::Input max_input, 
           tensorflow::gtl::ArraySlice<int64_t> ksize, 
           tensorflow::gtl::ArraySlice<int64_t> strides, 
           tensorflow::string padding) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _min_input = ::tensorflow::ops::AsNodeOut(scope, min_input);
      if (!scope.ok())
          return;
      auto _max_input = ::tensorflow::ops::AsNodeOut(scope, max_input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("QuantizedMaxPool");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "QuantizedMaxPool")
                                   .Input(_input)
                                   .Input(_min_input)
                                   .Input(_max_input)
                                   .Attr("ksize", ksize)
                                   .Attr("strides", strides)
                                   .Attr("padding", padding)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MirrorPadGrad::MirrorPadGrad(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::Input paddings, 
           tensorflow::string mode) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      if (!scope.ok())
          return;
      auto _paddings = ::tensorflow::ops::AsNodeOut(scope, paddings);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MirrorPadGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MirrorPadGrad")
                                   .Input(_input)
                                   .Input(_paddings)
                                   .Attr("mode", mode)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CTCGreedyDecoder::CTCGreedyDecoder(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::Input sequence_length, 
           bool merge_repeated) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _sequence_length = ::tensorflow::ops::AsNodeOut(scope, sequence_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CTCGreedyDecoder");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CTCGreedyDecoder")
                                   .Input(_inputs)
                                   .Input(_sequence_length)
                                   .Attr("merge_repeated", merge_repeated)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CopyHost::CopyHost(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string tensor_name, 
           tensorflow::gtl::ArraySlice<tensorflow::string> debug_ops_spec) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CopyHost");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CopyHost")
                                   .Input(_input)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("debug_ops_spec", debug_ops_spec)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

MapUnstageNoKey::MapUnstageNoKey(tensorflow::Scope& scope, 
           tensorflow::Input indices, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> dtypes, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           int64_t capacity, 
           int64_t memory_limit) {
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("MapUnstageNoKey");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "MapUnstageNoKey")
                                   .Input(_indices)
                                   .Attr("dtypes", dtypes)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("capacity", capacity)
                                   .Attr("memory_limit", memory_limit)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorScatterAdd::TensorScatterAdd(tensorflow::Scope& scope, 
           tensorflow::Input tensor, 
           tensorflow::Input indices, 
           tensorflow::Input updates) {
      if (!scope.ok())
          return;
      auto _tensor = ::tensorflow::ops::AsNodeOut(scope, tensor);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorScatterAdd");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorScatterAdd")
                                   .Input(_tensor)
                                   .Input(_indices)
                                   .Input(_updates)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalMaterializedIndexDatasetHandle::ExperimentalMaterializedIndexDatasetHandle(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalMaterializedIndexDatasetHandle");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalMaterializedIndexDatasetHandle")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesEnsembleResourceHandleOp::BoostedTreesEnsembleResourceHandleOp(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesEnsembleResourceHandleOp");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesEnsembleResourceHandleOp")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

SegmentMean::SegmentMean(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input segment_ids) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _segment_ids = ::tensorflow::ops::AsNodeOut(scope, segment_ids);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("SegmentMean");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "SegmentMean")
                                   .Input(_data)
                                   .Input(_segment_ids)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OptimizeDataset::OptimizeDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input optimizations, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _optimizations = ::tensorflow::ops::AsNodeOut(scope, optimizations);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OptimizeDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OptimizeDataset")
                                   .Input(_input_dataset)
                                   .Input(_optimizations)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DebugIdentity::DebugIdentity(tensorflow::Scope& scope, 
           tensorflow::Input input, 
           tensorflow::string device_name, 
           tensorflow::string tensor_name, 
           tensorflow::gtl::ArraySlice<tensorflow::string> debug_urls, 
           bool gated_grpc) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DebugIdentity");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DebugIdentity")
                                   .Input(_input)
                                   .Attr("device_name", device_name)
                                   .Attr("tensor_name", tensor_name)
                                   .Attr("debug_urls", debug_urls)
                                   .Attr("gated_grpc", gated_grpc)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BroadcastArgs::BroadcastArgs(tensorflow::Scope& scope, 
           tensorflow::Input s0, 
           tensorflow::Input s1) {
      if (!scope.ok())
          return;
      auto _s0 = ::tensorflow::ops::AsNodeOut(scope, s0);
      if (!scope.ok())
          return;
      auto _s1 = ::tensorflow::ops::AsNodeOut(scope, s1);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BroadcastArgs");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BroadcastArgs")
                                   .Input(_s0)
                                   .Input(_s1)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DecodeCSV::DecodeCSV(tensorflow::Scope& scope, 
           tensorflow::Input records, 
           tensorflow::Input record_defaults, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> OUT_TYPE, 
           tensorflow::string na_value, 
           tensorflow::gtl::ArraySlice<int64_t> select_cols, 
           tensorflow::string field_delim, 
           bool use_quote_delim) {
      if (!scope.ok())
          return;
      auto _records = ::tensorflow::ops::AsNodeOut(scope, records);
      if (!scope.ok())
          return;
      auto _record_defaults = ::tensorflow::ops::AsNodeOut(scope, record_defaults);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DecodeCSV");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DecodeCSV")
                                   .Input(_records)
                                   .Input(_record_defaults)
                                   .Attr("OUT_TYPE", OUT_TYPE)
                                   .Attr("na_value", na_value)
                                   .Attr("select_cols", select_cols)
                                   .Attr("field_delim", field_delim)
                                   .Attr("use_quote_delim", use_quote_delim)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalLMDBDataset::ExperimentalLMDBDataset(tensorflow::Scope& scope, 
           tensorflow::Input filenames, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _filenames = ::tensorflow::ops::AsNodeOut(scope, filenames);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalLMDBDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalLMDBDataset")
                                   .Input(_filenames)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

OptionalNone::OptionalNone(tensorflow::Scope& scope) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("OptionalNone");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "OptionalNone")
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalNumaMapAndBatchDataset::ExperimentalNumaMapAndBatchDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input other_arguments, 
           tensorflow::Input batch_size, 
           tensorflow::Input num_parallel_calls, 
           tensorflow::Input drop_remainder, 
           tensorflow::NameAttrList f, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> Targuments, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes, 
           bool preserve_cardinality) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _other_arguments = ::tensorflow::ops::AsNodeOut(scope, other_arguments);
      if (!scope.ok())
          return;
      auto _batch_size = ::tensorflow::ops::AsNodeOut(scope, batch_size);
      if (!scope.ok())
          return;
      auto _num_parallel_calls = ::tensorflow::ops::AsNodeOut(scope, num_parallel_calls);
      if (!scope.ok())
          return;
      auto _drop_remainder = ::tensorflow::ops::AsNodeOut(scope, drop_remainder);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalNumaMapAndBatchDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalNumaMapAndBatchDataset")
                                   .Input(_input_dataset)
                                   .Input(_other_arguments)
                                   .Input(_batch_size)
                                   .Input(_num_parallel_calls)
                                   .Input(_drop_remainder)
                                   .Attr("f", f)
                                   .Attr("Targuments", Targuments)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
                                   .Attr("preserve_cardinality", preserve_cardinality)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DynamicPartition::DynamicPartition(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input partitions, 
           int64_t num_partitions) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _partitions = ::tensorflow::ops::AsNodeOut(scope, partitions);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DynamicPartition");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DynamicPartition")
                                   .Input(_data)
                                   .Input(_partitions)
                                   .Attr("num_partitions", num_partitions)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

LinSpace::LinSpace(tensorflow::Scope& scope, 
           tensorflow::Input start, 
           tensorflow::Input stop, 
           tensorflow::Input num) {
      if (!scope.ok())
          return;
      auto _start = ::tensorflow::ops::AsNodeOut(scope, start);
      if (!scope.ok())
          return;
      auto _stop = ::tensorflow::ops::AsNodeOut(scope, stop);
      if (!scope.ok())
          return;
      auto _num = ::tensorflow::ops::AsNodeOut(scope, num);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("LinSpace");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "LinSpace")
                                   .Input(_start)
                                   .Input(_stop)
                                   .Input(_num)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FixedLengthRecordDataset::FixedLengthRecordDataset(tensorflow::Scope& scope, 
           tensorflow::Input filenames, 
           tensorflow::Input header_bytes, 
           tensorflow::Input record_bytes, 
           tensorflow::Input footer_bytes, 
           tensorflow::Input buffer_size) {
      if (!scope.ok())
          return;
      auto _filenames = ::tensorflow::ops::AsNodeOut(scope, filenames);
      if (!scope.ok())
          return;
      auto _header_bytes = ::tensorflow::ops::AsNodeOut(scope, header_bytes);
      if (!scope.ok())
          return;
      auto _record_bytes = ::tensorflow::ops::AsNodeOut(scope, record_bytes);
      if (!scope.ok())
          return;
      auto _footer_bytes = ::tensorflow::ops::AsNodeOut(scope, footer_bytes);
      if (!scope.ok())
          return;
      auto _buffer_size = ::tensorflow::ops::AsNodeOut(scope, buffer_size);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FixedLengthRecordDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FixedLengthRecordDataset")
                                   .Input(_filenames)
                                   .Input(_header_bytes)
                                   .Input(_record_bytes)
                                   .Input(_footer_bytes)
                                   .Input(_buffer_size)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

CTCLoss::CTCLoss(tensorflow::Scope& scope, 
           tensorflow::Input inputs, 
           tensorflow::Input labels_indices, 
           tensorflow::Input labels_values, 
           tensorflow::Input sequence_length, 
           bool preprocess_collapse_repeated, 
           bool ctc_merge_repeated, 
           bool ignore_longer_outputs_than_inputs) {
      if (!scope.ok())
          return;
      auto _inputs = ::tensorflow::ops::AsNodeOut(scope, inputs);
      if (!scope.ok())
          return;
      auto _labels_indices = ::tensorflow::ops::AsNodeOut(scope, labels_indices);
      if (!scope.ok())
          return;
      auto _labels_values = ::tensorflow::ops::AsNodeOut(scope, labels_values);
      if (!scope.ok())
          return;
      auto _sequence_length = ::tensorflow::ops::AsNodeOut(scope, sequence_length);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("CTCLoss");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "CTCLoss")
                                   .Input(_inputs)
                                   .Input(_labels_indices)
                                   .Input(_labels_values)
                                   .Input(_sequence_length)
                                   .Attr("preprocess_collapse_repeated", preprocess_collapse_repeated)
                                   .Attr("ctc_merge_repeated", ctc_merge_repeated)
                                   .Attr("ignore_longer_outputs_than_inputs", ignore_longer_outputs_than_inputs)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

DebugGradientIdentity::DebugGradientIdentity(tensorflow::Scope& scope, 
           tensorflow::Input input) {
      if (!scope.ok())
          return;
      auto _input = ::tensorflow::ops::AsNodeOut(scope, input);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("DebugGradientIdentity");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "DebugGradientIdentity")
                                   .Input(_input)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TensorArraySplit::TensorArraySplit(tensorflow::Scope& scope, 
           tensorflow::Input handle, 
           tensorflow::Input value, 
           tensorflow::Input lengths, 
           tensorflow::Input flow_in) {
      if (!scope.ok())
          return;
      auto _handle = ::tensorflow::ops::AsNodeOut(scope, handle);
      if (!scope.ok())
          return;
      auto _value = ::tensorflow::ops::AsNodeOut(scope, value);
      if (!scope.ok())
          return;
      auto _lengths = ::tensorflow::ops::AsNodeOut(scope, lengths);
      if (!scope.ok())
          return;
      auto _flow_in = ::tensorflow::ops::AsNodeOut(scope, flow_in);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TensorArraySplit");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TensorArraySplit")
                                   .Input(_handle)
                                   .Input(_value)
                                   .Input(_lengths)
                                   .Input(_flow_in)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

UnicodeEncode::UnicodeEncode(tensorflow::Scope& scope, 
           tensorflow::Input input_values, 
           tensorflow::Input input_splits, 
           tensorflow::string output_encoding, 
           tensorflow::string errors, 
           int64_t replacement_char) {
      if (!scope.ok())
          return;
      auto _input_values = ::tensorflow::ops::AsNodeOut(scope, input_values);
      if (!scope.ok())
          return;
      auto _input_splits = ::tensorflow::ops::AsNodeOut(scope, input_splits);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("UnicodeEncode");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "UnicodeEncode")
                                   .Input(_input_values)
                                   .Input(_input_splits)
                                   .Attr("output_encoding", output_encoding)
                                   .Attr("errors", errors)
                                   .Attr("replacement_char", replacement_char)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

Switch::Switch(tensorflow::Scope& scope, 
           tensorflow::Input data, 
           tensorflow::Input pred) {
      if (!scope.ok())
          return;
      auto _data = ::tensorflow::ops::AsNodeOut(scope, data);
      if (!scope.ok())
          return;
      auto _pred = ::tensorflow::ops::AsNodeOut(scope, pred);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("Switch");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "Switch")
                                   .Input(_data)
                                   .Input(_pred)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ResourceScatterMul::ResourceScatterMul(tensorflow::Scope& scope, 
           tensorflow::Input resource, 
           tensorflow::Input indices, 
           tensorflow::Input updates, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _resource = ::tensorflow::ops::AsNodeOut(scope, resource);
      if (!scope.ok())
          return;
      auto _indices = ::tensorflow::ops::AsNodeOut(scope, indices);
      if (!scope.ok())
          return;
      auto _updates = ::tensorflow::ops::AsNodeOut(scope, updates);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ResourceScatterMul");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ResourceScatterMul")
                                   .Input(_resource)
                                   .Input(_indices)
                                   .Input(_updates)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
}

WholeFileReader::WholeFileReader(tensorflow::Scope& scope, 
           tensorflow::string container, 
           tensorflow::string shared_name) {
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("WholeFileReader");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "WholeFileReader")
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

ExperimentalSlidingWindowDataset::ExperimentalSlidingWindowDataset(tensorflow::Scope& scope, 
           tensorflow::Input input_dataset, 
           tensorflow::Input window_size, 
           tensorflow::Input window_shift, 
           tensorflow::Input window_stride, 
           tensorflow::gtl::ArraySlice<tensorflow::DataType> output_types, 
           tensorflow::gtl::ArraySlice<tensorflow::PartialTensorShape> output_shapes) {
      if (!scope.ok())
          return;
      auto _input_dataset = ::tensorflow::ops::AsNodeOut(scope, input_dataset);
      if (!scope.ok())
          return;
      auto _window_size = ::tensorflow::ops::AsNodeOut(scope, window_size);
      if (!scope.ok())
          return;
      auto _window_shift = ::tensorflow::ops::AsNodeOut(scope, window_shift);
      if (!scope.ok())
          return;
      auto _window_stride = ::tensorflow::ops::AsNodeOut(scope, window_stride);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("ExperimentalSlidingWindowDataset");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "ExperimentalSlidingWindowDataset")
                                   .Input(_input_dataset)
                                   .Input(_window_size)
                                   .Input(_window_shift)
                                   .Input(_window_stride)
                                   .Attr("output_types", output_types)
                                   .Attr("output_shapes", output_shapes)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

TakeManySparseFromTensorsMap::TakeManySparseFromTensorsMap(tensorflow::Scope& scope, 
           tensorflow::Input sparse_handles, 
           tensorflow::string container, 
           tensorflow::string shared_name, 
           tensorflow::DataType dtype) {
      if (!scope.ok())
          return;
      auto _sparse_handles = ::tensorflow::ops::AsNodeOut(scope, sparse_handles);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("TakeManySparseFromTensorsMap");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "TakeManySparseFromTensorsMap")
                                   .Input(_sparse_handles)
                                   .Attr("container", container)
                                   .Attr("shared_name", shared_name)
                                   .Attr("dtype", dtype)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

BoostedTreesMakeQuantileSummaries::BoostedTreesMakeQuantileSummaries(tensorflow::Scope& scope, 
           tensorflow::Input float_values, 
           tensorflow::Input example_weights, 
           tensorflow::Input epsilon, 
           int64_t num_features) {
      if (!scope.ok())
          return;
      auto _float_values = ::tensorflow::ops::AsNodeOut(scope, float_values);
      if (!scope.ok())
          return;
      auto _example_weights = ::tensorflow::ops::AsNodeOut(scope, example_weights);
      if (!scope.ok())
          return;
      auto _epsilon = ::tensorflow::ops::AsNodeOut(scope, epsilon);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("BoostedTreesMakeQuantileSummaries");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "BoostedTreesMakeQuantileSummaries")
                                   .Input(_float_values)
                                   .Input(_example_weights)
                                   .Input(_epsilon)
                                   .Attr("num_features", num_features)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

FractionalMaxPoolGrad::FractionalMaxPoolGrad(tensorflow::Scope& scope, 
           tensorflow::Input orig_input, 
           tensorflow::Input orig_output, 
           tensorflow::Input out_backprop, 
           tensorflow::Input row_pooling_sequence, 
           tensorflow::Input col_pooling_sequence, 
           bool overlapping) {
      if (!scope.ok())
          return;
      auto _orig_input = ::tensorflow::ops::AsNodeOut(scope, orig_input);
      if (!scope.ok())
          return;
      auto _orig_output = ::tensorflow::ops::AsNodeOut(scope, orig_output);
      if (!scope.ok())
          return;
      auto _out_backprop = ::tensorflow::ops::AsNodeOut(scope, out_backprop);
      if (!scope.ok())
          return;
      auto _row_pooling_sequence = ::tensorflow::ops::AsNodeOut(scope, row_pooling_sequence);
      if (!scope.ok())
          return;
      auto _col_pooling_sequence = ::tensorflow::ops::AsNodeOut(scope, col_pooling_sequence);
      ::tensorflow::Node *ret;
      const auto unique_name = scope.GetUniqueNameForOp("FractionalMaxPoolGrad");
      auto builder = ::tensorflow::NodeBuilder(unique_name, "FractionalMaxPoolGrad")
                                   .Input(_orig_input)
                                   .Input(_orig_output)
                                   .Input(_out_backprop)
                                   .Input(_row_pooling_sequence)
                                   .Input(_col_pooling_sequence)
                                   .Attr("overlapping", overlapping)
      ;
      scope.UpdateBuilder(&builder);
      scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));
      if (!scope.ok()) return;
      scope.UpdateStatus(scope.DoShapeInference(ret));
      this->operation = ::tensorflow::Operation(ret);
      this->output = tensorflow::Output(ret, 0);
}

