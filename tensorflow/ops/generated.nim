import ../core/core

{.compile:"../tensorflow/ops/generated.cc".}


type GcsConfigureBlockCache*{.header:"../tensorflow/ops/generated.h", importcpp:"GcsConfigureBlockCache/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iigcsConfigureBlockCache(scope: Scope,
                             max_cache_size: ouint64,
                             block_size: ouint64,
                             max_staleness: ouint64): GcsConfigureBlockCache {.header:"../tensorflow/ops/generated.h", importcpp:"GcsConfigureBlockCache(*#, #, #, #)", constructor.}

proc gcsConfigureBlockCache*(scope: Scope,
                             max_cache_size: ouint64,
                             block_size: ouint64,
                             max_staleness: ouint64): GcsConfigureBlockCache =
  return iigcsConfigureBlockCache(scope,
                                  max_cache_size,
                                  block_size,
                                  max_staleness)




type GenerateBigQueryReaderPartitions* {.header:"../tensorflow/ops/generated.h", importcpp:"GenerateBigQueryReaderPartitions/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iigenerateBigQueryReaderPartitions(scope: Scope,
                                       project_id: cstring,
                                       dataset_id: cstring,
                                       table_id: cstring,
                                       columns: ArraySlice[cstring],
                                       test_end_point: cstring,
                                       timestamp_millis: int64,
                                       num_partitions: int64): GenerateBigQueryReaderPartitions {.header:"../tensorflow/ops/generated.h", importcpp:"GenerateBigQueryReaderPartitions(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, tensorflow::string(#), #, #)", constructor.}

proc generateBigQueryReaderPartitions*(scope: Scope,
                                       project_id: cstring,
                                       dataset_id: cstring,
                                       table_id: cstring,
                                       columns: openArray[cstring],
                                       test_end_point: cstring,
                                       timestamp_millis: int64 = 0.int,
                                       num_partitions: int64 = 0.int): GenerateBigQueryReaderPartitions =
  return iigenerateBigQueryReaderPartitions(scope,
                                            project_id,
                                            dataset_id,
                                            table_id,
                                            newArraySlice(columns),
                                            test_end_point,
                                            timestamp_millis,
                                            num_partitions)

converter generateBigQueryReaderPartitionsToOut*(op: GenerateBigQueryReaderPartitions): ostring {.inline.} = return op.output


type Fact* {.header:"../tensorflow/ops/generated.h", importcpp:"Fact/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iifact(scope: Scope): Fact {.header:"../tensorflow/ops/generated.h", importcpp:"Fact(*#)", constructor.}

proc fact*(scope: Scope): Fact =
  return iifact(scope)

converter factToOut*(op: Fact): ostring {.inline.} = return op.output

type ResourceApplyAddSignT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAddSign*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAddSign/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAddSign(scope: Scope,
                           nvar: oresource,
                           m: oresource,
                           lr: ResourceApplyAddSignT,
                           alpha: ResourceApplyAddSignT,
                           sign_decay: ResourceApplyAddSignT,
                           beta: ResourceApplyAddSignT,
                           grad: ResourceApplyAddSignT,
                           use_locking: bool): ResourceApplyAddSign {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAddSign(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAddSign*(scope: Scope,
                           nvar: oresource,
                           m: oresource,
                           lr: ResourceApplyAddSignT,
                           alpha: ResourceApplyAddSignT,
                           sign_decay: ResourceApplyAddSignT,
                           beta: ResourceApplyAddSignT,
                           grad: ResourceApplyAddSignT,
                           use_locking: bool = false): ResourceApplyAddSign =
  return iiresourceApplyAddSign(scope,
                                nvar,
                                m,
                                lr,
                                alpha,
                                sign_decay,
                                beta,
                                grad,
                                use_locking)



type ResourceSparseApplyRMSPropT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyRMSPropTindices* = oint32 | oint64

type ResourceSparseApplyRMSProp*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyRMSProp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyRMSProp(scope: Scope,
                                 nvar: oresource,
                                 ms: oresource,
                                 mom: oresource,
                                 lr: ResourceSparseApplyRMSPropT,
                                 rho: ResourceSparseApplyRMSPropT,
                                 momentum: ResourceSparseApplyRMSPropT,
                                 epsilon: ResourceSparseApplyRMSPropT,
                                 grad: ResourceSparseApplyRMSPropT,
                                 indices: ResourceSparseApplyRMSPropTindices,
                                 use_locking: bool): ResourceSparseApplyRMSProp {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyRMSProp*(scope: Scope,
                                 nvar: oresource,
                                 ms: oresource,
                                 mom: oresource,
                                 lr: ResourceSparseApplyRMSPropT,
                                 rho: ResourceSparseApplyRMSPropT,
                                 momentum: ResourceSparseApplyRMSPropT,
                                 epsilon: ResourceSparseApplyRMSPropT,
                                 grad: ResourceSparseApplyRMSPropT,
                                 indices: ResourceSparseApplyRMSPropTindices,
                                 use_locking: bool = false): ResourceSparseApplyRMSProp =
  return iiresourceSparseApplyRMSProp(scope,
                                      nvar,
                                      ms,
                                      mom,
                                      lr,
                                      rho,
                                      momentum,
                                      epsilon,
                                      grad,
                                      indices,
                                      use_locking)



type ResourceSparseApplyCenteredRMSPropT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyCenteredRMSPropTindices* = oint32 | oint64

type ResourceSparseApplyCenteredRMSProp*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyCenteredRMSProp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyCenteredRMSProp(scope: Scope,
                                         nvar: oresource,
                                         mg: oresource,
                                         ms: oresource,
                                         mom: oresource,
                                         lr: ResourceSparseApplyCenteredRMSPropT,
                                         rho: ResourceSparseApplyCenteredRMSPropT,
                                         momentum: ResourceSparseApplyCenteredRMSPropT,
                                         epsilon: ResourceSparseApplyCenteredRMSPropT,
                                         grad: ResourceSparseApplyCenteredRMSPropT,
                                         indices: ResourceSparseApplyCenteredRMSPropTindices,
                                         use_locking: bool): ResourceSparseApplyCenteredRMSProp {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyCenteredRMSProp*(scope: Scope,
                                         nvar: oresource,
                                         mg: oresource,
                                         ms: oresource,
                                         mom: oresource,
                                         lr: ResourceSparseApplyCenteredRMSPropT,
                                         rho: ResourceSparseApplyCenteredRMSPropT,
                                         momentum: ResourceSparseApplyCenteredRMSPropT,
                                         epsilon: ResourceSparseApplyCenteredRMSPropT,
                                         grad: ResourceSparseApplyCenteredRMSPropT,
                                         indices: ResourceSparseApplyCenteredRMSPropTindices,
                                         use_locking: bool = false): ResourceSparseApplyCenteredRMSProp =
  return iiresourceSparseApplyCenteredRMSProp(scope,
                                              nvar,
                                              mg,
                                              ms,
                                              mom,
                                              lr,
                                              rho,
                                              momentum,
                                              epsilon,
                                              grad,
                                              indices,
                                              use_locking)



type SparseApplyCenteredRMSPropTindices* = oint32 | oint64

type SparseApplyCenteredRMSProp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyCenteredRMSProp/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyCenteredRMSProp[oT: oall](scope: Scope,
                                 nvar: oT,
                                 mg: oT,
                                 ms: oT,
                                 mom: oT,
                                 lr: oT,
                                 rho: oT,
                                 momentum: oT,
                                 epsilon: oT,
                                 grad: oT,
                                 indices: SparseApplyCenteredRMSPropTindices,
                                 T: DType,
                                 use_locking: bool): SparseApplyCenteredRMSProp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyCenteredRMSProp*[oT: oall](scope: Scope,
                                 nvar: oT,
                                 mg: oT,
                                 ms: oT,
                                 mom: oT,
                                 lr: oT,
                                 rho: oT,
                                 momentum: oT,
                                 epsilon: oT,
                                 grad: oT,
                                 indices: SparseApplyCenteredRMSPropTindices,
                                 use_locking: bool = false): SparseApplyCenteredRMSProp[oT] =
  return iisparseApplyCenteredRMSProp(scope,
                                      nvar,
                                      mg,
                                      ms,
                                      mom,
                                      lr,
                                      rho,
                                      momentum,
                                      epsilon,
                                      grad,
                                      indices,
                                      oT[].oTF,
                                      use_locking)

converter sparseApplyCenteredRMSPropToOut*[oT: oall](op: SparseApplyCenteredRMSProp[oT]): oT {.inline.} = return op.output

type SparseApplyRMSPropTindices* = oint32 | oint64

type SparseApplyRMSProp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyRMSProp/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyRMSProp[oT: oall](scope: Scope,
                         nvar: oT,
                         ms: oT,
                         mom: oT,
                         lr: oT,
                         rho: oT,
                         momentum: oT,
                         epsilon: oT,
                         grad: oT,
                         indices: SparseApplyRMSPropTindices,
                         T: DType,
                         use_locking: bool): SparseApplyRMSProp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyRMSProp(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyRMSProp*[oT: oall](scope: Scope,
                         nvar: oT,
                         ms: oT,
                         mom: oT,
                         lr: oT,
                         rho: oT,
                         momentum: oT,
                         epsilon: oT,
                         grad: oT,
                         indices: SparseApplyRMSPropTindices,
                         use_locking: bool = false): SparseApplyRMSProp[oT] =
  return iisparseApplyRMSProp(scope,
                              nvar,
                              ms,
                              mom,
                              lr,
                              rho,
                              momentum,
                              epsilon,
                              grad,
                              indices,
                              oT[].oTF,
                              use_locking)

converter sparseApplyRMSPropToOut*[oT: oall](op: SparseApplyRMSProp[oT]): oT {.inline.} = return op.output


type ApplyRMSProp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyRMSProp/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyRMSProp[oT: oall](scope: Scope,
                   nvar: oT,
                   ms: oT,
                   mom: oT,
                   lr: oT,
                   rho: oT,
                   momentum: oT,
                   epsilon: oT,
                   grad: oT,
                   T: DType,
                   use_locking: bool): ApplyRMSProp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyRMSProp*[oT: oall](scope: Scope,
                   nvar: oT,
                   ms: oT,
                   mom: oT,
                   lr: oT,
                   rho: oT,
                   momentum: oT,
                   epsilon: oT,
                   grad: oT,
                   use_locking: bool = false): ApplyRMSProp[oT] =
  return iiapplyRMSProp(scope,
                        nvar,
                        ms,
                        mom,
                        lr,
                        rho,
                        momentum,
                        epsilon,
                        grad,
                        oT[].oTF,
                        use_locking)

converter applyRMSPropToOut*[oT: oall](op: ApplyRMSProp[oT]): oT {.inline.} = return op.output

type ResourceApplyAdaMaxT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdaMax*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdaMax/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAdaMax(scope: Scope,
                          nvar: oresource,
                          m: oresource,
                          v: oresource,
                          beta1_power: ResourceApplyAdaMaxT,
                          lr: ResourceApplyAdaMaxT,
                          beta1: ResourceApplyAdaMaxT,
                          beta2: ResourceApplyAdaMaxT,
                          epsilon: ResourceApplyAdaMaxT,
                          grad: ResourceApplyAdaMaxT,
                          use_locking: bool): ResourceApplyAdaMax {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdaMax(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdaMax*(scope: Scope,
                          nvar: oresource,
                          m: oresource,
                          v: oresource,
                          beta1_power: ResourceApplyAdaMaxT,
                          lr: ResourceApplyAdaMaxT,
                          beta1: ResourceApplyAdaMaxT,
                          beta2: ResourceApplyAdaMaxT,
                          epsilon: ResourceApplyAdaMaxT,
                          grad: ResourceApplyAdaMaxT,
                          use_locking: bool = false): ResourceApplyAdaMax =
  return iiresourceApplyAdaMax(scope,
                               nvar,
                               m,
                               v,
                               beta1_power,
                               lr,
                               beta1,
                               beta2,
                               epsilon,
                               grad,
                               use_locking)




type ApplyAdaMax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdaMax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyAdaMax[oT: oall](scope: Scope,
                  nvar: oT,
                  m: oT,
                  v: oT,
                  beta1_power: oT,
                  lr: oT,
                  beta1: oT,
                  beta2: oT,
                  epsilon: oT,
                  grad: oT,
                  T: DType,
                  use_locking: bool): ApplyAdaMax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdaMax(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdaMax*[oT: oall](scope: Scope,
                  nvar: oT,
                  m: oT,
                  v: oT,
                  beta1_power: oT,
                  lr: oT,
                  beta1: oT,
                  beta2: oT,
                  epsilon: oT,
                  grad: oT,
                  use_locking: bool = false): ApplyAdaMax[oT] =
  return iiapplyAdaMax(scope,
                       nvar,
                       m,
                       v,
                       beta1_power,
                       lr,
                       beta1,
                       beta2,
                       epsilon,
                       grad,
                       oT[].oTF,
                       use_locking)

converter applyAdaMaxToOut*[oT: oall](op: ApplyAdaMax[oT]): oT {.inline.} = return op.output


type ApplyAdam*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdam/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyAdam[oT: oall](scope: Scope,
                nvar: oT,
                m: oT,
                v: oT,
                beta1_power: oT,
                beta2_power: oT,
                lr: oT,
                beta1: oT,
                beta2: oT,
                epsilon: oT,
                grad: oT,
                T: DType,
                use_locking: bool,
                use_nesterov: bool): ApplyAdam[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdam(*#, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdam*[oT: oall](scope: Scope,
                nvar: oT,
                m: oT,
                v: oT,
                beta1_power: oT,
                beta2_power: oT,
                lr: oT,
                beta1: oT,
                beta2: oT,
                epsilon: oT,
                grad: oT,
                use_locking: bool = false,
                use_nesterov: bool = false): ApplyAdam[oT] =
  return iiapplyAdam(scope,
                     nvar,
                     m,
                     v,
                     beta1_power,
                     beta2_power,
                     lr,
                     beta1,
                     beta2,
                     epsilon,
                     grad,
                     oT[].oTF,
                     use_locking,
                     use_nesterov)

converter applyAdamToOut*[oT: oall](op: ApplyAdam[oT]): oT {.inline.} = return op.output

type ResourceSparseApplyKerasMomentumT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyKerasMomentumTindices* = oint32 | oint64

type ResourceSparseApplyKerasMomentum*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyKerasMomentum/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyKerasMomentum(scope: Scope,
                                       nvar: oresource,
                                       accum: oresource,
                                       lr: ResourceSparseApplyKerasMomentumT,
                                       grad: ResourceSparseApplyKerasMomentumT,
                                       indices: ResourceSparseApplyKerasMomentumTindices,
                                       momentum: ResourceSparseApplyKerasMomentumT,
                                       use_nesterov: bool,
                                       use_locking: bool): ResourceSparseApplyKerasMomentum {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyKerasMomentum(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyKerasMomentum*(scope: Scope,
                                       nvar: oresource,
                                       accum: oresource,
                                       lr: ResourceSparseApplyKerasMomentumT,
                                       grad: ResourceSparseApplyKerasMomentumT,
                                       indices: ResourceSparseApplyKerasMomentumTindices,
                                       momentum: ResourceSparseApplyKerasMomentumT,
                                       use_nesterov: bool = false,
                                       use_locking: bool = false): ResourceSparseApplyKerasMomentum =
  return iiresourceSparseApplyKerasMomentum(scope,
                                            nvar,
                                            accum,
                                            lr,
                                            grad,
                                            indices,
                                            momentum,
                                            use_nesterov,
                                            use_locking)



type ResourceApplyKerasMomentumT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyKerasMomentum*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyKerasMomentum/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyKerasMomentum(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceApplyKerasMomentumT,
                                 grad: ResourceApplyKerasMomentumT,
                                 momentum: ResourceApplyKerasMomentumT,
                                 use_nesterov: bool,
                                 use_locking: bool): ResourceApplyKerasMomentum {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyKerasMomentum(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyKerasMomentum*(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceApplyKerasMomentumT,
                                 grad: ResourceApplyKerasMomentumT,
                                 momentum: ResourceApplyKerasMomentumT,
                                 use_nesterov: bool = false,
                                 use_locking: bool = false): ResourceApplyKerasMomentum =
  return iiresourceApplyKerasMomentum(scope,
                                      nvar,
                                      accum,
                                      lr,
                                      grad,
                                      momentum,
                                      use_nesterov,
                                      use_locking)



type ResourceSparseApplyMomentumT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyMomentumTindices* = oint32 | oint64

type ResourceSparseApplyMomentum*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyMomentum/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyMomentum(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  lr: ResourceSparseApplyMomentumT,
                                  grad: ResourceSparseApplyMomentumT,
                                  indices: ResourceSparseApplyMomentumTindices,
                                  momentum: ResourceSparseApplyMomentumT,
                                  use_nesterov: bool,
                                  use_locking: bool): ResourceSparseApplyMomentum {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyMomentum(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyMomentum*(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  lr: ResourceSparseApplyMomentumT,
                                  grad: ResourceSparseApplyMomentumT,
                                  indices: ResourceSparseApplyMomentumTindices,
                                  momentum: ResourceSparseApplyMomentumT,
                                  use_nesterov: bool = false,
                                  use_locking: bool = false): ResourceSparseApplyMomentum =
  return iiresourceSparseApplyMomentum(scope,
                                       nvar,
                                       accum,
                                       lr,
                                       grad,
                                       indices,
                                       momentum,
                                       use_nesterov,
                                       use_locking)



type ResourceApplyMomentumT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyMomentum*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyMomentum/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyMomentum(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            lr: ResourceApplyMomentumT,
                            grad: ResourceApplyMomentumT,
                            momentum: ResourceApplyMomentumT,
                            use_nesterov: bool,
                            use_locking: bool): ResourceApplyMomentum {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyMomentum(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyMomentum*(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            lr: ResourceApplyMomentumT,
                            grad: ResourceApplyMomentumT,
                            momentum: ResourceApplyMomentumT,
                            use_nesterov: bool = false,
                            use_locking: bool = false): ResourceApplyMomentum =
  return iiresourceApplyMomentum(scope,
                                 nvar,
                                 accum,
                                 lr,
                                 grad,
                                 momentum,
                                 use_nesterov,
                                 use_locking)



type ResourceSparseApplyFtrlV2T* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyFtrlV2Tindices* = oint32 | oint64

type ResourceSparseApplyFtrlV2*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyFtrlV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyFtrlV2(scope: Scope,
                                nvar: oresource,
                                accum: oresource,
                                linear: oresource,
                                grad: ResourceSparseApplyFtrlV2T,
                                indices: ResourceSparseApplyFtrlV2Tindices,
                                lr: ResourceSparseApplyFtrlV2T,
                                l1: ResourceSparseApplyFtrlV2T,
                                l2: ResourceSparseApplyFtrlV2T,
                                l2_shrinkage: ResourceSparseApplyFtrlV2T,
                                lr_power: ResourceSparseApplyFtrlV2T,
                                use_locking: bool): ResourceSparseApplyFtrlV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyFtrlV2*(scope: Scope,
                                nvar: oresource,
                                accum: oresource,
                                linear: oresource,
                                grad: ResourceSparseApplyFtrlV2T,
                                indices: ResourceSparseApplyFtrlV2Tindices,
                                lr: ResourceSparseApplyFtrlV2T,
                                l1: ResourceSparseApplyFtrlV2T,
                                l2: ResourceSparseApplyFtrlV2T,
                                l2_shrinkage: ResourceSparseApplyFtrlV2T,
                                lr_power: ResourceSparseApplyFtrlV2T,
                                use_locking: bool = false): ResourceSparseApplyFtrlV2 =
  return iiresourceSparseApplyFtrlV2(scope,
                                     nvar,
                                     accum,
                                     linear,
                                     grad,
                                     indices,
                                     lr,
                                     l1,
                                     l2,
                                     l2_shrinkage,
                                     lr_power,
                                     use_locking)



type ResourceSparseApplyFtrlT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyFtrlTindices* = oint32 | oint64

type ResourceSparseApplyFtrl*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyFtrl/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyFtrl(scope: Scope,
                              nvar: oresource,
                              accum: oresource,
                              linear: oresource,
                              grad: ResourceSparseApplyFtrlT,
                              indices: ResourceSparseApplyFtrlTindices,
                              lr: ResourceSparseApplyFtrlT,
                              l1: ResourceSparseApplyFtrlT,
                              l2: ResourceSparseApplyFtrlT,
                              lr_power: ResourceSparseApplyFtrlT,
                              use_locking: bool): ResourceSparseApplyFtrl {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyFtrl(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyFtrl*(scope: Scope,
                              nvar: oresource,
                              accum: oresource,
                              linear: oresource,
                              grad: ResourceSparseApplyFtrlT,
                              indices: ResourceSparseApplyFtrlTindices,
                              lr: ResourceSparseApplyFtrlT,
                              l1: ResourceSparseApplyFtrlT,
                              l2: ResourceSparseApplyFtrlT,
                              lr_power: ResourceSparseApplyFtrlT,
                              use_locking: bool = false): ResourceSparseApplyFtrl =
  return iiresourceSparseApplyFtrl(scope,
                                   nvar,
                                   accum,
                                   linear,
                                   grad,
                                   indices,
                                   lr,
                                   l1,
                                   l2,
                                   lr_power,
                                   use_locking)



type SparseApplyFtrlTindices* = oint32 | oint64

type SparseApplyFtrl*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyFtrl/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyFtrl[oT: oall](scope: Scope,
                      nvar: oT,
                      accum: oT,
                      linear: oT,
                      grad: oT,
                      indices: SparseApplyFtrlTindices,
                      lr: oT,
                      l1: oT,
                      l2: oT,
                      lr_power: oT,
                      T: DType,
                      use_locking: bool): SparseApplyFtrl[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyFtrl(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyFtrl*[oT: oall](scope: Scope,
                      nvar: oT,
                      accum: oT,
                      linear: oT,
                      grad: oT,
                      indices: SparseApplyFtrlTindices,
                      lr: oT,
                      l1: oT,
                      l2: oT,
                      lr_power: oT,
                      use_locking: bool = false): SparseApplyFtrl[oT] =
  return iisparseApplyFtrl(scope,
                           nvar,
                           accum,
                           linear,
                           grad,
                           indices,
                           lr,
                           l1,
                           l2,
                           lr_power,
                           oT[].oTF,
                           use_locking)

converter sparseApplyFtrlToOut*[oT: oall](op: SparseApplyFtrl[oT]): oT {.inline.} = return op.output


type ApplyFtrl*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyFtrl/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyFtrl[oT: oall](scope: Scope,
                nvar: oT,
                accum: oT,
                linear: oT,
                grad: oT,
                lr: oT,
                l1: oT,
                l2: oT,
                lr_power: oT,
                T: DType,
                use_locking: bool): ApplyFtrl[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyFtrl(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyFtrl*[oT: oall](scope: Scope,
                nvar: oT,
                accum: oT,
                linear: oT,
                grad: oT,
                lr: oT,
                l1: oT,
                l2: oT,
                lr_power: oT,
                use_locking: bool = false): ApplyFtrl[oT] =
  return iiapplyFtrl(scope,
                     nvar,
                     accum,
                     linear,
                     grad,
                     lr,
                     l1,
                     l2,
                     lr_power,
                     oT[].oTF,
                     use_locking)

converter applyFtrlToOut*[oT: oall](op: ApplyFtrl[oT]): oT {.inline.} = return op.output

type ResourceSparseApplyAdagradDAT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyAdagradDATindices* = oint32 | oint64

type ResourceSparseApplyAdagradDA*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyAdagradDA/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyAdagradDA(scope: Scope,
                                   nvar: oresource,
                                   gradient_accumulator: oresource,
                                   gradient_squared_accumulator: oresource,
                                   grad: ResourceSparseApplyAdagradDAT,
                                   indices: ResourceSparseApplyAdagradDATindices,
                                   lr: ResourceSparseApplyAdagradDAT,
                                   l1: ResourceSparseApplyAdagradDAT,
                                   l2: ResourceSparseApplyAdagradDAT,
                                   global_step: oint64,
                                   use_locking: bool): ResourceSparseApplyAdagradDA {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyAdagradDA*(scope: Scope,
                                   nvar: oresource,
                                   gradient_accumulator: oresource,
                                   gradient_squared_accumulator: oresource,
                                   grad: ResourceSparseApplyAdagradDAT,
                                   indices: ResourceSparseApplyAdagradDATindices,
                                   lr: ResourceSparseApplyAdagradDAT,
                                   l1: ResourceSparseApplyAdagradDAT,
                                   l2: ResourceSparseApplyAdagradDAT,
                                   global_step: oint64,
                                   use_locking: bool = false): ResourceSparseApplyAdagradDA =
  return iiresourceSparseApplyAdagradDA(scope,
                                        nvar,
                                        gradient_accumulator,
                                        gradient_squared_accumulator,
                                        grad,
                                        indices,
                                        lr,
                                        l1,
                                        l2,
                                        global_step,
                                        use_locking)



type SparseApplyProximalAdagradTindices* = oint32 | oint64

type SparseApplyProximalAdagrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyProximalAdagrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyProximalAdagrad[oT: oall](scope: Scope,
                                 nvar: oT,
                                 accum: oT,
                                 lr: oT,
                                 l1: oT,
                                 l2: oT,
                                 grad: oT,
                                 indices: SparseApplyProximalAdagradTindices,
                                 T: DType,
                                 use_locking: bool): SparseApplyProximalAdagrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyProximalAdagrad(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyProximalAdagrad*[oT: oall](scope: Scope,
                                 nvar: oT,
                                 accum: oT,
                                 lr: oT,
                                 l1: oT,
                                 l2: oT,
                                 grad: oT,
                                 indices: SparseApplyProximalAdagradTindices,
                                 use_locking: bool = false): SparseApplyProximalAdagrad[oT] =
  return iisparseApplyProximalAdagrad(scope,
                                      nvar,
                                      accum,
                                      lr,
                                      l1,
                                      l2,
                                      grad,
                                      indices,
                                      oT[].oTF,
                                      use_locking)

converter sparseApplyProximalAdagradToOut*[oT: oall](op: SparseApplyProximalAdagrad[oT]): oT {.inline.} = return op.output

type SparseApplyAdagradDATindices* = oint32 | oint64

type SparseApplyAdagradDA*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyAdagradDA/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyAdagradDA[oT: oall](scope: Scope,
                           nvar: oT,
                           gradient_accumulator: oT,
                           gradient_squared_accumulator: oT,
                           grad: oT,
                           indices: SparseApplyAdagradDATindices,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           global_step: oint64,
                           T: DType,
                           use_locking: bool): SparseApplyAdagradDA[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyAdagradDA*[oT: oall](scope: Scope,
                           nvar: oT,
                           gradient_accumulator: oT,
                           gradient_squared_accumulator: oT,
                           grad: oT,
                           indices: SparseApplyAdagradDATindices,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           global_step: oint64,
                           use_locking: bool = false): SparseApplyAdagradDA[oT] =
  return iisparseApplyAdagradDA(scope,
                                nvar,
                                gradient_accumulator,
                                gradient_squared_accumulator,
                                grad,
                                indices,
                                lr,
                                l1,
                                l2,
                                global_step,
                                oT[].oTF,
                                use_locking)

converter sparseApplyAdagradDAToOut*[oT: oall](op: SparseApplyAdagradDA[oT]): oT {.inline.} = return op.output


type ApplyAdagradDA*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdagradDA/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyAdagradDA[oT: oall](scope: Scope,
                     nvar: oT,
                     gradient_accumulator: oT,
                     gradient_squared_accumulator: oT,
                     grad: oT,
                     lr: oT,
                     l1: oT,
                     l2: oT,
                     global_step: oint64,
                     T: DType,
                     use_locking: bool): ApplyAdagradDA[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdagradDA*[oT: oall](scope: Scope,
                     nvar: oT,
                     gradient_accumulator: oT,
                     gradient_squared_accumulator: oT,
                     grad: oT,
                     lr: oT,
                     l1: oT,
                     l2: oT,
                     global_step: oint64,
                     use_locking: bool = false): ApplyAdagradDA[oT] =
  return iiapplyAdagradDA(scope,
                          nvar,
                          gradient_accumulator,
                          gradient_squared_accumulator,
                          grad,
                          lr,
                          l1,
                          l2,
                          global_step,
                          oT[].oTF,
                          use_locking)

converter applyAdagradDAToOut*[oT: oall](op: ApplyAdagradDA[oT]): oT {.inline.} = return op.output

type ResourceSparseApplyAdagradT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyAdagradTindices* = oint32 | oint64

type ResourceSparseApplyAdagrad*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyAdagrad/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyAdagrad(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceSparseApplyAdagradT,
                                 grad: ResourceSparseApplyAdagradT,
                                 indices: ResourceSparseApplyAdagradTindices,
                                 update_slots: bool,
                                 use_locking: bool): ResourceSparseApplyAdagrad {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyAdagrad*(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceSparseApplyAdagradT,
                                 grad: ResourceSparseApplyAdagradT,
                                 indices: ResourceSparseApplyAdagradTindices,
                                 update_slots: bool = true,
                                 use_locking: bool = false): ResourceSparseApplyAdagrad =
  return iiresourceSparseApplyAdagrad(scope,
                                      nvar,
                                      accum,
                                      lr,
                                      grad,
                                      indices,
                                      update_slots,
                                      use_locking)



type SparseApplyAdagradTindices* = oint32 | oint64

type SparseApplyAdagrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyAdagrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyAdagrad[oT: oall](scope: Scope,
                         nvar: oT,
                         accum: oT,
                         lr: oT,
                         grad: oT,
                         indices: SparseApplyAdagradTindices,
                         T: DType,
                         update_slots: bool,
                         use_locking: bool): SparseApplyAdagrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyAdagrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyAdagrad*[oT: oall](scope: Scope,
                         nvar: oT,
                         accum: oT,
                         lr: oT,
                         grad: oT,
                         indices: SparseApplyAdagradTindices,
                         update_slots: bool = true,
                         use_locking: bool = false): SparseApplyAdagrad[oT] =
  return iisparseApplyAdagrad(scope,
                              nvar,
                              accum,
                              lr,
                              grad,
                              indices,
                              oT[].oTF,
                              update_slots,
                              use_locking)

converter sparseApplyAdagradToOut*[oT: oall](op: SparseApplyAdagrad[oT]): oT {.inline.} = return op.output

type ResourceApplyAdagradT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdagrad*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdagrad/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAdagrad(scope: Scope,
                           nvar: oresource,
                           accum: oresource,
                           lr: ResourceApplyAdagradT,
                           grad: ResourceApplyAdagradT,
                           update_slots: bool,
                           use_locking: bool): ResourceApplyAdagrad {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdagrad(*#, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdagrad*(scope: Scope,
                           nvar: oresource,
                           accum: oresource,
                           lr: ResourceApplyAdagradT,
                           grad: ResourceApplyAdagradT,
                           update_slots: bool = true,
                           use_locking: bool = false): ResourceApplyAdagrad =
  return iiresourceApplyAdagrad(scope,
                                nvar,
                                accum,
                                lr,
                                grad,
                                update_slots,
                                use_locking)




type ApplyAdagrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdagrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyAdagrad[oT: oall](scope: Scope,
                   nvar: oT,
                   accum: oT,
                   lr: oT,
                   grad: oT,
                   T: DType,
                   use_locking: bool,
                   update_slots: bool): ApplyAdagrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc applyAdagrad*[oT: oall](scope: Scope,
                   nvar: oT,
                   accum: oT,
                   lr: oT,
                   grad: oT,
                   use_locking: bool = false,
                   update_slots: bool = true): ApplyAdagrad[oT] =
  return iiapplyAdagrad(scope,
                        nvar,
                        accum,
                        lr,
                        grad,
                        oT[].oTF,
                        use_locking,
                        update_slots)

converter applyAdagradToOut*[oT: oall](op: ApplyAdagrad[oT]): oT {.inline.} = return op.output

type SparseApplyAdadeltaTindices* = oint32 | oint64

type SparseApplyAdadelta*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyAdadelta/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyAdadelta[oT: oall](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          accum_update: oT,
                          lr: oT,
                          rho: oT,
                          epsilon: oT,
                          grad: oT,
                          indices: SparseApplyAdadeltaTindices,
                          T: DType,
                          use_locking: bool): SparseApplyAdadelta[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyAdadelta(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyAdadelta*[oT: oall](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          accum_update: oT,
                          lr: oT,
                          rho: oT,
                          epsilon: oT,
                          grad: oT,
                          indices: SparseApplyAdadeltaTindices,
                          use_locking: bool = false): SparseApplyAdadelta[oT] =
  return iisparseApplyAdadelta(scope,
                               nvar,
                               accum,
                               accum_update,
                               lr,
                               rho,
                               epsilon,
                               grad,
                               indices,
                               oT[].oTF,
                               use_locking)

converter sparseApplyAdadeltaToOut*[oT: oall](op: SparseApplyAdadelta[oT]): oT {.inline.} = return op.output


type ApplyAdadelta*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdadelta/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyAdadelta[oT: oall](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    accum_update: oT,
                    lr: oT,
                    rho: oT,
                    epsilon: oT,
                    grad: oT,
                    T: DType,
                    use_locking: bool): ApplyAdadelta[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAdadelta(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdadelta*[oT: oall](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    accum_update: oT,
                    lr: oT,
                    rho: oT,
                    epsilon: oT,
                    grad: oT,
                    use_locking: bool = false): ApplyAdadelta[oT] =
  return iiapplyAdadelta(scope,
                         nvar,
                         accum,
                         accum_update,
                         lr,
                         rho,
                         epsilon,
                         grad,
                         oT[].oTF,
                         use_locking)

converter applyAdadeltaToOut*[oT: oall](op: ApplyAdadelta[oT]): oT {.inline.} = return op.output

type ResourceSparseApplyProximalGradientDescentT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyProximalGradientDescentTindices* = oint32 | oint64

type ResourceSparseApplyProximalGradientDescent*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyProximalGradientDescent/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyProximalGradientDescent(scope: Scope,
                                                 nvar: oresource,
                                                 alpha: ResourceSparseApplyProximalGradientDescentT,
                                                 l1: ResourceSparseApplyProximalGradientDescentT,
                                                 l2: ResourceSparseApplyProximalGradientDescentT,
                                                 grad: ResourceSparseApplyProximalGradientDescentT,
                                                 indices: ResourceSparseApplyProximalGradientDescentTindices,
                                                 use_locking: bool): ResourceSparseApplyProximalGradientDescent {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyProximalGradientDescent(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyProximalGradientDescent*(scope: Scope,
                                                 nvar: oresource,
                                                 alpha: ResourceSparseApplyProximalGradientDescentT,
                                                 l1: ResourceSparseApplyProximalGradientDescentT,
                                                 l2: ResourceSparseApplyProximalGradientDescentT,
                                                 grad: ResourceSparseApplyProximalGradientDescentT,
                                                 indices: ResourceSparseApplyProximalGradientDescentTindices,
                                                 use_locking: bool = false): ResourceSparseApplyProximalGradientDescent =
  return iiresourceSparseApplyProximalGradientDescent(scope,
                                                      nvar,
                                                      alpha,
                                                      l1,
                                                      l2,
                                                      grad,
                                                      indices,
                                                      use_locking)



type ResourceApplyProximalGradientDescentT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyProximalGradientDescent*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyProximalGradientDescent/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyProximalGradientDescent(scope: Scope,
                                           nvar: oresource,
                                           alpha: ResourceApplyProximalGradientDescentT,
                                           l1: ResourceApplyProximalGradientDescentT,
                                           l2: ResourceApplyProximalGradientDescentT,
                                           delta: ResourceApplyProximalGradientDescentT,
                                           use_locking: bool): ResourceApplyProximalGradientDescent {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyProximalGradientDescent(*#, #, #, #, #, #, #)", constructor.}

proc resourceApplyProximalGradientDescent*(scope: Scope,
                                           nvar: oresource,
                                           alpha: ResourceApplyProximalGradientDescentT,
                                           l1: ResourceApplyProximalGradientDescentT,
                                           l2: ResourceApplyProximalGradientDescentT,
                                           delta: ResourceApplyProximalGradientDescentT,
                                           use_locking: bool = false): ResourceApplyProximalGradientDescent =
  return iiresourceApplyProximalGradientDescent(scope,
                                                nvar,
                                                alpha,
                                                l1,
                                                l2,
                                                delta,
                                                use_locking)




type ApplyProximalGradientDescent*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyProximalGradientDescent/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyProximalGradientDescent[oT: oall](scope: Scope,
                                   nvar: oT,
                                   alpha: oT,
                                   l1: oT,
                                   l2: oT,
                                   delta: oT,
                                   T: DType,
                                   use_locking: bool): ApplyProximalGradientDescent[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyProximalGradientDescent(*#, #, #, #, #, #, #, #)", constructor.}

proc applyProximalGradientDescent*[oT: oall](scope: Scope,
                                   nvar: oT,
                                   alpha: oT,
                                   l1: oT,
                                   l2: oT,
                                   delta: oT,
                                   use_locking: bool = false): ApplyProximalGradientDescent[oT] =
  return iiapplyProximalGradientDescent(scope,
                                        nvar,
                                        alpha,
                                        l1,
                                        l2,
                                        delta,
                                        oT[].oTF,
                                        use_locking)

converter applyProximalGradientDescentToOut*[oT: oall](op: ApplyProximalGradientDescent[oT]): oT {.inline.} = return op.output


type UnicodeDecodeWithOffsets* {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeDecodeWithOffsets/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiunicodeDecodeWithOffsets(scope: Scope,
                               input: ostring,
                               input_encoding: cstring,
                               errors: cstring,
                               replacement_char: int64,
                               replace_control_characters: bool): UnicodeDecodeWithOffsets {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeDecodeWithOffsets(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unicodeDecodeWithOffsets*(scope: Scope,
                               input: ostring,
                               input_encoding: cstring,
                               errors: cstring = "replace",
                               replacement_char: int64 = 65533.int,
                               replace_control_characters: bool = false): UnicodeDecodeWithOffsets =
  return iiunicodeDecodeWithOffsets(scope,
                                    input,
                                    input_encoding,
                                    errors,
                                    replacement_char,
                                    replace_control_characters)

converter unicodeDecodeWithOffsetsToOut*(op: UnicodeDecodeWithOffsets): oint64 {.inline.} = return op.output


type UnicodeTranscode* {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeTranscode/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiunicodeTranscode(scope: Scope,
                       input: ostring,
                       input_encoding: cstring,
                       output_encoding: cstring,
                       errors: cstring,
                       replacement_char: int64,
                       replace_control_characters: bool): UnicodeTranscode {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeTranscode(*#, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unicodeTranscode*(scope: Scope,
                       input: ostring,
                       input_encoding: cstring,
                       output_encoding: cstring,
                       errors: cstring = "replace",
                       replacement_char: int64 = 65533.int,
                       replace_control_characters: bool = false): UnicodeTranscode =
  return iiunicodeTranscode(scope,
                            input,
                            input_encoding,
                            output_encoding,
                            errors,
                            replacement_char,
                            replace_control_characters)

converter unicodeTranscodeToOut*(op: UnicodeTranscode): ostring {.inline.} = return op.output

type SubstrT* = oint32 | oint64

type Substr* {.header:"../tensorflow/ops/generated.h", importcpp:"Substr/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iisubstr(scope: Scope,
             input: ostring,
             pos: SubstrT,
             len: SubstrT,
             unit: cstring): Substr {.header:"../tensorflow/ops/generated.h", importcpp:"Substr(*#, #, #, #, tensorflow::string(#))", constructor.}

proc substr*(scope: Scope,
             input: ostring,
             pos: SubstrT,
             len: SubstrT,
             unit: cstring = "BYTE"): Substr =
  return iisubstr(scope,
                  input,
                  pos,
                  len,
                  unit)

converter substrToOut*(op: Substr): ostring {.inline.} = return op.output


type DecodeBase64* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeBase64/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iidecodeBase64(scope: Scope,
                   input: ostring): DecodeBase64 {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeBase64(*#, #)", constructor.}

proc decodeBase64*(scope: Scope,
                   input: ostring): DecodeBase64 =
  return iidecodeBase64(scope,
                        input)

converter decodeBase64ToOut*(op: DecodeBase64): ostring {.inline.} = return op.output


type EncodeBase64* {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeBase64/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiencodeBase64(scope: Scope,
                   input: ostring,
                   pad: bool): EncodeBase64 {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeBase64(*#, #, #)", constructor.}

proc encodeBase64*(scope: Scope,
                   input: ostring,
                   pad: bool = false): EncodeBase64 =
  return iiencodeBase64(scope,
                        input,
                        pad)

converter encodeBase64ToOut*(op: EncodeBase64): ostring {.inline.} = return op.output


type StringSplit* {.header:"../tensorflow/ops/generated.h", importcpp:"StringSplit/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iistringSplit(scope: Scope,
                  input: ostring,
                  delimiter: ostring,
                  skip_empty: bool): StringSplit {.header:"../tensorflow/ops/generated.h", importcpp:"StringSplit(*#, #, #, #)", constructor.}

proc stringSplit*(scope: Scope,
                  input: ostring,
                  delimiter: ostring,
                  skip_empty: bool = true): StringSplit =
  return iistringSplit(scope,
                       input,
                       delimiter,
                       skip_empty)

converter stringSplitToOut*(op: StringSplit): oint64 {.inline.} = return op.output


type StringJoin* {.header:"../tensorflow/ops/generated.h", importcpp:"StringJoin/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iistringJoin(scope: Scope,
                 inputs: olist[ostring],
                 separator: cstring): StringJoin {.header:"../tensorflow/ops/generated.h", importcpp:"StringJoin(*#, #, tensorflow::string(#))", constructor.}

proc stringJoin*(scope: Scope,
                 inputs: olist[ostring],
                 separator: cstring): StringJoin =
  return iistringJoin(scope,
                      inputs,
                      separator)

converter stringJoinToOut*(op: StringJoin): ostring {.inline.} = return op.output


type ReduceJoin* {.header:"../tensorflow/ops/generated.h", importcpp:"ReduceJoin/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireduceJoin(scope: Scope,
                 inputs: ostring,
                 reduction_indices: oint32,
                 separator: cstring,
                 keep_dims: bool): ReduceJoin {.header:"../tensorflow/ops/generated.h", importcpp:"ReduceJoin(*#, #, #, tensorflow::string(#), #)", constructor.}

proc reduceJoin*(scope: Scope,
                 inputs: ostring,
                 reduction_indices: oint32,
                 separator: cstring,
                 keep_dims: bool = false): ReduceJoin =
  return iireduceJoin(scope,
                      inputs,
                      reduction_indices,
                      separator,
                      keep_dims)

converter reduceJoinToOut*(op: ReduceJoin): ostring {.inline.} = return op.output


type StringToHashBucketFast* {.header:"../tensorflow/ops/generated.h", importcpp:"StringToHashBucketFast/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iistringToHashBucketFast(scope: Scope,
                             input: ostring,
                             num_buckets: int64): StringToHashBucketFast {.header:"../tensorflow/ops/generated.h", importcpp:"StringToHashBucketFast(*#, #, #)", constructor.}

proc stringToHashBucketFast*(scope: Scope,
                             input: ostring,
                             num_buckets: int64 = 0.int): StringToHashBucketFast =
  return iistringToHashBucketFast(scope,
                                  input,
                                  num_buckets)

converter stringToHashBucketFastToOut*(op: StringToHashBucketFast): oint64 {.inline.} = return op.output


type StaticRegexReplace* {.header:"../tensorflow/ops/generated.h", importcpp:"StaticRegexReplace/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iistaticRegexReplace(scope: Scope,
                         input: ostring,
                         pattern: cstring,
                         rewrite: cstring,
                         replace_global: bool): StaticRegexReplace {.header:"../tensorflow/ops/generated.h", importcpp:"StaticRegexReplace(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc staticRegexReplace*(scope: Scope,
                         input: ostring,
                         pattern: cstring,
                         rewrite: cstring,
                         replace_global: bool = true): StaticRegexReplace =
  return iistaticRegexReplace(scope,
                              input,
                              pattern,
                              rewrite,
                              replace_global)

converter staticRegexReplaceToOut*(op: StaticRegexReplace): ostring {.inline.} = return op.output


type RegexReplace* {.header:"../tensorflow/ops/generated.h", importcpp:"RegexReplace/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiregexReplace(scope: Scope,
                   input: ostring,
                   pattern: ostring,
                   rewrite: ostring,
                   replace_global: bool): RegexReplace {.header:"../tensorflow/ops/generated.h", importcpp:"RegexReplace(*#, #, #, #, #)", constructor.}

proc regexReplace*(scope: Scope,
                   input: ostring,
                   pattern: ostring,
                   rewrite: ostring,
                   replace_global: bool = true): RegexReplace =
  return iiregexReplace(scope,
                        input,
                        pattern,
                        rewrite,
                        replace_global)

converter regexReplaceToOut*(op: RegexReplace): ostring {.inline.} = return op.output

type StatelessMultinomialT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type StatelessMultinomialTseed* = oint32 | oint64

type StatelessMultinomial*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessMultinomial/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistatelessMultinomial[oT: oall](scope: Scope,
                           logits: StatelessMultinomialT,
                           num_samples: oint32,
                           seed: StatelessMultinomialTseed,
                           output_dtype: DType,
                           explicitT: type(oT)): StatelessMultinomial[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessMultinomial(*#, #, #, #, #)", constructor.}

proc statelessMultinomial*(scope: Scope,
                           logits: StatelessMultinomialT,
                           num_samples: oint32,
                           seed: StatelessMultinomialTseed,
                           output_dtype: type = oint64): auto =
  return iistatelessMultinomial(scope,
                                logits,
                                num_samples,
                                seed,
                                output_dtype[].oTF,
                                output_dtype)

converter statelessMultinomialToOut*[oT: oall](op: StatelessMultinomial[oT]): oT {.inline.} = return op.output

type StatelessRandomUniformIntT* = oint32 | oint64
type StatelessRandomUniformIntTseed* = oint32 | oint64

type StatelessRandomUniformInt*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessRandomUniformInt/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistatelessRandomUniformInt[oT: oall](scope: Scope,
                                shape: StatelessRandomUniformIntT,
                                seed: StatelessRandomUniformIntTseed,
                                minval: oT,
                                maxval: oT,
                                dtype: DType): StatelessRandomUniformInt[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessRandomUniformInt(*#, #, #, #, #, #)", constructor.}

proc statelessRandomUniformInt*[oT: oall](scope: Scope,
                                shape: StatelessRandomUniformIntT,
                                seed: StatelessRandomUniformIntTseed,
                                minval: oT,
                                maxval: oT): StatelessRandomUniformInt[oT] =
  return iistatelessRandomUniformInt(scope,
                                     shape,
                                     seed,
                                     minval,
                                     maxval,
                                     oT[].oTF)

converter statelessRandomUniformIntToOut*[oT: oall](op: StatelessRandomUniformInt[oT]): oT {.inline.} = return op.output

type StatelessRandomNormalT* = oint32 | oint64
type StatelessRandomNormalTseed* = oint32 | oint64

type StatelessRandomNormal*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessRandomNormal/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistatelessRandomNormal[oT: oall](scope: Scope,
                            shape: StatelessRandomNormalT,
                            seed: StatelessRandomNormalTseed,
                            dtype: DType,
                            explicitT: type(oT)): StatelessRandomNormal[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessRandomNormal(*#, #, #, #)", constructor.}

proc statelessRandomNormal*(scope: Scope,
                            shape: StatelessRandomNormalT,
                            seed: StatelessRandomNormalTseed,
                            dtype: type = ofloat): auto =
  return iistatelessRandomNormal(scope,
                                 shape,
                                 seed,
                                 dtype[].oTF,
                                 dtype)

converter statelessRandomNormalToOut*[oT: oall](op: StatelessRandomNormal[oT]): oT {.inline.} = return op.output

type StatelessRandomUniformT* = oint32 | oint64
type StatelessRandomUniformTseed* = oint32 | oint64

type StatelessRandomUniform*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessRandomUniform/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistatelessRandomUniform[oT: oall](scope: Scope,
                             shape: StatelessRandomUniformT,
                             seed: StatelessRandomUniformTseed,
                             dtype: DType,
                             explicitT: type(oT)): StatelessRandomUniform[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessRandomUniform(*#, #, #, #)", constructor.}

proc statelessRandomUniform*(scope: Scope,
                             shape: StatelessRandomUniformT,
                             seed: StatelessRandomUniformTseed,
                             dtype: type = ofloat): auto =
  return iistatelessRandomUniform(scope,
                                  shape,
                                  seed,
                                  dtype[].oTF,
                                  dtype)

converter statelessRandomUniformToOut*[oT: oall](op: StatelessRandomUniform[oT]): oT {.inline.} = return op.output


type CountUpTo*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CountUpTo/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicountUpTo[oT: oall](scope: Scope,
                nref: oT,
                limit: int64,
                T: DType): CountUpTo[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CountUpTo(*#, #, #, #)", constructor.}

proc countUpTo*[oT: oall](scope: Scope,
                nref: oT,
                limit: int64 = 0.int): CountUpTo[oT] =
  return iicountUpTo(scope,
                     nref,
                     limit,
                     oT[].oTF)

converter countUpToToOut*[oT: oall](op: CountUpTo[oT]): oT {.inline.} = return op.output

type ResourceScatterNdUpdateT* = oall
type ResourceScatterNdUpdateTindices* = oint32 | oint64

type ResourceScatterNdUpdate*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterNdUpdate/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterNdUpdate(scope: Scope,
                              nref: oresource,
                              indices: ResourceScatterNdUpdateTindices,
                              updates: ResourceScatterNdUpdateT,
                              use_locking: bool): ResourceScatterNdUpdate {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterNdUpdate(*#, #, #, #, #)", constructor.}

proc resourceScatterNdUpdate*(scope: Scope,
                              nref: oresource,
                              indices: ResourceScatterNdUpdateTindices,
                              updates: ResourceScatterNdUpdateT,
                              use_locking: bool = true): ResourceScatterNdUpdate =
  return iiresourceScatterNdUpdate(scope,
                                   nref,
                                   indices,
                                   updates,
                                   use_locking)



type ScatterNdUpdateTindices* = oint32 | oint64

type ScatterNdUpdate*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdUpdate/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterNdUpdate[oT: oall](scope: Scope,
                      nref: oT,
                      indices: ScatterNdUpdateTindices,
                      updates: oT,
                      T: DType,
                      use_locking: bool): ScatterNdUpdate[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdUpdate(*#, #, #, #, #, #)", constructor.}

proc scatterNdUpdate*[oT: oall](scope: Scope,
                      nref: oT,
                      indices: ScatterNdUpdateTindices,
                      updates: oT,
                      use_locking: bool = true): ScatterNdUpdate[oT] =
  return iiscatterNdUpdate(scope,
                           nref,
                           indices,
                           updates,
                           oT[].oTF,
                           use_locking)

converter scatterNdUpdateToOut*[oT: oall](op: ScatterNdUpdate[oT]): oT {.inline.} = return op.output

type ScatterMaxTindices* = oint32 | oint64

type ScatterMax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterMax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterMax[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterMaxTindices,
                 updates: oT,
                 T: DType,
                 use_locking: bool): ScatterMax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterMax(*#, #, #, #, #, #)", constructor.}

proc scatterMax*[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterMaxTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterMax[oT] =
  return iiscatterMax(scope,
                      nref,
                      indices,
                      updates,
                      oT[].oTF,
                      use_locking)

converter scatterMaxToOut*[oT: oall](op: ScatterMax[oT]): oT {.inline.} = return op.output

type ScatterMulTindices* = oint32 | oint64

type ScatterMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterMul[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterMulTindices,
                 updates: oT,
                 T: DType,
                 use_locking: bool): ScatterMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterMul(*#, #, #, #, #, #)", constructor.}

proc scatterMul*[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterMulTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterMul[oT] =
  return iiscatterMul(scope,
                      nref,
                      indices,
                      updates,
                      oT[].oTF,
                      use_locking)

converter scatterMulToOut*[oT: oall](op: ScatterMul[oT]): oT {.inline.} = return op.output

type ScatterSubTindices* = oint32 | oint64

type ScatterSub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterSub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterSub[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterSubTindices,
                 updates: oT,
                 T: DType,
                 use_locking: bool): ScatterSub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterSub(*#, #, #, #, #, #)", constructor.}

proc scatterSub*[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterSubTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterSub[oT] =
  return iiscatterSub(scope,
                      nref,
                      indices,
                      updates,
                      oT[].oTF,
                      use_locking)

converter scatterSubToOut*[oT: oall](op: ScatterSub[oT]): oT {.inline.} = return op.output

type ScatterAddTindices* = oint32 | oint64

type ScatterAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterAdd[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterAddTindices,
                 updates: oT,
                 T: DType,
                 use_locking: bool): ScatterAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterAdd(*#, #, #, #, #, #)", constructor.}

proc scatterAdd*[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterAddTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterAdd[oT] =
  return iiscatterAdd(scope,
                      nref,
                      indices,
                      updates,
                      oT[].oTF,
                      use_locking)

converter scatterAddToOut*[oT: oall](op: ScatterAdd[oT]): oT {.inline.} = return op.output

type ScatterUpdateTindices* = oint32 | oint64

type ScatterUpdate*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterUpdate/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterUpdate[oT: oall](scope: Scope,
                    nref: oT,
                    indices: ScatterUpdateTindices,
                    updates: oT,
                    T: DType,
                    use_locking: bool): ScatterUpdate[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterUpdate(*#, #, #, #, #, #)", constructor.}

proc scatterUpdate*[oT: oall](scope: Scope,
                    nref: oT,
                    indices: ScatterUpdateTindices,
                    updates: oT,
                    use_locking: bool = true): ScatterUpdate[oT] =
  return iiscatterUpdate(scope,
                         nref,
                         indices,
                         updates,
                         oT[].oTF,
                         use_locking)

converter scatterUpdateToOut*[oT: oall](op: ScatterUpdate[oT]): oT {.inline.} = return op.output


type AssignSub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AssignSub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiassignSub[oT: oall](scope: Scope,
                nref: oT,
                value: oT,
                T: DType,
                use_locking: bool): AssignSub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AssignSub(*#, #, #, #, #)", constructor.}

proc assignSub*[oT: oall](scope: Scope,
                nref: oT,
                value: oT,
                use_locking: bool = false): AssignSub[oT] =
  return iiassignSub(scope,
                     nref,
                     value,
                     oT[].oTF,
                     use_locking)

converter assignSubToOut*[oT: oall](op: AssignSub[oT]): oT {.inline.} = return op.output


type Assign*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Assign/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiassign[oT: oall](scope: Scope,
             nref: oT,
             value: oT,
             T: DType,
             validate_shape: bool,
             use_locking: bool): Assign[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Assign(*#, #, #, #, #, #)", constructor.}

proc assign*[oT: oall](scope: Scope,
             nref: oT,
             value: oT,
             validate_shape: bool = true,
             use_locking: bool = true): Assign[oT] =
  return iiassign(scope,
                  nref,
                  value,
                  oT[].oTF,
                  validate_shape,
                  use_locking)

converter assignToOut*[oT: oall](op: Assign[oT]): oT {.inline.} = return op.output


type DestroyTemporaryVariable*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DestroyTemporaryVariable/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidestroyTemporaryVariable[oT: oall](scope: Scope,
                               nref: oT,
                               var_name: cstring,
                               T: DType): DestroyTemporaryVariable[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DestroyTemporaryVariable(*#, #, tensorflow::string(#), #)", constructor.}

proc destroyTemporaryVariable*[oT: oall](scope: Scope,
                               nref: oT,
                               var_name: cstring): DestroyTemporaryVariable[oT] =
  return iidestroyTemporaryVariable(scope,
                                    nref,
                                    var_name,
                                    oT[].oTF)

converter destroyTemporaryVariableToOut*[oT: oall](op: DestroyTemporaryVariable[oT]): oT {.inline.} = return op.output


type TemporaryVariable*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TemporaryVariable/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitemporaryVariable[oT: oall](scope: Scope,
                        var_name: cstring,
                        shape: TensorShape,
                        dtype: DType,
                        explicitT: type(oT)): TemporaryVariable[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TemporaryVariable(*#, tensorflow::string(#), #, #)", constructor.}

proc temporaryVariable*(scope: Scope,
                        var_name: cstring,
                        shape: TensorShape = [].shape,
                        dtype: type = oinvalid): auto =
  return iitemporaryVariable(scope,
                             var_name,
                             shape,
                             dtype[].oTF,
                             dtype)

converter temporaryVariableToOut*[oT: oall](op: TemporaryVariable[oT]): oT {.inline.} = return op.output

type IsVariableInitializeddtype* = oall

type IsVariableInitialized* {.header:"../tensorflow/ops/generated.h", importcpp:"IsVariableInitialized/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiisVariableInitialized(scope: Scope,
                            nref: IsVariableInitializeddtype): IsVariableInitialized {.header:"../tensorflow/ops/generated.h", importcpp:"IsVariableInitialized(*#, #)", constructor.}

proc isVariableInitialized*(scope: Scope,
                            nref: IsVariableInitializeddtype): IsVariableInitialized =
  return iiisVariableInitialized(scope,
                                 nref)

converter isVariableInitializedToOut*(op: IsVariableInitialized): obool {.inline.} = return op.output


type VariableV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"VariableV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iivariableV2[oT: oall](scope: Scope,
                 container: cstring,
                 shared_name: cstring,
                 shape: TensorShape,
                 dtype: DType,
                 explicitT: type(oT)): VariableV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"VariableV2(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc variableV2*(scope: Scope,
                 container: cstring,
                 shared_name: cstring,
                 shape: TensorShape = [].shape,
                 dtype: type = oinvalid): auto =
  return iivariableV2(scope,
                      container,
                      shared_name,
                      shape,
                      dtype[].oTF,
                      dtype)

converter variableV2ToOut*[oT: oall](op: VariableV2[oT]): oT {.inline.} = return op.output


type BatchFFT2D* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFFT2D/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iibatchFFT2D(scope: Scope,
                 input: ocomplex64): BatchFFT2D {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFFT2D(*#, #)", constructor.}

proc batchFFT2D*(scope: Scope,
                 input: ocomplex64): BatchFFT2D =
  return iibatchFFT2D(scope,
                      input)

converter batchFFT2DToOut*(op: BatchFFT2D): ocomplex64 {.inline.} = return op.output


type BatchFFT* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFFT/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iibatchFFT(scope: Scope,
               input: ocomplex64): BatchFFT {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFFT(*#, #)", constructor.}

proc batchFFT*(scope: Scope,
               input: ocomplex64): BatchFFT =
  return iibatchFFT(scope,
                    input)

converter batchFFTToOut*(op: BatchFFT): ocomplex64 {.inline.} = return op.output


type IRFFT3D* {.header:"../tensorflow/ops/generated.h", importcpp:"IRFFT3D/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiiRFFT3D(scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT3D {.header:"../tensorflow/ops/generated.h", importcpp:"IRFFT3D(*#, #, #)", constructor.}

proc iRFFT3D*(scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT3D =
  return iiiRFFT3D(scope,
                   input,
                   fft_length)

converter iRFFT3DToOut*(op: IRFFT3D): ofloat {.inline.} = return op.output


type IRFFT2D* {.header:"../tensorflow/ops/generated.h", importcpp:"IRFFT2D/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiiRFFT2D(scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT2D {.header:"../tensorflow/ops/generated.h", importcpp:"IRFFT2D(*#, #, #)", constructor.}

proc iRFFT2D*(scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT2D =
  return iiiRFFT2D(scope,
                   input,
                   fft_length)

converter iRFFT2DToOut*(op: IRFFT2D): ofloat {.inline.} = return op.output


type RFFT2D* {.header:"../tensorflow/ops/generated.h", importcpp:"RFFT2D/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iirFFT2D(scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT2D {.header:"../tensorflow/ops/generated.h", importcpp:"RFFT2D(*#, #, #)", constructor.}

proc rFFT2D*(scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT2D =
  return iirFFT2D(scope,
                  input,
                  fft_length)

converter rFFT2DToOut*(op: RFFT2D): ocomplex64 {.inline.} = return op.output


type IRFFT* {.header:"../tensorflow/ops/generated.h", importcpp:"IRFFT/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiiRFFT(scope: Scope,
            input: ocomplex64,
            fft_length: oint32): IRFFT {.header:"../tensorflow/ops/generated.h", importcpp:"IRFFT(*#, #, #)", constructor.}

proc iRFFT*(scope: Scope,
            input: ocomplex64,
            fft_length: oint32): IRFFT =
  return iiiRFFT(scope,
                 input,
                 fft_length)

converter iRFFTToOut*(op: IRFFT): ofloat {.inline.} = return op.output


type RFFT* {.header:"../tensorflow/ops/generated.h", importcpp:"RFFT/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iirFFT(scope: Scope,
           input: ofloat,
           fft_length: oint32): RFFT {.header:"../tensorflow/ops/generated.h", importcpp:"RFFT(*#, #, #)", constructor.}

proc rFFT*(scope: Scope,
           input: ofloat,
           fft_length: oint32): RFFT =
  return iirFFT(scope,
                input,
                fft_length)

converter rFFTToOut*(op: RFFT): ocomplex64 {.inline.} = return op.output


type FFT3D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FFT3D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifFT3D[oT: oall](scope: Scope,
            input: oT,
            Tcomplex: DType): FFT3D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FFT3D(*#, #, #)", constructor.}

proc fFT3D*[oT: oall](scope: Scope,
            input: oT): FFT3D[oT] =
  return iifFT3D(scope,
                 input,
                 oT[].oTF)

converter fFT3DToOut*[oT: oall](op: FFT3D[oT]): oT {.inline.} = return op.output


type IFFT2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IFFT2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiFFT2D[oT: oall](scope: Scope,
             input: oT,
             Tcomplex: DType): IFFT2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IFFT2D(*#, #, #)", constructor.}

proc iFFT2D*[oT: oall](scope: Scope,
             input: oT): IFFT2D[oT] =
  return iiiFFT2D(scope,
                  input,
                  oT[].oTF)

converter iFFT2DToOut*[oT: oall](op: IFFT2D[oT]): oT {.inline.} = return op.output


type FFT2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FFT2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifFT2D[oT: oall](scope: Scope,
            input: oT,
            Tcomplex: DType): FFT2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FFT2D(*#, #, #)", constructor.}

proc fFT2D*[oT: oall](scope: Scope,
            input: oT): FFT2D[oT] =
  return iifFT2D(scope,
                 input,
                 oT[].oTF)

converter fFT2DToOut*[oT: oall](op: FFT2D[oT]): oT {.inline.} = return op.output


type IFFT*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IFFT/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiFFT[oT: oall](scope: Scope,
           input: oT,
           Tcomplex: DType): IFFT[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IFFT(*#, #, #)", constructor.}

proc iFFT*[oT: oall](scope: Scope,
           input: oT): IFFT[oT] =
  return iiiFFT(scope,
                input,
                oT[].oTF)

converter iFFTToOut*[oT: oall](op: IFFT[oT]): oT {.inline.} = return op.output


type FFT*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FFT/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifFT[oT: oall](scope: Scope,
          input: oT,
          Tcomplex: DType): FFT[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FFT(*#, #, #)", constructor.}

proc fFT*[oT: oall](scope: Scope,
          input: oT): FFT[oT] =
  return iifFT(scope,
               input,
               oT[].oTF)

converter fFTToOut*[oT: oall](op: FFT[oT]): oT {.inline.} = return op.output

type WriteScalarSummaryT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type WriteScalarSummary*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteScalarSummary/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteScalarSummary(scope: Scope,
                         writer: oresource,
                         step: oint64,
                         tag: ostring,
                         value: WriteScalarSummaryT): WriteScalarSummary {.header:"../tensorflow/ops/generated.h", importcpp:"WriteScalarSummary(*#, #, #, #, #)", constructor.}

proc writeScalarSummary*(scope: Scope,
                         writer: oresource,
                         step: oint64,
                         tag: ostring,
                         value: WriteScalarSummaryT): WriteScalarSummary =
  return iiwriteScalarSummary(scope,
                              writer,
                              step,
                              tag,
                              value)




type CloseSummaryWriter*{.header:"../tensorflow/ops/generated.h", importcpp:"CloseSummaryWriter/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iicloseSummaryWriter(scope: Scope,
                         writer: oresource): CloseSummaryWriter {.header:"../tensorflow/ops/generated.h", importcpp:"CloseSummaryWriter(*#, #)", constructor.}

proc closeSummaryWriter*(scope: Scope,
                         writer: oresource): CloseSummaryWriter =
  return iicloseSummaryWriter(scope,
                              writer)




type FlushSummaryWriter*{.header:"../tensorflow/ops/generated.h", importcpp:"FlushSummaryWriter/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiflushSummaryWriter(scope: Scope,
                         writer: oresource): FlushSummaryWriter {.header:"../tensorflow/ops/generated.h", importcpp:"FlushSummaryWriter(*#, #)", constructor.}

proc flushSummaryWriter*(scope: Scope,
                         writer: oresource): FlushSummaryWriter =
  return iiflushSummaryWriter(scope,
                              writer)




type CreateSummaryDbWriter*{.header:"../tensorflow/ops/generated.h", importcpp:"CreateSummaryDbWriter/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iicreateSummaryDbWriter(scope: Scope,
                            writer: oresource,
                            db_uri: ostring,
                            experiment_name: ostring,
                            run_name: ostring,
                            user_name: ostring): CreateSummaryDbWriter {.header:"../tensorflow/ops/generated.h", importcpp:"CreateSummaryDbWriter(*#, #, #, #, #, #)", constructor.}

proc createSummaryDbWriter*(scope: Scope,
                            writer: oresource,
                            db_uri: ostring,
                            experiment_name: ostring,
                            run_name: ostring,
                            user_name: ostring): CreateSummaryDbWriter =
  return iicreateSummaryDbWriter(scope,
                                 writer,
                                 db_uri,
                                 experiment_name,
                                 run_name,
                                 user_name)




type SummaryWriter* {.header:"../tensorflow/ops/generated.h", importcpp:"SummaryWriter/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iisummaryWriter(scope: Scope,
                    shared_name: cstring,
                    container: cstring): SummaryWriter {.header:"../tensorflow/ops/generated.h", importcpp:"SummaryWriter(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc summaryWriter*(scope: Scope,
                    shared_name: cstring,
                    container: cstring): SummaryWriter =
  return iisummaryWriter(scope,
                         shared_name,
                         container)

converter summaryWriterToOut*(op: SummaryWriter): oresource {.inline.} = return op.output


type SparseFillEmptyRowsGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseFillEmptyRowsGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseFillEmptyRowsGrad[oT: oall](scope: Scope,
                              reverse_index_map: oint64,
                              grad_values: oT,
                              T: DType): SparseFillEmptyRowsGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseFillEmptyRowsGrad(*#, #, #, #)", constructor.}

proc sparseFillEmptyRowsGrad*[oT: oall](scope: Scope,
                              reverse_index_map: oint64,
                              grad_values: oT): SparseFillEmptyRowsGrad[oT] =
  return iisparseFillEmptyRowsGrad(scope,
                                   reverse_index_map,
                                   grad_values,
                                   oT[].oTF)

converter sparseFillEmptyRowsGradToOut*[oT: oall](op: SparseFillEmptyRowsGrad[oT]): oT {.inline.} = return op.output

type SparseFillEmptyRowsT* = oall

type SparseFillEmptyRows* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseFillEmptyRows/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseFillEmptyRows(scope: Scope,
                          indices: oint64,
                          values: SparseFillEmptyRowsT,
                          dense_shape: oint64,
                          default_value: SparseFillEmptyRowsT): SparseFillEmptyRows {.header:"../tensorflow/ops/generated.h", importcpp:"SparseFillEmptyRows(*#, #, #, #, #)", constructor.}

proc sparseFillEmptyRows*(scope: Scope,
                          indices: oint64,
                          values: SparseFillEmptyRowsT,
                          dense_shape: oint64,
                          default_value: SparseFillEmptyRowsT): SparseFillEmptyRows =
  return iisparseFillEmptyRows(scope,
                               indices,
                               values,
                               dense_shape,
                               default_value)

converter sparseFillEmptyRowsToOut*(op: SparseFillEmptyRows): oint64 {.inline.} = return op.output

type SparseSparseMinimumT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseSparseMinimum* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSparseMinimum/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseSparseMinimum(scope: Scope,
                          a_indices: oint64,
                          a_values: SparseSparseMinimumT,
                          a_shape: oint64,
                          b_indices: oint64,
                          b_values: SparseSparseMinimumT,
                          b_shape: oint64): SparseSparseMinimum {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSparseMinimum(*#, #, #, #, #, #, #)", constructor.}

proc sparseSparseMinimum*(scope: Scope,
                          a_indices: oint64,
                          a_values: SparseSparseMinimumT,
                          a_shape: oint64,
                          b_indices: oint64,
                          b_values: SparseSparseMinimumT,
                          b_shape: oint64): SparseSparseMinimum =
  return iisparseSparseMinimum(scope,
                               a_indices,
                               a_values,
                               a_shape,
                               b_indices,
                               b_values,
                               b_shape)

converter sparseSparseMinimumToOut*(op: SparseSparseMinimum): oint64 {.inline.} = return op.output

type SparseSparseMaximumT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseSparseMaximum* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSparseMaximum/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseSparseMaximum(scope: Scope,
                          a_indices: oint64,
                          a_values: SparseSparseMaximumT,
                          a_shape: oint64,
                          b_indices: oint64,
                          b_values: SparseSparseMaximumT,
                          b_shape: oint64): SparseSparseMaximum {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSparseMaximum(*#, #, #, #, #, #, #)", constructor.}

proc sparseSparseMaximum*(scope: Scope,
                          a_indices: oint64,
                          a_values: SparseSparseMaximumT,
                          a_shape: oint64,
                          b_indices: oint64,
                          b_values: SparseSparseMaximumT,
                          b_shape: oint64): SparseSparseMaximum =
  return iisparseSparseMaximum(scope,
                               a_indices,
                               a_values,
                               a_shape,
                               b_indices,
                               b_values,
                               b_shape)

converter sparseSparseMaximumToOut*(op: SparseSparseMaximum): oint64 {.inline.} = return op.output


type SparseSoftmax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSoftmax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSoftmax[oT: oall](scope: Scope,
                    sp_indices: oint64,
                    sp_values: oT,
                    sp_shape: oint64,
                    T: DType): SparseSoftmax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSoftmax(*#, #, #, #, #)", constructor.}

proc sparseSoftmax*[oT: oall](scope: Scope,
                    sp_indices: oint64,
                    sp_values: oT,
                    sp_shape: oint64): SparseSoftmax[oT] =
  return iisparseSoftmax(scope,
                         sp_indices,
                         sp_values,
                         sp_shape,
                         oT[].oTF)

converter sparseSoftmaxToOut*[oT: oall](op: SparseSoftmax[oT]): oT {.inline.} = return op.output


type SparseDenseCwiseAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseDenseCwiseAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseDenseCwiseAdd[oT: oall](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT,
                          T: DType): SparseDenseCwiseAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseDenseCwiseAdd(*#, #, #, #, #, #)", constructor.}

proc sparseDenseCwiseAdd*[oT: oall](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseAdd[oT] =
  return iisparseDenseCwiseAdd(scope,
                               sp_indices,
                               sp_values,
                               sp_shape,
                               dense,
                               oT[].oTF)

converter sparseDenseCwiseAddToOut*[oT: oall](op: SparseDenseCwiseAdd[oT]): oT {.inline.} = return op.output


type SparseDenseCwiseDiv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseDenseCwiseDiv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseDenseCwiseDiv[oT: oall](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT,
                          T: DType): SparseDenseCwiseDiv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseDenseCwiseDiv(*#, #, #, #, #, #)", constructor.}

proc sparseDenseCwiseDiv*[oT: oall](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseDiv[oT] =
  return iisparseDenseCwiseDiv(scope,
                               sp_indices,
                               sp_values,
                               sp_shape,
                               dense,
                               oT[].oTF)

converter sparseDenseCwiseDivToOut*[oT: oall](op: SparseDenseCwiseDiv[oT]): oT {.inline.} = return op.output


type SparseReduceMax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceMax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseReduceMax[oT: oall](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool,
                      T: DType): SparseReduceMax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceMax(*#, #, #, #, #, #, #)", constructor.}

proc sparseReduceMax*[oT: oall](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool = false): SparseReduceMax[oT] =
  return iisparseReduceMax(scope,
                           input_indices,
                           input_values,
                           input_shape,
                           reduction_axes,
                           keep_dims,
                           oT[].oTF)

converter sparseReduceMaxToOut*[oT: oall](op: SparseReduceMax[oT]): oT {.inline.} = return op.output


type SparseReshape* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReshape/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseReshape(scope: Scope,
                    input_indices: oint64,
                    input_shape: oint64,
                    new_shape: oint64): SparseReshape {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReshape(*#, #, #, #)", constructor.}

proc sparseReshape*(scope: Scope,
                    input_indices: oint64,
                    input_shape: oint64,
                    new_shape: oint64): SparseReshape =
  return iisparseReshape(scope,
                         input_indices,
                         input_shape,
                         new_shape)

converter sparseReshapeToOut*(op: SparseReshape): oint64 {.inline.} = return op.output

type SparseReorderT* = oall

type SparseReorder* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReorder/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseReorder(scope: Scope,
                    input_indices: oint64,
                    input_values: SparseReorderT,
                    input_shape: oint64): SparseReorder {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReorder(*#, #, #, #)", constructor.}

proc sparseReorder*(scope: Scope,
                    input_indices: oint64,
                    input_values: SparseReorderT,
                    input_shape: oint64): SparseReorder =
  return iisparseReorder(scope,
                         input_indices,
                         input_values,
                         input_shape)

converter sparseReorderToOut*(op: SparseReorder): oint64 {.inline.} = return op.output

type SparseSliceT* = oall

type SparseSlice* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSlice/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseSlice(scope: Scope,
                  indices: oint64,
                  values: SparseSliceT,
                  shape: oint64,
                  start: oint64,
                  size: oint64): SparseSlice {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSlice(*#, #, #, #, #, #)", constructor.}

proc sparseSlice*(scope: Scope,
                  indices: oint64,
                  values: SparseSliceT,
                  shape: oint64,
                  start: oint64,
                  size: oint64): SparseSlice =
  return iisparseSlice(scope,
                       indices,
                       values,
                       shape,
                       start,
                       size)

converter sparseSliceToOut*(op: SparseSlice): oint64 {.inline.} = return op.output


type SparseSliceGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSliceGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSliceGrad[oT: oall](scope: Scope,
                      backprop_val_grad: oT,
                      input_indices: oint64,
                      input_start: oint64,
                      output_indices: oint64,
                      T: DType): SparseSliceGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSliceGrad(*#, #, #, #, #, #)", constructor.}

proc sparseSliceGrad*[oT: oall](scope: Scope,
                      backprop_val_grad: oT,
                      input_indices: oint64,
                      input_start: oint64,
                      output_indices: oint64): SparseSliceGrad[oT] =
  return iisparseSliceGrad(scope,
                           backprop_val_grad,
                           input_indices,
                           input_start,
                           output_indices,
                           oT[].oTF)

converter sparseSliceGradToOut*[oT: oall](op: SparseSliceGrad[oT]): oT {.inline.} = return op.output


type SparseCross* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseCross/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseCross(scope: Scope,
                  indices: olist[oint64],
                  values: olist[oall],
                  shapes: olist[oint64],
                  dense_inputs: olist[oall],
                  sparse_types: ArraySlice[DType],
                  dense_types: ArraySlice[DType],
                  hashed_output: bool,
                  num_buckets: int64,
                  hash_key: int64,
                  out_type: DType,
                  internal_type: DType): SparseCross {.header:"../tensorflow/ops/generated.h", importcpp:"SparseCross(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseCross*(scope: Scope,
                  indices: olist[oint64],
                  values: olist[oall],
                  shapes: olist[oint64],
                  dense_inputs: olist[oall],
                  sparse_types: openArray[DType],
                  dense_types: openArray[DType],
                  hashed_output: bool = false,
                  num_buckets: int64 = 0.int,
                  hash_key: int64 = 0.int,
                  out_type: type(oint64) | type(ostring) = oinvalid,
                  internal_type: type(oint64) | type(ostring) = oinvalid): SparseCross =
  return iisparseCross(scope,
                       indices,
                       values,
                       shapes,
                       dense_inputs,
                       newArraySlice(sparse_types),
                       newArraySlice(dense_types),
                       hashed_output,
                       num_buckets,
                       hash_key,
                       oT[].oTF,
                       oT[].oTF)

converter sparseCrossToOut*(op: SparseCross): oint64 {.inline.} = return op.output

type SparseConcatT* = oall

type SparseConcat* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseConcat/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseConcat(scope: Scope,
                   indices: olist[oint64],
                   values: olist[SparseConcatT],
                   shapes: olist[oint64],
                   concat_dim: int64): SparseConcat {.header:"../tensorflow/ops/generated.h", importcpp:"SparseConcat(*#, #, #, #, #)", constructor.}

proc sparseConcat*(scope: Scope,
                   indices: olist[oint64],
                   values: olist[SparseConcatT],
                   shapes: olist[oint64],
                   concat_dim: int64 = 0.int): SparseConcat =
  return iisparseConcat(scope,
                        indices,
                        values,
                        shapes,
                        concat_dim)

converter sparseConcatToOut*(op: SparseConcat): oint64 {.inline.} = return op.output


type DeserializeManySparse* {.header:"../tensorflow/ops/generated.h", importcpp:"DeserializeManySparse/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iideserializeManySparse(scope: Scope,
                            serialized_sparse: ostring,
                            dtype: DType): DeserializeManySparse {.header:"../tensorflow/ops/generated.h", importcpp:"DeserializeManySparse(*#, #, #)", constructor.}

proc deserializeManySparse*(scope: Scope,
                            serialized_sparse: ostring,
                            dtype: type oall = oinvalid): DeserializeManySparse =
  return iideserializeManySparse(scope,
                                 serialized_sparse,
                                 oT[].oTF)

converter deserializeManySparseToOut*(op: DeserializeManySparse): oint64 {.inline.} = return op.output

type SerializeManySparseT* = oall

type SerializeManySparse*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeManySparse/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiserializeManySparse[oT: oall](scope: Scope,
                          sparse_indices: oint64,
                          sparse_values: SerializeManySparseT,
                          sparse_shape: oint64,
                          out_type: DType,
                          explicitT: type(oT)): SerializeManySparse[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeManySparse(*#, #, #, #, #)", constructor.}

proc serializeManySparse*(scope: Scope,
                          sparse_indices: oint64,
                          sparse_values: SerializeManySparseT,
                          sparse_shape: oint64,
                          out_type: type = ostring): auto =
  return iiserializeManySparse(scope,
                               sparse_indices,
                               sparse_values,
                               sparse_shape,
                               out_type[].oTF,
                               out_type)

converter serializeManySparseToOut*[oT: oall](op: SerializeManySparse[oT]): oT {.inline.} = return op.output

type SerializeSparseT* = oall

type SerializeSparse*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeSparse/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiserializeSparse[oT: oall](scope: Scope,
                      sparse_indices: oint64,
                      sparse_values: SerializeSparseT,
                      sparse_shape: oint64,
                      out_type: DType,
                      explicitT: type(oT)): SerializeSparse[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeSparse(*#, #, #, #, #)", constructor.}

proc serializeSparse*(scope: Scope,
                      sparse_indices: oint64,
                      sparse_values: SerializeSparseT,
                      sparse_shape: oint64,
                      out_type: type = ostring): auto =
  return iiserializeSparse(scope,
                           sparse_indices,
                           sparse_values,
                           sparse_shape,
                           out_type[].oTF,
                           out_type)

converter serializeSparseToOut*[oT: oall](op: SerializeSparse[oT]): oT {.inline.} = return op.output


type SparseAddGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAddGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseAddGrad[oT: oall](scope: Scope,
                    backprop_val_grad: oT,
                    a_indices: oint64,
                    b_indices: oint64,
                    sum_indices: oint64,
                    T: DType): SparseAddGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAddGrad(*#, #, #, #, #, #)", constructor.}

proc sparseAddGrad*[oT: oall](scope: Scope,
                    backprop_val_grad: oT,
                    a_indices: oint64,
                    b_indices: oint64,
                    sum_indices: oint64): SparseAddGrad[oT] =
  return iisparseAddGrad(scope,
                         backprop_val_grad,
                         a_indices,
                         b_indices,
                         sum_indices,
                         oT[].oTF)

converter sparseAddGradToOut*[oT: oall](op: SparseAddGrad[oT]): oT {.inline.} = return op.output

type SparseToSparseSetOperationT* = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type SparseToSparseSetOperation* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseToSparseSetOperation/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseToSparseSetOperation(scope: Scope,
                                 set1_indices: oint64,
                                 set1_values: SparseToSparseSetOperationT,
                                 set1_shape: oint64,
                                 set2_indices: oint64,
                                 set2_values: SparseToSparseSetOperationT,
                                 set2_shape: oint64,
                                 set_operation: cstring,
                                 validate_indices: bool): SparseToSparseSetOperation {.header:"../tensorflow/ops/generated.h", importcpp:"SparseToSparseSetOperation(*#, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc sparseToSparseSetOperation*(scope: Scope,
                                 set1_indices: oint64,
                                 set1_values: SparseToSparseSetOperationT,
                                 set1_shape: oint64,
                                 set2_indices: oint64,
                                 set2_values: SparseToSparseSetOperationT,
                                 set2_shape: oint64,
                                 set_operation: cstring,
                                 validate_indices: bool = true): SparseToSparseSetOperation =
  return iisparseToSparseSetOperation(scope,
                                      set1_indices,
                                      set1_values,
                                      set1_shape,
                                      set2_indices,
                                      set2_values,
                                      set2_shape,
                                      set_operation,
                                      validate_indices)

converter sparseToSparseSetOperationToOut*(op: SparseToSparseSetOperation): oint64 {.inline.} = return op.output

type DenseToDenseSetOperationT* = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type DenseToDenseSetOperation* {.header:"../tensorflow/ops/generated.h", importcpp:"DenseToDenseSetOperation/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iidenseToDenseSetOperation(scope: Scope,
                               set1: DenseToDenseSetOperationT,
                               set2: DenseToDenseSetOperationT,
                               set_operation: cstring,
                               validate_indices: bool): DenseToDenseSetOperation {.header:"../tensorflow/ops/generated.h", importcpp:"DenseToDenseSetOperation(*#, #, #, tensorflow::string(#), #)", constructor.}

proc denseToDenseSetOperation*(scope: Scope,
                               set1: DenseToDenseSetOperationT,
                               set2: DenseToDenseSetOperationT,
                               set_operation: cstring,
                               validate_indices: bool = true): DenseToDenseSetOperation =
  return iidenseToDenseSetOperation(scope,
                                    set1,
                                    set2,
                                    set_operation,
                                    validate_indices)

converter denseToDenseSetOperationToOut*(op: DenseToDenseSetOperation): oint64 {.inline.} = return op.output


type IRecv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_Recv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiRecv[oT: oall](scope: Scope,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            tensor_type: DType,
            send_device_incarnation: int64,
            client_terminated: bool,
            explicitT: type(oT)): IRecv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_Recv(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc iRecv*(scope: Scope,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            tensor_type: type = oinvalid,
            send_device_incarnation: int64 = 0.int,
            client_terminated: bool = false): auto =
  return iiiRecv(scope,
                 tensor_name,
                 send_device,
                 recv_device,
                 tensor_type[].oTF,
                 send_device_incarnation,
                 client_terminated,
                 tensor_type)

converter iRecvToOut*[oT: oall](op: IRecv[oT]): oT {.inline.} = return op.output

type ISendT* = oall

type ISend*{.header:"../tensorflow/ops/generated.h", importcpp:"_Send/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiiSend(scope: Scope,
            tensor: ISendT,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            client_terminated: bool,
            send_device_incarnation: int64): ISend {.header:"../tensorflow/ops/generated.h", importcpp:"_Send(*#, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iSend*(scope: Scope,
            tensor: ISendT,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            client_terminated: bool = false,
            send_device_incarnation: int64 = 0.int): ISend =
  return iiiSend(scope,
                 tensor,
                 tensor_name,
                 send_device,
                 recv_device,
                 client_terminated,
                 send_device_incarnation)




type SdcaFprint* {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaFprint/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisdcaFprint(scope: Scope,
                 input: ostring): SdcaFprint {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaFprint(*#, #)", constructor.}

proc sdcaFprint*(scope: Scope,
                 input: ostring): SdcaFprint =
  return iisdcaFprint(scope,
                      input)

converter sdcaFprintToOut*(op: SdcaFprint): oint64 {.inline.} = return op.output


type SdcaShrinkL1*{.header:"../tensorflow/ops/generated.h", importcpp:"SdcaShrinkL1/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iisdcaShrinkL1(scope: Scope,
                   weights: ofloat,
                   num_features: int64,
                   l1: float32,
                   l2: float32): SdcaShrinkL1 {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaShrinkL1(*#, #, #, #, #)", constructor.}

proc sdcaShrinkL1*(scope: Scope,
                   weights: ofloat,
                   num_features: int64 = 0.int,
                   l1: float32 = 0.0.float32,
                   l2: float32 = 0.0.float32): SdcaShrinkL1 =
  return iisdcaShrinkL1(scope,
                        weights,
                        num_features,
                        l1,
                        l2)




type SdcaOptimizerV2* {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaOptimizerV2/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iisdcaOptimizerV2(scope: Scope,
                      sparse_example_indices: oint64,
                      sparse_feature_indices: oint64,
                      sparse_feature_values: ofloat,
                      dense_features: ofloat,
                      example_weights: ofloat,
                      example_labels: ofloat,
                      sparse_indices: oint64,
                      sparse_weights: ofloat,
                      dense_weights: ofloat,
                      example_state_data: ofloat,
                      loss_type: cstring,
                      adaptive: bool,
                      num_sparse_features: int64,
                      num_sparse_features_with_values: int64,
                      num_dense_features: int64,
                      l1: float32,
                      l2: float32,
                      num_loss_partitions: int64,
                      num_inner_iterations: int64): SdcaOptimizerV2 {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaOptimizerV2(*#, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), #, #, #, #, #, #, #, #)", constructor.}

proc sdcaOptimizerV2*(scope: Scope,
                      sparse_example_indices: oint64,
                      sparse_feature_indices: oint64,
                      sparse_feature_values: ofloat,
                      dense_features: ofloat,
                      example_weights: ofloat,
                      example_labels: ofloat,
                      sparse_indices: oint64,
                      sparse_weights: ofloat,
                      dense_weights: ofloat,
                      example_state_data: ofloat,
                      loss_type: cstring,
                      adaptive: bool = false,
                      num_sparse_features: int64 = 0.int,
                      num_sparse_features_with_values: int64 = 0.int,
                      num_dense_features: int64 = 0.int,
                      l1: float32 = 0.0.float32,
                      l2: float32 = 0.0.float32,
                      num_loss_partitions: int64 = 0.int,
                      num_inner_iterations: int64 = 0.int): SdcaOptimizerV2 =
  return iisdcaOptimizerV2(scope,
                           sparse_example_indices,
                           sparse_feature_indices,
                           sparse_feature_values,
                           dense_features,
                           example_weights,
                           example_labels,
                           sparse_indices,
                           sparse_weights,
                           dense_weights,
                           example_state_data,
                           loss_type,
                           adaptive,
                           num_sparse_features,
                           num_sparse_features_with_values,
                           num_dense_features,
                           l1,
                           l2,
                           num_loss_partitions,
                           num_inner_iterations)

converter sdcaOptimizerV2ToOut*(op: SdcaOptimizerV2): ofloat {.inline.} = return op.output


type SdcaOptimizer* {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaOptimizer/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iisdcaOptimizer(scope: Scope,
                    sparse_example_indices: oint64,
                    sparse_feature_indices: oint64,
                    sparse_feature_values: ofloat,
                    dense_features: ofloat,
                    example_weights: ofloat,
                    example_labels: ofloat,
                    sparse_indices: oint64,
                    sparse_weights: ofloat,
                    dense_weights: ofloat,
                    example_state_data: ofloat,
                    loss_type: cstring,
                    adaptative: bool,
                    num_sparse_features: int64,
                    num_sparse_features_with_values: int64,
                    num_dense_features: int64,
                    l1: float32,
                    l2: float32,
                    num_loss_partitions: int64,
                    num_inner_iterations: int64): SdcaOptimizer {.header:"../tensorflow/ops/generated.h", importcpp:"SdcaOptimizer(*#, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), #, #, #, #, #, #, #, #)", constructor.}

proc sdcaOptimizer*(scope: Scope,
                    sparse_example_indices: oint64,
                    sparse_feature_indices: oint64,
                    sparse_feature_values: ofloat,
                    dense_features: ofloat,
                    example_weights: ofloat,
                    example_labels: ofloat,
                    sparse_indices: oint64,
                    sparse_weights: ofloat,
                    dense_weights: ofloat,
                    example_state_data: ofloat,
                    loss_type: cstring,
                    adaptative: bool = false,
                    num_sparse_features: int64 = 0.int,
                    num_sparse_features_with_values: int64 = 0.int,
                    num_dense_features: int64 = 0.int,
                    l1: float32 = 0.0.float32,
                    l2: float32 = 0.0.float32,
                    num_loss_partitions: int64 = 0.int,
                    num_inner_iterations: int64 = 0.int): SdcaOptimizer =
  return iisdcaOptimizer(scope,
                         sparse_example_indices,
                         sparse_feature_indices,
                         sparse_feature_values,
                         dense_features,
                         example_weights,
                         example_labels,
                         sparse_indices,
                         sparse_weights,
                         dense_weights,
                         example_state_data,
                         loss_type,
                         adaptative,
                         num_sparse_features,
                         num_sparse_features_with_values,
                         num_dense_features,
                         l1,
                         l2,
                         num_loss_partitions,
                         num_inner_iterations)

converter sdcaOptimizerToOut*(op: SdcaOptimizer): ofloat {.inline.} = return op.output


type EagerPyFunc*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"EagerPyFunc/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iieagerPyFunc[oT: oall](scope: Scope,
                  input: olist[oall],
                  token: cstring,
                  Tin: ArraySlice[DType],
                  Tout: ArraySlice[DType],
                  explicitT: type(oT)): EagerPyFunc[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"EagerPyFunc(*#, #, tensorflow::string(#), #, #)", constructor.}

proc eagerPyFunc*(scope: Scope,
                  input: olist[oall],
                  token: cstring,
                  Tin: openArray[DType],
                  Tout: openArray[DType],
                  explicitT: type): auto =
  return iieagerPyFunc(scope,
                       input,
                       token,
                       newArraySlice(Tin),
                       newArraySlice(Tout),
                       explicitT)

converter eagerPyFuncToOutList*[oT: oall](op: EagerPyFunc[oT]): olist[oT] {.inline.} = return op.output


type PyFuncStateless*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PyFuncStateless/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iipyFuncStateless[oT: oall](scope: Scope,
                      input: olist[oall],
                      token: cstring,
                      Tin: ArraySlice[DType],
                      Tout: ArraySlice[DType],
                      explicitT: type(oT)): PyFuncStateless[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PyFuncStateless(*#, #, tensorflow::string(#), #, #)", constructor.}

proc pyFuncStateless*(scope: Scope,
                      input: olist[oall],
                      token: cstring,
                      Tin: openArray[DType],
                      Tout: openArray[DType],
                      explicitT: type): auto =
  return iipyFuncStateless(scope,
                           input,
                           token,
                           newArraySlice(Tin),
                           newArraySlice(Tout),
                           explicitT)

converter pyFuncStatelessToOutList*[oT: oall](op: PyFuncStateless[oT]): olist[oT] {.inline.} = return op.output


type IScopedAllocatorSplit*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ScopedAllocatorSplit/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiScopedAllocatorSplit[oT: oall](scope: Scope,
                            concat: oT,
                            split: olist[oT],
                            sa_name: cstring,
                            shapes: ArraySlice[TensorShape],
                            T: DType,
                            id: int64): IScopedAllocatorSplit[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ScopedAllocatorSplit(*#, #, #, tensorflow::string(#), #, #, #)", constructor.}

proc iScopedAllocatorSplit*[oT: oall](scope: Scope,
                            concat: oT,
                            split: olist[oT],
                            sa_name: cstring,
                            shapes: openArray[TensorShape],
                            id: int64 = 0.int): IScopedAllocatorSplit[oT] =
  return iiiScopedAllocatorSplit(scope,
                                 concat,
                                 split,
                                 sa_name,
                                 newArraySlice(shapes),
                                 oT[].oTF,
                                 id)

converter iScopedAllocatorSplitToOutList*[oT: oall](op: IScopedAllocatorSplit[oT]): olist[oT] {.inline.} = return op.output


type IScopedAllocator*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ScopedAllocator/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiScopedAllocator[oT: oall](scope: Scope,
                       shapes: ArraySlice[TensorShape],
                       sa_name: cstring,
                       shape: TensorShape,
                       T: DType,
                       id: int64,
                       expected_call_count: int64,
                       explicitT: type(oT)): IScopedAllocator[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ScopedAllocator(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc iScopedAllocator*(scope: Scope,
                       shapes: openArray[TensorShape],
                       sa_name: cstring,
                       shape: TensorShape = [].shape,
                       T: type = oinvalid,
                       id: int64 = 0.int,
                       expected_call_count: int64 = 0.int): auto =
  return iiiScopedAllocator(scope,
                            newArraySlice(shapes),
                            sa_name,
                            shape,
                            T[].oTF,
                            id,
                            expected_call_count,
                            T)

converter iScopedAllocatorToOut*[oT: oall](op: IScopedAllocator[oT]): oT {.inline.} = return op.output


type ConsumeMutexLock*{.header:"../tensorflow/ops/generated.h", importcpp:"ConsumeMutexLock/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiconsumeMutexLock(scope: Scope,
                       mutex_lock: ovariant): ConsumeMutexLock {.header:"../tensorflow/ops/generated.h", importcpp:"ConsumeMutexLock(*#, #)", constructor.}

proc consumeMutexLock*(scope: Scope,
                       mutex_lock: ovariant): ConsumeMutexLock =
  return iiconsumeMutexLock(scope,
                            mutex_lock)




type MutexLock* {.header:"../tensorflow/ops/generated.h", importcpp:"MutexLock/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iimutexLock(scope: Scope,
                mutex: oresource): MutexLock {.header:"../tensorflow/ops/generated.h", importcpp:"MutexLock(*#, #)", constructor.}

proc mutexLock*(scope: Scope,
                mutex: oresource): MutexLock =
  return iimutexLock(scope,
                     mutex)

converter mutexLockToOut*(op: MutexLock): ovariant {.inline.} = return op.output


type MutexV2* {.header:"../tensorflow/ops/generated.h", importcpp:"MutexV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iimutexV2(scope: Scope,
              container: cstring,
              shared_name: cstring): MutexV2 {.header:"../tensorflow/ops/generated.h", importcpp:"MutexV2(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc mutexV2*(scope: Scope,
              container: cstring,
              shared_name: cstring): MutexV2 =
  return iimutexV2(scope,
                   container,
                   shared_name)

converter mutexV2ToOut*(op: MutexV2): oresource {.inline.} = return op.output

type ResourceScatterUpdatedtype* = oall
type ResourceScatterUpdateTindices* = oint32 | oint64

type ResourceScatterUpdate*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterUpdate/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterUpdate(scope: Scope,
                            resource: oresource,
                            indices: ResourceScatterUpdateTindices,
                            updates: ResourceScatterUpdatedtype): ResourceScatterUpdate {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterUpdate(*#, #, #, #)", constructor.}

proc resourceScatterUpdate*(scope: Scope,
                            resource: oresource,
                            indices: ResourceScatterUpdateTindices,
                            updates: ResourceScatterUpdatedtype): ResourceScatterUpdate =
  return iiresourceScatterUpdate(scope,
                                 resource,
                                 indices,
                                 updates)



type ResourceScatterMindtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceScatterMinTindices* = oint32 | oint64

type ResourceScatterMin*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterMin/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterMin(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMinTindices,
                         updates: ResourceScatterMindtype): ResourceScatterMin {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterMin(*#, #, #, #)", constructor.}

proc resourceScatterMin*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMinTindices,
                         updates: ResourceScatterMindtype): ResourceScatterMin =
  return iiresourceScatterMin(scope,
                              resource,
                              indices,
                              updates)



type ResourceScatterAdddtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceScatterAddTindices* = oint32 | oint64

type ResourceScatterAdd*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterAdd/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterAdd(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterAddTindices,
                         updates: ResourceScatterAdddtype): ResourceScatterAdd {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterAdd(*#, #, #, #)", constructor.}

proc resourceScatterAdd*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterAddTindices,
                         updates: ResourceScatterAdddtype): ResourceScatterAdd =
  return iiresourceScatterAdd(scope,
                              resource,
                              indices,
                              updates)




type VariableShape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"VariableShape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iivariableShape[oT: oall](scope: Scope,
                    input: oresource,
                    out_type: DType,
                    explicitT: type(oT)): VariableShape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"VariableShape(*#, #, #)", constructor.}

proc variableShape*(scope: Scope,
                    input: oresource,
                    out_type: type = oint32): auto =
  return iivariableShape(scope,
                         input,
                         out_type[].oTF,
                         out_type)

converter variableShapeToOut*[oT: oall](op: VariableShape[oT]): oT {.inline.} = return op.output


type RemoteFusedGraphExecute*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RemoteFusedGraphExecute/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiremoteFusedGraphExecute[oT: oall](scope: Scope,
                              inputs: olist[oall],
                              Tinputs: ArraySlice[DType],
                              Toutputs: ArraySlice[DType],
                              serialized_remote_fused_graph_execute_info: cstring,
                              explicitT: type(oT)): RemoteFusedGraphExecute[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RemoteFusedGraphExecute(*#, #, #, #, tensorflow::string(#))", constructor.}

proc remoteFusedGraphExecute*(scope: Scope,
                              inputs: olist[oall],
                              Tinputs: openArray[DType],
                              Toutputs: openArray[DType],
                              serialized_remote_fused_graph_execute_info: cstring,
                              explicitT: type): auto =
  return iiremoteFusedGraphExecute(scope,
                                   inputs,
                                   newArraySlice(Tinputs),
                                   newArraySlice(Toutputs),
                                   serialized_remote_fused_graph_execute_info,
                                   explicitT)

converter remoteFusedGraphExecuteToOutList*[oT: oall](op: RemoteFusedGraphExecute[oT]): olist[oT] {.inline.} = return op.output

type RandomPoissonV2S* = oint32 | oint64
type RandomPoissonV2R* = ohalf | ofloat | odouble | oint32 | oint64

type RandomPoissonV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomPoissonV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomPoissonV2[oT: oall](scope: Scope,
                      shape: RandomPoissonV2S,
                      rate: RandomPoissonV2R,
                      seed: int64,
                      seed2: int64,
                      dtype: DType,
                      explicitT: type(oT)): RandomPoissonV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomPoissonV2(*#, #, #, #, #, #)", constructor.}

proc randomPoissonV2*(scope: Scope,
                      shape: RandomPoissonV2S,
                      rate: RandomPoissonV2R,
                      seed: int64 = 0.int,
                      seed2: int64 = 0.int,
                      dtype: type = oint64): auto =
  return iirandomPoissonV2(scope,
                           shape,
                           rate,
                           seed,
                           seed2,
                           dtype[].oTF,
                           dtype)

converter randomPoissonV2ToOut*[oT: oall](op: RandomPoissonV2[oT]): oT {.inline.} = return op.output

type RandomPoissonS* = oint32 | oint64

type RandomPoisson*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomPoisson/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomPoisson[oT: oall](scope: Scope,
                    shape: RandomPoissonS,
                    rate: oT,
                    seed: int64,
                    seed2: int64,
                    dtype: DType): RandomPoisson[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomPoisson(*#, #, #, #, #, #)", constructor.}

proc randomPoisson*[oT: oall](scope: Scope,
                    shape: RandomPoissonS,
                    rate: oT,
                    seed: int64 = 0.int,
                    seed2: int64 = 0.int): RandomPoisson[oT] =
  return iirandomPoisson(scope,
                         shape,
                         rate,
                         seed,
                         seed2,
                         oT[].oTF)

converter randomPoissonToOut*[oT: oall](op: RandomPoisson[oT]): oT {.inline.} = return op.output


type RandomGammaGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomGammaGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomGammaGrad[oT: oall](scope: Scope,
                      alpha: oT,
                      sample: oT,
                      T: DType): RandomGammaGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomGammaGrad(*#, #, #, #)", constructor.}

proc randomGammaGrad*[oT: oall](scope: Scope,
                      alpha: oT,
                      sample: oT): RandomGammaGrad[oT] =
  return iirandomGammaGrad(scope,
                           alpha,
                           sample,
                           oT[].oTF)

converter randomGammaGradToOut*[oT: oall](op: RandomGammaGrad[oT]): oT {.inline.} = return op.output

type MultinomialT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Multinomial*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Multinomial/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimultinomial[oT: oall](scope: Scope,
                  logits: MultinomialT,
                  num_samples: oint32,
                  seed: int64,
                  seed2: int64,
                  output_dtype: DType,
                  explicitT: type(oT)): Multinomial[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Multinomial(*#, #, #, #, #, #)", constructor.}

proc multinomial*(scope: Scope,
                  logits: MultinomialT,
                  num_samples: oint32,
                  seed: int64 = 0.int,
                  seed2: int64 = 0.int,
                  output_dtype: type = oint64): auto =
  return iimultinomial(scope,
                       logits,
                       num_samples,
                       seed,
                       seed2,
                       output_dtype[].oTF,
                       output_dtype)

converter multinomialToOut*[oT: oall](op: Multinomial[oT]): oT {.inline.} = return op.output


type RandomShuffle*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomShuffle/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomShuffle[oT: oall](scope: Scope,
                    value: oT,
                    seed: int64,
                    seed2: int64,
                    T: DType): RandomShuffle[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomShuffle(*#, #, #, #, #)", constructor.}

proc randomShuffle*[oT: oall](scope: Scope,
                    value: oT,
                    seed: int64 = 0.int,
                    seed2: int64 = 0.int): RandomShuffle[oT] =
  return iirandomShuffle(scope,
                         value,
                         seed,
                         seed2,
                         oT[].oTF)

converter randomShuffleToOut*[oT: oall](op: RandomShuffle[oT]): oT {.inline.} = return op.output

type ParameterizedTruncatedNormalT* = oint32 | oint64

type ParameterizedTruncatedNormal*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ParameterizedTruncatedNormal/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiparameterizedTruncatedNormal[oT: oall](scope: Scope,
                                   shape: ParameterizedTruncatedNormalT,
                                   means: oT,
                                   stdevs: oT,
                                   minvals: oT,
                                   maxvals: oT,
                                   seed: int64,
                                   seed2: int64,
                                   dtype: DType): ParameterizedTruncatedNormal[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ParameterizedTruncatedNormal(*#, #, #, #, #, #, #, #, #)", constructor.}

proc parameterizedTruncatedNormal*[oT: oall](scope: Scope,
                                   shape: ParameterizedTruncatedNormalT,
                                   means: oT,
                                   stdevs: oT,
                                   minvals: oT,
                                   maxvals: oT,
                                   seed: int64 = 0.int,
                                   seed2: int64 = 0.int): ParameterizedTruncatedNormal[oT] =
  return iiparameterizedTruncatedNormal(scope,
                                        shape,
                                        means,
                                        stdevs,
                                        minvals,
                                        maxvals,
                                        seed,
                                        seed2,
                                        oT[].oTF)

converter parameterizedTruncatedNormalToOut*[oT: oall](op: ParameterizedTruncatedNormal[oT]): oT {.inline.} = return op.output

type RandomUniformIntT* = oint32 | oint64

type RandomUniformInt*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomUniformInt/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomUniformInt[oT: oall](scope: Scope,
                       shape: RandomUniformIntT,
                       minval: oT,
                       maxval: oT,
                       seed: int64,
                       seed2: int64,
                       Tout: DType): RandomUniformInt[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomUniformInt(*#, #, #, #, #, #, #)", constructor.}

proc randomUniformInt*[oT: oall](scope: Scope,
                       shape: RandomUniformIntT,
                       minval: oT,
                       maxval: oT,
                       seed: int64 = 0.int,
                       seed2: int64 = 0.int): RandomUniformInt[oT] =
  return iirandomUniformInt(scope,
                            shape,
                            minval,
                            maxval,
                            seed,
                            seed2,
                            oT[].oTF)

converter randomUniformIntToOut*[oT: oall](op: RandomUniformInt[oT]): oT {.inline.} = return op.output

type RandomUniformT* = oint32 | oint64

type RandomUniform*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomUniform/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomUniform[oT: oall](scope: Scope,
                    shape: RandomUniformT,
                    seed: int64,
                    seed2: int64,
                    dtype: DType,
                    explicitT: type(oT)): RandomUniform[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomUniform(*#, #, #, #, #)", constructor.}

proc randomUniform*(scope: Scope,
                    shape: RandomUniformT,
                    seed: int64 = 0.int,
                    seed2: int64 = 0.int,
                    dtype: type = oinvalid): auto =
  return iirandomUniform(scope,
                         shape,
                         seed,
                         seed2,
                         dtype[].oTF,
                         dtype)

converter randomUniformToOut*[oT: oall](op: RandomUniform[oT]): oT {.inline.} = return op.output

type RaggedGatherTvalues* = oall
type RaggedGatherTindices* = oint32 | oint64

type RaggedGather* {.header:"../tensorflow/ops/generated.h", importcpp:"RaggedGather/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiraggedGather(scope: Scope,
                   params_nested_splits: oint64,
                   params_dense_values: RaggedGatherTvalues,
                   indices: RaggedGatherTindices,
                   OUTPUT_RAGGED_RANK: int64,
                   PARAMS_RAGGED_RANK: int64): RaggedGather {.header:"../tensorflow/ops/generated.h", importcpp:"RaggedGather(*#, #, #, #, #, #)", constructor.}

proc raggedGather*(scope: Scope,
                   params_nested_splits: oint64,
                   params_dense_values: RaggedGatherTvalues,
                   indices: RaggedGatherTindices,
                   OUTPUT_RAGGED_RANK: int64 = 0.int,
                   PARAMS_RAGGED_RANK: int64 = 0.int): RaggedGather =
  return iiraggedGather(scope,
                        params_nested_splits,
                        params_dense_values,
                        indices,
                        OUTPUT_RAGGED_RANK,
                        PARAMS_RAGGED_RANK)

converter raggedGatherToOut*(op: RaggedGather): oint64 {.inline.} = return op.output


type BatchIFFT2D* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchIFFT2D/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iibatchIFFT2D(scope: Scope,
                  input: ocomplex64): BatchIFFT2D {.header:"../tensorflow/ops/generated.h", importcpp:"BatchIFFT2D(*#, #)", constructor.}

proc batchIFFT2D*(scope: Scope,
                  input: ocomplex64): BatchIFFT2D =
  return iibatchIFFT2D(scope,
                       input)

converter batchIFFT2DToOut*(op: BatchIFFT2D): ocomplex64 {.inline.} = return op.output


type StringToNumber*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StringToNumber/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistringToNumber[oT: oall](scope: Scope,
                     string_tensor: ostring,
                     out_type: DType,
                     explicitT: type(oT)): StringToNumber[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StringToNumber(*#, #, #)", constructor.}

proc stringToNumber*(scope: Scope,
                     string_tensor: ostring,
                     out_type: type = ofloat): auto =
  return iistringToNumber(scope,
                          string_tensor,
                          out_type[].oTF,
                          out_type)

converter stringToNumberToOut*[oT: oall](op: StringToNumber[oT]): oT {.inline.} = return op.output


type DecodeJSONExample* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeJSONExample/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iidecodeJSONExample(scope: Scope,
                        json_examples: ostring): DecodeJSONExample {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeJSONExample(*#, #)", constructor.}

proc decodeJSONExample*(scope: Scope,
                        json_examples: ostring): DecodeJSONExample =
  return iidecodeJSONExample(scope,
                             json_examples)

converter decodeJSONExampleToOut*(op: DecodeJSONExample): ostring {.inline.} = return op.output

type SerializeTensorT* = oall

type SerializeTensor* {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeTensor/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiserializeTensor(scope: Scope,
                      tensor: SerializeTensorT): SerializeTensor {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeTensor(*#, #)", constructor.}

proc serializeTensor*(scope: Scope,
                      tensor: SerializeTensorT): SerializeTensor =
  return iiserializeTensor(scope,
                           tensor)

converter serializeTensorToOut*(op: SerializeTensor): ostring {.inline.} = return op.output


type ParseTensor*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ParseTensor/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiparseTensor[oT: oall](scope: Scope,
                  serialized: ostring,
                  out_type: DType,
                  explicitT: type(oT)): ParseTensor[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ParseTensor(*#, #, #)", constructor.}

proc parseTensor*(scope: Scope,
                  serialized: ostring,
                  out_type: type = oinvalid): auto =
  return iiparseTensor(scope,
                       serialized,
                       out_type[].oTF,
                       out_type)

converter parseTensorToOut*[oT: oall](op: ParseTensor[oT]): oT {.inline.} = return op.output


type ParseSequenceExample* {.header:"../tensorflow/ops/generated.h", importcpp:"ParseSequenceExample/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiparseSequenceExample(scope: Scope,
                           serialized: ostring,
                           debug_name: ostring,
                           context_dense_defaults: olist[oall],
                           feature_list_dense_missing_assumed_empty: ArraySlice[cstring],
                           context_sparse_keys: ArraySlice[cstring],
                           context_dense_keys: ArraySlice[cstring],
                           feature_list_sparse_keys: ArraySlice[cstring],
                           feature_list_dense_keys: ArraySlice[cstring],
                           context_sparse_types: ArraySlice[DType],
                           Tcontext_dense: ArraySlice[DType],
                           feature_list_dense_types: ArraySlice[DType],
                           context_dense_shapes: ArraySlice[TensorShape],
                           feature_list_sparse_types: ArraySlice[DType],
                           feature_list_dense_shapes: ArraySlice[TensorShape],
                           Ncontext_sparse: int64,
                           Ncontext_dense: int64,
                           Nfeature_list_sparse: int64,
                           Nfeature_list_dense: int64): ParseSequenceExample {.header:"../tensorflow/ops/generated.h", importcpp:"ParseSequenceExample(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parseSequenceExample*(scope: Scope,
                           serialized: ostring,
                           debug_name: ostring,
                           context_dense_defaults: olist[oall],
                           feature_list_dense_missing_assumed_empty: openArray[cstring],
                           context_sparse_keys: openArray[cstring],
                           context_dense_keys: openArray[cstring],
                           feature_list_sparse_keys: openArray[cstring],
                           feature_list_dense_keys: openArray[cstring],
                           context_sparse_types: openArray[DType],
                           Tcontext_dense: openArray[DType],
                           feature_list_dense_types: openArray[DType],
                           context_dense_shapes: openArray[TensorShape],
                           feature_list_sparse_types: openArray[DType],
                           feature_list_dense_shapes: openArray[TensorShape],
                           Ncontext_sparse: int64 = 0.int,
                           Ncontext_dense: int64 = 0.int,
                           Nfeature_list_sparse: int64 = 0.int,
                           Nfeature_list_dense: int64 = 0.int): ParseSequenceExample =
  return iiparseSequenceExample(scope,
                                serialized,
                                debug_name,
                                context_dense_defaults,
                                newArraySlice(feature_list_dense_missing_assumed_empty),
                                newArraySlice(context_sparse_keys),
                                newArraySlice(context_dense_keys),
                                newArraySlice(feature_list_sparse_keys),
                                newArraySlice(feature_list_dense_keys),
                                newArraySlice(context_sparse_types),
                                newArraySlice(Tcontext_dense),
                                newArraySlice(feature_list_dense_types),
                                newArraySlice(context_dense_shapes),
                                newArraySlice(feature_list_sparse_types),
                                newArraySlice(feature_list_dense_shapes),
                                Ncontext_sparse,
                                Ncontext_dense,
                                Nfeature_list_sparse,
                                Nfeature_list_dense)

converter parseSequenceExampleToOut*(op: ParseSequenceExample): oint64 {.inline.} = return op.output


type ParseExample* {.header:"../tensorflow/ops/generated.h", importcpp:"ParseExample/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiparseExample(scope: Scope,
                   serialized: ostring,
                   names: ostring,
                   sparse_keys: ostring,
                   dense_keys: ostring,
                   dense_defaults: olist[oall],
                   sparse_types: ArraySlice[DType],
                   Tdense: ArraySlice[DType],
                   dense_shapes: ArraySlice[TensorShape],
                   Nsparse: int64,
                   Ndense: int64): ParseExample {.header:"../tensorflow/ops/generated.h", importcpp:"ParseExample(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parseExample*(scope: Scope,
                   serialized: ostring,
                   names: ostring,
                   sparse_keys: ostring,
                   dense_keys: ostring,
                   dense_defaults: olist[oall],
                   sparse_types: openArray[DType],
                   Tdense: openArray[DType],
                   dense_shapes: openArray[TensorShape],
                   Nsparse: int64 = 0.int,
                   Ndense: int64 = 0.int): ParseExample =
  return iiparseExample(scope,
                        serialized,
                        names,
                        sparse_keys,
                        dense_keys,
                        dense_defaults,
                        newArraySlice(sparse_types),
                        newArraySlice(Tdense),
                        newArraySlice(dense_shapes),
                        Nsparse,
                        Ndense)

converter parseExampleToOut*(op: ParseExample): oint64 {.inline.} = return op.output


type DecodeCompressed* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeCompressed/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iidecodeCompressed(scope: Scope,
                       bytes: ostring,
                       compression_type: cstring): DecodeCompressed {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeCompressed(*#, #, tensorflow::string(#))", constructor.}

proc decodeCompressed*(scope: Scope,
                       bytes: ostring,
                       compression_type: cstring): DecodeCompressed =
  return iidecodeCompressed(scope,
                            bytes,
                            compression_type)

converter decodeCompressedToOut*(op: DecodeCompressed): ostring {.inline.} = return op.output

type QuantizedBatchNormWithGlobalNormalizationTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedBatchNormWithGlobalNormalization*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedBatchNormWithGlobalNormalization/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedBatchNormWithGlobalNormalization[oT: oall](scope: Scope,
                                                t: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                t_min: ofloat,
                                                t_max: ofloat,
                                                m: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                m_min: ofloat,
                                                m_max: ofloat,
                                                v: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                v_min: ofloat,
                                                v_max: ofloat,
                                                beta: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                beta_min: ofloat,
                                                beta_max: ofloat,
                                                gamma: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                gamma_min: ofloat,
                                                gamma_max: ofloat,
                                                scale_after_normalization: bool,
                                                out_type: DType,
                                                variance_epsilon: float32,
                                                explicitT: type(oT)): QuantizedBatchNormWithGlobalNormalization[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedBatchNormWithGlobalNormalization(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc quantizedBatchNormWithGlobalNormalization*(scope: Scope,
                                                t: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                t_min: ofloat,
                                                t_max: ofloat,
                                                m: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                m_min: ofloat,
                                                m_max: ofloat,
                                                v: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                v_min: ofloat,
                                                v_max: ofloat,
                                                beta: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                beta_min: ofloat,
                                                beta_max: ofloat,
                                                gamma: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                gamma_min: ofloat,
                                                gamma_max: ofloat,
                                                scale_after_normalization: bool = false,
                                                out_type: type = oinvalid,
                                                variance_epsilon: float32 = 0.0.float32): auto =
  return iiquantizedBatchNormWithGlobalNormalization(scope,
                                                     t,
                                                     t_min,
                                                     t_max,
                                                     m,
                                                     m_min,
                                                     m_max,
                                                     v,
                                                     v_min,
                                                     v_max,
                                                     beta,
                                                     beta_min,
                                                     beta_max,
                                                     gamma,
                                                     gamma_min,
                                                     gamma_max,
                                                     scale_after_normalization,
                                                     out_type[].oTF,
                                                     variance_epsilon,
                                                     out_type)

converter quantizedBatchNormWithGlobalNormalizationToOut*[oT: oall](op: QuantizedBatchNormWithGlobalNormalization[oT]): oT {.inline.} = return op.output

type QuantizedReluXTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedReluX*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedReluX/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedReluX[oT: oall](scope: Scope,
                     features: QuantizedReluXTinput,
                     max_value: ofloat,
                     min_features: ofloat,
                     max_features: ofloat,
                     out_type: DType,
                     explicitT: type(oT)): QuantizedReluX[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedReluX(*#, #, #, #, #, #)", constructor.}

proc quantizedReluX*(scope: Scope,
                     features: QuantizedReluXTinput,
                     max_value: ofloat,
                     min_features: ofloat,
                     max_features: ofloat,
                     out_type: type = oquint8): auto =
  return iiquantizedReluX(scope,
                          features,
                          max_value,
                          min_features,
                          max_features,
                          out_type[].oTF,
                          out_type)

converter quantizedReluXToOut*[oT: oall](op: QuantizedReluX[oT]): oT {.inline.} = return op.output

type QuantizedReluTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedRelu*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedRelu/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedRelu[oT: oall](scope: Scope,
                    features: QuantizedReluTinput,
                    min_features: ofloat,
                    max_features: ofloat,
                    out_type: DType,
                    explicitT: type(oT)): QuantizedRelu[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedRelu(*#, #, #, #, #)", constructor.}

proc quantizedRelu*(scope: Scope,
                    features: QuantizedReluTinput,
                    min_features: ofloat,
                    max_features: ofloat,
                    out_type: type = oquint8): auto =
  return iiquantizedRelu(scope,
                         features,
                         min_features,
                         max_features,
                         out_type[].oTF,
                         out_type)

converter quantizedReluToOut*[oT: oall](op: QuantizedRelu[oT]): oT {.inline.} = return op.output

type ScatterNdSubTindices* = oint32 | oint64

type ScatterNdSub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdSub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterNdSub[oT: oall](scope: Scope,
                   nref: oT,
                   indices: ScatterNdSubTindices,
                   updates: oT,
                   T: DType,
                   use_locking: bool): ScatterNdSub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdSub(*#, #, #, #, #, #)", constructor.}

proc scatterNdSub*[oT: oall](scope: Scope,
                   nref: oT,
                   indices: ScatterNdSubTindices,
                   updates: oT,
                   use_locking: bool = false): ScatterNdSub[oT] =
  return iiscatterNdSub(scope,
                        nref,
                        indices,
                        updates,
                        oT[].oTF,
                        use_locking)

converter scatterNdSubToOut*[oT: oall](op: ScatterNdSub[oT]): oT {.inline.} = return op.output

type QuantizedConv2DTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedConv2DTfilter* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedConv2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedConv2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedConv2D[oT: oall](scope: Scope,
                      input: QuantizedConv2DTinput,
                      filter: QuantizedConv2DTfilter,
                      min_input: ofloat,
                      max_input: ofloat,
                      min_filter: ofloat,
                      max_filter: ofloat,
                      strides: ArraySlice[int],
                      padding: cstring,
                      dilations: ArraySlice[int],
                      out_type: DType,
                      explicitT: type(oT)): QuantizedConv2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedConv2D(*#, #, #, #, #, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc quantizedConv2D*(scope: Scope,
                      input: QuantizedConv2DTinput,
                      filter: QuantizedConv2DTfilter,
                      min_input: ofloat,
                      max_input: ofloat,
                      min_filter: ofloat,
                      max_filter: ofloat,
                      strides: openArray[int],
                      padding: cstring,
                      dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int],
                      out_type: type = oqint32): auto =
  return iiquantizedConv2D(scope,
                           input,
                           filter,
                           min_input,
                           max_input,
                           min_filter,
                           max_filter,
                           newArraySlice(strides),
                           padding,
                           newArraySlice(dilations),
                           out_type[].oTF,
                           out_type)

converter quantizedConv2DToOut*[oT: oall](op: QuantizedConv2D[oT]): oT {.inline.} = return op.output


type Reciprocal*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Reciprocal/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireciprocal[oT: oall](scope: Scope,
                 x: oT,
                 T: DType): Reciprocal[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Reciprocal(*#, #, #)", constructor.}

proc reciprocal*[oT: oall](scope: Scope,
                 x: oT): Reciprocal[oT] =
  return iireciprocal(scope,
                      x,
                      oT[].oTF)

converter reciprocalToOut*[oT: oall](op: Reciprocal[oT]): oT {.inline.} = return op.output


type FractionalMaxPool*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalMaxPool/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifractionalMaxPool[oT: oall](scope: Scope,
                        value: oT,
                        pooling_ratio: ArraySlice[float32],
                        pseudo_random: bool,
                        overlapping: bool,
                        deterministic: bool,
                        seed: int64,
                        seed2: int64,
                        T: DType): FractionalMaxPool[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalMaxPool(*#, #, #, #, #, #, #, #, #)", constructor.}

proc fractionalMaxPool*[oT: oall](scope: Scope,
                        value: oT,
                        pooling_ratio: openArray[float32],
                        pseudo_random: bool = false,
                        overlapping: bool = false,
                        deterministic: bool = false,
                        seed: int64 = 0.int,
                        seed2: int64 = 0.int): FractionalMaxPool[oT] =
  return iifractionalMaxPool(scope,
                             value,
                             newArraySlice(pooling_ratio),
                             pseudo_random,
                             overlapping,
                             deterministic,
                             seed,
                             seed2,
                             oT[].oTF)

converter fractionalMaxPoolToOut*[oT: oall](op: FractionalMaxPool[oT]): oT {.inline.} = return op.output


type NthElement*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"NthElement/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iinthElement[oT: oall](scope: Scope,
                 input: oT,
                 n: oint32,
                 reverse: bool,
                 T: DType): NthElement[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"NthElement(*#, #, #, #, #)", constructor.}

proc nthElement*[oT: oall](scope: Scope,
                 input: oT,
                 n: oint32,
                 reverse: bool = false): NthElement[oT] =
  return iinthElement(scope,
                      input,
                      n,
                      reverse,
                      oT[].oTF)

converter nthElementToOut*[oT: oall](op: NthElement[oT]): oT {.inline.} = return op.output

type InTopKV2T* = oint32 | oint64

type InTopKV2* {.header:"../tensorflow/ops/generated.h", importcpp:"InTopKV2/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiinTopKV2(scope: Scope,
               predictions: ofloat,
               targets: InTopKV2T,
               k: InTopKV2T): InTopKV2 {.header:"../tensorflow/ops/generated.h", importcpp:"InTopKV2(*#, #, #, #)", constructor.}

proc inTopKV2*(scope: Scope,
               predictions: ofloat,
               targets: InTopKV2T,
               k: InTopKV2T): InTopKV2 =
  return iiinTopKV2(scope,
                    predictions,
                    targets,
                    k)

converter inTopKV2ToOut*(op: InTopKV2): obool {.inline.} = return op.output


type Sub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisub[oT: oall](scope: Scope,
          x: oT,
          y: oT,
          T: DType): Sub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sub(*#, #, #, #)", constructor.}

proc sub*[oT: oall](scope: Scope,
          x: oT,
          y: oT): Sub[oT] =
  return iisub(scope,
               x,
               y,
               oT[].oTF)

converter subToOut*[oT: oall](op: Sub[oT]): oT {.inline.} = return op.output

type InTopKT* = oint32 | oint64

type InTopK* {.header:"../tensorflow/ops/generated.h", importcpp:"InTopK/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiinTopK(scope: Scope,
             predictions: ofloat,
             targets: InTopKT,
             k: int64): InTopK {.header:"../tensorflow/ops/generated.h", importcpp:"InTopK(*#, #, #, #)", constructor.}

proc inTopK*(scope: Scope,
             predictions: ofloat,
             targets: InTopKT,
             k: int64 = 0.int): InTopK =
  return iiinTopK(scope,
                  predictions,
                  targets,
                  k)

converter inTopKToOut*(op: InTopK): obool {.inline.} = return op.output


type DatasetToSingleElement*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DatasetToSingleElement/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iidatasetToSingleElement[oT: oall](scope: Scope,
                             dataset: ovariant,
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape],
                             explicitT: type(oT)): DatasetToSingleElement[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DatasetToSingleElement(*#, #, #, #)", constructor.}

proc datasetToSingleElement*(scope: Scope,
                             dataset: ovariant,
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape],
                             explicitT: type): auto =
  return iidatasetToSingleElement(scope,
                                  dataset,
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes),
                                  explicitT)

converter datasetToSingleElementToOutList*[oT: oall](op: DatasetToSingleElement[oT]): olist[oT] {.inline.} = return op.output


type SoftmaxCrossEntropyWithLogits*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SoftmaxCrossEntropyWithLogits/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisoftmaxCrossEntropyWithLogits[oT: oall](scope: Scope,
                                    features: oT,
                                    labels: oT,
                                    T: DType): SoftmaxCrossEntropyWithLogits[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SoftmaxCrossEntropyWithLogits(*#, #, #, #)", constructor.}

proc softmaxCrossEntropyWithLogits*[oT: oall](scope: Scope,
                                    features: oT,
                                    labels: oT): SoftmaxCrossEntropyWithLogits[oT] =
  return iisoftmaxCrossEntropyWithLogits(scope,
                                         features,
                                         labels,
                                         oT[].oTF)

converter softmaxCrossEntropyWithLogitsToOut*[oT: oall](op: SoftmaxCrossEntropyWithLogits[oT]): oT {.inline.} = return op.output


type LogSoftmax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LogSoftmax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilogSoftmax[oT: oall](scope: Scope,
                 logits: oT,
                 T: DType): LogSoftmax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LogSoftmax(*#, #, #)", constructor.}

proc logSoftmax*[oT: oall](scope: Scope,
                 logits: oT): LogSoftmax[oT] =
  return iilogSoftmax(scope,
                      logits,
                      oT[].oTF)

converter logSoftmaxToOut*[oT: oall](op: LogSoftmax[oT]): oT {.inline.} = return op.output


type MutableHashTableV2* {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTableV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iimutableHashTableV2(scope: Scope,
                         container: cstring,
                         shared_name: cstring,
                         use_node_name_sharing: bool,
                         key_dtype: DType,
                         value_dtype: DType): MutableHashTableV2 {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTableV2(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc mutableHashTableV2*(scope: Scope,
                         container: cstring,
                         shared_name: cstring,
                         use_node_name_sharing: bool = false,
                         key_dtype: type oall = oinvalid,
                         value_dtype: type oall = oinvalid): MutableHashTableV2 =
  return iimutableHashTableV2(scope,
                              container,
                              shared_name,
                              use_node_name_sharing,
                              oT[].oTF,
                              oT[].oTF)

converter mutableHashTableV2ToOut*(op: MutableHashTableV2): oresource {.inline.} = return op.output


type Softplus*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Softplus/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisoftplus[oT: oall](scope: Scope,
               features: oT,
               T: DType): Softplus[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Softplus(*#, #, #)", constructor.}

proc softplus*[oT: oall](scope: Scope,
               features: oT): Softplus[oT] =
  return iisoftplus(scope,
                    features,
                    oT[].oTF)

converter softplusToOut*[oT: oall](op: Softplus[oT]): oT {.inline.} = return op.output


type Selu*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Selu/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiselu[oT: oall](scope: Scope,
           features: oT,
           T: DType): Selu[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Selu(*#, #, #)", constructor.}

proc selu*[oT: oall](scope: Scope,
           features: oT): Selu[oT] =
  return iiselu(scope,
                features,
                oT[].oTF)

converter seluToOut*[oT: oall](op: Selu[oT]): oT {.inline.} = return op.output


type EluGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"EluGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iieluGrad[oT: oall](scope: Scope,
              gradients: oT,
              outputs: oT,
              T: DType): EluGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"EluGrad(*#, #, #, #)", constructor.}

proc eluGrad*[oT: oall](scope: Scope,
              gradients: oT,
              outputs: oT): EluGrad[oT] =
  return iieluGrad(scope,
                   gradients,
                   outputs,
                   oT[].oTF)

converter eluGradToOut*[oT: oall](op: EluGrad[oT]): oT {.inline.} = return op.output


type LeakyReluGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LeakyReluGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iileakyReluGrad[oT: oall](scope: Scope,
                    gradients: oT,
                    features: oT,
                    alpha: float32,
                    T: DType): LeakyReluGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LeakyReluGrad(*#, #, #, #, #)", constructor.}

proc leakyReluGrad*[oT: oall](scope: Scope,
                    gradients: oT,
                    features: oT,
                    alpha: float32 = 0.2000000029802322.float32): LeakyReluGrad[oT] =
  return iileakyReluGrad(scope,
                         gradients,
                         features,
                         alpha,
                         oT[].oTF)

converter leakyReluGradToOut*[oT: oall](op: LeakyReluGrad[oT]): oT {.inline.} = return op.output


type StackPush*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPush/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistackPush[oT: oall](scope: Scope,
                handle: ostring,
                elem: oT,
                T: DType,
                swap_memory: bool): StackPush[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPush(*#, #, #, #, #)", constructor.}

proc stackPush*[oT: oall](scope: Scope,
                handle: ostring,
                elem: oT,
                swap_memory: bool = false): StackPush[oT] =
  return iistackPush(scope,
                     handle,
                     elem,
                     oT[].oTF,
                     swap_memory)

converter stackPushToOut*[oT: oall](op: StackPush[oT]): oT {.inline.} = return op.output


type LeakyRelu*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LeakyRelu/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iileakyRelu[oT: oall](scope: Scope,
                features: oT,
                alpha: float32,
                T: DType): LeakyRelu[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LeakyRelu(*#, #, #, #)", constructor.}

proc leakyRelu*[oT: oall](scope: Scope,
                features: oT,
                alpha: float32 = 0.2000000029802322.float32): LeakyRelu[oT] =
  return iileakyRelu(scope,
                     features,
                     alpha,
                     oT[].oTF)

converter leakyReluToOut*[oT: oall](op: LeakyRelu[oT]): oT {.inline.} = return op.output

type SparseSplitT* = oall

type SparseSplit* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSplit/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseSplit(scope: Scope,
                  split_dim: oint64,
                  indices: oint64,
                  values: SparseSplitT,
                  shape: oint64,
                  num_split: int64): SparseSplit {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSplit(*#, #, #, #, #, #)", constructor.}

proc sparseSplit*(scope: Scope,
                  split_dim: oint64,
                  indices: oint64,
                  values: SparseSplitT,
                  shape: oint64,
                  num_split: int64 = 0.int): SparseSplit =
  return iisparseSplit(scope,
                       split_dim,
                       indices,
                       values,
                       shape,
                       num_split)

converter sparseSplitToOut*(op: SparseSplit): oint64 {.inline.} = return op.output

type RaggedRangeT* = obfloat16 | ofloat | odouble | oint32 | oint64

type RaggedRange* {.header:"../tensorflow/ops/generated.h", importcpp:"RaggedRange/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiraggedRange(scope: Scope,
                  starts: RaggedRangeT,
                  limits: RaggedRangeT,
                  deltas: RaggedRangeT): RaggedRange {.header:"../tensorflow/ops/generated.h", importcpp:"RaggedRange(*#, #, #, #)", constructor.}

proc raggedRange*(scope: Scope,
                  starts: RaggedRangeT,
                  limits: RaggedRangeT,
                  deltas: RaggedRangeT): RaggedRange =
  return iiraggedRange(scope,
                       starts,
                       limits,
                       deltas)

converter raggedRangeToOut*(op: RaggedRange): oint64 {.inline.} = return op.output


type ReaderSerializeStateV2* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderSerializeStateV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireaderSerializeStateV2(scope: Scope,
                             reader_handle: oresource): ReaderSerializeStateV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderSerializeStateV2(*#, #)", constructor.}

proc readerSerializeStateV2*(scope: Scope,
                             reader_handle: oresource): ReaderSerializeStateV2 =
  return iireaderSerializeStateV2(scope,
                                  reader_handle)

converter readerSerializeStateV2ToOut*(op: ReaderSerializeStateV2): ostring {.inline.} = return op.output


type Relu6*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Relu6/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirelu6[oT: oall](scope: Scope,
            features: oT,
            T: DType): Relu6[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Relu6(*#, #, #)", constructor.}

proc relu6*[oT: oall](scope: Scope,
            features: oT): Relu6[oT] =
  return iirelu6(scope,
                 features,
                 oT[].oTF)

converter relu6ToOut*[oT: oall](op: Relu6[oT]): oT {.inline.} = return op.output


type ReluGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ReluGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireluGrad[oT: oall](scope: Scope,
               gradients: oT,
               features: oT,
               T: DType): ReluGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ReluGrad(*#, #, #, #)", constructor.}

proc reluGrad*[oT: oall](scope: Scope,
               gradients: oT,
               features: oT): ReluGrad[oT] =
  return iireluGrad(scope,
                    gradients,
                    features,
                    oT[].oTF)

converter reluGradToOut*[oT: oall](op: ReluGrad[oT]): oT {.inline.} = return op.output

type AllTidx* = oint32 | oint64

type All* {.header:"../tensorflow/ops/generated.h", importcpp:"All/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiall(scope: Scope,
          input: obool,
          reduction_indices: AllTidx,
          keep_dims: bool): All {.header:"../tensorflow/ops/generated.h", importcpp:"All(*#, #, #, #)", constructor.}

proc all*(scope: Scope,
          input: obool,
          reduction_indices: AllTidx,
          keep_dims: bool = false): All =
  return iiall(scope,
               input,
               reduction_indices,
               keep_dims)

converter allToOut*(op: All): obool {.inline.} = return op.output


type Dilation2DBackpropInput*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Dilation2DBackpropInput/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidilation2DBackpropInput[oT: oall](scope: Scope,
                              input: oT,
                              filter: oT,
                              out_backprop: oT,
                              strides: ArraySlice[int],
                              rates: ArraySlice[int],
                              padding: cstring,
                              T: DType): Dilation2DBackpropInput[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Dilation2DBackpropInput(*#, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc dilation2DBackpropInput*[oT: oall](scope: Scope,
                              input: oT,
                              filter: oT,
                              out_backprop: oT,
                              strides: openArray[int],
                              rates: openArray[int],
                              padding: cstring): Dilation2DBackpropInput[oT] =
  return iidilation2DBackpropInput(scope,
                                   input,
                                   filter,
                                   out_backprop,
                                   newArraySlice(strides),
                                   newArraySlice(rates),
                                   padding,
                                   oT[].oTF)

converter dilation2DBackpropInputToOut*[oT: oall](op: Dilation2DBackpropInput[oT]): oT {.inline.} = return op.output

type MaxPoolGradWithArgmaxTargmax* = oint32 | oint64

type MaxPoolGradWithArgmax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradWithArgmax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolGradWithArgmax[oT: oall](scope: Scope,
                            input: oT,
                            grad: oT,
                            argmax: MaxPoolGradWithArgmaxTargmax,
                            ksize: ArraySlice[int],
                            strides: ArraySlice[int],
                            padding: cstring,
                            T: DType): MaxPoolGradWithArgmax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradWithArgmax(*#, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc maxPoolGradWithArgmax*[oT: oall](scope: Scope,
                            input: oT,
                            grad: oT,
                            argmax: MaxPoolGradWithArgmaxTargmax,
                            ksize: openArray[int],
                            strides: openArray[int],
                            padding: cstring): MaxPoolGradWithArgmax[oT] =
  return iimaxPoolGradWithArgmax(scope,
                                 input,
                                 grad,
                                 argmax,
                                 newArraySlice(ksize),
                                 newArraySlice(strides),
                                 padding,
                                 oT[].oTF)

converter maxPoolGradWithArgmaxToOut*[oT: oall](op: MaxPoolGradWithArgmax[oT]): oT {.inline.} = return op.output


type MaxPoolGradGradV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradGradV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolGradGradV2[oT: oall](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: oint32,
                        strides: oint32,
                        padding: cstring,
                        data_format: cstring,
                        T: DType): MaxPoolGradGradV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradGradV2(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPoolGradGradV2*[oT: oall](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: oint32,
                        strides: oint32,
                        padding: cstring,
                        data_format: cstring = "NHWC"): MaxPoolGradGradV2[oT] =
  return iimaxPoolGradGradV2(scope,
                             orig_input,
                             orig_output,
                             grad,
                             ksize,
                             strides,
                             padding,
                             data_format,
                             oT[].oTF)

converter maxPoolGradGradV2ToOut*[oT: oall](op: MaxPoolGradGradV2[oT]): oT {.inline.} = return op.output


type MaxPoolGradV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolGradV2[oT: oall](scope: Scope,
                    orig_input: oT,
                    orig_output: oT,
                    grad: oT,
                    ksize: oint32,
                    strides: oint32,
                    padding: cstring,
                    data_format: cstring,
                    T: DType): MaxPoolGradV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradV2(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPoolGradV2*[oT: oall](scope: Scope,
                    orig_input: oT,
                    orig_output: oT,
                    grad: oT,
                    ksize: oint32,
                    strides: oint32,
                    padding: cstring,
                    data_format: cstring = "NHWC"): MaxPoolGradV2[oT] =
  return iimaxPoolGradV2(scope,
                         orig_input,
                         orig_output,
                         grad,
                         ksize,
                         strides,
                         padding,
                         data_format,
                         oT[].oTF)

converter maxPoolGradV2ToOut*[oT: oall](op: MaxPoolGradV2[oT]): oT {.inline.} = return op.output

type RollTaxis* = oint32 | oint64
type RollTshift* = oint32 | oint64

type Roll*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Roll/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiroll[oT: oall](scope: Scope,
           input: oT,
           shift: RollTshift,
           axis: RollTaxis,
           T: DType): Roll[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Roll(*#, #, #, #, #)", constructor.}

proc roll*[oT: oall](scope: Scope,
           input: oT,
           shift: RollTshift,
           axis: RollTaxis): Roll[oT] =
  return iiroll(scope,
                input,
                shift,
                axis,
                oT[].oTF)

converter rollToOut*[oT: oall](op: Roll[oT]): oT {.inline.} = return op.output


type MaxPoolGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolGrad[oT: oall](scope: Scope,
                  orig_input: oT,
                  orig_output: oT,
                  grad: oT,
                  ksize: ArraySlice[int],
                  strides: ArraySlice[int],
                  padding: cstring,
                  data_format: cstring,
                  T: DType): MaxPoolGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPoolGrad*[oT: oall](scope: Scope,
                  orig_input: oT,
                  orig_output: oT,
                  grad: oT,
                  ksize: openArray[int],
                  strides: openArray[int],
                  padding: cstring,
                  data_format: cstring = "NHWC"): MaxPoolGrad[oT] =
  return iimaxPoolGrad(scope,
                       orig_input,
                       orig_output,
                       grad,
                       newArraySlice(ksize),
                       newArraySlice(strides),
                       padding,
                       data_format,
                       oT[].oTF)

converter maxPoolGradToOut*[oT: oall](op: MaxPoolGrad[oT]): oT {.inline.} = return op.output


type LRNGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LRNGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilRNGrad[oT: oall](scope: Scope,
              input_grads: oT,
              input_image: oT,
              output_image: oT,
              depth_radius: int64,
              bias: float32,
              alpha: float32,
              beta: float32,
              T: DType): LRNGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LRNGrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc lRNGrad*[oT: oall](scope: Scope,
              input_grads: oT,
              input_image: oT,
              output_image: oT,
              depth_radius: int64 = 5.int,
              bias: float32 = 1.0.float32,
              alpha: float32 = 1.0.float32,
              beta: float32 = 0.5.float32): LRNGrad[oT] =
  return iilRNGrad(scope,
                   input_grads,
                   input_image,
                   output_image,
                   depth_radius,
                   bias,
                   alpha,
                   beta,
                   oT[].oTF)

converter lRNGradToOut*[oT: oall](op: LRNGrad[oT]): oT {.inline.} = return op.output


type MaxPool3DGradGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool3DGradGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPool3DGradGrad[oT: oall](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: ArraySlice[int],
                        strides: ArraySlice[int],
                        padding: cstring,
                        data_format: cstring,
                        T: DType): MaxPool3DGradGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool3DGradGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPool3DGradGrad*[oT: oall](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: openArray[int],
                        strides: openArray[int],
                        padding: cstring,
                        data_format: cstring = "NDHWC"): MaxPool3DGradGrad[oT] =
  return iimaxPool3DGradGrad(scope,
                             orig_input,
                             orig_output,
                             grad,
                             newArraySlice(ksize),
                             newArraySlice(strides),
                             padding,
                             data_format,
                             oT[].oTF)

converter maxPool3DGradGradToOut*[oT: oall](op: MaxPool3DGradGrad[oT]): oT {.inline.} = return op.output


type Conv3DBackpropFilter*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropFilter/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv3DBackpropFilter[oT: oall](scope: Scope,
                           input: oT,
                           filter: oT,
                           out_backprop: oT,
                           strides: ArraySlice[int],
                           padding: cstring,
                           T: DType,
                           dilations: ArraySlice[int]): Conv3DBackpropFilter[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropFilter(*#, #, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc conv3DBackpropFilter*[oT: oall](scope: Scope,
                           input: oT,
                           filter: oT,
                           out_backprop: oT,
                           strides: openArray[int],
                           padding: cstring,
                           dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int, 1.int]): Conv3DBackpropFilter[oT] =
  return iiconv3DBackpropFilter(scope,
                                input,
                                filter,
                                out_backprop,
                                newArraySlice(strides),
                                padding,
                                oT[].oTF,
                                newArraySlice(dilations))

converter conv3DBackpropFilterToOut*[oT: oall](op: Conv3DBackpropFilter[oT]): oT {.inline.} = return op.output


type Conv3D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv3D[oT: oall](scope: Scope,
             input: oT,
             filter: oT,
             strides: ArraySlice[int],
             padding: cstring,
             T: DType,
             data_format: cstring,
             dilations: ArraySlice[int]): Conv3D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3D(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc conv3D*[oT: oall](scope: Scope,
             input: oT,
             filter: oT,
             strides: openArray[int],
             padding: cstring,
             data_format: cstring = "NDHWC",
             dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int, 1.int]): Conv3D[oT] =
  return iiconv3D(scope,
                  input,
                  filter,
                  newArraySlice(strides),
                  padding,
                  oT[].oTF,
                  data_format,
                  newArraySlice(dilations))

converter conv3DToOut*[oT: oall](op: Conv3D[oT]): oT {.inline.} = return op.output

type CropAndResizeT* = ouint8 | ouint16 | oint8 | oint16 | oint32 | oint64 | ohalf | ofloat | odouble

type CropAndResize* {.header:"../tensorflow/ops/generated.h", importcpp:"CropAndResize/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iicropAndResize(scope: Scope,
                    image: CropAndResizeT,
                    boxes: ofloat,
                    box_ind: oint32,
                    crop_size: oint32,
                    extrapolation_value: float32,
                    nmethod: cstring): CropAndResize {.header:"../tensorflow/ops/generated.h", importcpp:"CropAndResize(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc cropAndResize*(scope: Scope,
                    image: CropAndResizeT,
                    boxes: ofloat,
                    box_ind: oint32,
                    crop_size: oint32,
                    extrapolation_value: float32 = 0.0.float32,
                    nmethod: cstring = "bilinear"): CropAndResize =
  return iicropAndResize(scope,
                         image,
                         boxes,
                         box_ind,
                         crop_size,
                         extrapolation_value,
                         nmethod)

converter cropAndResizeToOut*(op: CropAndResize): ofloat {.inline.} = return op.output


type DepthwiseConv2dNativeBackpropFilter*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthwiseConv2dNativeBackpropFilter/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidepthwiseConv2dNativeBackpropFilter[oT: oall](scope: Scope,
                                          input: oT,
                                          filter_sizes: oint32,
                                          out_backprop: oT,
                                          strides: ArraySlice[int],
                                          padding: cstring,
                                          T: DType,
                                          data_format: cstring,
                                          dilations: ArraySlice[int]): DepthwiseConv2dNativeBackpropFilter[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthwiseConv2dNativeBackpropFilter(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc depthwiseConv2dNativeBackpropFilter*[oT: oall](scope: Scope,
                                          input: oT,
                                          filter_sizes: oint32,
                                          out_backprop: oT,
                                          strides: openArray[int],
                                          padding: cstring,
                                          data_format: cstring = "NHWC",
                                          dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int]): DepthwiseConv2dNativeBackpropFilter[oT] =
  return iidepthwiseConv2dNativeBackpropFilter(scope,
                                               input,
                                               filter_sizes,
                                               out_backprop,
                                               newArraySlice(strides),
                                               padding,
                                               oT[].oTF,
                                               data_format,
                                               newArraySlice(dilations))

converter depthwiseConv2dNativeBackpropFilterToOut*[oT: oall](op: DepthwiseConv2dNativeBackpropFilter[oT]): oT {.inline.} = return op.output


type Expm1*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Expm1/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiexpm1[oT: oall](scope: Scope,
            x: oT,
            T: DType): Expm1[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Expm1(*#, #, #)", constructor.}

proc expm1*[oT: oall](scope: Scope,
            x: oT): Expm1[oT] =
  return iiexpm1(scope,
                 x,
                 oT[].oTF)

converter expm1ToOut*[oT: oall](op: Expm1[oT]): oT {.inline.} = return op.output


type Conv2DBackpropInput*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv2DBackpropInput/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv2DBackpropInput[oT: oall](scope: Scope,
                          input_sizes: oint32,
                          filter: oT,
                          out_backprop: oT,
                          strides: ArraySlice[int],
                          padding: cstring,
                          T: DType,
                          use_cudnn_on_gpu: bool,
                          data_format: cstring,
                          dilations: ArraySlice[int]): Conv2DBackpropInput[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv2DBackpropInput(*#, #, #, #, #, tensorflow::string(#), #, #, tensorflow::string(#), #)", constructor.}

proc conv2DBackpropInput*[oT: oall](scope: Scope,
                          input_sizes: oint32,
                          filter: oT,
                          out_backprop: oT,
                          strides: openArray[int],
                          padding: cstring,
                          use_cudnn_on_gpu: bool = true,
                          data_format: cstring = "NHWC",
                          dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int]): Conv2DBackpropInput[oT] =
  return iiconv2DBackpropInput(scope,
                               input_sizes,
                               filter,
                               out_backprop,
                               newArraySlice(strides),
                               padding,
                               oT[].oTF,
                               use_cudnn_on_gpu,
                               data_format,
                               newArraySlice(dilations))

converter conv2DBackpropInputToOut*[oT: oall](op: Conv2DBackpropInput[oT]): oT {.inline.} = return op.output


type INcclReduceRecv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_NcclReduceRecv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiNcclReduceRecv[oT: oall](scope: Scope,
                      input: oT,
                      reduction: cstring,
                      shared_name: cstring,
                      T: DType,
                      num_devices: int64): INcclReduceRecv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_NcclReduceRecv(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iNcclReduceRecv*[oT: oall](scope: Scope,
                      input: oT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64 = 0.int): INcclReduceRecv[oT] =
  return iiiNcclReduceRecv(scope,
                           input,
                           reduction,
                           shared_name,
                           oT[].oTF,
                           num_devices)

converter iNcclReduceRecvToOut*[oT: oall](op: INcclReduceRecv[oT]): oT {.inline.} = return op.output


type Conv2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv2D[oT: oall](scope: Scope,
             input: oT,
             filter: oT,
             strides: ArraySlice[int],
             padding: cstring,
             T: DType,
             use_cudnn_on_gpu: bool,
             data_format: cstring,
             dilations: ArraySlice[int]): Conv2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv2D(*#, #, #, #, tensorflow::string(#), #, #, tensorflow::string(#), #)", constructor.}

proc conv2D*[oT: oall](scope: Scope,
             input: oT,
             filter: oT,
             strides: openArray[int],
             padding: cstring,
             use_cudnn_on_gpu: bool = true,
             data_format: cstring = "NHWC",
             dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int]): Conv2D[oT] =
  return iiconv2D(scope,
                  input,
                  filter,
                  newArraySlice(strides),
                  padding,
                  oT[].oTF,
                  use_cudnn_on_gpu,
                  data_format,
                  newArraySlice(dilations))

converter conv2DToOut*[oT: oall](op: Conv2D[oT]): oT {.inline.} = return op.output


type Sin*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sin/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisin[oT: oall](scope: Scope,
          x: oT,
          T: DType): Sin[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sin(*#, #, #)", constructor.}

proc sin*[oT: oall](scope: Scope,
          x: oT): Sin[oT] =
  return iisin(scope,
               x,
               oT[].oTF)

converter sinToOut*[oT: oall](op: Sin[oT]): oT {.inline.} = return op.output

type FusedBatchNormV2U* = ofloat

type FusedBatchNormV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNormV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifusedBatchNormV2[oT: oall](scope: Scope,
                       x: oT,
                       scale: FusedBatchNormV2U,
                       offset: FusedBatchNormV2U,
                       mean: FusedBatchNormV2U,
                       variance: FusedBatchNormV2U,
                       T: DType,
                       is_training: bool,
                       epsilon: float32,
                       data_format: cstring): FusedBatchNormV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNormV2(*#, #, #, #, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc fusedBatchNormV2*[oT: oall](scope: Scope,
                       x: oT,
                       scale: FusedBatchNormV2U,
                       offset: FusedBatchNormV2U,
                       mean: FusedBatchNormV2U,
                       variance: FusedBatchNormV2U,
                       is_training: bool = true,
                       epsilon: float32 = 9.999999747378752e-05.float32,
                       data_format: cstring = "NHWC"): FusedBatchNormV2[oT] =
  return iifusedBatchNormV2(scope,
                            x,
                            scale,
                            offset,
                            mean,
                            variance,
                            oT[].oTF,
                            is_training,
                            epsilon,
                            data_format)

converter fusedBatchNormV2ToOut*[oT: oall](op: FusedBatchNormV2[oT]): oT {.inline.} = return op.output

type SparseMatMulTa* = ofloat | obfloat16
type SparseMatMulTb* = ofloat | obfloat16

type SparseMatMul* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseMatMul/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iisparseMatMul(scope: Scope,
                   a: SparseMatMulTa,
                   b: SparseMatMulTb,
                   transpose_a: bool,
                   transpose_b: bool,
                   a_is_sparse: bool,
                   b_is_sparse: bool): SparseMatMul {.header:"../tensorflow/ops/generated.h", importcpp:"SparseMatMul(*#, #, #, #, #, #, #)", constructor.}

proc sparseMatMul*(scope: Scope,
                   a: SparseMatMulTa,
                   b: SparseMatMulTb,
                   transpose_a: bool = false,
                   transpose_b: bool = false,
                   a_is_sparse: bool = false,
                   b_is_sparse: bool = false): SparseMatMul =
  return iisparseMatMul(scope,
                        a,
                        b,
                        transpose_a,
                        transpose_b,
                        a_is_sparse,
                        b_is_sparse)

converter sparseMatMulToOut*(op: SparseMatMul): ofloat {.inline.} = return op.output


type FusedBatchNorm*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNorm/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifusedBatchNorm[oT: oall](scope: Scope,
                     x: oT,
                     scale: oT,
                     offset: oT,
                     mean: oT,
                     variance: oT,
                     T: DType,
                     epsilon: float32,
                     data_format: cstring,
                     is_training: bool): FusedBatchNorm[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNorm(*#, #, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc fusedBatchNorm*[oT: oall](scope: Scope,
                     x: oT,
                     scale: oT,
                     offset: oT,
                     mean: oT,
                     variance: oT,
                     epsilon: float32 = 9.999999747378752e-05.float32,
                     data_format: cstring = "NHWC",
                     is_training: bool = true): FusedBatchNorm[oT] =
  return iifusedBatchNorm(scope,
                          x,
                          scale,
                          offset,
                          mean,
                          variance,
                          oT[].oTF,
                          epsilon,
                          data_format,
                          is_training)

converter fusedBatchNormToOut*[oT: oall](op: FusedBatchNorm[oT]): oT {.inline.} = return op.output


type ReduceDataset*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ReduceDataset/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iireduceDataset[oT: oall](scope: Scope,
                    input_dataset: ovariant,
                    initial_state: olist[oall],
                    other_arguments: olist[oall],
                    f: NameAttrList,
                    Tstate: ArraySlice[DType],
                    Targuments: ArraySlice[DType],
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape],
                    use_inter_op_parallelism: bool,
                    explicitT: type(oT)): ReduceDataset[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ReduceDataset(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc reduceDataset*(scope: Scope,
                    input_dataset: ovariant,
                    initial_state: olist[oall],
                    other_arguments: olist[oall],
                    f: NameAttrList,
                    Tstate: openArray[DType],
                    Targuments: openArray[DType],
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape],
                    use_inter_op_parallelism: bool = true,
                    explicitT: type): auto =
  return iireduceDataset(scope,
                         input_dataset,
                         initial_state,
                         other_arguments,
                         f,
                         newArraySlice(Tstate),
                         newArraySlice(Targuments),
                         newArraySlice(output_types),
                         newArraySlice(output_shapes),
                         use_inter_op_parallelism,
                         explicitT)

converter reduceDatasetToOutList*[oT: oall](op: ReduceDataset[oT]): olist[oT] {.inline.} = return op.output


type FakeQuantWithMinMaxArgs* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxArgs/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iifakeQuantWithMinMaxArgs(scope: Scope,
                              inputs: ofloat,
                              min: float32,
                              max: float32,
                              num_bits: int64,
                              narrow_range: bool): FakeQuantWithMinMaxArgs {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxArgs(*#, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxArgs*(scope: Scope,
                              inputs: ofloat,
                              min: float32 = -6.0.float32,
                              max: float32 = 6.0.float32,
                              num_bits: int64 = 8.int,
                              narrow_range: bool = false): FakeQuantWithMinMaxArgs =
  return iifakeQuantWithMinMaxArgs(scope,
                                   inputs,
                                   min,
                                   max,
                                   num_bits,
                                   narrow_range)

converter fakeQuantWithMinMaxArgsToOut*(op: FakeQuantWithMinMaxArgs): ofloat {.inline.} = return op.output


type BatchNormWithGlobalNormalization*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchNormWithGlobalNormalization/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchNormWithGlobalNormalization[oT: oall](scope: Scope,
                                       t: oT,
                                       m: oT,
                                       v: oT,
                                       beta: oT,
                                       gamma: oT,
                                       T: DType,
                                       variance_epsilon: float32,
                                       scale_after_normalization: bool): BatchNormWithGlobalNormalization[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchNormWithGlobalNormalization(*#, #, #, #, #, #, #, #, #)", constructor.}

proc batchNormWithGlobalNormalization*[oT: oall](scope: Scope,
                                       t: oT,
                                       m: oT,
                                       v: oT,
                                       beta: oT,
                                       gamma: oT,
                                       variance_epsilon: float32 = 0.0.float32,
                                       scale_after_normalization: bool = false): BatchNormWithGlobalNormalization[oT] =
  return iibatchNormWithGlobalNormalization(scope,
                                            t,
                                            m,
                                            v,
                                            beta,
                                            gamma,
                                            oT[].oTF,
                                            variance_epsilon,
                                            scale_after_normalization)

converter batchNormWithGlobalNormalizationToOut*[oT: oall](op: BatchNormWithGlobalNormalization[oT]): oT {.inline.} = return op.output


type ApplyFtrlV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyFtrlV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyFtrlV2[oT: oall](scope: Scope,
                  nvar: oT,
                  accum: oT,
                  linear: oT,
                  grad: oT,
                  lr: oT,
                  l1: oT,
                  l2: oT,
                  l2_shrinkage: oT,
                  lr_power: oT,
                  T: DType,
                  use_locking: bool): ApplyFtrlV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyFtrlV2*[oT: oall](scope: Scope,
                  nvar: oT,
                  accum: oT,
                  linear: oT,
                  grad: oT,
                  lr: oT,
                  l1: oT,
                  l2: oT,
                  l2_shrinkage: oT,
                  lr_power: oT,
                  use_locking: bool = false): ApplyFtrlV2[oT] =
  return iiapplyFtrlV2(scope,
                       nvar,
                       accum,
                       linear,
                       grad,
                       lr,
                       l1,
                       l2,
                       l2_shrinkage,
                       lr_power,
                       oT[].oTF,
                       use_locking)

converter applyFtrlV2ToOut*[oT: oall](op: ApplyFtrlV2[oT]): oT {.inline.} = return op.output

type WhereT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64 | obool

type Where* {.header:"../tensorflow/ops/generated.h", importcpp:"Where/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiwhere(scope: Scope,
            input: WhereT): Where {.header:"../tensorflow/ops/generated.h", importcpp:"Where(*#, #)", constructor.}

proc where*(scope: Scope,
            input: WhereT): Where =
  return iiwhere(scope,
                 input)

converter whereToOut*(op: Where): oint64 {.inline.} = return op.output

type INcclReduceSendT* = ohalf | ofloat | odouble | oint32 | oint64

type INcclReduceSend*{.header:"../tensorflow/ops/generated.h", importcpp:"_NcclReduceSend/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiiNcclReduceSend(scope: Scope,
                      input: INcclReduceSendT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64): INcclReduceSend {.header:"../tensorflow/ops/generated.h", importcpp:"_NcclReduceSend(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc iNcclReduceSend*(scope: Scope,
                      input: INcclReduceSendT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64 = 0.int): INcclReduceSend =
  return iiiNcclReduceSend(scope,
                           input,
                           reduction,
                           shared_name,
                           num_devices)




type GetSessionTensor*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"GetSessionTensor/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iigetSessionTensor[oT: oall](scope: Scope,
                       handle: ostring,
                       dtype: DType,
                       explicitT: type(oT)): GetSessionTensor[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"GetSessionTensor(*#, #, #)", constructor.}

proc getSessionTensor*(scope: Scope,
                       handle: ostring,
                       dtype: type = oinvalid): auto =
  return iigetSessionTensor(scope,
                            handle,
                            dtype[].oTF,
                            dtype)

converter getSessionTensorToOut*[oT: oall](op: GetSessionTensor[oT]): oT {.inline.} = return op.output

type MinTidx* = oint32 | oint64

type Min*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Min/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimin[oT: oall](scope: Scope,
          input: oT,
          reduction_indices: MinTidx,
          keep_dims: bool,
          T: DType): Min[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Min(*#, #, #, #, #)", constructor.}

proc min*[oT: oall](scope: Scope,
          input: oT,
          reduction_indices: MinTidx,
          keep_dims: bool = false): Min[oT] =
  return iimin(scope,
               input,
               reduction_indices,
               keep_dims,
               oT[].oTF)

converter minToOut*[oT: oall](op: Min[oT]): oT {.inline.} = return op.output


type NcclAllReduce*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"NcclAllReduce/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iincclAllReduce[oT: oall](scope: Scope,
                    input: oT,
                    reduction: cstring,
                    shared_name: cstring,
                    T: DType,
                    num_devices: int64): NcclAllReduce[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"NcclAllReduce(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc ncclAllReduce*[oT: oall](scope: Scope,
                    input: oT,
                    reduction: cstring,
                    shared_name: cstring,
                    num_devices: int64 = 0.int): NcclAllReduce[oT] =
  return iincclAllReduce(scope,
                         input,
                         reduction,
                         shared_name,
                         oT[].oTF,
                         num_devices)

converter ncclAllReduceToOut*[oT: oall](op: NcclAllReduce[oT]): oT {.inline.} = return op.output


type ReadVariableOp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ReadVariableOp/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireadVariableOp[oT: oall](scope: Scope,
                     resource: oresource,
                     dtype: DType,
                     explicitT: type(oT)): ReadVariableOp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ReadVariableOp(*#, #, #)", constructor.}

proc readVariableOp*(scope: Scope,
                     resource: oresource,
                     dtype: type = oinvalid): auto =
  return iireadVariableOp(scope,
                          resource,
                          dtype[].oTF,
                          dtype)

converter readVariableOpToOut*[oT: oall](op: ReadVariableOp[oT]): oT {.inline.} = return op.output


type Lgamma*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Lgamma/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilgamma[oT: oall](scope: Scope,
             x: oT,
             T: DType): Lgamma[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Lgamma(*#, #, #)", constructor.}

proc lgamma*[oT: oall](scope: Scope,
             x: oT): Lgamma[oT] =
  return iilgamma(scope,
                  x,
                  oT[].oTF)

converter lgammaToOut*[oT: oall](op: Lgamma[oT]): oT {.inline.} = return op.output

type RequantizationRangeTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type RequantizationRange* {.header:"../tensorflow/ops/generated.h", importcpp:"RequantizationRange/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iirequantizationRange(scope: Scope,
                          input: RequantizationRangeTinput,
                          input_min: ofloat,
                          input_max: ofloat): RequantizationRange {.header:"../tensorflow/ops/generated.h", importcpp:"RequantizationRange(*#, #, #, #)", constructor.}

proc requantizationRange*(scope: Scope,
                          input: RequantizationRangeTinput,
                          input_min: ofloat,
                          input_max: ofloat): RequantizationRange =
  return iirequantizationRange(scope,
                               input,
                               input_min,
                               input_max)

converter requantizationRangeToOut*(op: RequantizationRange): ofloat {.inline.} = return op.output

type CompareAndBitpackT* = obool | ohalf | ofloat | odouble | oint8 | oint16 | oint32 | oint64

type CompareAndBitpack* {.header:"../tensorflow/ops/generated.h", importcpp:"CompareAndBitpack/*'0*/".} = object
  operation*: Operation[ouint8]
  output*: ouint8

proc iicompareAndBitpack(scope: Scope,
                        input: CompareAndBitpackT,
                        threshold: CompareAndBitpackT): CompareAndBitpack {.header:"../tensorflow/ops/generated.h", importcpp:"CompareAndBitpack(*#, #, #)", constructor.}

proc compareAndBitpack*(scope: Scope,
                        input: CompareAndBitpackT,
                        threshold: CompareAndBitpackT): CompareAndBitpack =
  return iicompareAndBitpack(scope,
                             input,
                             threshold)

converter compareAndBitpackToOut*(op: CompareAndBitpack): ouint8 {.inline.} = return op.output

type QuantizeDownAndShrinkRangeTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizeDownAndShrinkRange*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeDownAndShrinkRange/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizeDownAndShrinkRange[oT: oall](scope: Scope,
                                 input: QuantizeDownAndShrinkRangeTinput,
                                 input_min: ofloat,
                                 input_max: ofloat,
                                 out_type: DType,
                                 explicitT: type(oT)): QuantizeDownAndShrinkRange[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeDownAndShrinkRange(*#, #, #, #, #)", constructor.}

proc quantizeDownAndShrinkRange*(scope: Scope,
                                 input: QuantizeDownAndShrinkRangeTinput,
                                 input_min: ofloat,
                                 input_max: ofloat,
                                 out_type: type = oinvalid): auto =
  return iiquantizeDownAndShrinkRange(scope,
                                      input,
                                      input_min,
                                      input_max,
                                      out_type[].oTF,
                                      out_type)

converter quantizeDownAndShrinkRangeToOut*[oT: oall](op: QuantizeDownAndShrinkRange[oT]): oT {.inline.} = return op.output

type QuantizedMatMulT1* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedMatMulT2* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedMatMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedMatMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedMatMul[oT: oall](scope: Scope,
                      a: QuantizedMatMulT1,
                      b: QuantizedMatMulT2,
                      min_a: ofloat,
                      max_a: ofloat,
                      min_b: ofloat,
                      max_b: ofloat,
                      Tactivation: DType,
                      transpose_b: bool,
                      Toutput: DType,
                      transpose_a: bool,
                      explicitT: type(oT)): QuantizedMatMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedMatMul(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc quantizedMatMul*(scope: Scope,
                      a: QuantizedMatMulT1,
                      b: QuantizedMatMulT2,
                      min_a: ofloat,
                      max_a: ofloat,
                      min_b: ofloat,
                      max_b: ofloat,
                      Tactivation: type(oqint8) | type(oquint8) | type(oqint32) | type(oqint16) | type(oquint16) = oquint8,
                      transpose_b: bool = false,
                      Toutput: type = oqint32,
                      transpose_a: bool = false): auto =
  return iiquantizedMatMul(scope,
                           a,
                           b,
                           min_a,
                           max_a,
                           min_b,
                           max_b,
                           Tactivation[].oTF,
                           transpose_b,
                           Toutput[].oTF,
                           transpose_a,
                           Toutput)

converter quantizedMatMulToOut*[oT: oall](op: QuantizedMatMul[oT]): oT {.inline.} = return op.output


type BatchNormWithGlobalNormalizationGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchNormWithGlobalNormalizationGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchNormWithGlobalNormalizationGrad[oT: oall](scope: Scope,
                                           t: oT,
                                           m: oT,
                                           v: oT,
                                           gamma: oT,
                                           backprop: oT,
                                           T: DType,
                                           variance_epsilon: float32,
                                           scale_after_normalization: bool): BatchNormWithGlobalNormalizationGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchNormWithGlobalNormalizationGrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc batchNormWithGlobalNormalizationGrad*[oT: oall](scope: Scope,
                                           t: oT,
                                           m: oT,
                                           v: oT,
                                           gamma: oT,
                                           backprop: oT,
                                           variance_epsilon: float32 = 0.0.float32,
                                           scale_after_normalization: bool = false): BatchNormWithGlobalNormalizationGrad[oT] =
  return iibatchNormWithGlobalNormalizationGrad(scope,
                                                t,
                                                m,
                                                v,
                                                gamma,
                                                backprop,
                                                oT[].oTF,
                                                variance_epsilon,
                                                scale_after_normalization)

converter batchNormWithGlobalNormalizationGradToOut*[oT: oall](op: BatchNormWithGlobalNormalizationGrad[oT]): oT {.inline.} = return op.output


type Bincount*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Bincount/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibincount[oT: oall](scope: Scope,
               arr: oint32,
               size: oint32,
               weights: oT,
               T: DType): Bincount[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Bincount(*#, #, #, #, #)", constructor.}

proc bincount*[oT: oall](scope: Scope,
               arr: oint32,
               size: oint32,
               weights: oT): Bincount[oT] =
  return iibincount(scope,
                    arr,
                    size,
                    weights,
                    oT[].oTF)

converter bincountToOut*[oT: oall](op: Bincount[oT]): oT {.inline.} = return op.output


type DestroyResourceOp*{.header:"../tensorflow/ops/generated.h", importcpp:"DestroyResourceOp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iidestroyResourceOp(scope: Scope,
                        resource: oresource,
                        ignore_lookup_error: bool): DestroyResourceOp {.header:"../tensorflow/ops/generated.h", importcpp:"DestroyResourceOp(*#, #, #)", constructor.}

proc destroyResourceOp*(scope: Scope,
                        resource: oresource,
                        ignore_lookup_error: bool = true): DestroyResourceOp =
  return iidestroyResourceOp(scope,
                             resource,
                             ignore_lookup_error)



type HistogramFixedWidthT* = oint32 | oint64 | ofloat | odouble

type HistogramFixedWidth*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"HistogramFixedWidth/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iihistogramFixedWidth[oT: oall](scope: Scope,
                          values: HistogramFixedWidthT,
                          value_range: HistogramFixedWidthT,
                          nbins: oint32,
                          dtype: DType,
                          explicitT: type(oT)): HistogramFixedWidth[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"HistogramFixedWidth(*#, #, #, #, #)", constructor.}

proc histogramFixedWidth*(scope: Scope,
                          values: HistogramFixedWidthT,
                          value_range: HistogramFixedWidthT,
                          nbins: oint32,
                          dtype: type = oint32): auto =
  return iihistogramFixedWidth(scope,
                               values,
                               value_range,
                               nbins,
                               dtype[].oTF,
                               dtype)

converter histogramFixedWidthToOut*[oT: oall](op: HistogramFixedWidth[oT]): oT {.inline.} = return op.output


type BatchSelfAdjointEigV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchSelfAdjointEigV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchSelfAdjointEigV2[oT: oall](scope: Scope,
                            input: oT,
                            compute_v: bool,
                            T: DType): BatchSelfAdjointEigV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchSelfAdjointEigV2(*#, #, #, #)", constructor.}

proc batchSelfAdjointEigV2*[oT: oall](scope: Scope,
                            input: oT,
                            compute_v: bool = true): BatchSelfAdjointEigV2[oT] =
  return iibatchSelfAdjointEigV2(scope,
                                 input,
                                 compute_v,
                                 oT[].oTF)

converter batchSelfAdjointEigV2ToOut*[oT: oall](op: BatchSelfAdjointEigV2[oT]): oT {.inline.} = return op.output


type NcclBroadcast*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"NcclBroadcast/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iincclBroadcast[oT: oall](scope: Scope,
                    input: oT,
                    T: DType,
                    shape: TensorShape): NcclBroadcast[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"NcclBroadcast(*#, #, #, #)", constructor.}

proc ncclBroadcast*[oT: oall](scope: Scope,
                    input: oT,
                    shape: TensorShape = [].shape): NcclBroadcast[oT] =
  return iincclBroadcast(scope,
                         input,
                         oT[].oTF,
                         shape)

converter ncclBroadcastToOut*[oT: oall](op: NcclBroadcast[oT]): oT {.inline.} = return op.output


type Cross*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cross/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicross[oT: oall](scope: Scope,
            a: oT,
            b: oT,
            T: DType): Cross[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cross(*#, #, #, #)", constructor.}

proc cross*[oT: oall](scope: Scope,
            a: oT,
            b: oT): Cross[oT] =
  return iicross(scope,
                 a,
                 b,
                 oT[].oTF)

converter crossToOut*[oT: oall](op: Cross[oT]): oT {.inline.} = return op.output


type Conj*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conj/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconj[oT: oall](scope: Scope,
           input: oT,
           T: DType): Conj[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conj(*#, #, #)", constructor.}

proc conj*[oT: oall](scope: Scope,
           input: oT): Conj[oT] =
  return iiconj(scope,
                input,
                oT[].oTF)

converter conjToOut*[oT: oall](op: Conj[oT]): oT {.inline.} = return op.output


type ExperimentalSleepDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSleepDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalSleepDataset(scope: Scope,
                               input_dataset: ovariant,
                               sleep_microseconds: oint64,
                               output_types: ArraySlice[DType],
                               output_shapes: ArraySlice[TensorShape]): ExperimentalSleepDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSleepDataset(*#, #, #, #, #)", constructor.}

proc experimentalSleepDataset*(scope: Scope,
                               input_dataset: ovariant,
                               sleep_microseconds: oint64,
                               output_types: openArray[DType],
                               output_shapes: openArray[TensorShape]): ExperimentalSleepDataset =
  return iiexperimentalSleepDataset(scope,
                                    input_dataset,
                                    sleep_microseconds,
                                    newArraySlice(output_types),
                                    newArraySlice(output_shapes))

converter experimentalSleepDatasetToOut*(op: ExperimentalSleepDataset): ovariant {.inline.} = return op.output


type IMklAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiMklAdd[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8,
              T: DType): IMklAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklAdd(*#, #, #, #, #, #)", constructor.}

proc iMklAdd*[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklAdd[oT] =
  return iiiMklAdd(scope,
                   x,
                   y,
                   mkl_x,
                   mkl_y,
                   oT[].oTF)

converter iMklAddToOut*[oT: oall](op: IMklAdd[oT]): oT {.inline.} = return op.output

type RealT* = ocomplex64 | ocomplex128

type Real*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Real/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireal[oT: oall](scope: Scope,
           input: RealT,
           Tout: DType,
           explicitT: type(oT)): Real[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Real(*#, #, #)", constructor.}

proc real*(scope: Scope,
           input: RealT,
           Tout: type = ofloat): auto =
  return iireal(scope,
                input,
                Tout[].oTF,
                Tout)

converter realToOut*[oT: oall](op: Real[oT]): oT {.inline.} = return op.output

type DequantizeT* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type Dequantize* {.header:"../tensorflow/ops/generated.h", importcpp:"Dequantize/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iidequantize(scope: Scope,
                 input: DequantizeT,
                 min_range: ofloat,
                 max_range: ofloat,
                 mode: cstring): Dequantize {.header:"../tensorflow/ops/generated.h", importcpp:"Dequantize(*#, #, #, #, tensorflow::string(#))", constructor.}

proc dequantize*(scope: Scope,
                 input: DequantizeT,
                 min_range: ofloat,
                 max_range: ofloat,
                 mode: cstring = "MIN_COMBINED"): Dequantize =
  return iidequantize(scope,
                      input,
                      min_range,
                      max_range,
                      mode)

converter dequantizeToOut*(op: Dequantize): ofloat {.inline.} = return op.output

type ComplexT* = ofloat | odouble

type Complex*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Complex/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicomplex[oT: oall](scope: Scope,
              real: ComplexT,
              imag: ComplexT,
              Tout: DType,
              explicitT: type(oT)): Complex[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Complex(*#, #, #, #)", constructor.}

proc complex*(scope: Scope,
              real: ComplexT,
              imag: ComplexT,
              Tout: type = ocomplex64): auto =
  return iicomplex(scope,
                   real,
                   imag,
                   Tout[].oTF,
                   Tout)

converter complexToOut*[oT: oall](op: Complex[oT]): oT {.inline.} = return op.output

type SparseSoftmaxCrossEntropyWithLogitsTlabels* = oint32 | oint64

type SparseSoftmaxCrossEntropyWithLogits*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSoftmaxCrossEntropyWithLogits/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSoftmaxCrossEntropyWithLogits[oT: oall](scope: Scope,
                                          features: oT,
                                          labels: SparseSoftmaxCrossEntropyWithLogitsTlabels,
                                          T: DType): SparseSoftmaxCrossEntropyWithLogits[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSoftmaxCrossEntropyWithLogits(*#, #, #, #)", constructor.}

proc sparseSoftmaxCrossEntropyWithLogits*[oT: oall](scope: Scope,
                                          features: oT,
                                          labels: SparseSoftmaxCrossEntropyWithLogitsTlabels): SparseSoftmaxCrossEntropyWithLogits[oT] =
  return iisparseSoftmaxCrossEntropyWithLogits(scope,
                                               features,
                                               labels,
                                               oT[].oTF)

converter sparseSoftmaxCrossEntropyWithLogitsToOut*[oT: oall](op: SparseSoftmaxCrossEntropyWithLogits[oT]): oT {.inline.} = return op.output


type Cholesky*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cholesky/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicholesky[oT: oall](scope: Scope,
               input: oT,
               T: DType): Cholesky[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cholesky(*#, #, #)", constructor.}

proc cholesky*[oT: oall](scope: Scope,
               input: oT): Cholesky[oT] =
  return iicholesky(scope,
                    input,
                    oT[].oTF)

converter choleskyToOut*[oT: oall](op: Cholesky[oT]): oT {.inline.} = return op.output

type SparseSegmentSqrtNWithNumSegmentsTidx* = oint32 | oint64
type SparseSegmentSqrtNWithNumSegmentsTnumsegments* = oint32 | oint64

type SparseSegmentSqrtNWithNumSegments*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSqrtNWithNumSegments/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentSqrtNWithNumSegments[oT: oall](scope: Scope,
                                        data: oT,
                                        indices: SparseSegmentSqrtNWithNumSegmentsTidx,
                                        segment_ids: oint32,
                                        num_segments: SparseSegmentSqrtNWithNumSegmentsTnumsegments,
                                        T: DType): SparseSegmentSqrtNWithNumSegments[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSqrtNWithNumSegments(*#, #, #, #, #, #)", constructor.}

proc sparseSegmentSqrtNWithNumSegments*[oT: oall](scope: Scope,
                                        data: oT,
                                        indices: SparseSegmentSqrtNWithNumSegmentsTidx,
                                        segment_ids: oint32,
                                        num_segments: SparseSegmentSqrtNWithNumSegmentsTnumsegments): SparseSegmentSqrtNWithNumSegments[oT] =
  return iisparseSegmentSqrtNWithNumSegments(scope,
                                             data,
                                             indices,
                                             segment_ids,
                                             num_segments,
                                             oT[].oTF)

converter sparseSegmentSqrtNWithNumSegmentsToOut*[oT: oall](op: SparseSegmentSqrtNWithNumSegments[oT]): oT {.inline.} = return op.output

type SparseSegmentMeanTidx* = oint32 | oint64

type SparseSegmentMean*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentMean/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentMean[oT: oall](scope: Scope,
                        data: oT,
                        indices: SparseSegmentMeanTidx,
                        segment_ids: oint32,
                        T: DType): SparseSegmentMean[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentMean(*#, #, #, #, #)", constructor.}

proc sparseSegmentMean*[oT: oall](scope: Scope,
                        data: oT,
                        indices: SparseSegmentMeanTidx,
                        segment_ids: oint32): SparseSegmentMean[oT] =
  return iisparseSegmentMean(scope,
                             data,
                             indices,
                             segment_ids,
                             oT[].oTF)

converter sparseSegmentMeanToOut*[oT: oall](op: SparseSegmentMean[oT]): oT {.inline.} = return op.output

type SparseSegmentSumWithNumSegmentsTidx* = oint32 | oint64
type SparseSegmentSumWithNumSegmentsTnumsegments* = oint32 | oint64

type SparseSegmentSumWithNumSegments*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSumWithNumSegments/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentSumWithNumSegments[oT: oall](scope: Scope,
                                      data: oT,
                                      indices: SparseSegmentSumWithNumSegmentsTidx,
                                      segment_ids: oint32,
                                      num_segments: SparseSegmentSumWithNumSegmentsTnumsegments,
                                      T: DType): SparseSegmentSumWithNumSegments[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSumWithNumSegments(*#, #, #, #, #, #)", constructor.}

proc sparseSegmentSumWithNumSegments*[oT: oall](scope: Scope,
                                      data: oT,
                                      indices: SparseSegmentSumWithNumSegmentsTidx,
                                      segment_ids: oint32,
                                      num_segments: SparseSegmentSumWithNumSegmentsTnumsegments): SparseSegmentSumWithNumSegments[oT] =
  return iisparseSegmentSumWithNumSegments(scope,
                                           data,
                                           indices,
                                           segment_ids,
                                           num_segments,
                                           oT[].oTF)

converter sparseSegmentSumWithNumSegmentsToOut*[oT: oall](op: SparseSegmentSumWithNumSegments[oT]): oT {.inline.} = return op.output

type UnsortedSegmentProdTindices* = oint32 | oint64
type UnsortedSegmentProdTnumsegments* = oint32 | oint64

type UnsortedSegmentProd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentProd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunsortedSegmentProd[oT: oall](scope: Scope,
                          data: oT,
                          segment_ids: UnsortedSegmentProdTindices,
                          num_segments: UnsortedSegmentProdTnumsegments,
                          T: DType): UnsortedSegmentProd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentProd(*#, #, #, #, #)", constructor.}

proc unsortedSegmentProd*[oT: oall](scope: Scope,
                          data: oT,
                          segment_ids: UnsortedSegmentProdTindices,
                          num_segments: UnsortedSegmentProdTnumsegments): UnsortedSegmentProd[oT] =
  return iiunsortedSegmentProd(scope,
                               data,
                               segment_ids,
                               num_segments,
                               oT[].oTF)

converter unsortedSegmentProdToOut*[oT: oall](op: UnsortedSegmentProd[oT]): oT {.inline.} = return op.output

type UnsortedSegmentSumTindices* = oint32 | oint64
type UnsortedSegmentSumTnumsegments* = oint32 | oint64

type UnsortedSegmentSum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentSum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunsortedSegmentSum[oT: oall](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentSumTindices,
                         num_segments: UnsortedSegmentSumTnumsegments,
                         T: DType): UnsortedSegmentSum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentSum(*#, #, #, #, #)", constructor.}

proc unsortedSegmentSum*[oT: oall](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentSumTindices,
                         num_segments: UnsortedSegmentSumTnumsegments): UnsortedSegmentSum[oT] =
  return iiunsortedSegmentSum(scope,
                              data,
                              segment_ids,
                              num_segments,
                              oT[].oTF)

converter unsortedSegmentSumToOut*[oT: oall](op: UnsortedSegmentSum[oT]): oT {.inline.} = return op.output


type IReadVariablesOp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ReadVariablesOp/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiReadVariablesOp[oT: oall](scope: Scope,
                       resources: olist[oresource],
                       dtypes: ArraySlice[DType],
                       explicitT: type(oT)): IReadVariablesOp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ReadVariablesOp(*#, #, #)", constructor.}

proc iReadVariablesOp*(scope: Scope,
                       resources: olist[oresource],
                       dtypes: openArray[DType],
                       explicitT: type): auto =
  return iiiReadVariablesOp(scope,
                            resources,
                            newArraySlice(dtypes),
                            explicitT)

converter iReadVariablesOpToOutList*[oT: oall](op: IReadVariablesOp[oT]): olist[oT] {.inline.} = return op.output


type L2Loss*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"L2Loss/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iil2Loss[oT: oall](scope: Scope,
             t: oT,
             T: DType): L2Loss[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"L2Loss(*#, #, #)", constructor.}

proc l2Loss*[oT: oall](scope: Scope,
             t: oT): L2Loss[oT] =
  return iil2Loss(scope,
                  t,
                  oT[].oTF)

converter l2LossToOut*[oT: oall](op: L2Loss[oT]): oT {.inline.} = return op.output

type CastSrcT* = oall

type Cast*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cast/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iincast[oT: oall](scope: Scope,
            x: CastSrcT,
            Truncate: bool,
            DstT: DType,
            explicitT: type(oT)): Cast[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cast(*#, #, #, #)", constructor.}

proc ncast*(scope: Scope,
            x: CastSrcT,
            Truncate: bool = false,
            DstT: type = oinvalid): auto =
  return iincast(scope,
                 x,
                 Truncate,
                 DstT[].oTF,
                 DstT)

converter ncastToOut*[oT: oall](op: Cast[oT]): oT {.inline.} = return op.output

type SegmentMaxTindices* = oint32 | oint64

type SegmentMax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentMax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisegmentMax[oT: oall](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMaxTindices,
                 T: DType): SegmentMax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentMax(*#, #, #, #)", constructor.}

proc segmentMax*[oT: oall](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMaxTindices): SegmentMax[oT] =
  return iisegmentMax(scope,
                      data,
                      segment_ids,
                      oT[].oTF)

converter segmentMaxToOut*[oT: oall](op: SegmentMax[oT]): oT {.inline.} = return op.output


type Atan2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Atan2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiatan2[oT: oall](scope: Scope,
            y: oT,
            x: oT,
            T: DType): Atan2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Atan2(*#, #, #, #)", constructor.}

proc atan2*[oT: oall](scope: Scope,
            y: oT,
            x: oT): Atan2[oT] =
  return iiatan2(scope,
                 y,
                 x,
                 oT[].oTF)

converter atan2ToOut*[oT: oall](op: Atan2[oT]): oT {.inline.} = return op.output

type SegmentProdTindices* = oint32 | oint64

type SegmentProd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentProd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisegmentProd[oT: oall](scope: Scope,
                  data: oT,
                  segment_ids: SegmentProdTindices,
                  T: DType): SegmentProd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentProd(*#, #, #, #)", constructor.}

proc segmentProd*[oT: oall](scope: Scope,
                  data: oT,
                  segment_ids: SegmentProdTindices): SegmentProd[oT] =
  return iisegmentProd(scope,
                       data,
                       segment_ids,
                       oT[].oTF)

converter segmentProdToOut*[oT: oall](op: SegmentProd[oT]): oT {.inline.} = return op.output

type ArgMinT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ArgMinTidx* = oint32 | oint64

type ArgMin*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ArgMin/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiargMin[oT: oall](scope: Scope,
             input: ArgMinT,
             dimension: ArgMinTidx,
             output_type: DType,
             explicitT: type(oT)): ArgMin[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ArgMin(*#, #, #, #)", constructor.}

proc argMin*(scope: Scope,
             input: ArgMinT,
             dimension: ArgMinTidx,
             output_type: type = oint64): auto =
  return iiargMin(scope,
                  input,
                  dimension,
                  output_type[].oTF,
                  output_type)

converter argMinToOut*[oT: oall](op: ArgMin[oT]): oT {.inline.} = return op.output


type ResizeBilinearGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBilinearGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiresizeBilinearGrad[oT: oall](scope: Scope,
                         grads: ofloat,
                         original_image: oT,
                         T: DType,
                         align_corners: bool): ResizeBilinearGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBilinearGrad(*#, #, #, #, #)", constructor.}

proc resizeBilinearGrad*[oT: oall](scope: Scope,
                         grads: ofloat,
                         original_image: oT,
                         align_corners: bool = false): ResizeBilinearGrad[oT] =
  return iiresizeBilinearGrad(scope,
                              grads,
                              original_image,
                              oT[].oTF,
                              align_corners)

converter resizeBilinearGradToOut*[oT: oall](op: ResizeBilinearGrad[oT]): oT {.inline.} = return op.output

type MaxTidx* = oint32 | oint64

type Max*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Max/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimax[oT: oall](scope: Scope,
          input: oT,
          reduction_indices: MaxTidx,
          keep_dims: bool,
          T: DType): Max[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Max(*#, #, #, #, #)", constructor.}

proc max*[oT: oall](scope: Scope,
          input: oT,
          reduction_indices: MaxTidx,
          keep_dims: bool = false): Max[oT] =
  return iimax(scope,
               input,
               reduction_indices,
               keep_dims,
               oT[].oTF)

converter maxToOut*[oT: oall](op: Max[oT]): oT {.inline.} = return op.output

type AccumulatorApplyGradientdtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type AccumulatorApplyGradient*{.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorApplyGradient/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiaccumulatorApplyGradient(scope: Scope,
                               handle: ostring,
                               local_step: oint64,
                               gradient: AccumulatorApplyGradientdtype): AccumulatorApplyGradient {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorApplyGradient(*#, #, #, #)", constructor.}

proc accumulatorApplyGradient*(scope: Scope,
                               handle: ostring,
                               local_step: oint64,
                               gradient: AccumulatorApplyGradientdtype): AccumulatorApplyGradient =
  return iiaccumulatorApplyGradient(scope,
                                    handle,
                                    local_step,
                                    gradient)




type SampleDistortedBoundingBoxV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SampleDistortedBoundingBoxV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisampleDistortedBoundingBoxV2[oT: oall](scope: Scope,
                                   image_size: oT,
                                   bounding_boxes: ofloat,
                                   min_object_covered: ofloat,
                                   T: DType,
                                   seed: int64,
                                   seed2: int64,
                                   aspect_ratio_range: ArraySlice[float32],
                                   area_range: ArraySlice[float32],
                                   max_attempts: int64,
                                   use_image_if_no_bounding_boxes: bool): SampleDistortedBoundingBoxV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SampleDistortedBoundingBoxV2(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sampleDistortedBoundingBoxV2*[oT: oall](scope: Scope,
                                   image_size: oT,
                                   bounding_boxes: ofloat,
                                   min_object_covered: ofloat,
                                   seed: int64 = 0.int,
                                   seed2: int64 = 0.int,
                                   aspect_ratio_range: openArray[float32] = [0.75.float32, 1.330000042915344.float32],
                                   area_range: openArray[float32] = [0.05000000074505806.float32, 1.0.float32],
                                   max_attempts: int64 = 100.int,
                                   use_image_if_no_bounding_boxes: bool = false): SampleDistortedBoundingBoxV2[oT] =
  return iisampleDistortedBoundingBoxV2(scope,
                                        image_size,
                                        bounding_boxes,
                                        min_object_covered,
                                        oT[].oTF,
                                        seed,
                                        seed2,
                                        newArraySlice(aspect_ratio_range),
                                        newArraySlice(area_range),
                                        max_attempts,
                                        use_image_if_no_bounding_boxes)

converter sampleDistortedBoundingBoxV2ToOut*[oT: oall](op: SampleDistortedBoundingBoxV2[oT]): oT {.inline.} = return op.output

type ProdTidx* = oint32 | oint64

type Prod*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Prod/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiprod[oT: oall](scope: Scope,
           input: oT,
           reduction_indices: ProdTidx,
           keep_dims: bool,
           T: DType): Prod[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Prod(*#, #, #, #, #)", constructor.}

proc prod*[oT: oall](scope: Scope,
           input: oT,
           reduction_indices: ProdTidx,
           keep_dims: bool = false): Prod[oT] =
  return iiprod(scope,
                input,
                reduction_indices,
                keep_dims,
                oT[].oTF)

converter prodToOut*[oT: oall](op: Prod[oT]): oT {.inline.} = return op.output

type SumTidx* = oint32 | oint64

type Sum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisum[oT: oall](scope: Scope,
          input: oT,
          reduction_indices: SumTidx,
          keep_dims: bool,
          T: DType): Sum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sum(*#, #, #, #, #)", constructor.}

proc sum*[oT: oall](scope: Scope,
          input: oT,
          reduction_indices: SumTidx,
          keep_dims: bool = false): Sum[oT] =
  return iisum(scope,
               input,
               reduction_indices,
               keep_dims,
               oT[].oTF)

converter sumToOut*[oT: oall](op: Sum[oT]): oT {.inline.} = return op.output


type SeluGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SeluGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiseluGrad[oT: oall](scope: Scope,
               gradients: oT,
               outputs: oT,
               T: DType): SeluGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SeluGrad(*#, #, #, #)", constructor.}

proc seluGrad*[oT: oall](scope: Scope,
               gradients: oT,
               outputs: oT): SeluGrad[oT] =
  return iiseluGrad(scope,
                    gradients,
                    outputs,
                    oT[].oTF)

converter seluGradToOut*[oT: oall](op: SeluGrad[oT]): oT {.inline.} = return op.output


type Select*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Select/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiselect[oT: oall](scope: Scope,
             condition: obool,
             t: oT,
             e: oT,
             T: DType): Select[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Select(*#, #, #, #, #)", constructor.}

proc select*[oT: oall](scope: Scope,
             condition: obool,
             t: oT,
             e: oT): Select[oT] =
  return iiselect(scope,
                  condition,
                  t,
                  e,
                  oT[].oTF)

converter selectToOut*[oT: oall](op: Select[oT]): oT {.inline.} = return op.output


type CollectiveBcastSend*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CollectiveBcastSend/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicollectiveBcastSend[oT: oall](scope: Scope,
                          input: oT,
                          T: DType,
                          group_size: int64,
                          group_key: int64,
                          instance_key: int64,
                          shape: TensorShape): CollectiveBcastSend[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CollectiveBcastSend(*#, #, #, #, #, #, #)", constructor.}

proc collectiveBcastSend*[oT: oall](scope: Scope,
                          input: oT,
                          group_size: int64 = 0.int,
                          group_key: int64 = 0.int,
                          instance_key: int64 = 0.int,
                          shape: TensorShape = [].shape): CollectiveBcastSend[oT] =
  return iicollectiveBcastSend(scope,
                               input,
                               oT[].oTF,
                               group_size,
                               group_key,
                               instance_key,
                               shape)

converter collectiveBcastSendToOut*[oT: oall](op: CollectiveBcastSend[oT]): oT {.inline.} = return op.output


type LogicalAnd* {.header:"../tensorflow/ops/generated.h", importcpp:"LogicalAnd/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iilogicalAnd(scope: Scope,
                 x: obool,
                 y: obool): LogicalAnd {.header:"../tensorflow/ops/generated.h", importcpp:"LogicalAnd(*#, #, #)", constructor.}

proc logicalAnd*(scope: Scope,
                 x: obool,
                 y: obool): LogicalAnd =
  return iilogicalAnd(scope,
                      x,
                      y)

converter logicalAndToOut*(op: LogicalAnd): obool {.inline.} = return op.output


type WriteGraphSummary*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteGraphSummary/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteGraphSummary(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tensor: ostring): WriteGraphSummary {.header:"../tensorflow/ops/generated.h", importcpp:"WriteGraphSummary(*#, #, #, #)", constructor.}

proc writeGraphSummary*(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tensor: ostring): WriteGraphSummary =
  return iiwriteGraphSummary(scope,
                             writer,
                             step,
                             tensor)



type ApproximateEqualT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApproximateEqual* {.header:"../tensorflow/ops/generated.h", importcpp:"ApproximateEqual/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiapproximateEqual(scope: Scope,
                       x: ApproximateEqualT,
                       y: ApproximateEqualT,
                       tolerance: float32): ApproximateEqual {.header:"../tensorflow/ops/generated.h", importcpp:"ApproximateEqual(*#, #, #, #)", constructor.}

proc approximateEqual*(scope: Scope,
                       x: ApproximateEqualT,
                       y: ApproximateEqualT,
                       tolerance: float32 = 9.999999747378752e-06.float32): ApproximateEqual =
  return iiapproximateEqual(scope,
                            x,
                            y,
                            tolerance)

converter approximateEqualToOut*(op: ApproximateEqual): obool {.inline.} = return op.output

type EqualT* = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | oquint8 | oqint8 | oqint32 | ostring | obool | ocomplex128

type Equal* {.header:"../tensorflow/ops/generated.h", importcpp:"Equal/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiequal(scope: Scope,
            x: EqualT,
            y: EqualT): Equal {.header:"../tensorflow/ops/generated.h", importcpp:"Equal(*#, #, #)", constructor.}

proc equal*(scope: Scope,
            x: EqualT,
            y: EqualT): Equal =
  return iiequal(scope,
                 x,
                 y)

converter equalToOut*(op: Equal): obool {.inline.} = return op.output


type QuantizeV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizeV2[oT: oall](scope: Scope,
                 input: ofloat,
                 min_range: ofloat,
                 max_range: ofloat,
                 T: DType,
                 mode: cstring,
                 round_mode: cstring,
                 explicitT: type(oT)): QuantizeV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeV2(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc quantizeV2*(scope: Scope,
                 input: ofloat,
                 min_range: ofloat,
                 max_range: ofloat,
                 T: type = oinvalid,
                 mode: cstring = "MIN_COMBINED",
                 round_mode: cstring = "HALF_AWAY_FROM_ZERO"): auto =
  return iiquantizeV2(scope,
                      input,
                      min_range,
                      max_range,
                      T[].oTF,
                      mode,
                      round_mode,
                      T)

converter quantizeV2ToOut*[oT: oall](op: QuantizeV2[oT]): oT {.inline.} = return op.output

type GreaterEqualT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type GreaterEqual* {.header:"../tensorflow/ops/generated.h", importcpp:"GreaterEqual/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iigreaterEqual(scope: Scope,
                   x: GreaterEqualT,
                   y: GreaterEqualT): GreaterEqual {.header:"../tensorflow/ops/generated.h", importcpp:"GreaterEqual(*#, #, #)", constructor.}

proc greaterEqual*(scope: Scope,
                   x: GreaterEqualT,
                   y: GreaterEqualT): GreaterEqual =
  return iigreaterEqual(scope,
                        x,
                        y)

converter greaterEqualToOut*(op: GreaterEqual): obool {.inline.} = return op.output

type ResourceScatterMaxdtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceScatterMaxTindices* = oint32 | oint64

type ResourceScatterMax*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterMax/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterMax(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMaxTindices,
                         updates: ResourceScatterMaxdtype): ResourceScatterMax {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterMax(*#, #, #, #)", constructor.}

proc resourceScatterMax*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMaxTindices,
                         updates: ResourceScatterMaxdtype): ResourceScatterMax =
  return iiresourceScatterMax(scope,
                              resource,
                              indices,
                              updates)




type Betainc*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Betainc/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibetainc[oT: oall](scope: Scope,
              a: oT,
              b: oT,
              x: oT,
              T: DType): Betainc[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Betainc(*#, #, #, #, #)", constructor.}

proc betainc*[oT: oall](scope: Scope,
              a: oT,
              b: oT,
              x: oT): Betainc[oT] =
  return iibetainc(scope,
                   a,
                   b,
                   x,
                   oT[].oTF)

converter betaincToOut*[oT: oall](op: Betainc[oT]): oT {.inline.} = return op.output


type Polygamma*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Polygamma/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iipolygamma[oT: oall](scope: Scope,
                a: oT,
                x: oT,
                T: DType): Polygamma[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Polygamma(*#, #, #, #)", constructor.}

proc polygamma*[oT: oall](scope: Scope,
                a: oT,
                x: oT): Polygamma[oT] =
  return iipolygamma(scope,
                     a,
                     x,
                     oT[].oTF)

converter polygammaToOut*[oT: oall](op: Polygamma[oT]): oT {.inline.} = return op.output


type Assert*{.header:"../tensorflow/ops/generated.h", importcpp:"Assert/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiassert(scope: Scope,
             condition: obool,
             data: olist[oall],
             T: ArraySlice[DType],
             summarize: int64): Assert {.header:"../tensorflow/ops/generated.h", importcpp:"Assert(*#, #, #, #, #)", constructor.}

proc assert*(scope: Scope,
             condition: obool,
             data: olist[oall],
             T: openArray[DType],
             summarize: int64 = 3.int): Assert =
  return iiassert(scope,
                  condition,
                  data,
                  newArraySlice(T),
                  summarize)



type TransposeTperm* = oint32 | oint64

type Transpose*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Transpose/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitranspose[oT: oall](scope: Scope,
                x: oT,
                perm: TransposeTperm,
                T: DType): Transpose[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Transpose(*#, #, #, #)", constructor.}

proc transpose*[oT: oall](scope: Scope,
                x: oT,
                perm: TransposeTperm): Transpose[oT] =
  return iitranspose(scope,
                     x,
                     perm,
                     oT[].oTF)

converter transposeToOut*[oT: oall](op: Transpose[oT]): oT {.inline.} = return op.output


type IgammaGradA*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IgammaGradA/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiigammaGradA[oT: oall](scope: Scope,
                  a: oT,
                  x: oT,
                  T: DType): IgammaGradA[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IgammaGradA(*#, #, #, #)", constructor.}

proc igammaGradA*[oT: oall](scope: Scope,
                  a: oT,
                  x: oT): IgammaGradA[oT] =
  return iiigammaGradA(scope,
                       a,
                       x,
                       oT[].oTF)

converter igammaGradAToOut*[oT: oall](op: IgammaGradA[oT]): oT {.inline.} = return op.output


type StringSplitV2* {.header:"../tensorflow/ops/generated.h", importcpp:"StringSplitV2/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iistringSplitV2(scope: Scope,
                    input: ostring,
                    sep: ostring,
                    maxsplit: int64): StringSplitV2 {.header:"../tensorflow/ops/generated.h", importcpp:"StringSplitV2(*#, #, #, #)", constructor.}

proc stringSplitV2*(scope: Scope,
                    input: ostring,
                    sep: ostring,
                    maxsplit: int64 = -1.int): StringSplitV2 =
  return iistringSplitV2(scope,
                         input,
                         sep,
                         maxsplit)

converter stringSplitV2ToOut*(op: StringSplitV2): oint64 {.inline.} = return op.output


type ImportEvent*{.header:"../tensorflow/ops/generated.h", importcpp:"ImportEvent/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiimportEvent(scope: Scope,
                  writer: oresource,
                  event: ostring): ImportEvent {.header:"../tensorflow/ops/generated.h", importcpp:"ImportEvent(*#, #, #)", constructor.}

proc importEvent*(scope: Scope,
                  writer: oresource,
                  event: ostring): ImportEvent =
  return iiimportEvent(scope,
                       writer,
                       event)




type Igamma*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Igamma/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiigamma[oT: oall](scope: Scope,
             a: oT,
             x: oT,
             T: DType): Igamma[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Igamma(*#, #, #, #)", constructor.}

proc igamma*[oT: oall](scope: Scope,
             a: oT,
             x: oT): Igamma[oT] =
  return iiigamma(scope,
                  a,
                  x,
                  oT[].oTF)

converter igammaToOut*[oT: oall](op: Igamma[oT]): oT {.inline.} = return op.output


type Igammac*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Igammac/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiigammac[oT: oall](scope: Scope,
              a: oT,
              x: oT,
              T: DType): Igammac[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Igammac(*#, #, #, #)", constructor.}

proc igammac*[oT: oall](scope: Scope,
              a: oT,
              x: oT): Igammac[oT] =
  return iiigammac(scope,
                   a,
                   x,
                   oT[].oTF)

converter igammacToOut*[oT: oall](op: Igammac[oT]): oT {.inline.} = return op.output


type Mod*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Mod/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iinmod[oT: oall](scope: Scope,
           x: oT,
           y: oT,
           T: DType): Mod[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Mod(*#, #, #, #)", constructor.}

proc nmod*[oT: oall](scope: Scope,
           x: oT,
           y: oT): Mod[oT] =
  return iinmod(scope,
                x,
                y,
                oT[].oTF)

converter nmodToOut*[oT: oall](op: Mod[oT]): oT {.inline.} = return op.output


type Maximum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Maximum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaximum[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              T: DType): Maximum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Maximum(*#, #, #, #)", constructor.}

proc maximum*[oT: oall](scope: Scope,
              x: oT,
              y: oT): Maximum[oT] =
  return iimaximum(scope,
                   x,
                   y,
                   oT[].oTF)

converter maximumToOut*[oT: oall](op: Maximum[oT]): oT {.inline.} = return op.output


type Xlogy*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Xlogy/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iixlogy[oT: oall](scope: Scope,
            x: oT,
            y: oT,
            T: DType): Xlogy[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Xlogy(*#, #, #, #)", constructor.}

proc xlogy*[oT: oall](scope: Scope,
            x: oT,
            y: oT): Xlogy[oT] =
  return iixlogy(scope,
                 x,
                 y,
                 oT[].oTF)

converter xlogyToOut*[oT: oall](op: Xlogy[oT]): oT {.inline.} = return op.output


type SquaredDifference*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SquaredDifference/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisquaredDifference[oT: oall](scope: Scope,
                        x: oT,
                        y: oT,
                        T: DType): SquaredDifference[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SquaredDifference(*#, #, #, #)", constructor.}

proc squaredDifference*[oT: oall](scope: Scope,
                        x: oT,
                        y: oT): SquaredDifference[oT] =
  return iisquaredDifference(scope,
                             x,
                             y,
                             oT[].oTF)

converter squaredDifferenceToOut*[oT: oall](op: SquaredDifference[oT]): oT {.inline.} = return op.output


type ResourceCountUpTo*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceCountUpTo/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiresourceCountUpTo[oT: oall](scope: Scope,
                        resource: oresource,
                        limit: int64,
                        T: DType,
                        explicitT: type(oT)): ResourceCountUpTo[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceCountUpTo(*#, #, #, #)", constructor.}

proc resourceCountUpTo*(scope: Scope,
                        resource: oresource,
                        limit: int64 = 0.int,
                        T: type = oinvalid): auto =
  return iiresourceCountUpTo(scope,
                             resource,
                             limit,
                             T[].oTF,
                             T)

converter resourceCountUpToToOut*[oT: oall](op: ResourceCountUpTo[oT]): oT {.inline.} = return op.output


type RealDiv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RealDiv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirealDiv[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              T: DType): RealDiv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RealDiv(*#, #, #, #)", constructor.}

proc realDiv*[oT: oall](scope: Scope,
              x: oT,
              y: oT): RealDiv[oT] =
  return iirealDiv(scope,
                   x,
                   y,
                   oT[].oTF)

converter realDivToOut*[oT: oall](op: RealDiv[oT]): oT {.inline.} = return op.output


type TruncateDiv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TruncateDiv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitruncateDiv[oT: oall](scope: Scope,
                  x: oT,
                  y: oT,
                  T: DType): TruncateDiv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TruncateDiv(*#, #, #, #)", constructor.}

proc truncateDiv*[oT: oall](scope: Scope,
                  x: oT,
                  y: oT): TruncateDiv[oT] =
  return iitruncateDiv(scope,
                       x,
                       y,
                       oT[].oTF)

converter truncateDivToOut*[oT: oall](op: TruncateDiv[oT]): oT {.inline.} = return op.output


type StringToHashBucketStrong* {.header:"../tensorflow/ops/generated.h", importcpp:"StringToHashBucketStrong/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iistringToHashBucketStrong(scope: Scope,
                               input: ostring,
                               key: ArraySlice[int],
                               num_buckets: int64): StringToHashBucketStrong {.header:"../tensorflow/ops/generated.h", importcpp:"StringToHashBucketStrong(*#, #, #, #)", constructor.}

proc stringToHashBucketStrong*(scope: Scope,
                               input: ostring,
                               key: openArray[int],
                               num_buckets: int64 = 0.int): StringToHashBucketStrong =
  return iistringToHashBucketStrong(scope,
                                    input,
                                    newArraySlice(key),
                                    num_buckets)

converter stringToHashBucketStrongToOut*(op: StringToHashBucketStrong): oint64 {.inline.} = return op.output


type QueueEnqueue*{.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueue/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiqueueEnqueue(scope: Scope,
                   handle: ostring,
                   components: olist[oall],
                   Tcomponents: ArraySlice[DType],
                   timeout_ms: int64): QueueEnqueue {.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueue(*#, #, #, #, #)", constructor.}

proc queueEnqueue*(scope: Scope,
                   handle: ostring,
                   components: olist[oall],
                   Tcomponents: openArray[DType],
                   timeout_ms: int64 = -1.int): QueueEnqueue =
  return iiqueueEnqueue(scope,
                        handle,
                        components,
                        newArraySlice(Tcomponents),
                        timeout_ms)




type IMklSub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklSub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiMklSub[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8,
              T: DType): IMklSub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklSub(*#, #, #, #, #, #)", constructor.}

proc iMklSub*[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklSub[oT] =
  return iiiMklSub(scope,
                   x,
                   y,
                   mkl_x,
                   mkl_y,
                   oT[].oTF)

converter iMklSubToOut*[oT: oall](op: IMklSub[oT]): oT {.inline.} = return op.output

type AsStringT* = oint8 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128 | ofloat | odouble | obool

type AsString* {.header:"../tensorflow/ops/generated.h", importcpp:"AsString/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiasString(scope: Scope,
               input: AsStringT,
               fill: cstring,
               width: int64,
               precision: int64,
               scientific: bool,
               shortest: bool): AsString {.header:"../tensorflow/ops/generated.h", importcpp:"AsString(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc asString*(scope: Scope,
               input: AsStringT,
               fill: cstring,
               width: int64 = -1.int,
               precision: int64 = -1.int,
               scientific: bool = false,
               shortest: bool = false): AsString =
  return iiasString(scope,
                    input,
                    fill,
                    width,
                    precision,
                    scientific,
                    shortest)

converter asStringToOut*(op: AsString): ostring {.inline.} = return op.output


type Conv3DBackpropFilterV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropFilterV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv3DBackpropFilterV2[oT: oall](scope: Scope,
                             input: oT,
                             filter_sizes: oint32,
                             out_backprop: oT,
                             strides: ArraySlice[int],
                             padding: cstring,
                             T: DType,
                             data_format: cstring,
                             dilations: ArraySlice[int]): Conv3DBackpropFilterV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropFilterV2(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc conv3DBackpropFilterV2*[oT: oall](scope: Scope,
                             input: oT,
                             filter_sizes: oint32,
                             out_backprop: oT,
                             strides: openArray[int],
                             padding: cstring,
                             data_format: cstring = "NDHWC",
                             dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int, 1.int]): Conv3DBackpropFilterV2[oT] =
  return iiconv3DBackpropFilterV2(scope,
                                  input,
                                  filter_sizes,
                                  out_backprop,
                                  newArraySlice(strides),
                                  padding,
                                  oT[].oTF,
                                  data_format,
                                  newArraySlice(dilations))

converter conv3DBackpropFilterV2ToOut*[oT: oall](op: Conv3DBackpropFilterV2[oT]): oT {.inline.} = return op.output


type AddV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AddV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiaddV2[oT: oall](scope: Scope,
            x: oT,
            y: oT,
            T: DType): AddV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AddV2(*#, #, #, #)", constructor.}

proc addV2*[oT: oall](scope: Scope,
            x: oT,
            y: oT): AddV2[oT] =
  return iiaddV2(scope,
                 x,
                 y,
                 oT[].oTF)

converter addV2ToOut*[oT: oall](op: AddV2[oT]): oT {.inline.} = return op.output


type TryRpc* {.header:"../tensorflow/ops/generated.h", importcpp:"TryRpc/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitryRpc(scope: Scope,
             address: ostring,
             nmethod: ostring,
             request: ostring,
             protocol: cstring,
             fail_fast: bool,
             timeout_in_ms: int64): TryRpc {.header:"../tensorflow/ops/generated.h", importcpp:"TryRpc(*#, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc tryRpc*(scope: Scope,
             address: ostring,
             nmethod: ostring,
             request: ostring,
             protocol: cstring,
             fail_fast: bool = true,
             timeout_in_ms: int64 = 0.int): TryRpc =
  return iitryRpc(scope,
                  address,
                  nmethod,
                  request,
                  protocol,
                  fail_fast,
                  timeout_in_ms)

converter tryRpcToOut*(op: TryRpc): ostring {.inline.} = return op.output

type ResourceGatherTindices* = oint32 | oint64

type ResourceGather*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceGather/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiresourceGather[oT: oall](scope: Scope,
                     resource: oresource,
                     indices: ResourceGatherTindices,
                     validate_indices: bool,
                     dtype: DType,
                     explicitT: type(oT)): ResourceGather[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceGather(*#, #, #, #, #)", constructor.}

proc resourceGather*(scope: Scope,
                     resource: oresource,
                     indices: ResourceGatherTindices,
                     validate_indices: bool = true,
                     dtype: type = oinvalid): auto =
  return iiresourceGather(scope,
                          resource,
                          indices,
                          validate_indices,
                          dtype[].oTF,
                          dtype)

converter resourceGatherToOut*[oT: oall](op: ResourceGather[oT]): oT {.inline.} = return op.output


type UniformCandidateSampler* {.header:"../tensorflow/ops/generated.h", importcpp:"UniformCandidateSampler/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiuniformCandidateSampler(scope: Scope,
                              true_classes: oint64,
                              num_true: int64,
                              num_sampled: int64,
                              unique: bool,
                              range_max: int64,
                              seed: int64,
                              seed2: int64): UniformCandidateSampler {.header:"../tensorflow/ops/generated.h", importcpp:"UniformCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc uniformCandidateSampler*(scope: Scope,
                              true_classes: oint64,
                              num_true: int64 = 0.int,
                              num_sampled: int64 = 0.int,
                              unique: bool = false,
                              range_max: int64 = 0.int,
                              seed: int64 = 0.int,
                              seed2: int64 = 0.int): UniformCandidateSampler =
  return iiuniformCandidateSampler(scope,
                                   true_classes,
                                   num_true,
                                   num_sampled,
                                   unique,
                                   range_max,
                                   seed,
                                   seed2)

converter uniformCandidateSamplerToOut*(op: UniformCandidateSampler): oint64 {.inline.} = return op.output


type Add*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Add/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiadd[oT: oall](scope: Scope,
          x: oT,
          y: oT,
          T: DType): Add[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Add(*#, #, #, #)", constructor.}

proc add*[oT: oall](scope: Scope,
          x: oT,
          y: oT): Add[oT] =
  return iiadd(scope,
               x,
               y,
               oT[].oTF)

converter addToOut*[oT: oall](op: Add[oT]): oT {.inline.} = return op.output


type Floor*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Floor/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifloor[oT: oall](scope: Scope,
            x: oT,
            T: DType): Floor[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Floor(*#, #, #)", constructor.}

proc floor*[oT: oall](scope: Scope,
            x: oT): Floor[oT] =
  return iifloor(scope,
                 x,
                 oT[].oTF)

converter floorToOut*[oT: oall](op: Floor[oT]): oT {.inline.} = return op.output


type Ceil*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Ceil/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiceil[oT: oall](scope: Scope,
           x: oT,
           T: DType): Ceil[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Ceil(*#, #, #)", constructor.}

proc ceil*[oT: oall](scope: Scope,
           x: oT): Ceil[oT] =
  return iiceil(scope,
                x,
                oT[].oTF)

converter ceilToOut*[oT: oall](op: Ceil[oT]): oT {.inline.} = return op.output

type IsFiniteT* = obfloat16 | ohalf | ofloat | odouble

type IsFinite* {.header:"../tensorflow/ops/generated.h", importcpp:"IsFinite/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiisFinite(scope: Scope,
               x: IsFiniteT): IsFinite {.header:"../tensorflow/ops/generated.h", importcpp:"IsFinite(*#, #)", constructor.}

proc isFinite*(scope: Scope,
               x: IsFiniteT): IsFinite =
  return iiisFinite(scope,
                    x)

converter isFiniteToOut*(op: IsFinite): obool {.inline.} = return op.output


type MaxPool3D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool3D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPool3D[oT: oall](scope: Scope,
                input: oT,
                ksize: ArraySlice[int],
                strides: ArraySlice[int],
                padding: cstring,
                data_format: cstring,
                T: DType): MaxPool3D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool3D(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPool3D*[oT: oall](scope: Scope,
                input: oT,
                ksize: openArray[int],
                strides: openArray[int],
                padding: cstring,
                data_format: cstring = "NDHWC"): MaxPool3D[oT] =
  return iimaxPool3D(scope,
                     input,
                     newArraySlice(ksize),
                     newArraySlice(strides),
                     padding,
                     data_format,
                     oT[].oTF)

converter maxPool3DToOut*[oT: oall](op: MaxPool3D[oT]): oT {.inline.} = return op.output

type IsInfT* = obfloat16 | ohalf | ofloat | odouble

type IsInf* {.header:"../tensorflow/ops/generated.h", importcpp:"IsInf/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiisInf(scope: Scope,
            x: IsInfT): IsInf {.header:"../tensorflow/ops/generated.h", importcpp:"IsInf(*#, #)", constructor.}

proc isInf*(scope: Scope,
            x: IsInfT): IsInf =
  return iiisInf(scope,
                 x)

converter isInfToOut*(op: IsInf): obool {.inline.} = return op.output

type CumsumTidx* = oint32 | oint64

type Cumsum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cumsum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicumsum[oT: oall](scope: Scope,
             x: oT,
             axis: CumsumTidx,
             exclusive: bool,
             reverse: bool,
             T: DType): Cumsum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cumsum(*#, #, #, #, #, #)", constructor.}

proc cumsum*[oT: oall](scope: Scope,
             x: oT,
             axis: CumsumTidx,
             exclusive: bool = false,
             reverse: bool = false): Cumsum[oT] =
  return iicumsum(scope,
                  x,
                  axis,
                  exclusive,
                  reverse,
                  oT[].oTF)

converter cumsumToOut*[oT: oall](op: Cumsum[oT]): oT {.inline.} = return op.output


type BesselI1e*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BesselI1e/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibesselI1e[oT: oall](scope: Scope,
                x: oT,
                T: DType): BesselI1e[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BesselI1e(*#, #, #)", constructor.}

proc besselI1e*[oT: oall](scope: Scope,
                x: oT): BesselI1e[oT] =
  return iibesselI1e(scope,
                     x,
                     oT[].oTF)

converter besselI1eToOut*[oT: oall](op: BesselI1e[oT]): oT {.inline.} = return op.output


type BesselI0e*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BesselI0e/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibesselI0e[oT: oall](scope: Scope,
                x: oT,
                T: DType): BesselI0e[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BesselI0e(*#, #, #)", constructor.}

proc besselI0e*[oT: oall](scope: Scope,
                x: oT): BesselI0e[oT] =
  return iibesselI0e(scope,
                     x,
                     oT[].oTF)

converter besselI0eToOut*[oT: oall](op: BesselI0e[oT]): oT {.inline.} = return op.output


type BiasAddGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BiasAddGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibiasAddGrad[oT: oall](scope: Scope,
                  out_backprop: oT,
                  T: DType,
                  data_format: cstring): BiasAddGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BiasAddGrad(*#, #, #, tensorflow::string(#))", constructor.}

proc biasAddGrad*[oT: oall](scope: Scope,
                  out_backprop: oT,
                  data_format: cstring = "NHWC"): BiasAddGrad[oT] =
  return iibiasAddGrad(scope,
                       out_backprop,
                       oT[].oTF,
                       data_format)

converter biasAddGradToOut*[oT: oall](op: BiasAddGrad[oT]): oT {.inline.} = return op.output

type WriteHistogramSummaryT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type WriteHistogramSummary*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteHistogramSummary/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteHistogramSummary(scope: Scope,
                            writer: oresource,
                            step: oint64,
                            tag: ostring,
                            values: WriteHistogramSummaryT): WriteHistogramSummary {.header:"../tensorflow/ops/generated.h", importcpp:"WriteHistogramSummary(*#, #, #, #, #)", constructor.}

proc writeHistogramSummary*(scope: Scope,
                            writer: oresource,
                            step: oint64,
                            tag: ostring,
                            values: WriteHistogramSummaryT): WriteHistogramSummary =
  return iiwriteHistogramSummary(scope,
                                 writer,
                                 step,
                                 tag,
                                 values)




type Tan*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Tan/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitan[oT: oall](scope: Scope,
          x: oT,
          T: DType): Tan[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Tan(*#, #, #)", constructor.}

proc tan*[oT: oall](scope: Scope,
          x: oT): Tan[oT] =
  return iitan(scope,
               x,
               oT[].oTF)

converter tanToOut*[oT: oall](op: Tan[oT]): oT {.inline.} = return op.output


type TopKV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TopKV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitopKV2[oT: oall](scope: Scope,
             input: oT,
             k: oint32,
             sorted: bool,
             T: DType): TopKV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TopKV2(*#, #, #, #, #)", constructor.}

proc topKV2*[oT: oall](scope: Scope,
             input: oT,
             k: oint32,
             sorted: bool = true): TopKV2[oT] =
  return iitopKV2(scope,
                  input,
                  k,
                  sorted,
                  oT[].oTF)

converter topKV2ToOut*[oT: oall](op: TopKV2[oT]): oT {.inline.} = return op.output

type PadV2Tpaddings* = oint32 | oint64

type PadV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PadV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iipadV2[oT: oall](scope: Scope,
            input: oT,
            paddings: PadV2Tpaddings,
            constant_values: oT,
            T: DType): PadV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PadV2(*#, #, #, #, #)", constructor.}

proc padV2*[oT: oall](scope: Scope,
            input: oT,
            paddings: PadV2Tpaddings,
            constant_values: oT): PadV2[oT] =
  return iipadV2(scope,
                 input,
                 paddings,
                 constant_values,
                 oT[].oTF)

converter padV2ToOut*[oT: oall](op: PadV2[oT]): oT {.inline.} = return op.output


type Cos*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cos/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicos[oT: oall](scope: Scope,
          x: oT,
          T: DType): Cos[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cos(*#, #, #)", constructor.}

proc cos*[oT: oall](scope: Scope,
          x: oT): Cos[oT] =
  return iicos(scope,
               x,
               oT[].oTF)

converter cosToOut*[oT: oall](op: Cos[oT]): oT {.inline.} = return op.output


type Erfc*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Erfc/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iierfc[oT: oall](scope: Scope,
           x: oT,
           T: DType): Erfc[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Erfc(*#, #, #)", constructor.}

proc erfc*[oT: oall](scope: Scope,
           x: oT): Erfc[oT] =
  return iierfc(scope,
                x,
                oT[].oTF)

converter erfcToOut*[oT: oall](op: Erfc[oT]): oT {.inline.} = return op.output


type Digamma*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Digamma/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidigamma[oT: oall](scope: Scope,
              x: oT,
              T: DType): Digamma[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Digamma(*#, #, #)", constructor.}

proc digamma*[oT: oall](scope: Scope,
              x: oT): Digamma[oT] =
  return iidigamma(scope,
                   x,
                   oT[].oTF)

converter digammaToOut*[oT: oall](op: Digamma[oT]): oT {.inline.} = return op.output


type BoostedTreesSerializeEnsemble* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesSerializeEnsemble/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiboostedTreesSerializeEnsemble(scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesSerializeEnsemble {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesSerializeEnsemble(*#, #)", constructor.}

proc boostedTreesSerializeEnsemble*(scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesSerializeEnsemble =
  return iiboostedTreesSerializeEnsemble(scope,
                                         tree_ensemble_handle)

converter boostedTreesSerializeEnsembleToOut*(op: BoostedTreesSerializeEnsemble): oint64 {.inline.} = return op.output


type Acosh*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Acosh/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiacosh[oT: oall](scope: Scope,
            x: oT,
            T: DType): Acosh[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Acosh(*#, #, #)", constructor.}

proc acosh*[oT: oall](scope: Scope,
            x: oT): Acosh[oT] =
  return iiacosh(scope,
                 x,
                 oT[].oTF)

converter acoshToOut*[oT: oall](op: Acosh[oT]): oT {.inline.} = return op.output


type Cosh*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cosh/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicosh[oT: oall](scope: Scope,
           x: oT,
           T: DType): Cosh[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cosh(*#, #, #)", constructor.}

proc cosh*[oT: oall](scope: Scope,
           x: oT): Cosh[oT] =
  return iicosh(scope,
                x,
                oT[].oTF)

converter coshToOut*[oT: oall](op: Cosh[oT]): oT {.inline.} = return op.output

type ResourceApplyProximalAdagradT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyProximalAdagrad*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyProximalAdagrad/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyProximalAdagrad(scope: Scope,
                                   nvar: oresource,
                                   accum: oresource,
                                   lr: ResourceApplyProximalAdagradT,
                                   l1: ResourceApplyProximalAdagradT,
                                   l2: ResourceApplyProximalAdagradT,
                                   grad: ResourceApplyProximalAdagradT,
                                   use_locking: bool): ResourceApplyProximalAdagrad {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyProximalAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyProximalAdagrad*(scope: Scope,
                                   nvar: oresource,
                                   accum: oresource,
                                   lr: ResourceApplyProximalAdagradT,
                                   l1: ResourceApplyProximalAdagradT,
                                   l2: ResourceApplyProximalAdagradT,
                                   grad: ResourceApplyProximalAdagradT,
                                   use_locking: bool = false): ResourceApplyProximalAdagrad =
  return iiresourceApplyProximalAdagrad(scope,
                                        nvar,
                                        accum,
                                        lr,
                                        l1,
                                        l2,
                                        grad,
                                        use_locking)



type ResourceScatterDivdtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceScatterDivTindices* = oint32 | oint64

type ResourceScatterDiv*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterDiv/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterDiv(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterDivTindices,
                         updates: ResourceScatterDivdtype): ResourceScatterDiv {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterDiv(*#, #, #, #)", constructor.}

proc resourceScatterDiv*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterDivTindices,
                         updates: ResourceScatterDivdtype): ResourceScatterDiv =
  return iiresourceScatterDiv(scope,
                              resource,
                              indices,
                              updates)




type Asin*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Asin/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiasin[oT: oall](scope: Scope,
           x: oT,
           T: DType): Asin[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Asin(*#, #, #)", constructor.}

proc asin*[oT: oall](scope: Scope,
           x: oT): Asin[oT] =
  return iiasin(scope,
                x,
                oT[].oTF)

converter asinToOut*[oT: oall](op: Asin[oT]): oT {.inline.} = return op.output


type IHostRecv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_HostRecv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiHostRecv[oT: oall](scope: Scope,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                tensor_type: DType,
                send_device_incarnation: int64,
                client_terminated: bool,
                explicitT: type(oT)): IHostRecv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_HostRecv(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc iHostRecv*(scope: Scope,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                tensor_type: type = oinvalid,
                send_device_incarnation: int64 = 0.int,
                client_terminated: bool = false): auto =
  return iiiHostRecv(scope,
                     tensor_name,
                     send_device,
                     recv_device,
                     tensor_type[].oTF,
                     send_device_incarnation,
                     client_terminated,
                     tensor_type)

converter iHostRecvToOut*[oT: oall](op: IHostRecv[oT]): oT {.inline.} = return op.output


type ExperimentalScanDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalScanDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalScanDataset(scope: Scope,
                              input_dataset: ovariant,
                              initial_state: olist[oall],
                              other_arguments: olist[oall],
                              f: NameAttrList,
                              Tstate: ArraySlice[DType],
                              Targuments: ArraySlice[DType],
                              output_types: ArraySlice[DType],
                              output_shapes: ArraySlice[TensorShape],
                              preserve_cardinality: bool): ExperimentalScanDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalScanDataset(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalScanDataset*(scope: Scope,
                              input_dataset: ovariant,
                              initial_state: olist[oall],
                              other_arguments: olist[oall],
                              f: NameAttrList,
                              Tstate: openArray[DType],
                              Targuments: openArray[DType],
                              output_types: openArray[DType],
                              output_shapes: openArray[TensorShape],
                              preserve_cardinality: bool = false): ExperimentalScanDataset =
  return iiexperimentalScanDataset(scope,
                                   input_dataset,
                                   initial_state,
                                   other_arguments,
                                   f,
                                   newArraySlice(Tstate),
                                   newArraySlice(Targuments),
                                   newArraySlice(output_types),
                                   newArraySlice(output_shapes),
                                   preserve_cardinality)

converter experimentalScanDatasetToOut*(op: ExperimentalScanDataset): ovariant {.inline.} = return op.output


type Log1p*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Log1p/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilog1p[oT: oall](scope: Scope,
            x: oT,
            T: DType): Log1p[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Log1p(*#, #, #)", constructor.}

proc log1p*[oT: oall](scope: Scope,
            x: oT): Log1p[oT] =
  return iilog1p(scope,
                 x,
                 oT[].oTF)

converter log1pToOut*[oT: oall](op: Log1p[oT]): oT {.inline.} = return op.output


type TensorArraySize* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iitensorArraySize(scope: Scope,
                      handle: ostring,
                      flow_in: ofloat): TensorArraySize {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySize(*#, #, #)", constructor.}

proc tensorArraySize*(scope: Scope,
                      handle: ostring,
                      flow_in: ofloat): TensorArraySize =
  return iitensorArraySize(scope,
                           handle,
                           flow_in)

converter tensorArraySizeToOut*(op: TensorArraySize): oint32 {.inline.} = return op.output

type RequantizeTinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type Requantize*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Requantize/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirequantize[oT: oall](scope: Scope,
                 input: RequantizeTinput,
                 input_min: ofloat,
                 input_max: ofloat,
                 requested_output_min: ofloat,
                 requested_output_max: ofloat,
                 out_type: DType,
                 explicitT: type(oT)): Requantize[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Requantize(*#, #, #, #, #, #, #)", constructor.}

proc requantize*(scope: Scope,
                 input: RequantizeTinput,
                 input_min: ofloat,
                 input_max: ofloat,
                 requested_output_min: ofloat,
                 requested_output_max: ofloat,
                 out_type: type = oinvalid): auto =
  return iirequantize(scope,
                      input,
                      input_min,
                      input_max,
                      requested_output_min,
                      requested_output_max,
                      out_type[].oTF,
                      out_type)

converter requantizeToOut*[oT: oall](op: Requantize[oT]): oT {.inline.} = return op.output


type Exp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Exp/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiexp[oT: oall](scope: Scope,
          x: oT,
          T: DType): Exp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Exp(*#, #, #)", constructor.}

proc exp*[oT: oall](scope: Scope,
          x: oT): Exp[oT] =
  return iiexp(scope,
               x,
               oT[].oTF)

converter expToOut*[oT: oall](op: Exp[oT]): oT {.inline.} = return op.output

type ScatterNdAddTindices* = oint32 | oint64

type ScatterNdAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterNdAdd[oT: oall](scope: Scope,
                   nref: oT,
                   indices: ScatterNdAddTindices,
                   updates: oT,
                   T: DType,
                   use_locking: bool): ScatterNdAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdAdd(*#, #, #, #, #, #)", constructor.}

proc scatterNdAdd*[oT: oall](scope: Scope,
                   nref: oT,
                   indices: ScatterNdAddTindices,
                   updates: oT,
                   use_locking: bool = false): ScatterNdAdd[oT] =
  return iiscatterNdAdd(scope,
                        nref,
                        indices,
                        updates,
                        oT[].oTF,
                        use_locking)

converter scatterNdAddToOut*[oT: oall](op: ScatterNdAdd[oT]): oT {.inline.} = return op.output


type MutableHashTableOfTensors* {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTableOfTensors/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iimutableHashTableOfTensors(scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                use_node_name_sharing: bool,
                                key_dtype: DType,
                                value_dtype: DType,
                                value_shape: TensorShape): MutableHashTableOfTensors {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTableOfTensors(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc mutableHashTableOfTensors*(scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                use_node_name_sharing: bool = false,
                                key_dtype: type oall = oinvalid,
                                value_dtype: type oall = oinvalid,
                                value_shape: TensorShape = [].shape): MutableHashTableOfTensors =
  return iimutableHashTableOfTensors(scope,
                                     container,
                                     shared_name,
                                     use_node_name_sharing,
                                     oT[].oTF,
                                     oT[].oTF,
                                     value_shape)

converter mutableHashTableOfTensorsToOut*(op: MutableHashTableOfTensors): ostring {.inline.} = return op.output


type Dilation2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Dilation2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidilation2D[oT: oall](scope: Scope,
                 input: oT,
                 filter: oT,
                 strides: ArraySlice[int],
                 rates: ArraySlice[int],
                 padding: cstring,
                 T: DType): Dilation2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Dilation2D(*#, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc dilation2D*[oT: oall](scope: Scope,
                 input: oT,
                 filter: oT,
                 strides: openArray[int],
                 rates: openArray[int],
                 padding: cstring): Dilation2D[oT] =
  return iidilation2D(scope,
                      input,
                      filter,
                      newArraySlice(strides),
                      newArraySlice(rates),
                      padding,
                      oT[].oTF)

converter dilation2DToOut*[oT: oall](op: Dilation2D[oT]): oT {.inline.} = return op.output


type DeserializeIterator*{.header:"../tensorflow/ops/generated.h", importcpp:"DeserializeIterator/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iideserializeIterator(scope: Scope,
                          resource_handle: oresource,
                          serialized: ovariant): DeserializeIterator {.header:"../tensorflow/ops/generated.h", importcpp:"DeserializeIterator(*#, #, #)", constructor.}

proc deserializeIterator*(scope: Scope,
                          resource_handle: oresource,
                          serialized: ovariant): DeserializeIterator =
  return iideserializeIterator(scope,
                               resource_handle,
                               serialized)




type RsqrtGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RsqrtGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirsqrtGrad[oT: oall](scope: Scope,
                y: oT,
                dy: oT,
                T: DType): RsqrtGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RsqrtGrad(*#, #, #, #)", constructor.}

proc rsqrtGrad*[oT: oall](scope: Scope,
                y: oT,
                dy: oT): RsqrtGrad[oT] =
  return iirsqrtGrad(scope,
                     y,
                     dy,
                     oT[].oTF)

converter rsqrtGradToOut*[oT: oall](op: RsqrtGrad[oT]): oT {.inline.} = return op.output


type QuantizedInstanceNorm*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedInstanceNorm/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedInstanceNorm[oT: oall](scope: Scope,
                            x: oT,
                            x_min: ofloat,
                            x_max: ofloat,
                            T: DType,
                            output_range_given: bool,
                            given_y_min: float32,
                            given_y_max: float32,
                            variance_epsilon: float32,
                            min_separation: float32): QuantizedInstanceNorm[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedInstanceNorm(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc quantizedInstanceNorm*[oT: oall](scope: Scope,
                            x: oT,
                            x_min: ofloat,
                            x_max: ofloat,
                            output_range_given: bool = false,
                            given_y_min: float32 = 0.0.float32,
                            given_y_max: float32 = 0.0.float32,
                            variance_epsilon: float32 = 9.999999747378752e-06.float32,
                            min_separation: float32 = 0.001000000047497451.float32): QuantizedInstanceNorm[oT] =
  return iiquantizedInstanceNorm(scope,
                                 x,
                                 x_min,
                                 x_max,
                                 oT[].oTF,
                                 output_range_given,
                                 given_y_min,
                                 given_y_max,
                                 variance_epsilon,
                                 min_separation)

converter quantizedInstanceNormToOut*[oT: oall](op: QuantizedInstanceNorm[oT]): oT {.inline.} = return op.output


type Rsqrt*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Rsqrt/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirsqrt[oT: oall](scope: Scope,
            x: oT,
            T: DType): Rsqrt[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Rsqrt(*#, #, #)", constructor.}

proc rsqrt*[oT: oall](scope: Scope,
            x: oT): Rsqrt[oT] =
  return iirsqrt(scope,
                 x,
                 oT[].oTF)

converter rsqrtToOut*[oT: oall](op: Rsqrt[oT]): oT {.inline.} = return op.output


type InitializeTableFromTextFile*{.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTableFromTextFile/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiinitializeTableFromTextFile(scope: Scope,
                                  table_handle: ostring,
                                  filename: ostring,
                                  key_index: int64,
                                  value_index: int64,
                                  vocab_size: int64,
                                  delimiter: cstring): InitializeTableFromTextFile {.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTableFromTextFile(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc initializeTableFromTextFile*(scope: Scope,
                                  table_handle: ostring,
                                  filename: ostring,
                                  key_index: int64 = 0.int,
                                  value_index: int64 = 0.int,
                                  vocab_size: int64 = -1.int,
                                  delimiter: cstring = "	"): InitializeTableFromTextFile =
  return iiinitializeTableFromTextFile(scope,
                                       table_handle,
                                       filename,
                                       key_index,
                                       value_index,
                                       vocab_size,
                                       delimiter)




type SqrtGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SqrtGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisqrtGrad[oT: oall](scope: Scope,
               y: oT,
               dy: oT,
               T: DType): SqrtGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SqrtGrad(*#, #, #, #)", constructor.}

proc sqrtGrad*[oT: oall](scope: Scope,
               y: oT,
               dy: oT): SqrtGrad[oT] =
  return iisqrtGrad(scope,
                    y,
                    dy,
                    oT[].oTF)

converter sqrtGradToOut*[oT: oall](op: SqrtGrad[oT]): oT {.inline.} = return op.output

type SparseSegmentSqrtNTidx* = oint32 | oint64

type SparseSegmentSqrtN*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSqrtN/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentSqrtN[oT: oall](scope: Scope,
                         data: oT,
                         indices: SparseSegmentSqrtNTidx,
                         segment_ids: oint32,
                         T: DType): SparseSegmentSqrtN[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSqrtN(*#, #, #, #, #)", constructor.}

proc sparseSegmentSqrtN*[oT: oall](scope: Scope,
                         data: oT,
                         indices: SparseSegmentSqrtNTidx,
                         segment_ids: oint32): SparseSegmentSqrtN[oT] =
  return iisparseSegmentSqrtN(scope,
                              data,
                              indices,
                              segment_ids,
                              oT[].oTF)

converter sparseSegmentSqrtNToOut*[oT: oall](op: SparseSegmentSqrtN[oT]): oT {.inline.} = return op.output


type IMklMaximum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklMaximum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiMklMaximum[oT: oall](scope: Scope,
                  x: oT,
                  y: oT,
                  mkl_x: ouint8,
                  mkl_y: ouint8,
                  T: DType): IMklMaximum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklMaximum(*#, #, #, #, #, #)", constructor.}

proc iMklMaximum*[oT: oall](scope: Scope,
                  x: oT,
                  y: oT,
                  mkl_x: ouint8,
                  mkl_y: ouint8): IMklMaximum[oT] =
  return iiiMklMaximum(scope,
                       x,
                       y,
                       mkl_x,
                       mkl_y,
                       oT[].oTF)

converter iMklMaximumToOut*[oT: oall](op: IMklMaximum[oT]): oT {.inline.} = return op.output


type Sqrt*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sqrt/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisqrt[oT: oall](scope: Scope,
           x: oT,
           T: DType): Sqrt[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sqrt(*#, #, #)", constructor.}

proc sqrt*[oT: oall](scope: Scope,
           x: oT): Sqrt[oT] =
  return iisqrt(scope,
                x,
                oT[].oTF)

converter sqrtToOut*[oT: oall](op: Sqrt[oT]): oT {.inline.} = return op.output


type InvGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"InvGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinvGrad[oT: oall](scope: Scope,
              y: oT,
              dy: oT,
              T: DType): InvGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"InvGrad(*#, #, #, #)", constructor.}

proc invGrad*[oT: oall](scope: Scope,
              y: oT,
              dy: oT): InvGrad[oT] =
  return iiinvGrad(scope,
                   y,
                   dy,
                   oT[].oTF)

converter invGradToOut*[oT: oall](op: InvGrad[oT]): oT {.inline.} = return op.output


type Inv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Inv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinv[oT: oall](scope: Scope,
          x: oT,
          T: DType): Inv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Inv(*#, #, #)", constructor.}

proc inv*[oT: oall](scope: Scope,
          x: oT): Inv[oT] =
  return iiinv(scope,
               x,
               oT[].oTF)

converter invToOut*[oT: oall](op: Inv[oT]): oT {.inline.} = return op.output


type ExperimentalStatsAggregatorSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalStatsAggregatorSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiexperimentalStatsAggregatorSummary(scope: Scope,
                                         niterator: oresource): ExperimentalStatsAggregatorSummary {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalStatsAggregatorSummary(*#, #)", constructor.}

proc experimentalStatsAggregatorSummary*(scope: Scope,
                                         niterator: oresource): ExperimentalStatsAggregatorSummary =
  return iiexperimentalStatsAggregatorSummary(scope,
                                              niterator)

converter experimentalStatsAggregatorSummaryToOut*(op: ExperimentalStatsAggregatorSummary): ostring {.inline.} = return op.output

type IHostCastSrcT* = oall

type IHostCast*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_HostCast/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiHostCast[oT: oall](scope: Scope,
                x: IHostCastSrcT,
                Truncate: bool,
                DstT: DType,
                explicitT: type(oT)): IHostCast[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_HostCast(*#, #, #, #)", constructor.}

proc iHostCast*(scope: Scope,
                x: IHostCastSrcT,
                Truncate: bool = false,
                DstT: type = oinvalid): auto =
  return iiiHostCast(scope,
                     x,
                     Truncate,
                     DstT[].oTF,
                     DstT)

converter iHostCastToOut*[oT: oall](op: IHostCast[oT]): oT {.inline.} = return op.output


type BatchMatMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatMul[oT: oall](scope: Scope,
                  x: oT,
                  y: oT,
                  T: DType,
                  adj_x: bool,
                  adj_y: bool): BatchMatMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatMul(*#, #, #, #, #, #)", constructor.}

proc batchMatMul*[oT: oall](scope: Scope,
                  x: oT,
                  y: oT,
                  adj_x: bool = false,
                  adj_y: bool = false): BatchMatMul[oT] =
  return iibatchMatMul(scope,
                       x,
                       y,
                       oT[].oTF,
                       adj_x,
                       adj_y)

converter batchMatMulToOut*[oT: oall](op: BatchMatMul[oT]): oT {.inline.} = return op.output


type AccumulateNV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulateNV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiaccumulateNV2[oT: oall](scope: Scope,
                    inputs: olist[oT],
                    T: DType,
                    shape: TensorShape): AccumulateNV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulateNV2(*#, #, #, #)", constructor.}

proc accumulateNV2*[oT: oall](scope: Scope,
                    inputs: olist[oT],
                    shape: TensorShape = [].shape): AccumulateNV2[oT] =
  return iiaccumulateNV2(scope,
                         inputs,
                         oT[].oTF,
                         shape)

converter accumulateNV2ToOut*[oT: oall](op: AccumulateNV2[oT]): oT {.inline.} = return op.output


type InitializeTableFromTextFileV2*{.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTableFromTextFileV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiinitializeTableFromTextFileV2(scope: Scope,
                                    table_handle: oresource,
                                    filename: ostring,
                                    key_index: int64,
                                    value_index: int64,
                                    vocab_size: int64,
                                    delimiter: cstring): InitializeTableFromTextFileV2 {.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTableFromTextFileV2(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc initializeTableFromTextFileV2*(scope: Scope,
                                    table_handle: oresource,
                                    filename: ostring,
                                    key_index: int64 = 0.int,
                                    value_index: int64 = 0.int,
                                    vocab_size: int64 = -1.int,
                                    delimiter: cstring = "	"): InitializeTableFromTextFileV2 =
  return iiinitializeTableFromTextFileV2(scope,
                                         table_handle,
                                         filename,
                                         key_index,
                                         value_index,
                                         vocab_size,
                                         delimiter)



type InitializeTableTval* = oall
type InitializeTableTkey* = oall

type InitializeTable*{.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTable/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiinitializeTable(scope: Scope,
                      table_handle: ostring,
                      keys: InitializeTableTkey,
                      values: InitializeTableTval): InitializeTable {.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTable(*#, #, #, #)", constructor.}

proc initializeTable*(scope: Scope,
                      table_handle: ostring,
                      keys: InitializeTableTkey,
                      values: InitializeTableTval): InitializeTable =
  return iiinitializeTable(scope,
                           table_handle,
                           keys,
                           values)




type FractionalAvgPoolGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalAvgPoolGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifractionalAvgPoolGrad[oT: oall](scope: Scope,
                            orig_input_tensor_shape: oint64,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool,
                            T: DType): FractionalAvgPoolGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalAvgPoolGrad(*#, #, #, #, #, #, #)", constructor.}

proc fractionalAvgPoolGrad*[oT: oall](scope: Scope,
                            orig_input_tensor_shape: oint64,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool = false): FractionalAvgPoolGrad[oT] =
  return iifractionalAvgPoolGrad(scope,
                                 orig_input_tensor_shape,
                                 out_backprop,
                                 row_pooling_sequence,
                                 col_pooling_sequence,
                                 overlapping,
                                 oT[].oTF)

converter fractionalAvgPoolGradToOut*[oT: oall](op: FractionalAvgPoolGrad[oT]): oT {.inline.} = return op.output

type MutableDenseHashTableV2key_dtype* = oall

type MutableDenseHashTableV2* {.header:"../tensorflow/ops/generated.h", importcpp:"MutableDenseHashTableV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iimutableDenseHashTableV2(scope: Scope,
                              empty_key: MutableDenseHashTableV2key_dtype,
                              deleted_key: MutableDenseHashTableV2key_dtype,
                              container: cstring,
                              shared_name: cstring,
                              use_node_name_sharing: bool,
                              max_load_factor: float32,
                              value_dtype: DType,
                              value_shape: TensorShape,
                              initial_num_buckets: int64): MutableDenseHashTableV2 {.header:"../tensorflow/ops/generated.h", importcpp:"MutableDenseHashTableV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc mutableDenseHashTableV2*(scope: Scope,
                              empty_key: MutableDenseHashTableV2key_dtype,
                              deleted_key: MutableDenseHashTableV2key_dtype,
                              container: cstring,
                              shared_name: cstring,
                              use_node_name_sharing: bool = false,
                              max_load_factor: float32 = 0.800000011920929.float32,
                              value_dtype: type oall = oinvalid,
                              value_shape: TensorShape = [].shape,
                              initial_num_buckets: int64 = 131072.int): MutableDenseHashTableV2 =
  return iimutableDenseHashTableV2(scope,
                                   empty_key,
                                   deleted_key,
                                   container,
                                   shared_name,
                                   use_node_name_sharing,
                                   max_load_factor,
                                   oT[].oTF,
                                   value_shape,
                                   initial_num_buckets)

converter mutableDenseHashTableV2ToOut*(op: MutableDenseHashTableV2): oresource {.inline.} = return op.output


type MutableHashTable* {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTable/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iimutableHashTable(scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       use_node_name_sharing: bool,
                       key_dtype: DType,
                       value_dtype: DType): MutableHashTable {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTable(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc mutableHashTable*(scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       use_node_name_sharing: bool = false,
                       key_dtype: type oall = oinvalid,
                       value_dtype: type oall = oinvalid): MutableHashTable =
  return iimutableHashTable(scope,
                            container,
                            shared_name,
                            use_node_name_sharing,
                            oT[].oTF,
                            oT[].oTF)

converter mutableHashTableToOut*(op: MutableHashTable): ostring {.inline.} = return op.output


type BoostedTreesCenterBias* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCenterBias/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiboostedTreesCenterBias(scope: Scope,
                             tree_ensemble_handle: oresource,
                             mean_gradients: ofloat,
                             mean_hessians: ofloat,
                             l1: ofloat,
                             l2: ofloat): BoostedTreesCenterBias {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCenterBias(*#, #, #, #, #, #)", constructor.}

proc boostedTreesCenterBias*(scope: Scope,
                             tree_ensemble_handle: oresource,
                             mean_gradients: ofloat,
                             mean_hessians: ofloat,
                             l1: ofloat,
                             l2: ofloat): BoostedTreesCenterBias =
  return iiboostedTreesCenterBias(scope,
                                  tree_ensemble_handle,
                                  mean_gradients,
                                  mean_hessians,
                                  l1,
                                  l2)

converter boostedTreesCenterBiasToOut*(op: BoostedTreesCenterBias): obool {.inline.} = return op.output


type HashTableV2* {.header:"../tensorflow/ops/generated.h", importcpp:"HashTableV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iihashTableV2(scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  use_node_name_sharing: bool,
                  key_dtype: DType,
                  value_dtype: DType): HashTableV2 {.header:"../tensorflow/ops/generated.h", importcpp:"HashTableV2(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc hashTableV2*(scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  use_node_name_sharing: bool = false,
                  key_dtype: type oall = oinvalid,
                  value_dtype: type oall = oinvalid): HashTableV2 =
  return iihashTableV2(scope,
                       container,
                       shared_name,
                       use_node_name_sharing,
                       oT[].oTF,
                       oT[].oTF)

converter hashTableV2ToOut*(op: HashTableV2): oresource {.inline.} = return op.output


type HashTable* {.header:"../tensorflow/ops/generated.h", importcpp:"HashTable/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iihashTable(scope: Scope,
                container: cstring,
                shared_name: cstring,
                use_node_name_sharing: bool,
                key_dtype: DType,
                value_dtype: DType): HashTable {.header:"../tensorflow/ops/generated.h", importcpp:"HashTable(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc hashTable*(scope: Scope,
                container: cstring,
                shared_name: cstring,
                use_node_name_sharing: bool = false,
                key_dtype: type oall = oinvalid,
                value_dtype: type oall = oinvalid): HashTable =
  return iihashTable(scope,
                     container,
                     shared_name,
                     use_node_name_sharing,
                     oT[].oTF,
                     oT[].oTF)

converter hashTableToOut*(op: HashTable): ostring {.inline.} = return op.output

type LookupTableImportV2Tout* = oall
type LookupTableImportV2Tin* = oall

type LookupTableImportV2*{.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableImportV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iilookupTableImportV2(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableImportV2Tin,
                          values: LookupTableImportV2Tout): LookupTableImportV2 {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableImportV2(*#, #, #, #)", constructor.}

proc lookupTableImportV2*(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableImportV2Tin,
                          values: LookupTableImportV2Tout): LookupTableImportV2 =
  return iilookupTableImportV2(scope,
                               table_handle,
                               keys,
                               values)




type RegexFullMatch* {.header:"../tensorflow/ops/generated.h", importcpp:"RegexFullMatch/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiregexFullMatch(scope: Scope,
                     input: ostring,
                     pattern: ostring): RegexFullMatch {.header:"../tensorflow/ops/generated.h", importcpp:"RegexFullMatch(*#, #, #)", constructor.}

proc regexFullMatch*(scope: Scope,
                     input: ostring,
                     pattern: ostring): RegexFullMatch =
  return iiregexFullMatch(scope,
                          input,
                          pattern)

converter regexFullMatchToOut*(op: RegexFullMatch): obool {.inline.} = return op.output

type LookupTableImportTout* = oall
type LookupTableImportTin* = oall

type LookupTableImport*{.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableImport/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iilookupTableImport(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableImportTin,
                        values: LookupTableImportTout): LookupTableImport {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableImport(*#, #, #, #)", constructor.}

proc lookupTableImport*(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableImportTin,
                        values: LookupTableImportTout): LookupTableImport =
  return iilookupTableImport(scope,
                             table_handle,
                             keys,
                             values)




type NonMaxSuppressionWithOverlaps* {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionWithOverlaps/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iinonMaxSuppressionWithOverlaps(scope: Scope,
                                    overlaps: ofloat,
                                    scores: ofloat,
                                    max_output_size: oint32,
                                    overlap_threshold: ofloat,
                                    score_threshold: ofloat): NonMaxSuppressionWithOverlaps {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionWithOverlaps(*#, #, #, #, #, #)", constructor.}

proc nonMaxSuppressionWithOverlaps*(scope: Scope,
                                    overlaps: ofloat,
                                    scores: ofloat,
                                    max_output_size: oint32,
                                    overlap_threshold: ofloat,
                                    score_threshold: ofloat): NonMaxSuppressionWithOverlaps =
  return iinonMaxSuppressionWithOverlaps(scope,
                                         overlaps,
                                         scores,
                                         max_output_size,
                                         overlap_threshold,
                                         score_threshold)

converter nonMaxSuppressionWithOverlapsToOut*(op: NonMaxSuppressionWithOverlaps): oint32 {.inline.} = return op.output


type LookupTableExportV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableExportV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilookupTableExportV2[oT: oall](scope: Scope,
                          table_handle: oresource,
                          Tkeys: DType,
                          Tvalues: DType,
                          explicitT: type(oT)): LookupTableExportV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableExportV2(*#, #, #, #)", constructor.}

proc lookupTableExportV2*(scope: Scope,
                          table_handle: oresource,
                          Tkeys: type = oinvalid,
                          Tvalues: type oall = oinvalid): auto =
  return iilookupTableExportV2(scope,
                               table_handle,
                               Tkeys[].oTF,
                               Tvalues[].oTF,
                               Tkeys)

converter lookupTableExportV2ToOut*[oT: oall](op: LookupTableExportV2[oT]): oT {.inline.} = return op.output

type AssignVariableOpdtype* = oall

type AssignVariableOp*{.header:"../tensorflow/ops/generated.h", importcpp:"AssignVariableOp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiassignVariableOp(scope: Scope,
                       resource: oresource,
                       value: AssignVariableOpdtype): AssignVariableOp {.header:"../tensorflow/ops/generated.h", importcpp:"AssignVariableOp(*#, #, #)", constructor.}

proc assignVariableOp*(scope: Scope,
                       resource: oresource,
                       value: AssignVariableOpdtype): AssignVariableOp =
  return iiassignVariableOp(scope,
                            resource,
                            value)




type LookupTableSize* {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableSize/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iilookupTableSize(scope: Scope,
                      table_handle: ostring): LookupTableSize {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableSize(*#, #)", constructor.}

proc lookupTableSize*(scope: Scope,
                      table_handle: ostring): LookupTableSize =
  return iilookupTableSize(scope,
                           table_handle)

converter lookupTableSizeToOut*(op: LookupTableSize): oint64 {.inline.} = return op.output


type PaddingFIFOQueueV2* {.header:"../tensorflow/ops/generated.h", importcpp:"PaddingFIFOQueueV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iipaddingFIFOQueueV2(scope: Scope,
                         component_types: ArraySlice[DType],
                         shapes: ArraySlice[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64): PaddingFIFOQueueV2 {.header:"../tensorflow/ops/generated.h", importcpp:"PaddingFIFOQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc paddingFIFOQueueV2*(scope: Scope,
                         component_types: openArray[DType],
                         shapes: openArray[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64 = -1.int): PaddingFIFOQueueV2 =
  return iipaddingFIFOQueueV2(scope,
                              newArraySlice(component_types),
                              newArraySlice(shapes),
                              container,
                              shared_name,
                              capacity)

converter paddingFIFOQueueV2ToOut*(op: PaddingFIFOQueueV2): oresource {.inline.} = return op.output

type LookupTableFindTin* = oall

type LookupTableFind*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableFind/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilookupTableFind[oT: oall](scope: Scope,
                      table_handle: ostring,
                      keys: LookupTableFindTin,
                      default_value: oT,
                      Tout: DType): LookupTableFind[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableFind(*#, #, #, #, #)", constructor.}

proc lookupTableFind*[oT: oall](scope: Scope,
                      table_handle: ostring,
                      keys: LookupTableFindTin,
                      default_value: oT): LookupTableFind[oT] =
  return iilookupTableFind(scope,
                           table_handle,
                           keys,
                           default_value,
                           oT[].oTF)

converter lookupTableFindToOut*[oT: oall](op: LookupTableFind[oT]): oT {.inline.} = return op.output

type LessEqualT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type LessEqual* {.header:"../tensorflow/ops/generated.h", importcpp:"LessEqual/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iilessEqual(scope: Scope,
                x: LessEqualT,
                y: LessEqualT): LessEqual {.header:"../tensorflow/ops/generated.h", importcpp:"LessEqual(*#, #, #)", constructor.}

proc lessEqual*(scope: Scope,
                x: LessEqualT,
                y: LessEqualT): LessEqual =
  return iilessEqual(scope,
                     x,
                     y)

converter lessEqualToOut*(op: LessEqual): obool {.inline.} = return op.output


type Timestamp* {.header:"../tensorflow/ops/generated.h", importcpp:"Timestamp/*'0*/".} = object
  operation*: Operation[odouble]
  output*: odouble

proc iitimestamp(scope: Scope): Timestamp {.header:"../tensorflow/ops/generated.h", importcpp:"Timestamp(*#)", constructor.}

proc timestamp*(scope: Scope): Timestamp =
  return iitimestamp(scope)

converter timestampToOut*(op: Timestamp): odouble {.inline.} = return op.output


type MergeSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"MergeSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iimergeSummary(scope: Scope,
                   inputs: olist[ostring]): MergeSummary {.header:"../tensorflow/ops/generated.h", importcpp:"MergeSummary(*#, #)", constructor.}

proc mergeSummary*(scope: Scope,
                   inputs: olist[ostring]): MergeSummary =
  return iimergeSummary(scope,
                        inputs)

converter mergeSummaryToOut*(op: MergeSummary): ostring {.inline.} = return op.output


type AvgPool*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPool/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiavgPool[oT: oall](scope: Scope,
              value: oT,
              ksize: ArraySlice[int],
              strides: ArraySlice[int],
              padding: cstring,
              data_format: cstring,
              T: DType): AvgPool[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPool(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc avgPool*[oT: oall](scope: Scope,
              value: oT,
              ksize: openArray[int],
              strides: openArray[int],
              padding: cstring,
              data_format: cstring = "NHWC"): AvgPool[oT] =
  return iiavgPool(scope,
                   value,
                   newArraySlice(ksize),
                   newArraySlice(strides),
                   padding,
                   data_format,
                   oT[].oTF)

converter avgPoolToOut*[oT: oall](op: AvgPool[oT]): oT {.inline.} = return op.output


type AudioSummaryV2* {.header:"../tensorflow/ops/generated.h", importcpp:"AudioSummaryV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiaudioSummaryV2(scope: Scope,
                     tag: ostring,
                     tensor: ofloat,
                     sample_rate: ofloat,
                     max_outputs: int64): AudioSummaryV2 {.header:"../tensorflow/ops/generated.h", importcpp:"AudioSummaryV2(*#, #, #, #, #)", constructor.}

proc audioSummaryV2*(scope: Scope,
                     tag: ostring,
                     tensor: ofloat,
                     sample_rate: ofloat,
                     max_outputs: int64 = 3.int): AudioSummaryV2 =
  return iiaudioSummaryV2(scope,
                          tag,
                          tensor,
                          sample_rate,
                          max_outputs)

converter audioSummaryV2ToOut*(op: AudioSummaryV2): ostring {.inline.} = return op.output

type HistogramSummaryT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type HistogramSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"HistogramSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iihistogramSummary(scope: Scope,
                       tag: ostring,
                       values: HistogramSummaryT): HistogramSummary {.header:"../tensorflow/ops/generated.h", importcpp:"HistogramSummary(*#, #, #)", constructor.}

proc histogramSummary*(scope: Scope,
                       tag: ostring,
                       values: HistogramSummaryT): HistogramSummary =
  return iihistogramSummary(scope,
                            tag,
                            values)

converter histogramSummaryToOut*(op: HistogramSummary): ostring {.inline.} = return op.output

type TensorListScatterelement_dtype* = oall
type TensorListScattershape_type* = oint32 | oint64

type TensorListScatter* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListScatter/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListScatter(scope: Scope,
                        tensor: TensorListScatterelement_dtype,
                        indices: oint32,
                        element_shape: TensorListScattershape_type): TensorListScatter {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListScatter(*#, #, #, #)", constructor.}

proc tensorListScatter*(scope: Scope,
                        tensor: TensorListScatterelement_dtype,
                        indices: oint32,
                        element_shape: TensorListScattershape_type): TensorListScatter =
  return iitensorListScatter(scope,
                             tensor,
                             indices,
                             element_shape)

converter tensorListScatterToOut*(op: TensorListScatter): ovariant {.inline.} = return op.output

type TensorListSetItemelement_dtype* = oall

type TensorListSetItem* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListSetItem/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListSetItem(scope: Scope,
                        input_handle: ovariant,
                        index: oint32,
                        item: TensorListSetItemelement_dtype): TensorListSetItem {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListSetItem(*#, #, #, #)", constructor.}

proc tensorListSetItem*(scope: Scope,
                        input_handle: ovariant,
                        index: oint32,
                        item: TensorListSetItemelement_dtype): TensorListSetItem =
  return iitensorListSetItem(scope,
                             input_handle,
                             index,
                             item)

converter tensorListSetItemToOut*(op: TensorListSetItem): ovariant {.inline.} = return op.output


type ClipByValue*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ClipByValue/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiclipByValue[oT: oall](scope: Scope,
                  t: oT,
                  clip_value_min: oT,
                  clip_value_max: oT,
                  T: DType): ClipByValue[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ClipByValue(*#, #, #, #, #)", constructor.}

proc clipByValue*[oT: oall](scope: Scope,
                  t: oT,
                  clip_value_min: oT,
                  clip_value_max: oT): ClipByValue[oT] =
  return iiclipByValue(scope,
                       t,
                       clip_value_min,
                       clip_value_max,
                       oT[].oTF)

converter clipByValueToOut*[oT: oall](op: ClipByValue[oT]): oT {.inline.} = return op.output

type TensorListReserveshape_type* = oint32 | oint64

type TensorListReserve* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListReserve/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListReserve(scope: Scope,
                        element_shape: TensorListReserveshape_type,
                        num_elements: oint32,
                        element_dtype: DType): TensorListReserve {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListReserve(*#, #, #, #)", constructor.}

proc tensorListReserve*(scope: Scope,
                        element_shape: TensorListReserveshape_type,
                        num_elements: oint32,
                        element_dtype: type oall = oinvalid): TensorListReserve =
  return iitensorListReserve(scope,
                             element_shape,
                             num_elements,
                             oT[].oTF)

converter tensorListReserveToOut*(op: TensorListReserve): ovariant {.inline.} = return op.output


type ExperimentalThreadPoolHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalThreadPoolHandle/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiexperimentalThreadPoolHandle(scope: Scope,
                                   display_name: cstring,
                                   container: cstring,
                                   shared_name: cstring,
                                   num_threads: int64,
                                   max_intra_op_parallelism: int64): ExperimentalThreadPoolHandle {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalThreadPoolHandle(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc experimentalThreadPoolHandle*(scope: Scope,
                                   display_name: cstring,
                                   container: cstring,
                                   shared_name: cstring,
                                   num_threads: int64 = 0.int,
                                   max_intra_op_parallelism: int64 = 1.int): ExperimentalThreadPoolHandle =
  return iiexperimentalThreadPoolHandle(scope,
                                        display_name,
                                        container,
                                        shared_name,
                                        num_threads,
                                        max_intra_op_parallelism)

converter experimentalThreadPoolHandleToOut*(op: ExperimentalThreadPoolHandle): oresource {.inline.} = return op.output

type TensorListFromTensorelement_dtype* = oall
type TensorListFromTensorshape_type* = oint32 | oint64

type TensorListFromTensor* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListFromTensor/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListFromTensor(scope: Scope,
                           tensor: TensorListFromTensorelement_dtype,
                           element_shape: TensorListFromTensorshape_type): TensorListFromTensor {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListFromTensor(*#, #, #)", constructor.}

proc tensorListFromTensor*(scope: Scope,
                           tensor: TensorListFromTensorelement_dtype,
                           element_shape: TensorListFromTensorshape_type): TensorListFromTensor =
  return iitensorListFromTensor(scope,
                                tensor,
                                element_shape)

converter tensorListFromTensorToOut*(op: TensorListFromTensor): ovariant {.inline.} = return op.output


type TensorListStack*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListStack/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorListStack[oT: oall](scope: Scope,
                      input_handle: ovariant,
                      element_dtype: DType,
                      num_elements: int64,
                      explicitT: type(oT)): TensorListStack[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListStack(*#, #, #, #)", constructor.}

proc tensorListStack*(scope: Scope,
                      input_handle: ovariant,
                      element_dtype: type = oinvalid,
                      num_elements: int64 = -1.int): auto =
  return iitensorListStack(scope,
                           input_handle,
                           element_dtype[].oTF,
                           num_elements,
                           element_dtype)

converter tensorListStackToOut*[oT: oall](op: TensorListStack[oT]): oT {.inline.} = return op.output


type IMklMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiMklMul[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8,
              T: DType): IMklMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklMul(*#, #, #, #, #, #)", constructor.}

proc iMklMul*[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklMul[oT] =
  return iiiMklMul(scope,
                   x,
                   y,
                   mkl_x,
                   mkl_y,
                   oT[].oTF)

converter iMklMulToOut*[oT: oall](op: IMklMul[oT]): oT {.inline.} = return op.output

type TensorScatterUpdateTindices* = oint32 | oint64

type TensorScatterUpdate*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorScatterUpdate/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorScatterUpdate[oT: oall](scope: Scope,
                          tensor: oT,
                          indices: TensorScatterUpdateTindices,
                          updates: oT,
                          T: DType): TensorScatterUpdate[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorScatterUpdate(*#, #, #, #, #)", constructor.}

proc tensorScatterUpdate*[oT: oall](scope: Scope,
                          tensor: oT,
                          indices: TensorScatterUpdateTindices,
                          updates: oT): TensorScatterUpdate[oT] =
  return iitensorScatterUpdate(scope,
                               tensor,
                               indices,
                               updates,
                               oT[].oTF)

converter tensorScatterUpdateToOut*[oT: oall](op: TensorScatterUpdate[oT]): oT {.inline.} = return op.output


type TakeDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"TakeDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitakeDataset(scope: Scope,
                  input_dataset: ovariant,
                  count: oint64,
                  output_types: ArraySlice[DType],
                  output_shapes: ArraySlice[TensorShape]): TakeDataset {.header:"../tensorflow/ops/generated.h", importcpp:"TakeDataset(*#, #, #, #, #)", constructor.}

proc takeDataset*(scope: Scope,
                  input_dataset: ovariant,
                  count: oint64,
                  output_types: openArray[DType],
                  output_shapes: openArray[TensorShape]): TakeDataset =
  return iitakeDataset(scope,
                       input_dataset,
                       count,
                       newArraySlice(output_types),
                       newArraySlice(output_shapes))

converter takeDatasetToOut*(op: TakeDataset): ovariant {.inline.} = return op.output


type TensorListPopBack* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListPopBack/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListPopBack(scope: Scope,
                        input_handle: ovariant,
                        element_dtype: DType): TensorListPopBack {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListPopBack(*#, #, #)", constructor.}

proc tensorListPopBack*(scope: Scope,
                        input_handle: ovariant,
                        element_dtype: type oall = oinvalid): TensorListPopBack =
  return iitensorListPopBack(scope,
                             input_handle,
                             oT[].oTF)

converter tensorListPopBackToOut*(op: TensorListPopBack): ovariant {.inline.} = return op.output


type TensorListLength* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListLength/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iitensorListLength(scope: Scope,
                       input_handle: ovariant): TensorListLength {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListLength(*#, #)", constructor.}

proc tensorListLength*(scope: Scope,
                       input_handle: ovariant): TensorListLength =
  return iitensorListLength(scope,
                            input_handle)

converter tensorListLengthToOut*(op: TensorListLength): oint32 {.inline.} = return op.output


type ExperimentalIndexedDatasetGet*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIndexedDatasetGet/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiexperimentalIndexedDatasetGet[oT: oall](scope: Scope,
                                    materialized: oresource,
                                    index: ouint64,
                                    output_types: ArraySlice[DType],
                                    output_shapes: ArraySlice[TensorShape],
                                    explicitT: type(oT)): ExperimentalIndexedDatasetGet[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIndexedDatasetGet(*#, #, #, #, #)", constructor.}

proc experimentalIndexedDatasetGet*(scope: Scope,
                                    materialized: oresource,
                                    index: ouint64,
                                    output_types: openArray[DType],
                                    output_shapes: openArray[TensorShape],
                                    explicitT: type): auto =
  return iiexperimentalIndexedDatasetGet(scope,
                                         materialized,
                                         index,
                                         newArraySlice(output_types),
                                         newArraySlice(output_shapes),
                                         explicitT)

converter experimentalIndexedDatasetGetToOutList*[oT: oall](op: ExperimentalIndexedDatasetGet[oT]): olist[oT] {.inline.} = return op.output

type TensorListPushBackBatchelement_dtype* = oall

type TensorListPushBackBatch* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListPushBackBatch/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListPushBackBatch(scope: Scope,
                              input_handles: ovariant,
                              tensor: TensorListPushBackBatchelement_dtype): TensorListPushBackBatch {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListPushBackBatch(*#, #, #)", constructor.}

proc tensorListPushBackBatch*(scope: Scope,
                              input_handles: ovariant,
                              tensor: TensorListPushBackBatchelement_dtype): TensorListPushBackBatch =
  return iitensorListPushBackBatch(scope,
                                   input_handles,
                                   tensor)

converter tensorListPushBackBatchToOut*(op: TensorListPushBackBatch): ovariant {.inline.} = return op.output

type EmptyTensorListshape_type* = oint32 | oint64

type EmptyTensorList* {.header:"../tensorflow/ops/generated.h", importcpp:"EmptyTensorList/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiemptyTensorList(scope: Scope,
                      element_shape: EmptyTensorListshape_type,
                      max_num_elements: oint32,
                      element_dtype: DType): EmptyTensorList {.header:"../tensorflow/ops/generated.h", importcpp:"EmptyTensorList(*#, #, #, #)", constructor.}

proc emptyTensorList*(scope: Scope,
                      element_shape: EmptyTensorListshape_type,
                      max_num_elements: oint32,
                      element_dtype: type oall = oinvalid): EmptyTensorList =
  return iiemptyTensorList(scope,
                           element_shape,
                           max_num_elements,
                           oT[].oTF)

converter emptyTensorListToOut*(op: EmptyTensorList): ovariant {.inline.} = return op.output

type RandomStandardNormalT* = oint32 | oint64

type RandomStandardNormal*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomStandardNormal/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomStandardNormal[oT: oall](scope: Scope,
                           shape: RandomStandardNormalT,
                           seed: int64,
                           seed2: int64,
                           dtype: DType,
                           explicitT: type(oT)): RandomStandardNormal[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomStandardNormal(*#, #, #, #, #)", constructor.}

proc randomStandardNormal*(scope: Scope,
                           shape: RandomStandardNormalT,
                           seed: int64 = 0.int,
                           seed2: int64 = 0.int,
                           dtype: type = oinvalid): auto =
  return iirandomStandardNormal(scope,
                                shape,
                                seed,
                                seed2,
                                dtype[].oTF,
                                dtype)

converter randomStandardNormalToOut*[oT: oall](op: RandomStandardNormal[oT]): oT {.inline.} = return op.output


type Erf*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Erf/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iierf[oT: oall](scope: Scope,
          x: oT,
          T: DType): Erf[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Erf(*#, #, #)", constructor.}

proc erf*[oT: oall](scope: Scope,
          x: oT): Erf[oT] =
  return iierf(scope,
               x,
               oT[].oTF)

converter erfToOut*[oT: oall](op: Erf[oT]): oT {.inline.} = return op.output

type MeanTidx* = oint32 | oint64

type Mean*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Mean/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimean[oT: oall](scope: Scope,
           input: oT,
           reduction_indices: MeanTidx,
           keep_dims: bool,
           T: DType): Mean[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Mean(*#, #, #, #, #)", constructor.}

proc mean*[oT: oall](scope: Scope,
           input: oT,
           reduction_indices: MeanTidx,
           keep_dims: bool = false): Mean[oT] =
  return iimean(scope,
                input,
                reduction_indices,
                keep_dims,
                oT[].oTF)

converter meanToOut*[oT: oall](op: Mean[oT]): oT {.inline.} = return op.output


type BatchMatrixTriangularSolve*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixTriangularSolve/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixTriangularSolve[oT: oall](scope: Scope,
                                 matrix: oT,
                                 rhs: oT,
                                 lower: bool,
                                 adjoint: bool,
                                 T: DType): BatchMatrixTriangularSolve[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixTriangularSolve(*#, #, #, #, #, #)", constructor.}

proc batchMatrixTriangularSolve*[oT: oall](scope: Scope,
                                 matrix: oT,
                                 rhs: oT,
                                 lower: bool = true,
                                 adjoint: bool = false): BatchMatrixTriangularSolve[oT] =
  return iibatchMatrixTriangularSolve(scope,
                                      matrix,
                                      rhs,
                                      lower,
                                      adjoint,
                                      oT[].oTF)

converter batchMatrixTriangularSolveToOut*[oT: oall](op: BatchMatrixTriangularSolve[oT]): oT {.inline.} = return op.output


type BatchMatrixSolve*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixSolve/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixSolve[oT: oall](scope: Scope,
                       matrix: oT,
                       rhs: oT,
                       adjoint: bool,
                       T: DType): BatchMatrixSolve[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixSolve(*#, #, #, #, #)", constructor.}

proc batchMatrixSolve*[oT: oall](scope: Scope,
                       matrix: oT,
                       rhs: oT,
                       adjoint: bool = false): BatchMatrixSolve[oT] =
  return iibatchMatrixSolve(scope,
                            matrix,
                            rhs,
                            adjoint,
                            oT[].oTF)

converter batchMatrixSolveToOut*[oT: oall](op: BatchMatrixSolve[oT]): oT {.inline.} = return op.output

type QuantizedBiasAddT1* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedBiasAddT2* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedBiasAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedBiasAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedBiasAdd[oT: oall](scope: Scope,
                       input: QuantizedBiasAddT1,
                       bias: QuantizedBiasAddT2,
                       min_input: ofloat,
                       max_input: ofloat,
                       min_bias: ofloat,
                       max_bias: ofloat,
                       out_type: DType,
                       explicitT: type(oT)): QuantizedBiasAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedBiasAdd(*#, #, #, #, #, #, #, #)", constructor.}

proc quantizedBiasAdd*(scope: Scope,
                       input: QuantizedBiasAddT1,
                       bias: QuantizedBiasAddT2,
                       min_input: ofloat,
                       max_input: ofloat,
                       min_bias: ofloat,
                       max_bias: ofloat,
                       out_type: type = oinvalid): auto =
  return iiquantizedBiasAdd(scope,
                            input,
                            bias,
                            min_input,
                            max_input,
                            min_bias,
                            max_bias,
                            out_type[].oTF,
                            out_type)

converter quantizedBiasAddToOut*[oT: oall](op: QuantizedBiasAdd[oT]): oT {.inline.} = return op.output


type DataFormatVecPermute*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DataFormatVecPermute/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidataFormatVecPermute[oT: oall](scope: Scope,
                           x: oT,
                           T: DType,
                           src_format: cstring,
                           dst_format: cstring): DataFormatVecPermute[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DataFormatVecPermute(*#, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc dataFormatVecPermute*[oT: oall](scope: Scope,
                           x: oT,
                           src_format: cstring = "NHWC",
                           dst_format: cstring = "NCHW"): DataFormatVecPermute[oT] =
  return iidataFormatVecPermute(scope,
                                x,
                                oT[].oTF,
                                src_format,
                                dst_format)

converter dataFormatVecPermuteToOut*[oT: oall](op: DataFormatVecPermute[oT]): oT {.inline.} = return op.output


type BatchCholeskyGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchCholeskyGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchCholeskyGrad[oT: oall](scope: Scope,
                        l: oT,
                        grad: oT,
                        T: DType): BatchCholeskyGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchCholeskyGrad(*#, #, #, #)", constructor.}

proc batchCholeskyGrad*[oT: oall](scope: Scope,
                        l: oT,
                        grad: oT): BatchCholeskyGrad[oT] =
  return iibatchCholeskyGrad(scope,
                             l,
                             grad,
                             oT[].oTF)

converter batchCholeskyGradToOut*[oT: oall](op: BatchCholeskyGrad[oT]): oT {.inline.} = return op.output


type BatchMatrixInverse*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixInverse/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixInverse[oT: oall](scope: Scope,
                         input: oT,
                         adjoint: bool,
                         T: DType): BatchMatrixInverse[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixInverse(*#, #, #, #)", constructor.}

proc batchMatrixInverse*[oT: oall](scope: Scope,
                         input: oT,
                         adjoint: bool = false): BatchMatrixInverse[oT] =
  return iibatchMatrixInverse(scope,
                              input,
                              adjoint,
                              oT[].oTF)

converter batchMatrixInverseToOut*[oT: oall](op: BatchMatrixInverse[oT]): oT {.inline.} = return op.output

type DebugNumericSummaryT* = oall

type DebugNumericSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"DebugNumericSummary/*'0*/".} = object
  operation*: Operation[odouble]
  output*: odouble

proc iidebugNumericSummary(scope: Scope,
                          input: DebugNumericSummaryT,
                          device_name: cstring,
                          tensor_name: cstring,
                          debug_urls: ArraySlice[cstring],
                          gated_grpc: bool,
                          lower_bound: float32,
                          upper_bound: float32,
                          mute_if_healthy: bool): DebugNumericSummary {.header:"../tensorflow/ops/generated.h", importcpp:"DebugNumericSummary(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc debugNumericSummary*(scope: Scope,
                          input: DebugNumericSummaryT,
                          device_name: cstring,
                          tensor_name: cstring,
                          debug_urls: openArray[cstring],
                          gated_grpc: bool = false,
                          lower_bound: float32 = NegInf.float32,
                          upper_bound: float32 = Inf.float32,
                          mute_if_healthy: bool = false): DebugNumericSummary =
  return iidebugNumericSummary(scope,
                               input,
                               device_name,
                               tensor_name,
                               newArraySlice(debug_urls),
                               gated_grpc,
                               lower_bound,
                               upper_bound,
                               mute_if_healthy)

converter debugNumericSummaryToOut*(op: DebugNumericSummary): odouble {.inline.} = return op.output


type BatchSelfAdjointEig*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchSelfAdjointEig/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchSelfAdjointEig[oT: oall](scope: Scope,
                          input: oT,
                          T: DType): BatchSelfAdjointEig[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchSelfAdjointEig(*#, #, #)", constructor.}

proc batchSelfAdjointEig*[oT: oall](scope: Scope,
                          input: oT): BatchSelfAdjointEig[oT] =
  return iibatchSelfAdjointEig(scope,
                               input,
                               oT[].oTF)

converter batchSelfAdjointEigToOut*[oT: oall](op: BatchSelfAdjointEig[oT]): oT {.inline.} = return op.output

type LookupTableFindV2Tin* = oall

type LookupTableFindV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableFindV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilookupTableFindV2[oT: oall](scope: Scope,
                        table_handle: oresource,
                        keys: LookupTableFindV2Tin,
                        default_value: oT,
                        Tout: DType): LookupTableFindV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableFindV2(*#, #, #, #, #)", constructor.}

proc lookupTableFindV2*[oT: oall](scope: Scope,
                        table_handle: oresource,
                        keys: LookupTableFindV2Tin,
                        default_value: oT): LookupTableFindV2[oT] =
  return iilookupTableFindV2(scope,
                             table_handle,
                             keys,
                             default_value,
                             oT[].oTF)

converter lookupTableFindV2ToOut*[oT: oall](op: LookupTableFindV2[oT]): oT {.inline.} = return op.output


type Asinh*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Asinh/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiasinh[oT: oall](scope: Scope,
            x: oT,
            T: DType): Asinh[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Asinh(*#, #, #)", constructor.}

proc asinh*[oT: oall](scope: Scope,
            x: oT): Asinh[oT] =
  return iiasinh(scope,
                 x,
                 oT[].oTF)

converter asinhToOut*[oT: oall](op: Asinh[oT]): oT {.inline.} = return op.output


type CollectiveBcastRecv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CollectiveBcastRecv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicollectiveBcastRecv[oT: oall](scope: Scope,
                          T: DType,
                          group_size: int64,
                          group_key: int64,
                          instance_key: int64,
                          shape: TensorShape,
                          explicitT: type(oT)): CollectiveBcastRecv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CollectiveBcastRecv(*#, #, #, #, #, #)", constructor.}

proc collectiveBcastRecv*(scope: Scope,
                          T: type = oinvalid,
                          group_size: int64 = 0.int,
                          group_key: int64 = 0.int,
                          instance_key: int64 = 0.int,
                          shape: TensorShape = [].shape): auto =
  return iicollectiveBcastRecv(scope,
                               T[].oTF,
                               group_size,
                               group_key,
                               instance_key,
                               shape,
                               T)

converter collectiveBcastRecvToOut*[oT: oall](op: CollectiveBcastRecv[oT]): oT {.inline.} = return op.output

type TensorArrayScatterV3T* = oall

type TensorArrayScatterV3* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayScatterV3/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayScatterV3(scope: Scope,
                           handle: oresource,
                           indices: oint32,
                           value: TensorArrayScatterV3T,
                           flow_in: ofloat): TensorArrayScatterV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayScatterV3(*#, #, #, #, #)", constructor.}

proc tensorArrayScatterV3*(scope: Scope,
                           handle: oresource,
                           indices: oint32,
                           value: TensorArrayScatterV3T,
                           flow_in: ofloat): TensorArrayScatterV3 =
  return iitensorArrayScatterV3(scope,
                                handle,
                                indices,
                                value,
                                flow_in)

converter tensorArrayScatterV3ToOut*(op: TensorArrayScatterV3): ofloat {.inline.} = return op.output


type MatrixSquareRoot*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSquareRoot/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixSquareRoot[oT: oall](scope: Scope,
                       input: oT,
                       T: DType): MatrixSquareRoot[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSquareRoot(*#, #, #)", constructor.}

proc matrixSquareRoot*[oT: oall](scope: Scope,
                       input: oT): MatrixSquareRoot[oT] =
  return iimatrixSquareRoot(scope,
                            input,
                            oT[].oTF)

converter matrixSquareRootToOut*[oT: oall](op: MatrixSquareRoot[oT]): oT {.inline.} = return op.output


type MatrixTriangularSolve*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixTriangularSolve/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixTriangularSolve[oT: oall](scope: Scope,
                            matrix: oT,
                            rhs: oT,
                            lower: bool,
                            adjoint: bool,
                            T: DType): MatrixTriangularSolve[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixTriangularSolve(*#, #, #, #, #, #)", constructor.}

proc matrixTriangularSolve*[oT: oall](scope: Scope,
                            matrix: oT,
                            rhs: oT,
                            lower: bool = true,
                            adjoint: bool = false): MatrixTriangularSolve[oT] =
  return iimatrixTriangularSolve(scope,
                                 matrix,
                                 rhs,
                                 lower,
                                 adjoint,
                                 oT[].oTF)

converter matrixTriangularSolveToOut*[oT: oall](op: MatrixTriangularSolve[oT]): oT {.inline.} = return op.output


type SelfAdjointEig*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SelfAdjointEig/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiselfAdjointEig[oT: oall](scope: Scope,
                     input: oT,
                     T: DType): SelfAdjointEig[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SelfAdjointEig(*#, #, #)", constructor.}

proc selfAdjointEig*[oT: oall](scope: Scope,
                     input: oT): SelfAdjointEig[oT] =
  return iiselfAdjointEig(scope,
                          input,
                          oT[].oTF)

converter selfAdjointEigToOut*[oT: oall](op: SelfAdjointEig[oT]): oT {.inline.} = return op.output

type ReshapeTshape* = oint32 | oint64

type Reshape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Reshape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireshape[oT: oall](scope: Scope,
              tensor: oT,
              shape: ReshapeTshape,
              T: DType): Reshape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Reshape(*#, #, #, #)", constructor.}

proc reshape*[oT: oall](scope: Scope,
              tensor: oT,
              shape: ReshapeTshape): Reshape[oT] =
  return iireshape(scope,
                   tensor,
                   shape,
                   oT[].oTF)

converter reshapeToOut*[oT: oall](op: Reshape[oT]): oT {.inline.} = return op.output

type ArgMaxT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ArgMaxTidx* = oint32 | oint64

type ArgMax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ArgMax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiargMax[oT: oall](scope: Scope,
             input: ArgMaxT,
             dimension: ArgMaxTidx,
             output_type: DType,
             explicitT: type(oT)): ArgMax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ArgMax(*#, #, #, #)", constructor.}

proc argMax*(scope: Scope,
             input: ArgMaxT,
             dimension: ArgMaxTidx,
             output_type: type = oint64): auto =
  return iiargMax(scope,
                  input,
                  dimension,
                  output_type[].oTF,
                  output_type)

converter argMaxToOut*[oT: oall](op: ArgMax[oT]): oT {.inline.} = return op.output


type CholeskyGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CholeskyGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicholeskyGrad[oT: oall](scope: Scope,
                   l: oT,
                   grad: oT,
                   T: DType): CholeskyGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CholeskyGrad(*#, #, #, #)", constructor.}

proc choleskyGrad*[oT: oall](scope: Scope,
                   l: oT,
                   grad: oT): CholeskyGrad[oT] =
  return iicholeskyGrad(scope,
                        l,
                        grad,
                        oT[].oTF)

converter choleskyGradToOut*[oT: oall](op: CholeskyGrad[oT]): oT {.inline.} = return op.output


type StaticRegexFullMatch* {.header:"../tensorflow/ops/generated.h", importcpp:"StaticRegexFullMatch/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iistaticRegexFullMatch(scope: Scope,
                           input: ostring,
                           pattern: cstring): StaticRegexFullMatch {.header:"../tensorflow/ops/generated.h", importcpp:"StaticRegexFullMatch(*#, #, tensorflow::string(#))", constructor.}

proc staticRegexFullMatch*(scope: Scope,
                           input: ostring,
                           pattern: cstring): StaticRegexFullMatch =
  return iistaticRegexFullMatch(scope,
                                input,
                                pattern)

converter staticRegexFullMatchToOut*(op: StaticRegexFullMatch): obool {.inline.} = return op.output


type ParseSingleSequenceExample* {.header:"../tensorflow/ops/generated.h", importcpp:"ParseSingleSequenceExample/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiparseSingleSequenceExample(scope: Scope,
                                 serialized: ostring,
                                 feature_list_dense_missing_assumed_empty: ostring,
                                 context_sparse_keys: ostring,
                                 context_dense_keys: ostring,
                                 feature_list_sparse_keys: ostring,
                                 feature_list_dense_keys: ostring,
                                 context_dense_defaults: olist[oall],
                                 debug_name: ostring,
                                 context_sparse_types: ArraySlice[DType],
                                 Tcontext_dense: ArraySlice[DType],
                                 feature_list_dense_types: ArraySlice[DType],
                                 context_dense_shapes: ArraySlice[TensorShape],
                                 feature_list_sparse_types: ArraySlice[DType],
                                 feature_list_dense_shapes: ArraySlice[TensorShape],
                                 Ncontext_sparse: int64,
                                 Ncontext_dense: int64,
                                 Nfeature_list_sparse: int64,
                                 Nfeature_list_dense: int64): ParseSingleSequenceExample {.header:"../tensorflow/ops/generated.h", importcpp:"ParseSingleSequenceExample(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parseSingleSequenceExample*(scope: Scope,
                                 serialized: ostring,
                                 feature_list_dense_missing_assumed_empty: ostring,
                                 context_sparse_keys: ostring,
                                 context_dense_keys: ostring,
                                 feature_list_sparse_keys: ostring,
                                 feature_list_dense_keys: ostring,
                                 context_dense_defaults: olist[oall],
                                 debug_name: ostring,
                                 context_sparse_types: openArray[DType],
                                 Tcontext_dense: openArray[DType],
                                 feature_list_dense_types: openArray[DType],
                                 context_dense_shapes: openArray[TensorShape],
                                 feature_list_sparse_types: openArray[DType],
                                 feature_list_dense_shapes: openArray[TensorShape],
                                 Ncontext_sparse: int64 = 0.int,
                                 Ncontext_dense: int64 = 0.int,
                                 Nfeature_list_sparse: int64 = 0.int,
                                 Nfeature_list_dense: int64 = 0.int): ParseSingleSequenceExample =
  return iiparseSingleSequenceExample(scope,
                                      serialized,
                                      feature_list_dense_missing_assumed_empty,
                                      context_sparse_keys,
                                      context_dense_keys,
                                      feature_list_sparse_keys,
                                      feature_list_dense_keys,
                                      context_dense_defaults,
                                      debug_name,
                                      newArraySlice(context_sparse_types),
                                      newArraySlice(Tcontext_dense),
                                      newArraySlice(feature_list_dense_types),
                                      newArraySlice(context_dense_shapes),
                                      newArraySlice(feature_list_sparse_types),
                                      newArraySlice(feature_list_dense_shapes),
                                      Ncontext_sparse,
                                      Ncontext_dense,
                                      Nfeature_list_sparse,
                                      Nfeature_list_dense)

converter parseSingleSequenceExampleToOut*(op: ParseSingleSequenceExample): oint64 {.inline.} = return op.output


type LookupTableExport*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableExport/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilookupTableExport[oT: oall](scope: Scope,
                        table_handle: ostring,
                        Tkeys: DType,
                        Tvalues: DType,
                        explicitT: type(oT)): LookupTableExport[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableExport(*#, #, #, #)", constructor.}

proc lookupTableExport*(scope: Scope,
                        table_handle: ostring,
                        Tkeys: type = oinvalid,
                        Tvalues: type oall = oinvalid): auto =
  return iilookupTableExport(scope,
                             table_handle,
                             Tkeys[].oTF,
                             Tvalues[].oTF,
                             Tkeys)

converter lookupTableExportToOut*[oT: oall](op: LookupTableExport[oT]): oT {.inline.} = return op.output


type QueueDequeue*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeue/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiqueueDequeue[oT: oall](scope: Scope,
                   handle: ostring,
                   component_types: ArraySlice[DType],
                   timeout_ms: int64,
                   explicitT: type(oT)): QueueDequeue[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeue(*#, #, #, #)", constructor.}

proc queueDequeue*(scope: Scope,
                   handle: ostring,
                   component_types: openArray[DType],
                   timeout_ms: int64 = -1.int,
                   explicitT: type): auto =
  return iiqueueDequeue(scope,
                        handle,
                        newArraySlice(component_types),
                        timeout_ms,
                        explicitT)

converter queueDequeueToOutList*[oT: oall](op: QueueDequeue[oT]): olist[oT] {.inline.} = return op.output

type TensorListSplitelement_dtype* = oall
type TensorListSplitshape_type* = oint32 | oint64

type TensorListSplit* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListSplit/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListSplit(scope: Scope,
                      tensor: TensorListSplitelement_dtype,
                      element_shape: TensorListSplitshape_type,
                      lengths: oint64): TensorListSplit {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListSplit(*#, #, #, #)", constructor.}

proc tensorListSplit*(scope: Scope,
                      tensor: TensorListSplitelement_dtype,
                      element_shape: TensorListSplitshape_type,
                      lengths: oint64): TensorListSplit =
  return iitensorListSplit(scope,
                           tensor,
                           element_shape,
                           lengths)

converter tensorListSplitToOut*(op: TensorListSplit): ovariant {.inline.} = return op.output


type BatchMatrixSolveLs*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixSolveLs/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixSolveLs[oT: oall](scope: Scope,
                         matrix: oT,
                         rhs: oT,
                         l2_regularizer: odouble,
                         T: DType,
                         fast: bool): BatchMatrixSolveLs[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixSolveLs(*#, #, #, #, #, #)", constructor.}

proc batchMatrixSolveLs*[oT: oall](scope: Scope,
                         matrix: oT,
                         rhs: oT,
                         l2_regularizer: odouble,
                         fast: bool = true): BatchMatrixSolveLs[oT] =
  return iibatchMatrixSolveLs(scope,
                              matrix,
                              rhs,
                              l2_regularizer,
                              oT[].oTF,
                              fast)

converter batchMatrixSolveLsToOut*[oT: oall](op: BatchMatrixSolveLs[oT]): oT {.inline.} = return op.output


type MatrixDeterminant*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixDeterminant/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixDeterminant[oT: oall](scope: Scope,
                        input: oT,
                        T: DType): MatrixDeterminant[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixDeterminant(*#, #, #)", constructor.}

proc matrixDeterminant*[oT: oall](scope: Scope,
                        input: oT): MatrixDeterminant[oT] =
  return iimatrixDeterminant(scope,
                             input,
                             oT[].oTF)

converter matrixDeterminantToOut*[oT: oall](op: MatrixDeterminant[oT]): oT {.inline.} = return op.output


type FloorMod*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FloorMod/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifloorMod[oT: oall](scope: Scope,
               x: oT,
               y: oT,
               T: DType): FloorMod[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FloorMod(*#, #, #, #)", constructor.}

proc floorMod*[oT: oall](scope: Scope,
               x: oT,
               y: oT): FloorMod[oT] =
  return iifloorMod(scope,
                    x,
                    y,
                    oT[].oTF)

converter floorModToOut*[oT: oall](op: FloorMod[oT]): oT {.inline.} = return op.output


type MatchingFiles* {.header:"../tensorflow/ops/generated.h", importcpp:"MatchingFiles/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iimatchingFiles(scope: Scope,
                    pattern: ostring): MatchingFiles {.header:"../tensorflow/ops/generated.h", importcpp:"MatchingFiles(*#, #)", constructor.}

proc matchingFiles*(scope: Scope,
                    pattern: ostring): MatchingFiles =
  return iimatchingFiles(scope,
                         pattern)

converter matchingFilesToOut*(op: MatchingFiles): ostring {.inline.} = return op.output

type WriteImageSummaryT* = ouint8 | ofloat | ohalf

type WriteImageSummary*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteImageSummary/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteImageSummary(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: WriteImageSummaryT,
                        bad_color: ouint8,
                        max_images: int64): WriteImageSummary {.header:"../tensorflow/ops/generated.h", importcpp:"WriteImageSummary(*#, #, #, #, #, #, #)", constructor.}

proc writeImageSummary*(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: WriteImageSummaryT,
                        bad_color: ouint8,
                        max_images: int64 = 3.int): WriteImageSummary =
  return iiwriteImageSummary(scope,
                             writer,
                             step,
                             tag,
                             tensor,
                             bad_color,
                             max_images)




type MatrixSolve*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSolve/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixSolve[oT: oall](scope: Scope,
                  matrix: oT,
                  rhs: oT,
                  adjoint: bool,
                  T: DType): MatrixSolve[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSolve(*#, #, #, #, #)", constructor.}

proc matrixSolve*[oT: oall](scope: Scope,
                  matrix: oT,
                  rhs: oT,
                  adjoint: bool = false): MatrixSolve[oT] =
  return iimatrixSolve(scope,
                       matrix,
                       rhs,
                       adjoint,
                       oT[].oTF)

converter matrixSolveToOut*[oT: oall](op: MatrixSolve[oT]): oT {.inline.} = return op.output


type TensorArrayConcatV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayConcatV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayConcatV2[oT: oall](scope: Scope,
                          handle: ostring,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape_except0: TensorShape,
                          explicitT: type(oT)): TensorArrayConcatV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayConcatV2(*#, #, #, #, #)", constructor.}

proc tensorArrayConcatV2*(scope: Scope,
                          handle: ostring,
                          flow_in: ofloat,
                          dtype: type = oinvalid,
                          element_shape_except0: TensorShape = [].shape): auto =
  return iitensorArrayConcatV2(scope,
                               handle,
                               flow_in,
                               dtype[].oTF,
                               element_shape_except0,
                               dtype)

converter tensorArrayConcatV2ToOut*[oT: oall](op: TensorArrayConcatV2[oT]): oT {.inline.} = return op.output


type WriteFile*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteFile/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteFile(scope: Scope,
                filename: ostring,
                contents: ostring): WriteFile {.header:"../tensorflow/ops/generated.h", importcpp:"WriteFile(*#, #, #)", constructor.}

proc writeFile*(scope: Scope,
                filename: ostring,
                contents: ostring): WriteFile =
  return iiwriteFile(scope,
                     filename,
                     contents)



type TruncatedNormalT* = oint32 | oint64

type TruncatedNormal*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TruncatedNormal/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitruncatedNormal[oT: oall](scope: Scope,
                      shape: TruncatedNormalT,
                      seed: int64,
                      seed2: int64,
                      dtype: DType,
                      explicitT: type(oT)): TruncatedNormal[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TruncatedNormal(*#, #, #, #, #)", constructor.}

proc truncatedNormal*(scope: Scope,
                      shape: TruncatedNormalT,
                      seed: int64 = 0.int,
                      seed2: int64 = 0.int,
                      dtype: type = oinvalid): auto =
  return iitruncatedNormal(scope,
                           shape,
                           seed,
                           seed2,
                           dtype[].oTF,
                           dtype)

converter truncatedNormalToOut*[oT: oall](op: TruncatedNormal[oT]): oT {.inline.} = return op.output


type ReadFile* {.header:"../tensorflow/ops/generated.h", importcpp:"ReadFile/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireadFile(scope: Scope,
               filename: ostring): ReadFile {.header:"../tensorflow/ops/generated.h", importcpp:"ReadFile(*#, #)", constructor.}

proc readFile*(scope: Scope,
               filename: ostring): ReadFile =
  return iireadFile(scope,
                    filename)

converter readFileToOut*(op: ReadFile): ostring {.inline.} = return op.output


type FakeQuantWithMinMaxVarsPerChannelGradient* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannelGradient/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iifakeQuantWithMinMaxVarsPerChannelGradient(scope: Scope,
                                                gradients: ofloat,
                                                inputs: ofloat,
                                                min: ofloat,
                                                max: ofloat,
                                                num_bits: int64,
                                                narrow_range: bool): FakeQuantWithMinMaxVarsPerChannelGradient {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannelGradient(*#, #, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVarsPerChannelGradient*(scope: Scope,
                                                gradients: ofloat,
                                                inputs: ofloat,
                                                min: ofloat,
                                                max: ofloat,
                                                num_bits: int64 = 8.int,
                                                narrow_range: bool = false): FakeQuantWithMinMaxVarsPerChannelGradient =
  return iifakeQuantWithMinMaxVarsPerChannelGradient(scope,
                                                     gradients,
                                                     inputs,
                                                     min,
                                                     max,
                                                     num_bits,
                                                     narrow_range)

converter fakeQuantWithMinMaxVarsPerChannelGradientToOut*(op: FakeQuantWithMinMaxVarsPerChannelGradient): ofloat {.inline.} = return op.output


type PrintV2*{.header:"../tensorflow/ops/generated.h", importcpp:"PrintV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiprintV2(scope: Scope,
              input: ostring,
              output_stream: cstring): PrintV2 {.header:"../tensorflow/ops/generated.h", importcpp:"PrintV2(*#, #, tensorflow::string(#))", constructor.}

proc printV2*(scope: Scope,
              input: ostring,
              output_stream: cstring = "stderr"): PrintV2 =
  return iiprintV2(scope,
                   input,
                   output_stream)




type ReaderResetV2*{.header:"../tensorflow/ops/generated.h", importcpp:"ReaderResetV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iireaderResetV2(scope: Scope,
                    reader_handle: oresource): ReaderResetV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderResetV2(*#, #)", constructor.}

proc readerResetV2*(scope: Scope,
                    reader_handle: oresource): ReaderResetV2 =
  return iireaderResetV2(scope,
                         reader_handle)




type ReaderSerializeState* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderSerializeState/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireaderSerializeState(scope: Scope,
                           reader_handle: ostring): ReaderSerializeState {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderSerializeState(*#, #)", constructor.}

proc readerSerializeState*(scope: Scope,
                           reader_handle: ostring): ReaderSerializeState =
  return iireaderSerializeState(scope,
                                reader_handle)

converter readerSerializeStateToOut*(op: ReaderSerializeState): ostring {.inline.} = return op.output


type ReaderNumWorkUnitsCompletedV2* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumWorkUnitsCompletedV2/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iireaderNumWorkUnitsCompletedV2(scope: Scope,
                                    reader_handle: oresource): ReaderNumWorkUnitsCompletedV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumWorkUnitsCompletedV2(*#, #)", constructor.}

proc readerNumWorkUnitsCompletedV2*(scope: Scope,
                                    reader_handle: oresource): ReaderNumWorkUnitsCompletedV2 =
  return iireaderNumWorkUnitsCompletedV2(scope,
                                         reader_handle)

converter readerNumWorkUnitsCompletedV2ToOut*(op: ReaderNumWorkUnitsCompletedV2): oint64 {.inline.} = return op.output

type LowerBoundT* = oall

type LowerBound*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LowerBound/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilowerBound[oT: oall](scope: Scope,
                 sorted_inputs: LowerBoundT,
                 values: LowerBoundT,
                 out_type: DType,
                 explicitT: type(oT)): LowerBound[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LowerBound(*#, #, #, #)", constructor.}

proc lowerBound*(scope: Scope,
                 sorted_inputs: LowerBoundT,
                 values: LowerBoundT,
                 out_type: type = oint32): auto =
  return iilowerBound(scope,
                      sorted_inputs,
                      values,
                      out_type[].oTF,
                      out_type)

converter lowerBoundToOut*[oT: oall](op: LowerBound[oT]): oT {.inline.} = return op.output

type GreaterT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Greater* {.header:"../tensorflow/ops/generated.h", importcpp:"Greater/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iigreater(scope: Scope,
              x: GreaterT,
              y: GreaterT): Greater {.header:"../tensorflow/ops/generated.h", importcpp:"Greater(*#, #, #)", constructor.}

proc greater*(scope: Scope,
              x: GreaterT,
              y: GreaterT): Greater =
  return iigreater(scope,
                   x,
                   y)

converter greaterToOut*(op: Greater): obool {.inline.} = return op.output


type ReaderNumWorkUnitsCompleted* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumWorkUnitsCompleted/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iireaderNumWorkUnitsCompleted(scope: Scope,
                                  reader_handle: ostring): ReaderNumWorkUnitsCompleted {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumWorkUnitsCompleted(*#, #)", constructor.}

proc readerNumWorkUnitsCompleted*(scope: Scope,
                                  reader_handle: ostring): ReaderNumWorkUnitsCompleted =
  return iireaderNumWorkUnitsCompleted(scope,
                                       reader_handle)

converter readerNumWorkUnitsCompletedToOut*(op: ReaderNumWorkUnitsCompleted): oint64 {.inline.} = return op.output


type DecodeRaw*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeRaw/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidecodeRaw[oT: oall](scope: Scope,
                bytes: ostring,
                out_type: DType,
                little_endian: bool,
                explicitT: type(oT)): DecodeRaw[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeRaw(*#, #, #, #)", constructor.}

proc decodeRaw*(scope: Scope,
                bytes: ostring,
                out_type: type = oinvalid,
                little_endian: bool = true): auto =
  return iidecodeRaw(scope,
                     bytes,
                     out_type[].oTF,
                     little_endian,
                     out_type)

converter decodeRawToOut*[oT: oall](op: DecodeRaw[oT]): oT {.inline.} = return op.output


type ReaderNumRecordsProducedV2* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumRecordsProducedV2/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iireaderNumRecordsProducedV2(scope: Scope,
                                 reader_handle: oresource): ReaderNumRecordsProducedV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumRecordsProducedV2(*#, #)", constructor.}

proc readerNumRecordsProducedV2*(scope: Scope,
                                 reader_handle: oresource): ReaderNumRecordsProducedV2 =
  return iireaderNumRecordsProducedV2(scope,
                                      reader_handle)

converter readerNumRecordsProducedV2ToOut*(op: ReaderNumRecordsProducedV2): oint64 {.inline.} = return op.output

type CumprodTidx* = oint32 | oint64

type Cumprod*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Cumprod/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicumprod[oT: oall](scope: Scope,
              x: oT,
              axis: CumprodTidx,
              exclusive: bool,
              reverse: bool,
              T: DType): Cumprod[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Cumprod(*#, #, #, #, #, #)", constructor.}

proc cumprod*[oT: oall](scope: Scope,
              x: oT,
              axis: CumprodTidx,
              exclusive: bool = false,
              reverse: bool = false): Cumprod[oT] =
  return iicumprod(scope,
                   x,
                   axis,
                   exclusive,
                   reverse,
                   oT[].oTF)

converter cumprodToOut*[oT: oall](op: Cumprod[oT]): oT {.inline.} = return op.output


type ReaderReadV2* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReadV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireaderReadV2(scope: Scope,
                   reader_handle: oresource,
                   queue_handle: oresource): ReaderReadV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReadV2(*#, #, #)", constructor.}

proc readerReadV2*(scope: Scope,
                   reader_handle: oresource,
                   queue_handle: oresource): ReaderReadV2 =
  return iireaderReadV2(scope,
                        reader_handle,
                        queue_handle)

converter readerReadV2ToOut*(op: ReaderReadV2): ostring {.inline.} = return op.output


type Square*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Square/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisquare[oT: oall](scope: Scope,
             x: oT,
             T: DType): Square[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Square(*#, #, #)", constructor.}

proc square*[oT: oall](scope: Scope,
             x: oT): Square[oT] =
  return iisquare(scope,
                  x,
                  oT[].oTF)

converter squareToOut*[oT: oall](op: Square[oT]): oT {.inline.} = return op.output


type IdentityReader* {.header:"../tensorflow/ops/generated.h", importcpp:"IdentityReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiidentityReader(scope: Scope,
                     container: cstring,
                     shared_name: cstring): IdentityReader {.header:"../tensorflow/ops/generated.h", importcpp:"IdentityReader(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc identityReader*(scope: Scope,
                     container: cstring,
                     shared_name: cstring): IdentityReader =
  return iiidentityReader(scope,
                          container,
                          shared_name)

converter identityReaderToOut*(op: IdentityReader): ostring {.inline.} = return op.output

type SliceIndex* = oint32 | oint64

type Slice*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Slice/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iislice[oT: oall](scope: Scope,
            input: oT,
            begin: SliceIndex,
            size: SliceIndex,
            T: DType): Slice[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Slice(*#, #, #, #, #)", constructor.}

proc slice*[oT: oall](scope: Scope,
            input: oT,
            begin: SliceIndex,
            size: SliceIndex): Slice[oT] =
  return iislice(scope,
                 input,
                 begin,
                 size,
                 oT[].oTF)

converter sliceToOut*[oT: oall](op: Slice[oT]): oT {.inline.} = return op.output


type LMDBReader* {.header:"../tensorflow/ops/generated.h", importcpp:"LMDBReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iilMDBReader(scope: Scope,
                 container: cstring,
                 shared_name: cstring): LMDBReader {.header:"../tensorflow/ops/generated.h", importcpp:"LMDBReader(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc lMDBReader*(scope: Scope,
                 container: cstring,
                 shared_name: cstring): LMDBReader =
  return iilMDBReader(scope,
                      container,
                      shared_name)

converter lMDBReaderToOut*(op: LMDBReader): ostring {.inline.} = return op.output


type TFRecordReaderV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TFRecordReaderV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iitFRecordReaderV2(scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       compression_type: cstring): TFRecordReaderV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TFRecordReaderV2(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc tFRecordReaderV2*(scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       compression_type: cstring): TFRecordReaderV2 =
  return iitFRecordReaderV2(scope,
                            container,
                            shared_name,
                            compression_type)

converter tFRecordReaderV2ToOut*(op: TFRecordReaderV2): oresource {.inline.} = return op.output


type TFRecordReader* {.header:"../tensorflow/ops/generated.h", importcpp:"TFRecordReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitFRecordReader(scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     compression_type: cstring): TFRecordReader {.header:"../tensorflow/ops/generated.h", importcpp:"TFRecordReader(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc tFRecordReader*(scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     compression_type: cstring): TFRecordReader =
  return iitFRecordReader(scope,
                          container,
                          shared_name,
                          compression_type)

converter tFRecordReaderToOut*(op: TFRecordReader): ostring {.inline.} = return op.output


type FixedLengthRecordReaderV2* {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordReaderV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iifixedLengthRecordReaderV2(scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                encoding: cstring,
                                header_bytes: int64,
                                record_bytes: int64,
                                footer_bytes: int64,
                                hop_bytes: int64): FixedLengthRecordReaderV2 {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordReaderV2(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc fixedLengthRecordReaderV2*(scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                encoding: cstring,
                                header_bytes: int64 = 0.int,
                                record_bytes: int64 = 0.int,
                                footer_bytes: int64 = 0.int,
                                hop_bytes: int64 = 0.int): FixedLengthRecordReaderV2 =
  return iifixedLengthRecordReaderV2(scope,
                                     container,
                                     shared_name,
                                     encoding,
                                     header_bytes,
                                     record_bytes,
                                     footer_bytes,
                                     hop_bytes)

converter fixedLengthRecordReaderV2ToOut*(op: FixedLengthRecordReaderV2): oresource {.inline.} = return op.output


type IdentityReaderV2* {.header:"../tensorflow/ops/generated.h", importcpp:"IdentityReaderV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiidentityReaderV2(scope: Scope,
                       container: cstring,
                       shared_name: cstring): IdentityReaderV2 {.header:"../tensorflow/ops/generated.h", importcpp:"IdentityReaderV2(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc identityReaderV2*(scope: Scope,
                       container: cstring,
                       shared_name: cstring): IdentityReaderV2 =
  return iiidentityReaderV2(scope,
                            container,
                            shared_name)

converter identityReaderV2ToOut*(op: IdentityReaderV2): oresource {.inline.} = return op.output


type TextLineReaderV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TextLineReaderV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iitextLineReaderV2(scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       skip_header_lines: int64): TextLineReaderV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TextLineReaderV2(*#, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc textLineReaderV2*(scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       skip_header_lines: int64 = 0.int): TextLineReaderV2 =
  return iitextLineReaderV2(scope,
                            container,
                            shared_name,
                            skip_header_lines)

converter textLineReaderV2ToOut*(op: TextLineReaderV2): oresource {.inline.} = return op.output


type ShardedFilename* {.header:"../tensorflow/ops/generated.h", importcpp:"ShardedFilename/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iishardedFilename(scope: Scope,
                      basename: ostring,
                      shard: oint32,
                      num_shards: oint32): ShardedFilename {.header:"../tensorflow/ops/generated.h", importcpp:"ShardedFilename(*#, #, #, #)", constructor.}

proc shardedFilename*(scope: Scope,
                      basename: ostring,
                      shard: oint32,
                      num_shards: oint32): ShardedFilename =
  return iishardedFilename(scope,
                           basename,
                           shard,
                           num_shards)

converter shardedFilenameToOut*(op: ShardedFilename): ostring {.inline.} = return op.output


type RestoreSlice*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RestoreSlice/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirestoreSlice[oT: oall](scope: Scope,
                   file_pattern: ostring,
                   tensor_name: ostring,
                   shape_and_slice: ostring,
                   dt: DType,
                   preferred_shard: int64,
                   explicitT: type(oT)): RestoreSlice[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RestoreSlice(*#, #, #, #, #, #)", constructor.}

proc restoreSlice*(scope: Scope,
                   file_pattern: ostring,
                   tensor_name: ostring,
                   shape_and_slice: ostring,
                   dt: type = oinvalid,
                   preferred_shard: int64 = -1.int): auto =
  return iirestoreSlice(scope,
                        file_pattern,
                        tensor_name,
                        shape_and_slice,
                        dt[].oTF,
                        preferred_shard,
                        dt)

converter restoreSliceToOut*[oT: oall](op: RestoreSlice[oT]): oT {.inline.} = return op.output


type Restore*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Restore/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirestore[oT: oall](scope: Scope,
              file_pattern: ostring,
              tensor_name: ostring,
              dt: DType,
              preferred_shard: int64,
              explicitT: type(oT)): Restore[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Restore(*#, #, #, #, #)", constructor.}

proc restore*(scope: Scope,
              file_pattern: ostring,
              tensor_name: ostring,
              dt: type = oinvalid,
              preferred_shard: int64 = -1.int): auto =
  return iirestore(scope,
                   file_pattern,
                   tensor_name,
                   dt[].oTF,
                   preferred_shard,
                   dt)

converter restoreToOut*[oT: oall](op: Restore[oT]): oT {.inline.} = return op.output


type SaveSlices*{.header:"../tensorflow/ops/generated.h", importcpp:"SaveSlices/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iisaveSlices(scope: Scope,
                 filename: ostring,
                 tensor_names: ostring,
                 shapes_and_slices: ostring,
                 data: olist[oall],
                 T: ArraySlice[DType]): SaveSlices {.header:"../tensorflow/ops/generated.h", importcpp:"SaveSlices(*#, #, #, #, #, #)", constructor.}

proc saveSlices*(scope: Scope,
                 filename: ostring,
                 tensor_names: ostring,
                 shapes_and_slices: ostring,
                 data: olist[oall],
                 T: openArray[DType]): SaveSlices =
  return iisaveSlices(scope,
                      filename,
                      tensor_names,
                      shapes_and_slices,
                      data,
                      newArraySlice(T))




type Save*{.header:"../tensorflow/ops/generated.h", importcpp:"Save/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iisave(scope: Scope,
           filename: ostring,
           tensor_names: ostring,
           data: olist[oall],
           T: ArraySlice[DType]): Save {.header:"../tensorflow/ops/generated.h", importcpp:"Save(*#, #, #, #, #)", constructor.}

proc save*(scope: Scope,
           filename: ostring,
           tensor_names: ostring,
           data: olist[oall],
           T: openArray[DType]): Save =
  return iisave(scope,
                filename,
                tensor_names,
                data,
                newArraySlice(T))




type MergeV2Checkpoints*{.header:"../tensorflow/ops/generated.h", importcpp:"MergeV2Checkpoints/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iimergeV2Checkpoints(scope: Scope,
                         checkpoint_prefixes: ostring,
                         destination_prefix: ostring,
                         delete_old_dirs: bool): MergeV2Checkpoints {.header:"../tensorflow/ops/generated.h", importcpp:"MergeV2Checkpoints(*#, #, #, #)", constructor.}

proc mergeV2Checkpoints*(scope: Scope,
                         checkpoint_prefixes: ostring,
                         destination_prefix: ostring,
                         delete_old_dirs: bool = true): MergeV2Checkpoints =
  return iimergeV2Checkpoints(scope,
                              checkpoint_prefixes,
                              destination_prefix,
                              delete_old_dirs)



type NonMaxSuppressionV2T* = ohalf | ofloat

type NonMaxSuppressionV2* {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionV2/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iinonMaxSuppressionV2(scope: Scope,
                          boxes: NonMaxSuppressionV2T,
                          scores: NonMaxSuppressionV2T,
                          max_output_size: oint32,
                          iou_threshold: ofloat): NonMaxSuppressionV2 {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionV2(*#, #, #, #, #)", constructor.}

proc nonMaxSuppressionV2*(scope: Scope,
                          boxes: NonMaxSuppressionV2T,
                          scores: NonMaxSuppressionV2T,
                          max_output_size: oint32,
                          iou_threshold: ofloat): NonMaxSuppressionV2 =
  return iinonMaxSuppressionV2(scope,
                               boxes,
                               scores,
                               max_output_size,
                               iou_threshold)

converter nonMaxSuppressionV2ToOut*(op: NonMaxSuppressionV2): oint32 {.inline.} = return op.output


type RefExit*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefExit/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefExit[oT: oall](scope: Scope,
              data: oT,
              T: DType): RefExit[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefExit(*#, #, #)", constructor.}

proc refExit*[oT: oall](scope: Scope,
              data: oT): RefExit[oT] =
  return iirefExit(scope,
                   data,
                   oT[].oTF)

converter refExitToOut*[oT: oall](op: RefExit[oT]): oT {.inline.} = return op.output

type NotEqualT* = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | oquint8 | oqint8 | oqint32 | ostring | obool | ocomplex128

type NotEqual* {.header:"../tensorflow/ops/generated.h", importcpp:"NotEqual/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iinotEqual(scope: Scope,
               x: NotEqualT,
               y: NotEqualT): NotEqual {.header:"../tensorflow/ops/generated.h", importcpp:"NotEqual(*#, #, #)", constructor.}

proc notEqual*(scope: Scope,
               x: NotEqualT,
               y: NotEqualT): NotEqual =
  return iinotEqual(scope,
                    x,
                    y)

converter notEqualToOut*(op: NotEqual): obool {.inline.} = return op.output

type LookupTableRemoveV2Tin* = oall

type LookupTableRemoveV2*{.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableRemoveV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iilookupTableRemoveV2(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableRemoveV2Tin): LookupTableRemoveV2 {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableRemoveV2(*#, #, #)", constructor.}

proc lookupTableRemoveV2*(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableRemoveV2Tin): LookupTableRemoveV2 =
  return iilookupTableRemoveV2(scope,
                               table_handle,
                               keys)




type NonMaxSuppression* {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppression/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iinonMaxSuppression(scope: Scope,
                        boxes: ofloat,
                        scores: ofloat,
                        max_output_size: oint32,
                        iou_threshold: float32): NonMaxSuppression {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppression(*#, #, #, #, #)", constructor.}

proc nonMaxSuppression*(scope: Scope,
                        boxes: ofloat,
                        scores: ofloat,
                        max_output_size: oint32,
                        iou_threshold: float32 = 0.5.float32): NonMaxSuppression =
  return iinonMaxSuppression(scope,
                             boxes,
                             scores,
                             max_output_size,
                             iou_threshold)

converter nonMaxSuppressionToOut*(op: NonMaxSuppression): oint32 {.inline.} = return op.output


type Tanh*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Tanh/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitanh[oT: oall](scope: Scope,
           x: oT,
           T: DType): Tanh[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Tanh(*#, #, #)", constructor.}

proc tanh*[oT: oall](scope: Scope,
           x: oT): Tanh[oT] =
  return iitanh(scope,
                x,
                oT[].oTF)

converter tanhToOut*[oT: oall](op: Tanh[oT]): oT {.inline.} = return op.output


type CropAndResizeGradImage*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CropAndResizeGradImage/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicropAndResizeGradImage[oT: oall](scope: Scope,
                             grads: ofloat,
                             boxes: ofloat,
                             box_ind: oint32,
                             image_size: oint32,
                             T: DType,
                             nmethod: cstring,
                             explicitT: type(oT)): CropAndResizeGradImage[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CropAndResizeGradImage(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc cropAndResizeGradImage*(scope: Scope,
                             grads: ofloat,
                             boxes: ofloat,
                             box_ind: oint32,
                             image_size: oint32,
                             T: type = oinvalid,
                             nmethod: cstring = "bilinear"): auto =
  return iicropAndResizeGradImage(scope,
                                  grads,
                                  boxes,
                                  box_ind,
                                  image_size,
                                  T[].oTF,
                                  nmethod,
                                  T)

converter cropAndResizeGradImageToOut*[oT: oall](op: CropAndResizeGradImage[oT]): oT {.inline.} = return op.output


type AdjustSaturation* {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustSaturation/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiadjustSaturation(scope: Scope,
                       images: ofloat,
                       scale: ofloat): AdjustSaturation {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustSaturation(*#, #, #)", constructor.}

proc adjustSaturation*(scope: Scope,
                       images: ofloat,
                       scale: ofloat): AdjustSaturation =
  return iiadjustSaturation(scope,
                            images,
                            scale)

converter adjustSaturationToOut*(op: AdjustSaturation): ofloat {.inline.} = return op.output


type ApplyPowerSign*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyPowerSign/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyPowerSign[oT: oall](scope: Scope,
                     nvar: oT,
                     m: oT,
                     lr: oT,
                     logbase: oT,
                     sign_decay: oT,
                     beta: oT,
                     grad: oT,
                     T: DType,
                     use_locking: bool): ApplyPowerSign[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyPowerSign(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyPowerSign*[oT: oall](scope: Scope,
                     nvar: oT,
                     m: oT,
                     lr: oT,
                     logbase: oT,
                     sign_decay: oT,
                     beta: oT,
                     grad: oT,
                     use_locking: bool = false): ApplyPowerSign[oT] =
  return iiapplyPowerSign(scope,
                          nvar,
                          m,
                          lr,
                          logbase,
                          sign_decay,
                          beta,
                          grad,
                          oT[].oTF,
                          use_locking)

converter applyPowerSignToOut*[oT: oall](op: ApplyPowerSign[oT]): oT {.inline.} = return op.output


type QuantizedAvgPool*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedAvgPool/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedAvgPool[oT: oall](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: ArraySlice[int],
                       strides: ArraySlice[int],
                       padding: cstring,
                       T: DType): QuantizedAvgPool[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedAvgPool(*#, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc quantizedAvgPool*[oT: oall](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: openArray[int],
                       strides: openArray[int],
                       padding: cstring): QuantizedAvgPool[oT] =
  return iiquantizedAvgPool(scope,
                            input,
                            min_input,
                            max_input,
                            newArraySlice(ksize),
                            newArraySlice(strides),
                            padding,
                            oT[].oTF)

converter quantizedAvgPoolToOut*[oT: oall](op: QuantizedAvgPool[oT]): oT {.inline.} = return op.output


type AdjustContrastv2* {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustContrastv2/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiadjustContrastv2(scope: Scope,
                       images: ofloat,
                       contrast_factor: ofloat): AdjustContrastv2 {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustContrastv2(*#, #, #)", constructor.}

proc adjustContrastv2*(scope: Scope,
                       images: ofloat,
                       contrast_factor: ofloat): AdjustContrastv2 =
  return iiadjustContrastv2(scope,
                            images,
                            contrast_factor)

converter adjustContrastv2ToOut*(op: AdjustContrastv2): ofloat {.inline.} = return op.output

type RankT* = oall

type Rank* {.header:"../tensorflow/ops/generated.h", importcpp:"Rank/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iirank(scope: Scope,
           input: RankT): Rank {.header:"../tensorflow/ops/generated.h", importcpp:"Rank(*#, #)", constructor.}

proc rank*(scope: Scope,
           input: RankT): Rank =
  return iirank(scope,
                input)

converter rankToOut*(op: Rank): oint32 {.inline.} = return op.output


type EncodeJpeg* {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeJpeg/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiencodeJpeg(scope: Scope,
                 image: ouint8,
                 format: cstring,
                 xmp_metadata: cstring,
                 quality: int64,
                 progressive: bool,
                 optimize_size: bool,
                 chroma_downsampling: bool,
                 density_unit: cstring,
                 x_density: int64,
                 y_density: int64): EncodeJpeg {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeJpeg(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc encodeJpeg*(scope: Scope,
                 image: ouint8,
                 format: cstring,
                 xmp_metadata: cstring,
                 quality: int64 = 95.int,
                 progressive: bool = false,
                 optimize_size: bool = false,
                 chroma_downsampling: bool = true,
                 density_unit: cstring = "in",
                 x_density: int64 = 300.int,
                 y_density: int64 = 300.int): EncodeJpeg =
  return iiencodeJpeg(scope,
                      image,
                      format,
                      xmp_metadata,
                      quality,
                      progressive,
                      optimize_size,
                      chroma_downsampling,
                      density_unit,
                      x_density,
                      y_density)

converter encodeJpegToOut*(op: EncodeJpeg): ostring {.inline.} = return op.output


type TensorArrayConcat*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayConcat/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayConcat[oT: oall](scope: Scope,
                        handle: ostring,
                        flow_in: ofloat,
                        dtype: DType,
                        element_shape_except0: TensorShape,
                        explicitT: type(oT)): TensorArrayConcat[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayConcat(*#, #, #, #, #)", constructor.}

proc tensorArrayConcat*(scope: Scope,
                        handle: ostring,
                        flow_in: ofloat,
                        dtype: type = oinvalid,
                        element_shape_except0: TensorShape = [].shape): auto =
  return iitensorArrayConcat(scope,
                             handle,
                             flow_in,
                             dtype[].oTF,
                             element_shape_except0,
                             dtype)

converter tensorArrayConcatToOut*[oT: oall](op: TensorArrayConcat[oT]): oT {.inline.} = return op.output


type DecodeAndCropJpeg* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeAndCropJpeg/*'0*/".} = object
  operation*: Operation[ouint8]
  output*: ouint8

proc iidecodeAndCropJpeg(scope: Scope,
                        contents: ostring,
                        crop_window: oint32,
                        dct_method: cstring,
                        channels: int64,
                        ratio: int64,
                        fancy_upscaling: bool,
                        try_recover_truncated: bool,
                        acceptable_fraction: float32): DecodeAndCropJpeg {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeAndCropJpeg(*#, #, #, tensorflow::string(#), #, #, #, #, #)", constructor.}

proc decodeAndCropJpeg*(scope: Scope,
                        contents: ostring,
                        crop_window: oint32,
                        dct_method: cstring,
                        channels: int64 = 0.int,
                        ratio: int64 = 1.int,
                        fancy_upscaling: bool = true,
                        try_recover_truncated: bool = false,
                        acceptable_fraction: float32 = 1.0.float32): DecodeAndCropJpeg =
  return iidecodeAndCropJpeg(scope,
                             contents,
                             crop_window,
                             dct_method,
                             channels,
                             ratio,
                             fancy_upscaling,
                             try_recover_truncated,
                             acceptable_fraction)

converter decodeAndCropJpegToOut*(op: DecodeAndCropJpeg): ouint8 {.inline.} = return op.output


type DecodeJpeg* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeJpeg/*'0*/".} = object
  operation*: Operation[ouint8]
  output*: ouint8

proc iidecodeJpeg(scope: Scope,
                 contents: ostring,
                 dct_method: cstring,
                 channels: int64,
                 ratio: int64,
                 fancy_upscaling: bool,
                 try_recover_truncated: bool,
                 acceptable_fraction: float32): DecodeJpeg {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeJpeg(*#, #, tensorflow::string(#), #, #, #, #, #)", constructor.}

proc decodeJpeg*(scope: Scope,
                 contents: ostring,
                 dct_method: cstring,
                 channels: int64 = 0.int,
                 ratio: int64 = 1.int,
                 fancy_upscaling: bool = true,
                 try_recover_truncated: bool = false,
                 acceptable_fraction: float32 = 1.0.float32): DecodeJpeg =
  return iidecodeJpeg(scope,
                      contents,
                      dct_method,
                      channels,
                      ratio,
                      fancy_upscaling,
                      try_recover_truncated,
                      acceptable_fraction)

converter decodeJpegToOut*(op: DecodeJpeg): ouint8 {.inline.} = return op.output


type RandomCrop*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomCrop/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomCrop[oT: oall](scope: Scope,
                 image: oT,
                 size: oint64,
                 T: DType,
                 seed: int64,
                 seed2: int64): RandomCrop[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomCrop(*#, #, #, #, #, #)", constructor.}

proc randomCrop*[oT: oall](scope: Scope,
                 image: oT,
                 size: oint64,
                 seed: int64 = 0.int,
                 seed2: int64 = 0.int): RandomCrop[oT] =
  return iirandomCrop(scope,
                      image,
                      size,
                      oT[].oTF,
                      seed,
                      seed2)

converter randomCropToOut*[oT: oall](op: RandomCrop[oT]): oT {.inline.} = return op.output


type BigQueryReader* {.header:"../tensorflow/ops/generated.h", importcpp:"BigQueryReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iibigQueryReader(scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     project_id: cstring,
                     dataset_id: cstring,
                     table_id: cstring,
                     columns: ArraySlice[cstring],
                     test_end_point: cstring,
                     timestamp_millis: int64): BigQueryReader {.header:"../tensorflow/ops/generated.h", importcpp:"BigQueryReader(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc bigQueryReader*(scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     project_id: cstring,
                     dataset_id: cstring,
                     table_id: cstring,
                     columns: openArray[cstring],
                     test_end_point: cstring,
                     timestamp_millis: int64 = 0.int): BigQueryReader =
  return iibigQueryReader(scope,
                          container,
                          shared_name,
                          project_id,
                          dataset_id,
                          table_id,
                          newArraySlice(columns),
                          test_end_point,
                          timestamp_millis)

converter bigQueryReaderToOut*(op: BigQueryReader): ostring {.inline.} = return op.output


type ResizeNearestNeighborGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeNearestNeighborGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiresizeNearestNeighborGrad[oT: oall](scope: Scope,
                                grads: oT,
                                size: oint32,
                                T: DType,
                                align_corners: bool): ResizeNearestNeighborGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeNearestNeighborGrad(*#, #, #, #, #)", constructor.}

proc resizeNearestNeighborGrad*[oT: oall](scope: Scope,
                                grads: oT,
                                size: oint32,
                                align_corners: bool = false): ResizeNearestNeighborGrad[oT] =
  return iiresizeNearestNeighborGrad(scope,
                                     grads,
                                     size,
                                     oT[].oTF,
                                     align_corners)

converter resizeNearestNeighborGradToOut*[oT: oall](op: ResizeNearestNeighborGrad[oT]): oT {.inline.} = return op.output


type LRN*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LRN/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilRN[oT: oall](scope: Scope,
          input: oT,
          depth_radius: int64,
          bias: float32,
          alpha: float32,
          beta: float32,
          T: DType): LRN[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LRN(*#, #, #, #, #, #, #)", constructor.}

proc lRN*[oT: oall](scope: Scope,
          input: oT,
          depth_radius: int64 = 5.int,
          bias: float32 = 1.0.float32,
          alpha: float32 = 1.0.float32,
          beta: float32 = 0.5.float32): LRN[oT] =
  return iilRN(scope,
               input,
               depth_radius,
               bias,
               alpha,
               beta,
               oT[].oTF)

converter lRNToOut*[oT: oall](op: LRN[oT]): oT {.inline.} = return op.output

type Conv3DBackpropInputV2Tshape* = oint32 | oint64

type Conv3DBackpropInputV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropInputV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv3DBackpropInputV2[oT: oall](scope: Scope,
                            input_sizes: Conv3DBackpropInputV2Tshape,
                            filter: oT,
                            out_backprop: oT,
                            strides: ArraySlice[int],
                            padding: cstring,
                            T: DType,
                            data_format: cstring,
                            dilations: ArraySlice[int]): Conv3DBackpropInputV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropInputV2(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc conv3DBackpropInputV2*[oT: oall](scope: Scope,
                            input_sizes: Conv3DBackpropInputV2Tshape,
                            filter: oT,
                            out_backprop: oT,
                            strides: openArray[int],
                            padding: cstring,
                            data_format: cstring = "NDHWC",
                            dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int, 1.int]): Conv3DBackpropInputV2[oT] =
  return iiconv3DBackpropInputV2(scope,
                                 input_sizes,
                                 filter,
                                 out_backprop,
                                 newArraySlice(strides),
                                 padding,
                                 oT[].oTF,
                                 data_format,
                                 newArraySlice(dilations))

converter conv3DBackpropInputV2ToOut*[oT: oall](op: Conv3DBackpropInputV2[oT]): oT {.inline.} = return op.output

type ResizeBilinearT* = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | obfloat16 | ohalf | ofloat | odouble

type ResizeBilinear* {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBilinear/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiresizeBilinear(scope: Scope,
                     images: ResizeBilinearT,
                     size: oint32,
                     align_corners: bool): ResizeBilinear {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBilinear(*#, #, #, #)", constructor.}

proc resizeBilinear*(scope: Scope,
                     images: ResizeBilinearT,
                     size: oint32,
                     align_corners: bool = false): ResizeBilinear =
  return iiresizeBilinear(scope,
                          images,
                          size,
                          align_corners)

converter resizeBilinearToOut*(op: ResizeBilinear): ofloat {.inline.} = return op.output

type AssignAddVariableOpdtype* = oall

type AssignAddVariableOp*{.header:"../tensorflow/ops/generated.h", importcpp:"AssignAddVariableOp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiassignAddVariableOp(scope: Scope,
                          resource: oresource,
                          value: AssignAddVariableOpdtype): AssignAddVariableOp {.header:"../tensorflow/ops/generated.h", importcpp:"AssignAddVariableOp(*#, #, #)", constructor.}

proc assignAddVariableOp*(scope: Scope,
                          resource: oresource,
                          value: AssignAddVariableOpdtype): AssignAddVariableOp =
  return iiassignAddVariableOp(scope,
                               resource,
                               value)




type DepthwiseConv2dNativeBackpropInput*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthwiseConv2dNativeBackpropInput/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidepthwiseConv2dNativeBackpropInput[oT: oall](scope: Scope,
                                         input_sizes: oint32,
                                         filter: oT,
                                         out_backprop: oT,
                                         strides: ArraySlice[int],
                                         padding: cstring,
                                         T: DType,
                                         data_format: cstring,
                                         dilations: ArraySlice[int]): DepthwiseConv2dNativeBackpropInput[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthwiseConv2dNativeBackpropInput(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc depthwiseConv2dNativeBackpropInput*[oT: oall](scope: Scope,
                                         input_sizes: oint32,
                                         filter: oT,
                                         out_backprop: oT,
                                         strides: openArray[int],
                                         padding: cstring,
                                         data_format: cstring = "NHWC",
                                         dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int]): DepthwiseConv2dNativeBackpropInput[oT] =
  return iidepthwiseConv2dNativeBackpropInput(scope,
                                              input_sizes,
                                              filter,
                                              out_backprop,
                                              newArraySlice(strides),
                                              padding,
                                              oT[].oTF,
                                              data_format,
                                              newArraySlice(dilations))

converter depthwiseConv2dNativeBackpropInputToOut*[oT: oall](op: DepthwiseConv2dNativeBackpropInput[oT]): oT {.inline.} = return op.output

type IsNanT* = obfloat16 | ohalf | ofloat | odouble

type IsNan* {.header:"../tensorflow/ops/generated.h", importcpp:"IsNan/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiisNan(scope: Scope,
            x: IsNanT): IsNan {.header:"../tensorflow/ops/generated.h", importcpp:"IsNan(*#, #)", constructor.}

proc isNan*(scope: Scope,
            x: IsNanT): IsNan =
  return iiisNan(scope,
                 x)

converter isNanToOut*(op: IsNan): obool {.inline.} = return op.output

type TensorListPushBackelement_dtype* = oall

type TensorListPushBack* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListPushBack/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListPushBack(scope: Scope,
                         input_handle: ovariant,
                         tensor: TensorListPushBackelement_dtype): TensorListPushBack {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListPushBack(*#, #, #)", constructor.}

proc tensorListPushBack*(scope: Scope,
                         input_handle: ovariant,
                         tensor: TensorListPushBackelement_dtype): TensorListPushBack =
  return iitensorListPushBack(scope,
                              input_handle,
                              tensor)

converter tensorListPushBackToOut*(op: TensorListPushBack): ovariant {.inline.} = return op.output

type SparseApplyMomentumTindices* = oint32 | oint64

type SparseApplyMomentum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyMomentum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyMomentum[oT: oall](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          lr: oT,
                          grad: oT,
                          indices: SparseApplyMomentumTindices,
                          momentum: oT,
                          T: DType,
                          use_nesterov: bool,
                          use_locking: bool): SparseApplyMomentum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyMomentum(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyMomentum*[oT: oall](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          lr: oT,
                          grad: oT,
                          indices: SparseApplyMomentumTindices,
                          momentum: oT,
                          use_nesterov: bool = false,
                          use_locking: bool = false): SparseApplyMomentum[oT] =
  return iisparseApplyMomentum(scope,
                               nvar,
                               accum,
                               lr,
                               grad,
                               indices,
                               momentum,
                               oT[].oTF,
                               use_nesterov,
                               use_locking)

converter sparseApplyMomentumToOut*[oT: oall](op: SparseApplyMomentum[oT]): oT {.inline.} = return op.output


type UniqueWithCounts*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UniqueWithCounts/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiuniqueWithCounts[oT: oall](scope: Scope,
                       x: oT,
                       T: DType,
                       out_idx: DType): UniqueWithCounts[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UniqueWithCounts(*#, #, #, #)", constructor.}

proc uniqueWithCounts*[oT: oall](scope: Scope,
                       x: oT,
                       out_idx: type(oint32) | type(oint64) = oint32): UniqueWithCounts[oT] =
  return iiuniqueWithCounts(scope,
                            x,
                            oT[].oTF,
                            oT[].oTF)

converter uniqueWithCountsToOut*[oT: oall](op: UniqueWithCounts[oT]): oT {.inline.} = return op.output


type ResizeBicubicGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBicubicGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiresizeBicubicGrad[oT: oall](scope: Scope,
                        grads: ofloat,
                        original_image: oT,
                        T: DType,
                        align_corners: bool): ResizeBicubicGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBicubicGrad(*#, #, #, #, #)", constructor.}

proc resizeBicubicGrad*[oT: oall](scope: Scope,
                        grads: ofloat,
                        original_image: oT,
                        align_corners: bool = false): ResizeBicubicGrad[oT] =
  return iiresizeBicubicGrad(scope,
                             grads,
                             original_image,
                             oT[].oTF,
                             align_corners)

converter resizeBicubicGradToOut*[oT: oall](op: ResizeBicubicGrad[oT]): oT {.inline.} = return op.output


type HSVToRGB*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"HSVToRGB/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iihSVToRGB[oT: oall](scope: Scope,
               images: oT,
               T: DType): HSVToRGB[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"HSVToRGB(*#, #, #)", constructor.}

proc hSVToRGB*[oT: oall](scope: Scope,
               images: oT): HSVToRGB[oT] =
  return iihSVToRGB(scope,
                    images,
                    oT[].oTF)

converter hSVToRGBToOut*[oT: oall](op: HSVToRGB[oT]): oT {.inline.} = return op.output

type SparseSegmentMeanWithNumSegmentsTidx* = oint32 | oint64
type SparseSegmentMeanWithNumSegmentsTnumsegments* = oint32 | oint64

type SparseSegmentMeanWithNumSegments*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentMeanWithNumSegments/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentMeanWithNumSegments[oT: oall](scope: Scope,
                                       data: oT,
                                       indices: SparseSegmentMeanWithNumSegmentsTidx,
                                       segment_ids: oint32,
                                       num_segments: SparseSegmentMeanWithNumSegmentsTnumsegments,
                                       T: DType): SparseSegmentMeanWithNumSegments[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentMeanWithNumSegments(*#, #, #, #, #, #)", constructor.}

proc sparseSegmentMeanWithNumSegments*[oT: oall](scope: Scope,
                                       data: oT,
                                       indices: SparseSegmentMeanWithNumSegmentsTidx,
                                       segment_ids: oint32,
                                       num_segments: SparseSegmentMeanWithNumSegmentsTnumsegments): SparseSegmentMeanWithNumSegments[oT] =
  return iisparseSegmentMeanWithNumSegments(scope,
                                            data,
                                            indices,
                                            segment_ids,
                                            num_segments,
                                            oT[].oTF)

converter sparseSegmentMeanWithNumSegmentsToOut*[oT: oall](op: SparseSegmentMeanWithNumSegments[oT]): oT {.inline.} = return op.output

type ResizeBicubicT* = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | ohalf | ofloat | odouble

type ResizeBicubic* {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBicubic/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiresizeBicubic(scope: Scope,
                    images: ResizeBicubicT,
                    size: oint32,
                    align_corners: bool): ResizeBicubic {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeBicubic(*#, #, #, #)", constructor.}

proc resizeBicubic*(scope: Scope,
                    images: ResizeBicubicT,
                    size: oint32,
                    align_corners: bool = false): ResizeBicubic =
  return iiresizeBicubic(scope,
                         images,
                         size,
                         align_corners)

converter resizeBicubicToOut*(op: ResizeBicubic): ofloat {.inline.} = return op.output


type ReaderRestoreState*{.header:"../tensorflow/ops/generated.h", importcpp:"ReaderRestoreState/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iireaderRestoreState(scope: Scope,
                         reader_handle: ostring,
                         state: ostring): ReaderRestoreState {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderRestoreState(*#, #, #)", constructor.}

proc readerRestoreState*(scope: Scope,
                         reader_handle: ostring,
                         state: ostring): ReaderRestoreState =
  return iireaderRestoreState(scope,
                              reader_handle,
                              state)



type ResizeAreaT* = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | ohalf | ofloat | odouble

type ResizeArea* {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeArea/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiresizeArea(scope: Scope,
                 images: ResizeAreaT,
                 size: oint32,
                 align_corners: bool): ResizeArea {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeArea(*#, #, #, #)", constructor.}

proc resizeArea*(scope: Scope,
                 images: ResizeAreaT,
                 size: oint32,
                 align_corners: bool = false): ResizeArea =
  return iiresizeArea(scope,
                      images,
                      size,
                      align_corners)

converter resizeAreaToOut*(op: ResizeArea): ofloat {.inline.} = return op.output

type ScatterMinTindices* = oint32 | oint64

type ScatterMin*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterMin/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterMin[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterMinTindices,
                 updates: oT,
                 T: DType,
                 use_locking: bool): ScatterMin[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterMin(*#, #, #, #, #, #)", constructor.}

proc scatterMin*[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterMinTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterMin[oT] =
  return iiscatterMin(scope,
                      nref,
                      indices,
                      updates,
                      oT[].oTF,
                      use_locking)

converter scatterMinToOut*[oT: oall](op: ScatterMin[oT]): oT {.inline.} = return op.output


type FakeParam*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FakeParam/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifakeParam[oT: oall](scope: Scope,
                dtype: DType,
                shape: TensorShape,
                explicitT: type(oT)): FakeParam[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FakeParam(*#, #, #)", constructor.}

proc fakeParam*(scope: Scope,
                dtype: type = oinvalid,
                shape: TensorShape = [].shape): auto =
  return iifakeParam(scope,
                     dtype[].oTF,
                     shape,
                     dtype)

converter fakeParamToOut*[oT: oall](op: FakeParam[oT]): oT {.inline.} = return op.output


type Pow*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Pow/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iipow[oT: oall](scope: Scope,
          x: oT,
          y: oT,
          T: DType): Pow[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Pow(*#, #, #, #)", constructor.}

proc pow*[oT: oall](scope: Scope,
          x: oT,
          y: oT): Pow[oT] =
  return iipow(scope,
               x,
               y,
               oT[].oTF)

converter powToOut*[oT: oall](op: Pow[oT]): oT {.inline.} = return op.output


type PartitionedCall*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PartitionedCall/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iipartitionedCall[oT: oall](scope: Scope,
                      args: olist[oall],
                      Tin: ArraySlice[DType],
                      Tout: ArraySlice[DType],
                      f: NameAttrList,
                      config: cstring,
                      config_proto: cstring,
                      executor_type: cstring,
                      explicitT: type(oT)): PartitionedCall[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PartitionedCall(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc partitionedCall*(scope: Scope,
                      args: olist[oall],
                      Tin: openArray[DType],
                      Tout: openArray[DType],
                      f: NameAttrList,
                      config: cstring,
                      config_proto: cstring,
                      executor_type: cstring,
                      explicitT: type): auto =
  return iipartitionedCall(scope,
                           args,
                           newArraySlice(Tin),
                           newArraySlice(Tout),
                           f,
                           config,
                           config_proto,
                           executor_type,
                           explicitT)

converter partitionedCallToOutList*[oT: oall](op: PartitionedCall[oT]): olist[oT] {.inline.} = return op.output


type Sign*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sign/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisign[oT: oall](scope: Scope,
           x: oT,
           T: DType): Sign[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sign(*#, #, #)", constructor.}

proc sign*[oT: oall](scope: Scope,
           x: oT): Sign[oT] =
  return iisign(scope,
                x,
                oT[].oTF)

converter signToOut*[oT: oall](op: Sign[oT]): oT {.inline.} = return op.output


type While*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"While/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iinwhile[oT: oall](scope: Scope,
             input: olist[oT],
             T: ArraySlice[DType],
             cond: NameAttrList,
             body: NameAttrList,
             output_shapes: ArraySlice[TensorShape]): While[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"While(*#, #, #, #, #, #)", constructor.}

proc nwhile*[oT: oall](scope: Scope,
             input: olist[oT],
             T: openArray[DType],
             cond: NameAttrList,
             body: NameAttrList,
             output_shapes: openArray[TensorShape]): While[oT] =
  return iinwhile(scope,
                  input,
                  newArraySlice(T),
                  cond,
                  body,
                  newArraySlice(output_shapes))

converter nwhileToOutList*[oT: oall](op: While[oT]): olist[oT] {.inline.} = return op.output


type Log*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Log/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilog[oT: oall](scope: Scope,
          x: oT,
          T: DType): Log[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Log(*#, #, #)", constructor.}

proc log*[oT: oall](scope: Scope,
          x: oT): Log[oT] =
  return iilog(scope,
               x,
               oT[].oTF)

converter logToOut*[oT: oall](op: Log[oT]): oT {.inline.} = return op.output


type IWhile*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_While/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiWhile[oT: oall](scope: Scope,
             input: olist[oT],
             T: ArraySlice[DType],
             cond: NameAttrList,
             body: NameAttrList): IWhile[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_While(*#, #, #, #, #)", constructor.}

proc iWhile*[oT: oall](scope: Scope,
             input: olist[oT],
             T: openArray[DType],
             cond: NameAttrList,
             body: NameAttrList): IWhile[oT] =
  return iiiWhile(scope,
                  input,
                  newArraySlice(T),
                  cond,
                  body)

converter iWhileToOutList*[oT: oall](op: IWhile[oT]): olist[oT] {.inline.} = return op.output

type AddManySparseToTensorsMapT* = oall

type AddManySparseToTensorsMap* {.header:"../tensorflow/ops/generated.h", importcpp:"AddManySparseToTensorsMap/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiaddManySparseToTensorsMap(scope: Scope,
                                sparse_indices: oint64,
                                sparse_values: AddManySparseToTensorsMapT,
                                sparse_shape: oint64,
                                container: cstring,
                                shared_name: cstring): AddManySparseToTensorsMap {.header:"../tensorflow/ops/generated.h", importcpp:"AddManySparseToTensorsMap(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc addManySparseToTensorsMap*(scope: Scope,
                                sparse_indices: oint64,
                                sparse_values: AddManySparseToTensorsMapT,
                                sparse_shape: oint64,
                                container: cstring,
                                shared_name: cstring): AddManySparseToTensorsMap =
  return iiaddManySparseToTensorsMap(scope,
                                     sparse_indices,
                                     sparse_values,
                                     sparse_shape,
                                     container,
                                     shared_name)

converter addManySparseToTensorsMapToOut*(op: AddManySparseToTensorsMap): oint64 {.inline.} = return op.output


type FlatMapDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"FlatMapDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiflatMapDataset(scope: Scope,
                     input_dataset: ovariant,
                     other_arguments: olist[oall],
                     f: NameAttrList,
                     Targuments: ArraySlice[DType],
                     output_types: ArraySlice[DType],
                     output_shapes: ArraySlice[TensorShape]): FlatMapDataset {.header:"../tensorflow/ops/generated.h", importcpp:"FlatMapDataset(*#, #, #, #, #, #, #)", constructor.}

proc flatMapDataset*(scope: Scope,
                     input_dataset: ovariant,
                     other_arguments: olist[oall],
                     f: NameAttrList,
                     Targuments: openArray[DType],
                     output_types: openArray[DType],
                     output_shapes: openArray[TensorShape]): FlatMapDataset =
  return iiflatMapDataset(scope,
                          input_dataset,
                          other_arguments,
                          f,
                          newArraySlice(Targuments),
                          newArraySlice(output_types),
                          newArraySlice(output_shapes))

converter flatMapDatasetToOut*(op: FlatMapDataset): ovariant {.inline.} = return op.output

type StatelessIfTcond* = oall

type StatelessIf*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessIf/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iistatelessIf[oT: oall](scope: Scope,
                  cond: StatelessIfTcond,
                  input: olist[oall],
                  Tin: ArraySlice[DType],
                  Tout: ArraySlice[DType],
                  then_branch: NameAttrList,
                  else_branch: NameAttrList,
                  explicitT: type(oT)): StatelessIf[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessIf(*#, #, #, #, #, #, #)", constructor.}

proc statelessIf*(scope: Scope,
                  cond: StatelessIfTcond,
                  input: olist[oall],
                  Tin: openArray[DType],
                  Tout: openArray[DType],
                  then_branch: NameAttrList,
                  else_branch: NameAttrList,
                  explicitT: type): auto =
  return iistatelessIf(scope,
                       cond,
                       input,
                       newArraySlice(Tin),
                       newArraySlice(Tout),
                       then_branch,
                       else_branch,
                       explicitT)

converter statelessIfToOutList*[oT: oall](op: StatelessIf[oT]): olist[oT] {.inline.} = return op.output

type AngleT* = ocomplex64 | ocomplex128

type Angle*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Angle/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiangle[oT: oall](scope: Scope,
            input: AngleT,
            Tout: DType,
            explicitT: type(oT)): Angle[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Angle(*#, #, #)", constructor.}

proc angle*(scope: Scope,
            input: AngleT,
            Tout: type = ofloat): auto =
  return iiangle(scope,
                 input,
                 Tout[].oTF,
                 Tout)

converter angleToOut*[oT: oall](op: Angle[oT]): oT {.inline.} = return op.output


type RemoteCall*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RemoteCall/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiremoteCall[oT: oall](scope: Scope,
                 target: ostring,
                 args: olist[oall],
                 Tin: ArraySlice[DType],
                 Tout: ArraySlice[DType],
                 f: NameAttrList,
                 explicitT: type(oT)): RemoteCall[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RemoteCall(*#, #, #, #, #, #)", constructor.}

proc remoteCall*(scope: Scope,
                 target: ostring,
                 args: olist[oall],
                 Tin: openArray[DType],
                 Tout: openArray[DType],
                 f: NameAttrList,
                 explicitT: type): auto =
  return iiremoteCall(scope,
                      target,
                      args,
                      newArraySlice(Tin),
                      newArraySlice(Tout),
                      f,
                      explicitT)

converter remoteCallToOutList*[oT: oall](op: RemoteCall[oT]): olist[oT] {.inline.} = return op.output


type ExperimentalMapAndBatchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMapAndBatchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalMapAndBatchDataset(scope: Scope,
                                     input_dataset: ovariant,
                                     other_arguments: olist[oall],
                                     batch_size: oint64,
                                     num_parallel_calls: oint64,
                                     drop_remainder: obool,
                                     f: NameAttrList,
                                     Targuments: ArraySlice[DType],
                                     output_types: ArraySlice[DType],
                                     output_shapes: ArraySlice[TensorShape],
                                     preserve_cardinality: bool): ExperimentalMapAndBatchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMapAndBatchDataset(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalMapAndBatchDataset*(scope: Scope,
                                     input_dataset: ovariant,
                                     other_arguments: olist[oall],
                                     batch_size: oint64,
                                     num_parallel_calls: oint64,
                                     drop_remainder: obool,
                                     f: NameAttrList,
                                     Targuments: openArray[DType],
                                     output_types: openArray[DType],
                                     output_shapes: openArray[TensorShape],
                                     preserve_cardinality: bool = false): ExperimentalMapAndBatchDataset =
  return iiexperimentalMapAndBatchDataset(scope,
                                          input_dataset,
                                          other_arguments,
                                          batch_size,
                                          num_parallel_calls,
                                          drop_remainder,
                                          f,
                                          newArraySlice(Targuments),
                                          newArraySlice(output_types),
                                          newArraySlice(output_shapes),
                                          preserve_cardinality)

converter experimentalMapAndBatchDatasetToOut*(op: ExperimentalMapAndBatchDataset): ovariant {.inline.} = return op.output


type SymbolicGradient*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SymbolicGradient/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iisymbolicGradient[oT: oall](scope: Scope,
                       input: olist[oall],
                       Tin: ArraySlice[DType],
                       Tout: ArraySlice[DType],
                       f: NameAttrList,
                       explicitT: type(oT)): SymbolicGradient[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SymbolicGradient(*#, #, #, #, #)", constructor.}

proc symbolicGradient*(scope: Scope,
                       input: olist[oall],
                       Tin: openArray[DType],
                       Tout: openArray[DType],
                       f: NameAttrList,
                       explicitT: type): auto =
  return iisymbolicGradient(scope,
                            input,
                            newArraySlice(Tin),
                            newArraySlice(Tout),
                            f,
                            explicitT)

converter symbolicGradientToOutList*[oT: oall](op: SymbolicGradient[oT]): olist[oT] {.inline.} = return op.output

type IArrayToListT* = oall

type IArrayToList*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ArrayToList/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiArrayToList[oT: oall](scope: Scope,
                   input: olist[IArrayToListT],
                   out_types: ArraySlice[DType],
                   explicitT: type(oT)): IArrayToList[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ArrayToList(*#, #, #)", constructor.}

proc iArrayToList*(scope: Scope,
                   input: olist[IArrayToListT],
                   out_types: openArray[DType],
                   explicitT: type): auto =
  return iiiArrayToList(scope,
                        input,
                        newArraySlice(out_types),
                        explicitT)

converter iArrayToListToOutList*[oT: oall](op: IArrayToList[oT]): olist[oT] {.inline.} = return op.output


type IListToArray*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ListToArray/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiListToArray[oT: oall](scope: Scope,
                   input: olist[oall],
                   Tin: ArraySlice[DType],
                   T: DType,
                   explicitT: type(oT)): IListToArray[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ListToArray(*#, #, #, #)", constructor.}

proc iListToArray*(scope: Scope,
                   input: olist[oall],
                   Tin: openArray[DType],
                   T: type = oinvalid): auto =
  return iiiListToArray(scope,
                        input,
                        newArraySlice(Tin),
                        T[].oTF,
                        T)

converter iListToArrayToOutList*[oT: oall](op: IListToArray[oT]): olist[oT] {.inline.} = return op.output


type IArg*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_Arg/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiArg[oT: oall](scope: Scope,
           T: DType,
           index: int64,
           explicitT: type(oT)): IArg[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_Arg(*#, #, #)", constructor.}

proc iArg*(scope: Scope,
           T: type = oinvalid,
           index: int64 = 0.int): auto =
  return iiiArg(scope,
                T[].oTF,
                index,
                T)

converter iArgToOut*[oT: oall](op: IArg[oT]): oT {.inline.} = return op.output


type ReaderRead* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderRead/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireaderRead(scope: Scope,
                 reader_handle: ostring,
                 queue_handle: ostring): ReaderRead {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderRead(*#, #, #)", constructor.}

proc readerRead*(scope: Scope,
                 reader_handle: ostring,
                 queue_handle: ostring): ReaderRead =
  return iireaderRead(scope,
                      reader_handle,
                      queue_handle)

converter readerReadToOut*(op: ReaderRead): ostring {.inline.} = return op.output

type MirrorPadTpaddings* = oint32 | oint64

type MirrorPad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MirrorPad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimirrorPad[oT: oall](scope: Scope,
                input: oT,
                paddings: MirrorPadTpaddings,
                mode: cstring,
                T: DType): MirrorPad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MirrorPad(*#, #, #, tensorflow::string(#), #)", constructor.}

proc mirrorPad*[oT: oall](scope: Scope,
                input: oT,
                paddings: MirrorPadTpaddings,
                mode: cstring): MirrorPad[oT] =
  return iimirrorPad(scope,
                     input,
                     paddings,
                     mode,
                     oT[].oTF)

converter mirrorPadToOut*[oT: oall](op: MirrorPad[oT]): oT {.inline.} = return op.output


type TensorArrayV3* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayV3/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iitensorArrayV3(scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: DType,
                    element_shape: TensorShape,
                    dynamic_size: bool,
                    clear_after_read: bool,
                    identical_element_shapes: bool): TensorArrayV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayV3(*#, #, tensorflow::string(#), #, #, #, #, #)", constructor.}

proc tensorArrayV3*(scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: type oall = oinvalid,
                    element_shape: TensorShape = [].shape,
                    dynamic_size: bool = false,
                    clear_after_read: bool = true,
                    identical_element_shapes: bool = false): TensorArrayV3 =
  return iitensorArrayV3(scope,
                         size,
                         tensor_array_name,
                         oT[].oTF,
                         element_shape,
                         dynamic_size,
                         clear_after_read,
                         identical_element_shapes)

converter tensorArrayV3ToOut*(op: TensorArrayV3): oresource {.inline.} = return op.output


type MatrixSolveLs*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSolveLs/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixSolveLs[oT: oall](scope: Scope,
                    matrix: oT,
                    rhs: oT,
                    l2_regularizer: odouble,
                    T: DType,
                    fast: bool): MatrixSolveLs[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSolveLs(*#, #, #, #, #, #)", constructor.}

proc matrixSolveLs*[oT: oall](scope: Scope,
                    matrix: oT,
                    rhs: oT,
                    l2_regularizer: odouble,
                    fast: bool = true): MatrixSolveLs[oT] =
  return iimatrixSolveLs(scope,
                         matrix,
                         rhs,
                         l2_regularizer,
                         oT[].oTF,
                         fast)

converter matrixSolveLsToOut*[oT: oall](op: MatrixSolveLs[oT]): oT {.inline.} = return op.output


type ExperimentalIdentityIndexedDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIdentityIndexedDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalIdentityIndexedDataset(scope: Scope,
                                         size: ouint64): ExperimentalIdentityIndexedDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIdentityIndexedDataset(*#, #)", constructor.}

proc experimentalIdentityIndexedDataset*(scope: Scope,
                                         size: ouint64): ExperimentalIdentityIndexedDataset =
  return iiexperimentalIdentityIndexedDataset(scope,
                                              size)

converter experimentalIdentityIndexedDatasetToOut*(op: ExperimentalIdentityIndexedDataset): ovariant {.inline.} = return op.output


type Sinh*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sinh/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisinh[oT: oall](scope: Scope,
           x: oT,
           T: DType): Sinh[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sinh(*#, #, #)", constructor.}

proc sinh*[oT: oall](scope: Scope,
           x: oT): Sinh[oT] =
  return iisinh(scope,
                x,
                oT[].oTF)

converter sinhToOut*[oT: oall](op: Sinh[oT]): oT {.inline.} = return op.output


type ExperimentalAssertNextDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalAssertNextDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalAssertNextDataset(scope: Scope,
                                    input_dataset: ovariant,
                                    transformations: ostring,
                                    output_types: ArraySlice[DType],
                                    output_shapes: ArraySlice[TensorShape]): ExperimentalAssertNextDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalAssertNextDataset(*#, #, #, #, #)", constructor.}

proc experimentalAssertNextDataset*(scope: Scope,
                                    input_dataset: ovariant,
                                    transformations: ostring,
                                    output_types: openArray[DType],
                                    output_shapes: openArray[TensorShape]): ExperimentalAssertNextDataset =
  return iiexperimentalAssertNextDataset(scope,
                                         input_dataset,
                                         transformations,
                                         newArraySlice(output_types),
                                         newArraySlice(output_shapes))

converter experimentalAssertNextDatasetToOut*(op: ExperimentalAssertNextDataset): ovariant {.inline.} = return op.output

type SparseReduceSumSparseT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseReduceSumSparse* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceSumSparse/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseReduceSumSparse(scope: Scope,
                            input_indices: oint64,
                            input_values: SparseReduceSumSparseT,
                            input_shape: oint64,
                            reduction_axes: oint32,
                            keep_dims: bool): SparseReduceSumSparse {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceSumSparse(*#, #, #, #, #, #)", constructor.}

proc sparseReduceSumSparse*(scope: Scope,
                            input_indices: oint64,
                            input_values: SparseReduceSumSparseT,
                            input_shape: oint64,
                            reduction_axes: oint32,
                            keep_dims: bool = false): SparseReduceSumSparse =
  return iisparseReduceSumSparse(scope,
                                 input_indices,
                                 input_values,
                                 input_shape,
                                 reduction_axes,
                                 keep_dims)

converter sparseReduceSumSparseToOut*(op: SparseReduceSumSparse): oint64 {.inline.} = return op.output


type Relu*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Relu/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirelu[oT: oall](scope: Scope,
           features: oT,
           T: DType): Relu[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Relu(*#, #, #)", constructor.}

proc relu*[oT: oall](scope: Scope,
           features: oT): Relu[oT] =
  return iirelu(scope,
                features,
                oT[].oTF)

converter reluToOut*[oT: oall](op: Relu[oT]): oT {.inline.} = return op.output


type MatMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatMul[oT: oall](scope: Scope,
             a: oT,
             b: oT,
             transpose_a: bool,
             transpose_b: bool,
             T: DType): MatMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatMul(*#, #, #, #, #, #)", constructor.}

proc matMul*[oT: oall](scope: Scope,
             a: oT,
             b: oT,
             transpose_a: bool = false,
             transpose_b: bool = false): MatMul[oT] =
  return iimatMul(scope,
                  a,
                  b,
                  transpose_a,
                  transpose_b,
                  oT[].oTF)

converter matMulToOut*[oT: oall](op: MatMul[oT]): oT {.inline.} = return op.output


type ExperimentalThreadPoolDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalThreadPoolDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalThreadPoolDataset(scope: Scope,
                                    input_dataset: ovariant,
                                    thread_pool: oresource,
                                    output_types: ArraySlice[DType],
                                    output_shapes: ArraySlice[TensorShape]): ExperimentalThreadPoolDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalThreadPoolDataset(*#, #, #, #, #)", constructor.}

proc experimentalThreadPoolDataset*(scope: Scope,
                                    input_dataset: ovariant,
                                    thread_pool: oresource,
                                    output_types: openArray[DType],
                                    output_shapes: openArray[TensorShape]): ExperimentalThreadPoolDataset =
  return iiexperimentalThreadPoolDataset(scope,
                                         input_dataset,
                                         thread_pool,
                                         newArraySlice(output_types),
                                         newArraySlice(output_shapes))

converter experimentalThreadPoolDatasetToOut*(op: ExperimentalThreadPoolDataset): ovariant {.inline.} = return op.output


type SoftplusGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SoftplusGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisoftplusGrad[oT: oall](scope: Scope,
                   gradients: oT,
                   features: oT,
                   T: DType): SoftplusGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SoftplusGrad(*#, #, #, #)", constructor.}

proc softplusGrad*[oT: oall](scope: Scope,
                   gradients: oT,
                   features: oT): SoftplusGrad[oT] =
  return iisoftplusGrad(scope,
                        gradients,
                        features,
                        oT[].oTF)

converter softplusGradToOut*[oT: oall](op: SoftplusGrad[oT]): oT {.inline.} = return op.output


type ExperimentalIndexedDatasetMaterialize*{.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIndexedDatasetMaterialize/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiexperimentalIndexedDatasetMaterialize(scope: Scope,
                                            dataset: ovariant,
                                            materialized: oresource): ExperimentalIndexedDatasetMaterialize {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIndexedDatasetMaterialize(*#, #, #)", constructor.}

proc experimentalIndexedDatasetMaterialize*(scope: Scope,
                                            dataset: ovariant,
                                            materialized: oresource): ExperimentalIndexedDatasetMaterialize =
  return iiexperimentalIndexedDatasetMaterialize(scope,
                                                 dataset,
                                                 materialized)




type QuantizeAndDequantizeV3*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeAndDequantizeV3/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizeAndDequantizeV3[oT: oall](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              num_bits: oint32,
                              signed_input: bool,
                              range_given: bool,
                              T: DType): QuantizeAndDequantizeV3[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeAndDequantizeV3(*#, #, #, #, #, #, #, #)", constructor.}

proc quantizeAndDequantizeV3*[oT: oall](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              num_bits: oint32,
                              signed_input: bool = true,
                              range_given: bool = true): QuantizeAndDequantizeV3[oT] =
  return iiquantizeAndDequantizeV3(scope,
                                   input,
                                   input_min,
                                   input_max,
                                   num_bits,
                                   signed_input,
                                   range_given,
                                   oT[].oTF)

converter quantizeAndDequantizeV3ToOut*[oT: oall](op: QuantizeAndDequantizeV3[oT]): oT {.inline.} = return op.output


type Mul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Mul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimul[oT: oall](scope: Scope,
          x: oT,
          y: oT,
          T: DType): Mul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Mul(*#, #, #, #)", constructor.}

proc mul*[oT: oall](scope: Scope,
          x: oT,
          y: oT): Mul[oT] =
  return iimul(scope,
               x,
               y,
               oT[].oTF)

converter mulToOut*[oT: oall](op: Mul[oT]): oT {.inline.} = return op.output

type BatchToSpaceTidx* = oint32 | oint64

type BatchToSpace*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchToSpace/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchToSpace[oT: oall](scope: Scope,
                   input: oT,
                   crops: BatchToSpaceTidx,
                   T: DType,
                   block_size: int64): BatchToSpace[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchToSpace(*#, #, #, #, #)", constructor.}

proc batchToSpace*[oT: oall](scope: Scope,
                   input: oT,
                   crops: BatchToSpaceTidx,
                   block_size: int64 = 0.int): BatchToSpace[oT] =
  return iibatchToSpace(scope,
                        input,
                        crops,
                        oT[].oTF,
                        block_size)

converter batchToSpaceToOut*[oT: oall](op: BatchToSpace[oT]): oT {.inline.} = return op.output


type ExperimentalPrivateThreadPoolDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalPrivateThreadPoolDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalPrivateThreadPoolDataset(scope: Scope,
                                           input_dataset: ovariant,
                                           num_threads: oint64,
                                           output_types: ArraySlice[DType],
                                           output_shapes: ArraySlice[TensorShape]): ExperimentalPrivateThreadPoolDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalPrivateThreadPoolDataset(*#, #, #, #, #)", constructor.}

proc experimentalPrivateThreadPoolDataset*(scope: Scope,
                                           input_dataset: ovariant,
                                           num_threads: oint64,
                                           output_types: openArray[DType],
                                           output_shapes: openArray[TensorShape]): ExperimentalPrivateThreadPoolDataset =
  return iiexperimentalPrivateThreadPoolDataset(scope,
                                                input_dataset,
                                                num_threads,
                                                newArraySlice(output_types),
                                                newArraySlice(output_shapes))

converter experimentalPrivateThreadPoolDatasetToOut*(op: ExperimentalPrivateThreadPoolDataset): ovariant {.inline.} = return op.output

type AddSparseToTensorsMapT* = oall

type AddSparseToTensorsMap* {.header:"../tensorflow/ops/generated.h", importcpp:"AddSparseToTensorsMap/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiaddSparseToTensorsMap(scope: Scope,
                            sparse_indices: oint64,
                            sparse_values: AddSparseToTensorsMapT,
                            sparse_shape: oint64,
                            container: cstring,
                            shared_name: cstring): AddSparseToTensorsMap {.header:"../tensorflow/ops/generated.h", importcpp:"AddSparseToTensorsMap(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc addSparseToTensorsMap*(scope: Scope,
                            sparse_indices: oint64,
                            sparse_values: AddSparseToTensorsMapT,
                            sparse_shape: oint64,
                            container: cstring,
                            shared_name: cstring): AddSparseToTensorsMap =
  return iiaddSparseToTensorsMap(scope,
                                 sparse_indices,
                                 sparse_values,
                                 sparse_shape,
                                 container,
                                 shared_name)

converter addSparseToTensorsMapToOut*(op: AddSparseToTensorsMap): oint64 {.inline.} = return op.output


type Elu*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Elu/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iielu[oT: oall](scope: Scope,
          features: oT,
          T: DType): Elu[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Elu(*#, #, #)", constructor.}

proc elu*[oT: oall](scope: Scope,
          features: oT): Elu[oT] =
  return iielu(scope,
               features,
               oT[].oTF)

converter eluToOut*[oT: oall](op: Elu[oT]): oT {.inline.} = return op.output


type ExperimentalBytesProducedStatsDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalBytesProducedStatsDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalBytesProducedStatsDataset(scope: Scope,
                                            input_dataset: ovariant,
                                            tag: ostring,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalBytesProducedStatsDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalBytesProducedStatsDataset(*#, #, #, #, #)", constructor.}

proc experimentalBytesProducedStatsDataset*(scope: Scope,
                                            input_dataset: ovariant,
                                            tag: ostring,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalBytesProducedStatsDataset =
  return iiexperimentalBytesProducedStatsDataset(scope,
                                                 input_dataset,
                                                 tag,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalBytesProducedStatsDatasetToOut*(op: ExperimentalBytesProducedStatsDataset): ovariant {.inline.} = return op.output


type ExperimentalIteratorGetDevice* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIteratorGetDevice/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiexperimentalIteratorGetDevice(scope: Scope,
                                    resource: oresource): ExperimentalIteratorGetDevice {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIteratorGetDevice(*#, #)", constructor.}

proc experimentalIteratorGetDevice*(scope: Scope,
                                    resource: oresource): ExperimentalIteratorGetDevice =
  return iiexperimentalIteratorGetDevice(scope,
                                         resource)

converter experimentalIteratorGetDeviceToOut*(op: ExperimentalIteratorGetDevice): ostring {.inline.} = return op.output


type StringFormat* {.header:"../tensorflow/ops/generated.h", importcpp:"StringFormat/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iistringFormat(scope: Scope,
                   inputs: olist[oall],
                   T: ArraySlice[DType],
                   ntemplate: cstring,
                   placeholder: cstring,
                   summarize: int64): StringFormat {.header:"../tensorflow/ops/generated.h", importcpp:"StringFormat(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc stringFormat*(scope: Scope,
                   inputs: olist[oall],
                   T: openArray[DType],
                   ntemplate: cstring = "%s",
                   placeholder: cstring = "%s",
                   summarize: int64 = 3.int): StringFormat =
  return iistringFormat(scope,
                        inputs,
                        newArraySlice(T),
                        ntemplate,
                        placeholder,
                        summarize)

converter stringFormatToOut*(op: StringFormat): ostring {.inline.} = return op.output


type ExperimentalUniqueDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalUniqueDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalUniqueDataset(scope: Scope,
                                input_dataset: ovariant,
                                output_types: ArraySlice[DType],
                                output_shapes: ArraySlice[TensorShape]): ExperimentalUniqueDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalUniqueDataset(*#, #, #, #)", constructor.}

proc experimentalUniqueDataset*(scope: Scope,
                                input_dataset: ovariant,
                                output_types: openArray[DType],
                                output_shapes: openArray[TensorShape]): ExperimentalUniqueDataset =
  return iiexperimentalUniqueDataset(scope,
                                     input_dataset,
                                     newArraySlice(output_types),
                                     newArraySlice(output_shapes))

converter experimentalUniqueDatasetToOut*(op: ExperimentalUniqueDataset): ovariant {.inline.} = return op.output


type ExperimentalUnbatchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalUnbatchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalUnbatchDataset(scope: Scope,
                                 input_dataset: ovariant,
                                 output_types: ArraySlice[DType],
                                 output_shapes: ArraySlice[TensorShape]): ExperimentalUnbatchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalUnbatchDataset(*#, #, #, #)", constructor.}

proc experimentalUnbatchDataset*(scope: Scope,
                                 input_dataset: ovariant,
                                 output_types: openArray[DType],
                                 output_shapes: openArray[TensorShape]): ExperimentalUnbatchDataset =
  return iiexperimentalUnbatchDataset(scope,
                                      input_dataset,
                                      newArraySlice(output_types),
                                      newArraySlice(output_shapes))

converter experimentalUnbatchDatasetToOut*(op: ExperimentalUnbatchDataset): ovariant {.inline.} = return op.output


type TensorArrayPack*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayPack/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayPack[oT: oall](scope: Scope,
                      handle: ostring,
                      flow_in: ofloat,
                      dtype: DType,
                      element_shape: TensorShape,
                      explicitT: type(oT)): TensorArrayPack[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayPack(*#, #, #, #, #)", constructor.}

proc tensorArrayPack*(scope: Scope,
                      handle: ostring,
                      flow_in: ofloat,
                      dtype: type = oinvalid,
                      element_shape: TensorShape = [].shape): auto =
  return iitensorArrayPack(scope,
                           handle,
                           flow_in,
                           dtype[].oTF,
                           element_shape,
                           dtype)

converter tensorArrayPackToOut*[oT: oall](op: TensorArrayPack[oT]): oT {.inline.} = return op.output


type ExperimentalStatsAggregatorHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalStatsAggregatorHandle/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiexperimentalStatsAggregatorHandle(scope: Scope,
                                        container: cstring,
                                        shared_name: cstring): ExperimentalStatsAggregatorHandle {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalStatsAggregatorHandle(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc experimentalStatsAggregatorHandle*(scope: Scope,
                                        container: cstring,
                                        shared_name: cstring): ExperimentalStatsAggregatorHandle =
  return iiexperimentalStatsAggregatorHandle(scope,
                                             container,
                                             shared_name)

converter experimentalStatsAggregatorHandleToOut*(op: ExperimentalStatsAggregatorHandle): oresource {.inline.} = return op.output


type LookupTableSizeV2* {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableSizeV2/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iilookupTableSizeV2(scope: Scope,
                        table_handle: oresource): LookupTableSizeV2 {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableSizeV2(*#, #)", constructor.}

proc lookupTableSizeV2*(scope: Scope,
                        table_handle: oresource): LookupTableSizeV2 =
  return iilookupTableSizeV2(scope,
                             table_handle)

converter lookupTableSizeV2ToOut*(op: LookupTableSizeV2): oint64 {.inline.} = return op.output


type ExperimentalSqlDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSqlDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalSqlDataset(scope: Scope,
                             driver_name: ostring,
                             data_source_name: ostring,
                             query: ostring,
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape]): ExperimentalSqlDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSqlDataset(*#, #, #, #, #, #)", constructor.}

proc experimentalSqlDataset*(scope: Scope,
                             driver_name: ostring,
                             data_source_name: ostring,
                             query: ostring,
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape]): ExperimentalSqlDataset =
  return iiexperimentalSqlDataset(scope,
                                  driver_name,
                                  data_source_name,
                                  query,
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes))

converter experimentalSqlDatasetToOut*(op: ExperimentalSqlDataset): ovariant {.inline.} = return op.output

type TensorArrayUnpackT* = oall

type TensorArrayUnpack* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayUnpack/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayUnpack(scope: Scope,
                        handle: ostring,
                        value: TensorArrayUnpackT,
                        flow_in: ofloat): TensorArrayUnpack {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayUnpack(*#, #, #, #)", constructor.}

proc tensorArrayUnpack*(scope: Scope,
                        handle: ostring,
                        value: TensorArrayUnpackT,
                        flow_in: ofloat): TensorArrayUnpack =
  return iitensorArrayUnpack(scope,
                             handle,
                             value,
                             flow_in)

converter tensorArrayUnpackToOut*(op: TensorArrayUnpack): ofloat {.inline.} = return op.output


type ExperimentalSetStatsAggregatorDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSetStatsAggregatorDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalSetStatsAggregatorDataset(scope: Scope,
                                            input_dataset: ovariant,
                                            stats_aggregator: oresource,
                                            tag: ostring,
                                            counter_prefix: ostring,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalSetStatsAggregatorDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSetStatsAggregatorDataset(*#, #, #, #, #, #, #)", constructor.}

proc experimentalSetStatsAggregatorDataset*(scope: Scope,
                                            input_dataset: ovariant,
                                            stats_aggregator: oresource,
                                            tag: ostring,
                                            counter_prefix: ostring,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalSetStatsAggregatorDataset =
  return iiexperimentalSetStatsAggregatorDataset(scope,
                                                 input_dataset,
                                                 stats_aggregator,
                                                 tag,
                                                 counter_prefix,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalSetStatsAggregatorDatasetToOut*(op: ExperimentalSetStatsAggregatorDataset): ovariant {.inline.} = return op.output


type IFFT3D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IFFT3D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiFFT3D[oT: oall](scope: Scope,
             input: oT,
             Tcomplex: DType): IFFT3D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IFFT3D(*#, #, #)", constructor.}

proc iFFT3D*[oT: oall](scope: Scope,
             input: oT): IFFT3D[oT] =
  return iiiFFT3D(scope,
                  input,
                  oT[].oTF)

converter iFFT3DToOut*[oT: oall](op: IFFT3D[oT]): oT {.inline.} = return op.output


type IUnaryOpsComposition*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_UnaryOpsComposition/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiUnaryOpsComposition[oT: oall](scope: Scope,
                           x: oT,
                           op_names: ArraySlice[cstring],
                           T: DType): IUnaryOpsComposition[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_UnaryOpsComposition(*#, #, #, #)", constructor.}

proc iUnaryOpsComposition*[oT: oall](scope: Scope,
                           x: oT,
                           op_names: openArray[cstring]): IUnaryOpsComposition[oT] =
  return iiiUnaryOpsComposition(scope,
                                x,
                                newArraySlice(op_names),
                                oT[].oTF)

converter iUnaryOpsCompositionToOut*[oT: oall](op: IUnaryOpsComposition[oT]): oT {.inline.} = return op.output


type BatchMatrixDeterminant*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixDeterminant/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixDeterminant[oT: oall](scope: Scope,
                             input: oT,
                             T: DType): BatchMatrixDeterminant[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixDeterminant(*#, #, #)", constructor.}

proc batchMatrixDeterminant*[oT: oall](scope: Scope,
                             input: oT): BatchMatrixDeterminant[oT] =
  return iibatchMatrixDeterminant(scope,
                                  input,
                                  oT[].oTF)

converter batchMatrixDeterminantToOut*[oT: oall](op: BatchMatrixDeterminant[oT]): oT {.inline.} = return op.output


type ExperimentalIgnoreErrorsDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIgnoreErrorsDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalIgnoreErrorsDataset(scope: Scope,
                                      input_dataset: ovariant,
                                      output_types: ArraySlice[DType],
                                      output_shapes: ArraySlice[TensorShape]): ExperimentalIgnoreErrorsDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalIgnoreErrorsDataset(*#, #, #, #)", constructor.}

proc experimentalIgnoreErrorsDataset*(scope: Scope,
                                      input_dataset: ovariant,
                                      output_types: openArray[DType],
                                      output_shapes: openArray[TensorShape]): ExperimentalIgnoreErrorsDataset =
  return iiexperimentalIgnoreErrorsDataset(scope,
                                           input_dataset,
                                           newArraySlice(output_types),
                                           newArraySlice(output_shapes))

converter experimentalIgnoreErrorsDatasetToOut*(op: ExperimentalIgnoreErrorsDataset): ovariant {.inline.} = return op.output


type ExperimentalRandomDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalRandomDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalRandomDataset(scope: Scope,
                                seed: oint64,
                                seed2: oint64,
                                output_types: ArraySlice[DType],
                                output_shapes: ArraySlice[TensorShape]): ExperimentalRandomDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalRandomDataset(*#, #, #, #, #)", constructor.}

proc experimentalRandomDataset*(scope: Scope,
                                seed: oint64,
                                seed2: oint64,
                                output_types: openArray[DType],
                                output_shapes: openArray[TensorShape]): ExperimentalRandomDataset =
  return iiexperimentalRandomDataset(scope,
                                     seed,
                                     seed2,
                                     newArraySlice(output_types),
                                     newArraySlice(output_shapes))

converter experimentalRandomDatasetToOut*(op: ExperimentalRandomDataset): ovariant {.inline.} = return op.output


type PriorityQueue* {.header:"../tensorflow/ops/generated.h", importcpp:"PriorityQueue/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iipriorityQueue(scope: Scope,
                    component_types: ArraySlice[DType],
                    shapes: ArraySlice[TensorShape],
                    container: cstring,
                    shared_name: cstring,
                    capacity: int64): PriorityQueue {.header:"../tensorflow/ops/generated.h", importcpp:"PriorityQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc priorityQueue*(scope: Scope,
                    component_types: openArray[DType],
                    shapes: openArray[TensorShape],
                    container: cstring,
                    shared_name: cstring,
                    capacity: int64 = -1.int): PriorityQueue =
  return iipriorityQueue(scope,
                         newArraySlice(component_types),
                         newArraySlice(shapes),
                         container,
                         shared_name,
                         capacity)

converter priorityQueueToOut*(op: PriorityQueue): ostring {.inline.} = return op.output


type For*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"For/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iinfor[oT: oall](scope: Scope,
           start: oint32,
           limit: oint32,
           delta: oint32,
           input: olist[oT],
           T: ArraySlice[DType],
           body: NameAttrList): For[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"For(*#, #, #, #, #, #, #)", constructor.}

proc nfor*[oT: oall](scope: Scope,
           start: oint32,
           limit: oint32,
           delta: oint32,
           input: olist[oT],
           T: openArray[DType],
           body: NameAttrList): For[oT] =
  return iinfor(scope,
                start,
                limit,
                delta,
                input,
                newArraySlice(T),
                body)

converter nforToOutList*[oT: oall](op: For[oT]): olist[oT] {.inline.} = return op.output


type ExperimentalParallelInterleaveDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalParallelInterleaveDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalParallelInterleaveDataset(scope: Scope,
                                            input_dataset: ovariant,
                                            other_arguments: olist[oall],
                                            cycle_length: oint64,
                                            block_length: oint64,
                                            sloppy: obool,
                                            buffer_output_elements: oint64,
                                            prefetch_input_elements: oint64,
                                            f: NameAttrList,
                                            Targuments: ArraySlice[DType],
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalParallelInterleaveDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalParallelInterleaveDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalParallelInterleaveDataset*(scope: Scope,
                                            input_dataset: ovariant,
                                            other_arguments: olist[oall],
                                            cycle_length: oint64,
                                            block_length: oint64,
                                            sloppy: obool,
                                            buffer_output_elements: oint64,
                                            prefetch_input_elements: oint64,
                                            f: NameAttrList,
                                            Targuments: openArray[DType],
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalParallelInterleaveDataset =
  return iiexperimentalParallelInterleaveDataset(scope,
                                                 input_dataset,
                                                 other_arguments,
                                                 cycle_length,
                                                 block_length,
                                                 sloppy,
                                                 buffer_output_elements,
                                                 prefetch_input_elements,
                                                 f,
                                                 newArraySlice(Targuments),
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalParallelInterleaveDatasetToOut*(op: ExperimentalParallelInterleaveDataset): ovariant {.inline.} = return op.output


type Skipgram* {.header:"../tensorflow/ops/generated.h", importcpp:"Skipgram/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiskipgram(scope: Scope,
               filename: cstring,
               batch_size: int64,
               window_size: int64,
               min_count: int64,
               subsample: float32): Skipgram {.header:"../tensorflow/ops/generated.h", importcpp:"Skipgram(*#, tensorflow::string(#), #, #, #, #)", constructor.}

proc skipgram*(scope: Scope,
               filename: cstring,
               batch_size: int64 = 0.int,
               window_size: int64 = 5.int,
               min_count: int64 = 5.int,
               subsample: float32 = 0.001000000047497451.float32): Skipgram =
  return iiskipgram(scope,
                    filename,
                    batch_size,
                    window_size,
                    min_count,
                    subsample)

converter skipgramToOut*(op: Skipgram): ostring {.inline.} = return op.output


type ExperimentalMatchingFilesDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMatchingFilesDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalMatchingFilesDataset(scope: Scope,
                                       patterns: ostring): ExperimentalMatchingFilesDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMatchingFilesDataset(*#, #)", constructor.}

proc experimentalMatchingFilesDataset*(scope: Scope,
                                       patterns: ostring): ExperimentalMatchingFilesDataset =
  return iiexperimentalMatchingFilesDataset(scope,
                                            patterns)

converter experimentalMatchingFilesDatasetToOut*(op: ExperimentalMatchingFilesDataset): ovariant {.inline.} = return op.output


type StageClear*{.header:"../tensorflow/ops/generated.h", importcpp:"StageClear/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iistageClear(scope: Scope,
                 dtypes: ArraySlice[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64,
                 memory_limit: int64): StageClear {.header:"../tensorflow/ops/generated.h", importcpp:"StageClear(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stageClear*(scope: Scope,
                 dtypes: openArray[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64 = 0.int,
                 memory_limit: int64 = 0.int): StageClear =
  return iistageClear(scope,
                      newArraySlice(dtypes),
                      container,
                      shared_name,
                      capacity,
                      memory_limit)




type ExperimentalMapDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMapDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalMapDataset(scope: Scope,
                             input_dataset: ovariant,
                             other_arguments: olist[oall],
                             f: NameAttrList,
                             Targuments: ArraySlice[DType],
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape],
                             use_inter_op_parallelism: bool,
                             preserve_cardinality: bool): ExperimentalMapDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMapDataset(*#, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalMapDataset*(scope: Scope,
                             input_dataset: ovariant,
                             other_arguments: olist[oall],
                             f: NameAttrList,
                             Targuments: openArray[DType],
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape],
                             use_inter_op_parallelism: bool = true,
                             preserve_cardinality: bool = false): ExperimentalMapDataset =
  return iiexperimentalMapDataset(scope,
                                  input_dataset,
                                  other_arguments,
                                  f,
                                  newArraySlice(Targuments),
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes),
                                  use_inter_op_parallelism,
                                  preserve_cardinality)

converter experimentalMapDatasetToOut*(op: ExperimentalMapDataset): ovariant {.inline.} = return op.output


type BiasAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BiasAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibiasAdd[oT: oall](scope: Scope,
              value: oT,
              bias: oT,
              T: DType,
              data_format: cstring): BiasAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BiasAdd(*#, #, #, #, tensorflow::string(#))", constructor.}

proc biasAdd*[oT: oall](scope: Scope,
              value: oT,
              bias: oT,
              data_format: cstring = "NHWC"): BiasAdd[oT] =
  return iibiasAdd(scope,
                   value,
                   bias,
                   oT[].oTF,
                   data_format)

converter biasAddToOut*[oT: oall](op: BiasAdd[oT]): oT {.inline.} = return op.output


type ExperimentalGroupByReducerDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalGroupByReducerDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalGroupByReducerDataset(scope: Scope,
                                        input_dataset: ovariant,
                                        key_func_other_arguments: olist[oall],
                                        init_func_other_arguments: olist[oall],
                                        reduce_func_other_arguments: olist[oall],
                                        finalize_func_other_arguments: olist[oall],
                                        key_func: NameAttrList,
                                        init_func: NameAttrList,
                                        reduce_func: NameAttrList,
                                        finalize_func: NameAttrList,
                                        Tkey_func_other_arguments: ArraySlice[DType],
                                        Tinit_func_other_arguments: ArraySlice[DType],
                                        Treduce_func_other_arguments: ArraySlice[DType],
                                        Tfinalize_func_other_arguments: ArraySlice[DType],
                                        output_types: ArraySlice[DType],
                                        output_shapes: ArraySlice[TensorShape]): ExperimentalGroupByReducerDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalGroupByReducerDataset(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalGroupByReducerDataset*(scope: Scope,
                                        input_dataset: ovariant,
                                        key_func_other_arguments: olist[oall],
                                        init_func_other_arguments: olist[oall],
                                        reduce_func_other_arguments: olist[oall],
                                        finalize_func_other_arguments: olist[oall],
                                        key_func: NameAttrList,
                                        init_func: NameAttrList,
                                        reduce_func: NameAttrList,
                                        finalize_func: NameAttrList,
                                        Tkey_func_other_arguments: openArray[DType],
                                        Tinit_func_other_arguments: openArray[DType],
                                        Treduce_func_other_arguments: openArray[DType],
                                        Tfinalize_func_other_arguments: openArray[DType],
                                        output_types: openArray[DType],
                                        output_shapes: openArray[TensorShape]): ExperimentalGroupByReducerDataset =
  return iiexperimentalGroupByReducerDataset(scope,
                                             input_dataset,
                                             key_func_other_arguments,
                                             init_func_other_arguments,
                                             reduce_func_other_arguments,
                                             finalize_func_other_arguments,
                                             key_func,
                                             init_func,
                                             reduce_func,
                                             finalize_func,
                                             newArraySlice(Tkey_func_other_arguments),
                                             newArraySlice(Tinit_func_other_arguments),
                                             newArraySlice(Treduce_func_other_arguments),
                                             newArraySlice(Tfinalize_func_other_arguments),
                                             newArraySlice(output_types),
                                             newArraySlice(output_shapes))

converter experimentalGroupByReducerDatasetToOut*(op: ExperimentalGroupByReducerDataset): ovariant {.inline.} = return op.output

type CropAndResizeGradBoxesT* = ouint8 | ouint16 | oint8 | oint16 | oint32 | oint64 | ohalf | ofloat | odouble

type CropAndResizeGradBoxes* {.header:"../tensorflow/ops/generated.h", importcpp:"CropAndResizeGradBoxes/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iicropAndResizeGradBoxes(scope: Scope,
                             grads: ofloat,
                             image: CropAndResizeGradBoxesT,
                             boxes: ofloat,
                             box_ind: oint32,
                             nmethod: cstring): CropAndResizeGradBoxes {.header:"../tensorflow/ops/generated.h", importcpp:"CropAndResizeGradBoxes(*#, #, #, #, #, tensorflow::string(#))", constructor.}

proc cropAndResizeGradBoxes*(scope: Scope,
                             grads: ofloat,
                             image: CropAndResizeGradBoxesT,
                             boxes: ofloat,
                             box_ind: oint32,
                             nmethod: cstring = "bilinear"): CropAndResizeGradBoxes =
  return iicropAndResizeGradBoxes(scope,
                                  grads,
                                  image,
                                  boxes,
                                  box_ind,
                                  nmethod)

converter cropAndResizeGradBoxesToOut*(op: CropAndResizeGradBoxes): ofloat {.inline.} = return op.output


type FIFOQueueV2* {.header:"../tensorflow/ops/generated.h", importcpp:"FIFOQueueV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iifIFOQueueV2(scope: Scope,
                  component_types: ArraySlice[DType],
                  shapes: ArraySlice[TensorShape],
                  container: cstring,
                  shared_name: cstring,
                  capacity: int64): FIFOQueueV2 {.header:"../tensorflow/ops/generated.h", importcpp:"FIFOQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc fIFOQueueV2*(scope: Scope,
                  component_types: openArray[DType],
                  shapes: openArray[TensorShape],
                  container: cstring,
                  shared_name: cstring,
                  capacity: int64 = -1.int): FIFOQueueV2 =
  return iifIFOQueueV2(scope,
                       newArraySlice(component_types),
                       newArraySlice(shapes),
                       container,
                       shared_name,
                       capacity)

converter fIFOQueueV2ToOut*(op: FIFOQueueV2): oresource {.inline.} = return op.output

type BatchToSpaceNDTblock_shape* = oint32 | oint64
type BatchToSpaceNDTcrops* = oint32 | oint64

type BatchToSpaceND*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchToSpaceND/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchToSpaceND[oT: oall](scope: Scope,
                     input: oT,
                     block_shape: BatchToSpaceNDTblock_shape,
                     crops: BatchToSpaceNDTcrops,
                     T: DType): BatchToSpaceND[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchToSpaceND(*#, #, #, #, #)", constructor.}

proc batchToSpaceND*[oT: oall](scope: Scope,
                     input: oT,
                     block_shape: BatchToSpaceNDTblock_shape,
                     crops: BatchToSpaceNDTcrops): BatchToSpaceND[oT] =
  return iibatchToSpaceND(scope,
                          input,
                          block_shape,
                          crops,
                          oT[].oTF)

converter batchToSpaceNDToOut*[oT: oall](op: BatchToSpaceND[oT]): oT {.inline.} = return op.output


type AccumulatorSetGlobalStep*{.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorSetGlobalStep/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiaccumulatorSetGlobalStep(scope: Scope,
                               handle: ostring,
                               new_global_step: oint64): AccumulatorSetGlobalStep {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorSetGlobalStep(*#, #, #)", constructor.}

proc accumulatorSetGlobalStep*(scope: Scope,
                               handle: ostring,
                               new_global_step: oint64): AccumulatorSetGlobalStep =
  return iiaccumulatorSetGlobalStep(scope,
                                    handle,
                                    new_global_step)




type ExperimentalDatasetCardinality* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDatasetCardinality/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiexperimentalDatasetCardinality(scope: Scope,
                                     input_dataset: ovariant): ExperimentalDatasetCardinality {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDatasetCardinality(*#, #)", constructor.}

proc experimentalDatasetCardinality*(scope: Scope,
                                     input_dataset: ovariant): ExperimentalDatasetCardinality =
  return iiexperimentalDatasetCardinality(scope,
                                          input_dataset)

converter experimentalDatasetCardinalityToOut*(op: ExperimentalDatasetCardinality): oint64 {.inline.} = return op.output

type IDeviceRetvalT* = oall

type IDeviceRetval*{.header:"../tensorflow/ops/generated.h", importcpp:"_DeviceRetval/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiiDeviceRetval(scope: Scope,
                    input: IDeviceRetvalT,
                    index: int64): IDeviceRetval {.header:"../tensorflow/ops/generated.h", importcpp:"_DeviceRetval(*#, #, #)", constructor.}

proc iDeviceRetval*(scope: Scope,
                    input: IDeviceRetvalT,
                    index: int64 = 0.int): IDeviceRetval =
  return iiiDeviceRetval(scope,
                         input,
                         index)




type LogUniformCandidateSampler* {.header:"../tensorflow/ops/generated.h", importcpp:"LogUniformCandidateSampler/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iilogUniformCandidateSampler(scope: Scope,
                                 true_classes: oint64,
                                 num_true: int64,
                                 num_sampled: int64,
                                 unique: bool,
                                 range_max: int64,
                                 seed: int64,
                                 seed2: int64): LogUniformCandidateSampler {.header:"../tensorflow/ops/generated.h", importcpp:"LogUniformCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc logUniformCandidateSampler*(scope: Scope,
                                 true_classes: oint64,
                                 num_true: int64 = 0.int,
                                 num_sampled: int64 = 0.int,
                                 unique: bool = false,
                                 range_max: int64 = 0.int,
                                 seed: int64 = 0.int,
                                 seed2: int64 = 0.int): LogUniformCandidateSampler =
  return iilogUniformCandidateSampler(scope,
                                      true_classes,
                                      num_true,
                                      num_sampled,
                                      unique,
                                      range_max,
                                      seed,
                                      seed2)

converter logUniformCandidateSamplerToOut*(op: LogUniformCandidateSampler): oint64 {.inline.} = return op.output


type MapDefun*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MapDefun/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iimapDefun[oT: oall](scope: Scope,
               arguments: olist[oall],
               captured_inputs: olist[oall],
               Targuments: ArraySlice[DType],
               Tcaptured: ArraySlice[DType],
               output_types: ArraySlice[DType],
               output_shapes: ArraySlice[TensorShape],
               f: NameAttrList,
               explicitT: type(oT)): MapDefun[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MapDefun(*#, #, #, #, #, #, #, #)", constructor.}

proc mapDefun*(scope: Scope,
               arguments: olist[oall],
               captured_inputs: olist[oall],
               Targuments: openArray[DType],
               Tcaptured: openArray[DType],
               output_types: openArray[DType],
               output_shapes: openArray[TensorShape],
               f: NameAttrList,
               explicitT: type): auto =
  return iimapDefun(scope,
                    arguments,
                    captured_inputs,
                    newArraySlice(Targuments),
                    newArraySlice(Tcaptured),
                    newArraySlice(output_types),
                    newArraySlice(output_shapes),
                    f,
                    explicitT)

converter mapDefunToOutList*[oT: oall](op: MapDefun[oT]): olist[oT] {.inline.} = return op.output


type ExperimentalCSVDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalCSVDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalCSVDataset(scope: Scope,
                             filenames: ostring,
                             compression_type: ostring,
                             buffer_size: oint64,
                             header: obool,
                             field_delim: ostring,
                             use_quote_delim: obool,
                             na_value: ostring,
                             select_cols: oint64,
                             record_defaults: olist[oall],
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape]): ExperimentalCSVDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalCSVDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalCSVDataset*(scope: Scope,
                             filenames: ostring,
                             compression_type: ostring,
                             buffer_size: oint64,
                             header: obool,
                             field_delim: ostring,
                             use_quote_delim: obool,
                             na_value: ostring,
                             select_cols: oint64,
                             record_defaults: olist[oall],
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape]): ExperimentalCSVDataset =
  return iiexperimentalCSVDataset(scope,
                                  filenames,
                                  compression_type,
                                  buffer_size,
                                  header,
                                  field_delim,
                                  use_quote_delim,
                                  na_value,
                                  select_cols,
                                  record_defaults,
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes))

converter experimentalCSVDatasetToOut*(op: ExperimentalCSVDataset): ovariant {.inline.} = return op.output

type UnsortedSegmentMinTindices* = oint32 | oint64
type UnsortedSegmentMinTnumsegments* = oint32 | oint64

type UnsortedSegmentMin*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentMin/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunsortedSegmentMin[oT: oall](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMinTindices,
                         num_segments: UnsortedSegmentMinTnumsegments,
                         T: DType): UnsortedSegmentMin[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentMin(*#, #, #, #, #)", constructor.}

proc unsortedSegmentMin*[oT: oall](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMinTindices,
                         num_segments: UnsortedSegmentMinTnumsegments): UnsortedSegmentMin[oT] =
  return iiunsortedSegmentMin(scope,
                              data,
                              segment_ids,
                              num_segments,
                              oT[].oTF)

converter unsortedSegmentMinToOut*[oT: oall](op: UnsortedSegmentMin[oT]): oT {.inline.} = return op.output

type SegmentMinTindices* = oint32 | oint64

type SegmentMin*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentMin/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisegmentMin[oT: oall](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMinTindices,
                 T: DType): SegmentMin[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentMin(*#, #, #, #)", constructor.}

proc segmentMin*[oT: oall](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMinTindices): SegmentMin[oT] =
  return iisegmentMin(scope,
                      data,
                      segment_ids,
                      oT[].oTF)

converter segmentMinToOut*[oT: oall](op: SegmentMin[oT]): oT {.inline.} = return op.output


type TensorForestTreePredict* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreePredict/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorForestTreePredict(scope: Scope,
                              tree_handle: oresource,
                              dense_features: ofloat,
                              logits_dimension: int64): TensorForestTreePredict {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreePredict(*#, #, #, #)", constructor.}

proc tensorForestTreePredict*(scope: Scope,
                              tree_handle: oresource,
                              dense_features: ofloat,
                              logits_dimension: int64 = 0.int): TensorForestTreePredict =
  return iitensorForestTreePredict(scope,
                                   tree_handle,
                                   dense_features,
                                   logits_dimension)

converter tensorForestTreePredictToOut*(op: TensorForestTreePredict): ofloat {.inline.} = return op.output


type EncodeProto* {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeProto/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiencodeProto(scope: Scope,
                  sizes: oint32,
                  values: olist[oall],
                  field_names: ArraySlice[cstring],
                  message_type: cstring,
                  Tinput_types: ArraySlice[DType],
                  descriptor_source: cstring): EncodeProto {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeProto(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc encodeProto*(scope: Scope,
                  sizes: oint32,
                  values: olist[oall],
                  field_names: openArray[cstring],
                  message_type: cstring,
                  Tinput_types: openArray[DType],
                  descriptor_source: cstring = "local://"): EncodeProto =
  return iiencodeProto(scope,
                       sizes,
                       values,
                       newArraySlice(field_names),
                       message_type,
                       newArraySlice(Tinput_types),
                       descriptor_source)

converter encodeProtoToOut*(op: EncodeProto): ostring {.inline.} = return op.output


type ExperimentalDirectedInterleaveDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDirectedInterleaveDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalDirectedInterleaveDataset(scope: Scope,
                                            selector_input_dataset: ovariant,
                                            data_input_datasets: olist[ovariant],
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalDirectedInterleaveDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDirectedInterleaveDataset(*#, #, #, #, #)", constructor.}

proc experimentalDirectedInterleaveDataset*(scope: Scope,
                                            selector_input_dataset: ovariant,
                                            data_input_datasets: olist[ovariant],
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalDirectedInterleaveDataset =
  return iiexperimentalDirectedInterleaveDataset(scope,
                                                 selector_input_dataset,
                                                 data_input_datasets,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalDirectedInterleaveDatasetToOut*(op: ExperimentalDirectedInterleaveDataset): ovariant {.inline.} = return op.output


type Minimum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Minimum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiminimum[oT: oall](scope: Scope,
              x: oT,
              y: oT,
              T: DType): Minimum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Minimum(*#, #, #, #)", constructor.}

proc minimum*[oT: oall](scope: Scope,
              x: oT,
              y: oT): Minimum[oT] =
  return iiminimum(scope,
                   x,
                   y,
                   oT[].oTF)

converter minimumToOut*[oT: oall](op: Minimum[oT]): oT {.inline.} = return op.output


type UnicodeDecode* {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeDecode/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiunicodeDecode(scope: Scope,
                    input: ostring,
                    input_encoding: cstring,
                    errors: cstring,
                    replacement_char: int64,
                    replace_control_characters: bool): UnicodeDecode {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeDecode(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unicodeDecode*(scope: Scope,
                    input: ostring,
                    input_encoding: cstring,
                    errors: cstring = "replace",
                    replacement_char: int64 = 65533.int,
                    replace_control_characters: bool = false): UnicodeDecode =
  return iiunicodeDecode(scope,
                         input,
                         input_encoding,
                         errors,
                         replacement_char,
                         replace_control_characters)

converter unicodeDecodeToOut*(op: UnicodeDecode): oint64 {.inline.} = return op.output

type WriteSummaryT* = oall

type WriteSummary*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteSummary/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteSummary(scope: Scope,
                   writer: oresource,
                   step: oint64,
                   tensor: WriteSummaryT,
                   tag: ostring,
                   summary_metadata: ostring): WriteSummary {.header:"../tensorflow/ops/generated.h", importcpp:"WriteSummary(*#, #, #, #, #, #)", constructor.}

proc writeSummary*(scope: Scope,
                   writer: oresource,
                   step: oint64,
                   tensor: WriteSummaryT,
                   tag: ostring,
                   summary_metadata: ostring): WriteSummary =
  return iiwriteSummary(scope,
                        writer,
                        step,
                        tensor,
                        tag,
                        summary_metadata)




type Batch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Batch/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iibatch[oT: oall](scope: Scope,
            in_tensors: olist[oT],
            allowed_batch_sizes: ArraySlice[int],
            container: cstring,
            shared_name: cstring,
            batching_queue: cstring,
            T: ArraySlice[DType],
            num_batch_threads: int64,
            max_batch_size: int64,
            max_enqueued_batches: int64,
            batch_timeout_micros: int64,
            grad_timeout_micros: int64): Batch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Batch(*#, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #, #, #)", constructor.}

proc batch*[oT: oall](scope: Scope,
            in_tensors: olist[oT],
            allowed_batch_sizes: openArray[int],
            container: cstring,
            shared_name: cstring,
            batching_queue: cstring,
            T: openArray[DType],
            num_batch_threads: int64 = 0.int,
            max_batch_size: int64 = 0.int,
            max_enqueued_batches: int64 = 10.int,
            batch_timeout_micros: int64 = 0.int,
            grad_timeout_micros: int64 = 0.int): Batch[oT] =
  return iibatch(scope,
                 in_tensors,
                 newArraySlice(allowed_batch_sizes),
                 container,
                 shared_name,
                 batching_queue,
                 newArraySlice(T),
                 num_batch_threads,
                 max_batch_size,
                 max_enqueued_batches,
                 batch_timeout_micros,
                 grad_timeout_micros)

converter batchToOutList*[oT: oall](op: Batch[oT]): olist[oT] {.inline.} = return op.output


type ParallelInterleaveDatasetV2* {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelInterleaveDatasetV2/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiparallelInterleaveDatasetV2(scope: Scope,
                                  input_dataset: ovariant,
                                  other_arguments: olist[oall],
                                  cycle_length: oint64,
                                  block_length: oint64,
                                  num_parallel_calls: oint64,
                                  f: NameAttrList,
                                  Targuments: ArraySlice[DType],
                                  output_types: ArraySlice[DType],
                                  output_shapes: ArraySlice[TensorShape],
                                  sloppy: bool): ParallelInterleaveDatasetV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelInterleaveDatasetV2(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parallelInterleaveDatasetV2*(scope: Scope,
                                  input_dataset: ovariant,
                                  other_arguments: olist[oall],
                                  cycle_length: oint64,
                                  block_length: oint64,
                                  num_parallel_calls: oint64,
                                  f: NameAttrList,
                                  Targuments: openArray[DType],
                                  output_types: openArray[DType],
                                  output_shapes: openArray[TensorShape],
                                  sloppy: bool = false): ParallelInterleaveDatasetV2 =
  return iiparallelInterleaveDatasetV2(scope,
                                       input_dataset,
                                       other_arguments,
                                       cycle_length,
                                       block_length,
                                       num_parallel_calls,
                                       f,
                                       newArraySlice(Targuments),
                                       newArraySlice(output_types),
                                       newArraySlice(output_shapes),
                                       sloppy)

converter parallelInterleaveDatasetV2ToOut*(op: ParallelInterleaveDatasetV2): ovariant {.inline.} = return op.output


type QueueIsClosed* {.header:"../tensorflow/ops/generated.h", importcpp:"QueueIsClosed/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiqueueIsClosed(scope: Scope,
                    handle: ostring): QueueIsClosed {.header:"../tensorflow/ops/generated.h", importcpp:"QueueIsClosed(*#, #)", constructor.}

proc queueIsClosed*(scope: Scope,
                    handle: ostring): QueueIsClosed =
  return iiqueueIsClosed(scope,
                         handle)

converter queueIsClosedToOut*(op: QueueIsClosed): obool {.inline.} = return op.output


type MultiDeviceIteratorFromStringHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorFromStringHandle/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iimultiDeviceIteratorFromStringHandle(scope: Scope,
                                          string_handle: ostring,
                                          output_types: ArraySlice[DType],
                                          output_shapes: ArraySlice[TensorShape]): MultiDeviceIteratorFromStringHandle {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorFromStringHandle(*#, #, #, #)", constructor.}

proc multiDeviceIteratorFromStringHandle*(scope: Scope,
                                          string_handle: ostring,
                                          output_types: openArray[DType],
                                          output_shapes: openArray[TensorShape]): MultiDeviceIteratorFromStringHandle =
  return iimultiDeviceIteratorFromStringHandle(scope,
                                               string_handle,
                                               newArraySlice(output_types),
                                               newArraySlice(output_shapes))

converter multiDeviceIteratorFromStringHandleToOut*(op: MultiDeviceIteratorFromStringHandle): oresource {.inline.} = return op.output


type MaxPoolGradGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolGradGrad[oT: oall](scope: Scope,
                      orig_input: oT,
                      orig_output: oT,
                      grad: oT,
                      ksize: ArraySlice[int],
                      strides: ArraySlice[int],
                      padding: cstring,
                      data_format: cstring,
                      T: DType): MaxPoolGradGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPoolGradGrad*[oT: oall](scope: Scope,
                      orig_input: oT,
                      orig_output: oT,
                      grad: oT,
                      ksize: openArray[int],
                      strides: openArray[int],
                      padding: cstring,
                      data_format: cstring = "NHWC"): MaxPoolGradGrad[oT] =
  return iimaxPoolGradGrad(scope,
                           orig_input,
                           orig_output,
                           grad,
                           newArraySlice(ksize),
                           newArraySlice(strides),
                           padding,
                           data_format,
                           oT[].oTF)

converter maxPoolGradGradToOut*[oT: oall](op: MaxPoolGradGrad[oT]): oT {.inline.} = return op.output


type UnwrapDatasetVariant* {.header:"../tensorflow/ops/generated.h", importcpp:"UnwrapDatasetVariant/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiunwrapDatasetVariant(scope: Scope,
                           input_handle: ovariant): UnwrapDatasetVariant {.header:"../tensorflow/ops/generated.h", importcpp:"UnwrapDatasetVariant(*#, #)", constructor.}

proc unwrapDatasetVariant*(scope: Scope,
                           input_handle: ovariant): UnwrapDatasetVariant =
  return iiunwrapDatasetVariant(scope,
                                input_handle)

converter unwrapDatasetVariantToOut*(op: UnwrapDatasetVariant): ovariant {.inline.} = return op.output


type WrapDatasetVariant* {.header:"../tensorflow/ops/generated.h", importcpp:"WrapDatasetVariant/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiwrapDatasetVariant(scope: Scope,
                         input_handle: ovariant): WrapDatasetVariant {.header:"../tensorflow/ops/generated.h", importcpp:"WrapDatasetVariant(*#, #)", constructor.}

proc wrapDatasetVariant*(scope: Scope,
                         input_handle: ovariant): WrapDatasetVariant =
  return iiwrapDatasetVariant(scope,
                              input_handle)

converter wrapDatasetVariantToOut*(op: WrapDatasetVariant): ovariant {.inline.} = return op.output


type Stage*{.header:"../tensorflow/ops/generated.h", importcpp:"Stage/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iistage(scope: Scope,
            values: olist[oall],
            dtypes: ArraySlice[DType],
            container: cstring,
            shared_name: cstring,
            capacity: int64,
            memory_limit: int64): Stage {.header:"../tensorflow/ops/generated.h", importcpp:"Stage(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stage*(scope: Scope,
            values: olist[oall],
            dtypes: openArray[DType],
            container: cstring,
            shared_name: cstring,
            capacity: int64 = 0.int,
            memory_limit: int64 = 0.int): Stage =
  return iistage(scope,
                 values,
                 newArraySlice(dtypes),
                 container,
                 shared_name,
                 capacity,
                 memory_limit)




type IdentityN*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IdentityN/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiidentityN[oT: oall](scope: Scope,
                input: olist[oT],
                T: ArraySlice[DType]): IdentityN[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IdentityN(*#, #, #)", constructor.}

proc identityN*[oT: oall](scope: Scope,
                input: olist[oT],
                T: openArray[DType]): IdentityN[oT] =
  return iiidentityN(scope,
                     input,
                     newArraySlice(T))

converter identityNToOutList*[oT: oall](op: IdentityN[oT]): olist[oT] {.inline.} = return op.output


type OptionalHasValue* {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalHasValue/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iioptionalHasValue(scope: Scope,
                       optional: ovariant): OptionalHasValue {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalHasValue(*#, #)", constructor.}

proc optionalHasValue*(scope: Scope,
                       optional: ovariant): OptionalHasValue =
  return iioptionalHasValue(scope,
                            optional)

converter optionalHasValueToOut*(op: OptionalHasValue): obool {.inline.} = return op.output


type Qr*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Qr/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiqr[oT: oall](scope: Scope,
         input: oT,
         full_matrices: bool,
         T: DType): Qr[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Qr(*#, #, #, #)", constructor.}

proc qr*[oT: oall](scope: Scope,
         input: oT,
         full_matrices: bool = false): Qr[oT] =
  return iiqr(scope,
              input,
              full_matrices,
              oT[].oTF)

converter qrToOut*[oT: oall](op: Qr[oT]): oT {.inline.} = return op.output


type StatefulPartitionedCall*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatefulPartitionedCall/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iistatefulPartitionedCall[oT: oall](scope: Scope,
                              args: olist[oall],
                              Tin: ArraySlice[DType],
                              Tout: ArraySlice[DType],
                              f: NameAttrList,
                              config: cstring,
                              config_proto: cstring,
                              executor_type: cstring,
                              explicitT: type(oT)): StatefulPartitionedCall[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatefulPartitionedCall(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc statefulPartitionedCall*(scope: Scope,
                              args: olist[oall],
                              Tin: openArray[DType],
                              Tout: openArray[DType],
                              f: NameAttrList,
                              config: cstring,
                              config_proto: cstring,
                              executor_type: cstring,
                              explicitT: type): auto =
  return iistatefulPartitionedCall(scope,
                                   args,
                                   newArraySlice(Tin),
                                   newArraySlice(Tout),
                                   f,
                                   config,
                                   config_proto,
                                   executor_type,
                                   explicitT)

converter statefulPartitionedCallToOutList*[oT: oall](op: StatefulPartitionedCall[oT]): olist[oT] {.inline.} = return op.output


type OptionalFromValue* {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalFromValue/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iioptionalFromValue(scope: Scope,
                        components: olist[oall],
                        Toutput_types: ArraySlice[DType]): OptionalFromValue {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalFromValue(*#, #, #)", constructor.}

proc optionalFromValue*(scope: Scope,
                        components: olist[oall],
                        Toutput_types: openArray[DType]): OptionalFromValue =
  return iioptionalFromValue(scope,
                             components,
                             newArraySlice(Toutput_types))

converter optionalFromValueToOut*(op: OptionalFromValue): ovariant {.inline.} = return op.output


type DatasetToGraph* {.header:"../tensorflow/ops/generated.h", importcpp:"DatasetToGraph/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iidatasetToGraph(scope: Scope,
                     input_dataset: ovariant): DatasetToGraph {.header:"../tensorflow/ops/generated.h", importcpp:"DatasetToGraph(*#, #)", constructor.}

proc datasetToGraph*(scope: Scope,
                     input_dataset: ovariant): DatasetToGraph =
  return iidatasetToGraph(scope,
                          input_dataset)

converter datasetToGraphToOut*(op: DatasetToGraph): ostring {.inline.} = return op.output


type ExtractGlimpse* {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractGlimpse/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiextractGlimpse(scope: Scope,
                     input: ofloat,
                     size: oint32,
                     offsets: ofloat,
                     centered: bool,
                     normalized: bool,
                     uniform_noise: bool): ExtractGlimpse {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractGlimpse(*#, #, #, #, #, #, #)", constructor.}

proc extractGlimpse*(scope: Scope,
                     input: ofloat,
                     size: oint32,
                     offsets: ofloat,
                     centered: bool = true,
                     normalized: bool = true,
                     uniform_noise: bool = true): ExtractGlimpse =
  return iiextractGlimpse(scope,
                          input,
                          size,
                          offsets,
                          centered,
                          normalized,
                          uniform_noise)

converter extractGlimpseToOut*(op: ExtractGlimpse): ofloat {.inline.} = return op.output


type ExperimentalDatasetToTFRecord*{.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDatasetToTFRecord/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiexperimentalDatasetToTFRecord(scope: Scope,
                                    input_dataset: ovariant,
                                    filename: ostring,
                                    compression_type: ostring): ExperimentalDatasetToTFRecord {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDatasetToTFRecord(*#, #, #, #)", constructor.}

proc experimentalDatasetToTFRecord*(scope: Scope,
                                    input_dataset: ovariant,
                                    filename: ostring,
                                    compression_type: ostring): ExperimentalDatasetToTFRecord =
  return iiexperimentalDatasetToTFRecord(scope,
                                         input_dataset,
                                         filename,
                                         compression_type)




type ShardedFilespec* {.header:"../tensorflow/ops/generated.h", importcpp:"ShardedFilespec/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iishardedFilespec(scope: Scope,
                      basename: ostring,
                      num_shards: oint32): ShardedFilespec {.header:"../tensorflow/ops/generated.h", importcpp:"ShardedFilespec(*#, #, #)", constructor.}

proc shardedFilespec*(scope: Scope,
                      basename: ostring,
                      num_shards: oint32): ShardedFilespec =
  return iishardedFilespec(scope,
                           basename,
                           num_shards)

converter shardedFilespecToOut*(op: ShardedFilespec): ostring {.inline.} = return op.output

type ResourceApplyCenteredRMSPropT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyCenteredRMSProp*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyCenteredRMSProp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyCenteredRMSProp(scope: Scope,
                                   nvar: oresource,
                                   mg: oresource,
                                   ms: oresource,
                                   mom: oresource,
                                   lr: ResourceApplyCenteredRMSPropT,
                                   rho: ResourceApplyCenteredRMSPropT,
                                   momentum: ResourceApplyCenteredRMSPropT,
                                   epsilon: ResourceApplyCenteredRMSPropT,
                                   grad: ResourceApplyCenteredRMSPropT,
                                   use_locking: bool): ResourceApplyCenteredRMSProp {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyCenteredRMSProp*(scope: Scope,
                                   nvar: oresource,
                                   mg: oresource,
                                   ms: oresource,
                                   mom: oresource,
                                   lr: ResourceApplyCenteredRMSPropT,
                                   rho: ResourceApplyCenteredRMSPropT,
                                   momentum: ResourceApplyCenteredRMSPropT,
                                   epsilon: ResourceApplyCenteredRMSPropT,
                                   grad: ResourceApplyCenteredRMSPropT,
                                   use_locking: bool = false): ResourceApplyCenteredRMSProp =
  return iiresourceApplyCenteredRMSProp(scope,
                                        nvar,
                                        mg,
                                        ms,
                                        mom,
                                        lr,
                                        rho,
                                        momentum,
                                        epsilon,
                                        grad,
                                        use_locking)




type SerializeIterator* {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeIterator/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiserializeIterator(scope: Scope,
                        resource_handle: oresource): SerializeIterator {.header:"../tensorflow/ops/generated.h", importcpp:"SerializeIterator(*#, #)", constructor.}

proc serializeIterator*(scope: Scope,
                        resource_handle: oresource): SerializeIterator =
  return iiserializeIterator(scope,
                             resource_handle)

converter serializeIteratorToOut*(op: SerializeIterator): ovariant {.inline.} = return op.output

type SparseSegmentSqrtNGradTidx* = oint32 | oint64

type SparseSegmentSqrtNGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSqrtNGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentSqrtNGrad[oT: oall](scope: Scope,
                             grad: oT,
                             indices: SparseSegmentSqrtNGradTidx,
                             segment_ids: oint32,
                             output_dim0: oint32,
                             T: DType): SparseSegmentSqrtNGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSqrtNGrad(*#, #, #, #, #, #)", constructor.}

proc sparseSegmentSqrtNGrad*[oT: oall](scope: Scope,
                             grad: oT,
                             indices: SparseSegmentSqrtNGradTidx,
                             segment_ids: oint32,
                             output_dim0: oint32): SparseSegmentSqrtNGrad[oT] =
  return iisparseSegmentSqrtNGrad(scope,
                                  grad,
                                  indices,
                                  segment_ids,
                                  output_dim0,
                                  oT[].oTF)

converter sparseSegmentSqrtNGradToOut*[oT: oall](op: SparseSegmentSqrtNGrad[oT]): oT {.inline.} = return op.output


type VarIsInitializedOp* {.header:"../tensorflow/ops/generated.h", importcpp:"VarIsInitializedOp/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iivarIsInitializedOp(scope: Scope,
                         resource: oresource): VarIsInitializedOp {.header:"../tensorflow/ops/generated.h", importcpp:"VarIsInitializedOp(*#, #)", constructor.}

proc varIsInitializedOp*(scope: Scope,
                         resource: oresource): VarIsInitializedOp =
  return iivarIsInitializedOp(scope,
                              resource)

converter varIsInitializedOpToOut*(op: VarIsInitializedOp): obool {.inline.} = return op.output


type FakeQuantWithMinMaxVarsPerChannel* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannel/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iifakeQuantWithMinMaxVarsPerChannel(scope: Scope,
                                        inputs: ofloat,
                                        min: ofloat,
                                        max: ofloat,
                                        num_bits: int64,
                                        narrow_range: bool): FakeQuantWithMinMaxVarsPerChannel {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannel(*#, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVarsPerChannel*(scope: Scope,
                                        inputs: ofloat,
                                        min: ofloat,
                                        max: ofloat,
                                        num_bits: int64 = 8.int,
                                        narrow_range: bool = false): FakeQuantWithMinMaxVarsPerChannel =
  return iifakeQuantWithMinMaxVarsPerChannel(scope,
                                             inputs,
                                             min,
                                             max,
                                             num_bits,
                                             narrow_range)

converter fakeQuantWithMinMaxVarsPerChannelToOut*(op: FakeQuantWithMinMaxVarsPerChannel): ofloat {.inline.} = return op.output


type WriteAudioSummary*{.header:"../tensorflow/ops/generated.h", importcpp:"WriteAudioSummary/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiwriteAudioSummary(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: ofloat,
                        sample_rate: ofloat,
                        max_outputs: int64): WriteAudioSummary {.header:"../tensorflow/ops/generated.h", importcpp:"WriteAudioSummary(*#, #, #, #, #, #, #)", constructor.}

proc writeAudioSummary*(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: ofloat,
                        sample_rate: ofloat,
                        max_outputs: int64 = 3.int): WriteAudioSummary =
  return iiwriteAudioSummary(scope,
                             writer,
                             step,
                             tag,
                             tensor,
                             sample_rate,
                             max_outputs)




type IteratorFromStringHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorFromStringHandle/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiiteratorFromStringHandle(scope: Scope,
                               string_handle: ostring,
                               output_types: ArraySlice[DType],
                               output_shapes: ArraySlice[TensorShape]): IteratorFromStringHandle {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorFromStringHandle(*#, #, #, #)", constructor.}

proc iteratorFromStringHandle*(scope: Scope,
                               string_handle: ostring,
                               output_types: openArray[DType],
                               output_shapes: openArray[TensorShape]): IteratorFromStringHandle =
  return iiiteratorFromStringHandle(scope,
                                    string_handle,
                                    newArraySlice(output_types),
                                    newArraySlice(output_shapes))

converter iteratorFromStringHandleToOut*(op: IteratorFromStringHandle): oresource {.inline.} = return op.output


type CheckNumerics*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CheckNumerics/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicheckNumerics[oT: oall](scope: Scope,
                    tensor: oT,
                    message: cstring,
                    T: DType): CheckNumerics[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CheckNumerics(*#, #, tensorflow::string(#), #)", constructor.}

proc checkNumerics*[oT: oall](scope: Scope,
                    tensor: oT,
                    message: cstring): CheckNumerics[oT] =
  return iicheckNumerics(scope,
                         tensor,
                         message,
                         oT[].oTF)

converter checkNumericsToOut*[oT: oall](op: CheckNumerics[oT]): oT {.inline.} = return op.output

type BroadcastToTidx* = oint32 | oint64

type BroadcastTo*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BroadcastTo/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibroadcastTo[oT: oall](scope: Scope,
                  input: oT,
                  shape: BroadcastToTidx,
                  T: DType): BroadcastTo[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BroadcastTo(*#, #, #, #)", constructor.}

proc broadcastTo*[oT: oall](scope: Scope,
                  input: oT,
                  shape: BroadcastToTidx): BroadcastTo[oT] =
  return iibroadcastTo(scope,
                       input,
                       shape,
                       oT[].oTF)

converter broadcastToToOut*[oT: oall](op: BroadcastTo[oT]): oT {.inline.} = return op.output


type IteratorToStringHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorToStringHandle/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiiteratorToStringHandle(scope: Scope,
                             resource_handle: oresource): IteratorToStringHandle {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorToStringHandle(*#, #)", constructor.}

proc iteratorToStringHandle*(scope: Scope,
                             resource_handle: oresource): IteratorToStringHandle =
  return iiiteratorToStringHandle(scope,
                                  resource_handle)

converter iteratorToStringHandleToOut*(op: IteratorToStringHandle): ostring {.inline.} = return op.output


type Atanh*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Atanh/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiatanh[oT: oall](scope: Scope,
            x: oT,
            T: DType): Atanh[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Atanh(*#, #, #)", constructor.}

proc atanh*[oT: oall](scope: Scope,
            x: oT): Atanh[oT] =
  return iiatanh(scope,
                 x,
                 oT[].oTF)

converter atanhToOut*[oT: oall](op: Atanh[oT]): oT {.inline.} = return op.output


type MakeIterator*{.header:"../tensorflow/ops/generated.h", importcpp:"MakeIterator/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iimakeIterator(scope: Scope,
                   dataset: ovariant,
                   niterator: oresource): MakeIterator {.header:"../tensorflow/ops/generated.h", importcpp:"MakeIterator(*#, #, #)", constructor.}

proc makeIterator*(scope: Scope,
                   dataset: ovariant,
                   niterator: oresource): MakeIterator =
  return iimakeIterator(scope,
                        dataset,
                        niterator)



type UniqueWithCountsV2Taxis* = oint32 | oint64

type UniqueWithCountsV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UniqueWithCountsV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiuniqueWithCountsV2[oT: oall](scope: Scope,
                         x: oT,
                         axis: UniqueWithCountsV2Taxis,
                         T: DType,
                         out_idx: DType): UniqueWithCountsV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UniqueWithCountsV2(*#, #, #, #, #)", constructor.}

proc uniqueWithCountsV2*[oT: oall](scope: Scope,
                         x: oT,
                         axis: UniqueWithCountsV2Taxis,
                         out_idx: type(oint32) | type(oint64) = oint32): UniqueWithCountsV2[oT] =
  return iiuniqueWithCountsV2(scope,
                              x,
                              axis,
                              oT[].oTF,
                              oT[].oTF)

converter uniqueWithCountsV2ToOut*[oT: oall](op: UniqueWithCountsV2[oT]): oT {.inline.} = return op.output


type AnonymousIterator* {.header:"../tensorflow/ops/generated.h", importcpp:"AnonymousIterator/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iianonymousIterator(scope: Scope,
                        output_types: ArraySlice[DType],
                        output_shapes: ArraySlice[TensorShape]): AnonymousIterator {.header:"../tensorflow/ops/generated.h", importcpp:"AnonymousIterator(*#, #, #)", constructor.}

proc anonymousIterator*(scope: Scope,
                        output_types: openArray[DType],
                        output_shapes: openArray[TensorShape]): AnonymousIterator =
  return iianonymousIterator(scope,
                             newArraySlice(output_types),
                             newArraySlice(output_shapes))

converter anonymousIteratorToOut*(op: AnonymousIterator): oresource {.inline.} = return op.output


type DebugGradientRefIdentity*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DebugGradientRefIdentity/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidebugGradientRefIdentity[oT: oall](scope: Scope,
                               input: oT,
                               T: DType): DebugGradientRefIdentity[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DebugGradientRefIdentity(*#, #, #)", constructor.}

proc debugGradientRefIdentity*[oT: oall](scope: Scope,
                               input: oT): DebugGradientRefIdentity[oT] =
  return iidebugGradientRefIdentity(scope,
                                    input,
                                    oT[].oTF)

converter debugGradientRefIdentityToOut*[oT: oall](op: DebugGradientRefIdentity[oT]): oT {.inline.} = return op.output


type IteratorV2* {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiiteratorV2(scope: Scope,
                 shared_name: cstring,
                 container: cstring,
                 output_types: ArraySlice[DType],
                 output_shapes: ArraySlice[TensorShape]): IteratorV2 {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorV2(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iteratorV2*(scope: Scope,
                 shared_name: cstring,
                 container: cstring,
                 output_types: openArray[DType],
                 output_shapes: openArray[TensorShape]): IteratorV2 =
  return iiiteratorV2(scope,
                      shared_name,
                      container,
                      newArraySlice(output_types),
                      newArraySlice(output_shapes))

converter iteratorV2ToOut*(op: IteratorV2): oresource {.inline.} = return op.output


type ImmutableConst*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ImmutableConst/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiimmutableConst[oT: oall](scope: Scope,
                     memory_region_name: cstring,
                     dtype: DType,
                     shape: TensorShape,
                     explicitT: type(oT)): ImmutableConst[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ImmutableConst(*#, tensorflow::string(#), #, #)", constructor.}

proc immutableConst*(scope: Scope,
                     memory_region_name: cstring,
                     dtype: type = oinvalid,
                     shape: TensorShape = [].shape): auto =
  return iiimmutableConst(scope,
                          memory_region_name,
                          dtype[].oTF,
                          shape,
                          dtype)

converter immutableConstToOut*[oT: oall](op: ImmutableConst[oT]): oT {.inline.} = return op.output


type BoostedTreesQuantileStreamResourceAddSummaries*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceAddSummaries/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesQuantileStreamResourceAddSummaries(scope: Scope,
                                                     quantile_stream_resource_handle: oresource,
                                                     summaries: ofloat,
                                                     num_features: int64): BoostedTreesQuantileStreamResourceAddSummaries {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceAddSummaries(*#, #, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceAddSummaries*(scope: Scope,
                                                     quantile_stream_resource_handle: oresource,
                                                     summaries: ofloat,
                                                     num_features: int64 = 0.int): BoostedTreesQuantileStreamResourceAddSummaries =
  return iiboostedTreesQuantileStreamResourceAddSummaries(scope,
                                                          quantile_stream_resource_handle,
                                                          summaries,
                                                          num_features)




type Iterator* {.header:"../tensorflow/ops/generated.h", importcpp:"Iterator/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiniterator(scope: Scope,
                shared_name: cstring,
                container: cstring,
                output_types: ArraySlice[DType],
                output_shapes: ArraySlice[TensorShape]): Iterator {.header:"../tensorflow/ops/generated.h", importcpp:"Iterator(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc niterator*(scope: Scope,
                shared_name: cstring,
                container: cstring,
                output_types: openArray[DType],
                output_shapes: openArray[TensorShape]): Iterator =
  return iiniterator(scope,
                     shared_name,
                     container,
                     newArraySlice(output_types),
                     newArraySlice(output_shapes))

converter niteratorToOut*(op: Iterator): oresource {.inline.} = return op.output


type Rpc* {.header:"../tensorflow/ops/generated.h", importcpp:"Rpc/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iirpc(scope: Scope,
          address: ostring,
          nmethod: ostring,
          request: ostring,
          protocol: cstring,
          fail_fast: bool,
          timeout_in_ms: int64): Rpc {.header:"../tensorflow/ops/generated.h", importcpp:"Rpc(*#, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc rpc*(scope: Scope,
          address: ostring,
          nmethod: ostring,
          request: ostring,
          protocol: cstring,
          fail_fast: bool = true,
          timeout_in_ms: int64 = 0.int): Rpc =
  return iirpc(scope,
               address,
               nmethod,
               request,
               protocol,
               fail_fast,
               timeout_in_ms)

converter rpcToOut*(op: Rpc): ostring {.inline.} = return op.output


type TFRecordDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"TFRecordDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitFRecordDataset(scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TFRecordDataset {.header:"../tensorflow/ops/generated.h", importcpp:"TFRecordDataset(*#, #, #, #)", constructor.}

proc tFRecordDataset*(scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TFRecordDataset =
  return iitFRecordDataset(scope,
                           filenames,
                           compression_type,
                           buffer_size)

converter tFRecordDatasetToOut*(op: TFRecordDataset): ovariant {.inline.} = return op.output

type SparseReduceMaxSparseT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseReduceMaxSparse* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceMaxSparse/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseReduceMaxSparse(scope: Scope,
                            input_indices: oint64,
                            input_values: SparseReduceMaxSparseT,
                            input_shape: oint64,
                            reduction_axes: oint32,
                            keep_dims: bool): SparseReduceMaxSparse {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceMaxSparse(*#, #, #, #, #, #)", constructor.}

proc sparseReduceMaxSparse*(scope: Scope,
                            input_indices: oint64,
                            input_values: SparseReduceMaxSparseT,
                            input_shape: oint64,
                            reduction_axes: oint32,
                            keep_dims: bool = false): SparseReduceMaxSparse =
  return iisparseReduceMaxSparse(scope,
                                 input_indices,
                                 input_values,
                                 input_shape,
                                 reduction_axes,
                                 keep_dims)

converter sparseReduceMaxSparseToOut*(op: SparseReduceMaxSparse): oint64 {.inline.} = return op.output


type CacheDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"CacheDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iicacheDataset(scope: Scope,
                   input_dataset: ovariant,
                   filename: ostring,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): CacheDataset {.header:"../tensorflow/ops/generated.h", importcpp:"CacheDataset(*#, #, #, #, #)", constructor.}

proc cacheDataset*(scope: Scope,
                   input_dataset: ovariant,
                   filename: ostring,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): CacheDataset =
  return iicacheDataset(scope,
                        input_dataset,
                        filename,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter cacheDatasetToOut*(op: CacheDataset): ovariant {.inline.} = return op.output


type MaxPoolV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolV2[oT: oall](scope: Scope,
                input: oT,
                ksize: oint32,
                strides: oint32,
                padding: cstring,
                T: DType,
                data_format: cstring): MaxPoolV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolV2(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc maxPoolV2*[oT: oall](scope: Scope,
                input: oT,
                ksize: oint32,
                strides: oint32,
                padding: cstring,
                data_format: cstring = "NHWC"): MaxPoolV2[oT] =
  return iimaxPoolV2(scope,
                     input,
                     ksize,
                     strides,
                     padding,
                     oT[].oTF,
                     data_format)

converter maxPoolV2ToOut*[oT: oall](op: MaxPoolV2[oT]): oT {.inline.} = return op.output

type QuantizedMulT1* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedMulT2* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedMul[oT: oall](scope: Scope,
                   x: QuantizedMulT1,
                   y: QuantizedMulT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat,
                   Toutput: DType,
                   explicitT: type(oT)): QuantizedMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedMul(*#, #, #, #, #, #, #, #)", constructor.}

proc quantizedMul*(scope: Scope,
                   x: QuantizedMulT1,
                   y: QuantizedMulT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat,
                   Toutput: type = oqint32): auto =
  return iiquantizedMul(scope,
                        x,
                        y,
                        min_x,
                        max_x,
                        min_y,
                        max_y,
                        Toutput[].oTF,
                        Toutput)

converter quantizedMulToOut*[oT: oall](op: QuantizedMul[oT]): oT {.inline.} = return op.output


type ShuffleAndRepeatDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ShuffleAndRepeatDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iishuffleAndRepeatDataset(scope: Scope,
                              input_dataset: ovariant,
                              buffer_size: oint64,
                              seed: oint64,
                              seed2: oint64,
                              count: oint64,
                              output_types: ArraySlice[DType],
                              output_shapes: ArraySlice[TensorShape]): ShuffleAndRepeatDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ShuffleAndRepeatDataset(*#, #, #, #, #, #, #, #)", constructor.}

proc shuffleAndRepeatDataset*(scope: Scope,
                              input_dataset: ovariant,
                              buffer_size: oint64,
                              seed: oint64,
                              seed2: oint64,
                              count: oint64,
                              output_types: openArray[DType],
                              output_shapes: openArray[TensorShape]): ShuffleAndRepeatDataset =
  return iishuffleAndRepeatDataset(scope,
                                   input_dataset,
                                   buffer_size,
                                   seed,
                                   seed2,
                                   count,
                                   newArraySlice(output_types),
                                   newArraySlice(output_shapes))

converter shuffleAndRepeatDatasetToOut*(op: ShuffleAndRepeatDataset): ovariant {.inline.} = return op.output

type INcclBroadcastSendT* = ohalf | ofloat | odouble | oint32 | oint64

type INcclBroadcastSend*{.header:"../tensorflow/ops/generated.h", importcpp:"_NcclBroadcastSend/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiiNcclBroadcastSend(scope: Scope,
                         input: INcclBroadcastSendT,
                         shared_name: cstring,
                         num_devices: int64): INcclBroadcastSend {.header:"../tensorflow/ops/generated.h", importcpp:"_NcclBroadcastSend(*#, #, tensorflow::string(#), #)", constructor.}

proc iNcclBroadcastSend*(scope: Scope,
                         input: INcclBroadcastSendT,
                         shared_name: cstring,
                         num_devices: int64 = 0.int): INcclBroadcastSend =
  return iiiNcclBroadcastSend(scope,
                              input,
                              shared_name,
                              num_devices)




type CudnnRNN*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNN/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNN[oT: oall](scope: Scope,
               input: oT,
               input_h: oT,
               input_c: oT,
               params: oT,
               T: DType,
               rnn_mode: cstring,
               input_mode: cstring,
               direction: cstring,
               dropout: float32,
               seed: int64,
               seed2: int64,
               is_training: bool): CudnnRNN[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNN(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc cudnnRNN*[oT: oall](scope: Scope,
               input: oT,
               input_h: oT,
               input_c: oT,
               params: oT,
               rnn_mode: cstring = "lstm",
               input_mode: cstring = "linear_input",
               direction: cstring = "unidirectional",
               dropout: float32 = 0.0.float32,
               seed: int64 = 0.int,
               seed2: int64 = 0.int,
               is_training: bool = true): CudnnRNN[oT] =
  return iicudnnRNN(scope,
                    input,
                    input_h,
                    input_c,
                    params,
                    oT[].oTF,
                    rnn_mode,
                    input_mode,
                    direction,
                    dropout,
                    seed,
                    seed2,
                    is_training)

converter cudnnRNNToOut*[oT: oall](op: CudnnRNN[oT]): oT {.inline.} = return op.output


type BatchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iibatchDataset(scope: Scope,
                   input_dataset: ovariant,
                   batch_size: oint64,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): BatchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"BatchDataset(*#, #, #, #, #)", constructor.}

proc batchDataset*(scope: Scope,
                   input_dataset: ovariant,
                   batch_size: oint64,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): BatchDataset =
  return iibatchDataset(scope,
                        input_dataset,
                        batch_size,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter batchDatasetToOut*(op: BatchDataset): ovariant {.inline.} = return op.output


type SoftsignGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SoftsignGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisoftsignGrad[oT: oall](scope: Scope,
                   gradients: oT,
                   features: oT,
                   T: DType): SoftsignGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SoftsignGrad(*#, #, #, #)", constructor.}

proc softsignGrad*[oT: oall](scope: Scope,
                   gradients: oT,
                   features: oT): SoftsignGrad[oT] =
  return iisoftsignGrad(scope,
                        gradients,
                        features,
                        oT[].oTF)

converter softsignGradToOut*[oT: oall](op: SoftsignGrad[oT]): oT {.inline.} = return op.output

type SetSizeT* = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type SetSize* {.header:"../tensorflow/ops/generated.h", importcpp:"SetSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iisetSize(scope: Scope,
              set_indices: oint64,
              set_values: SetSizeT,
              set_shape: oint64,
              validate_indices: bool): SetSize {.header:"../tensorflow/ops/generated.h", importcpp:"SetSize(*#, #, #, #, #)", constructor.}

proc setSize*(scope: Scope,
              set_indices: oint64,
              set_values: SetSizeT,
              set_shape: oint64,
              validate_indices: bool = true): SetSize =
  return iisetSize(scope,
                   set_indices,
                   set_values,
                   set_shape,
                   validate_indices)

converter setSizeToOut*(op: SetSize): oint32 {.inline.} = return op.output


type WindowDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"WindowDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiwindowDataset(scope: Scope,
                    input_dataset: ovariant,
                    size: oint64,
                    shift: oint64,
                    stride: oint64,
                    drop_remainder: obool,
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): WindowDataset {.header:"../tensorflow/ops/generated.h", importcpp:"WindowDataset(*#, #, #, #, #, #, #, #)", constructor.}

proc windowDataset*(scope: Scope,
                    input_dataset: ovariant,
                    size: oint64,
                    shift: oint64,
                    stride: oint64,
                    drop_remainder: obool,
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): WindowDataset =
  return iiwindowDataset(scope,
                         input_dataset,
                         size,
                         shift,
                         stride,
                         drop_remainder,
                         newArraySlice(output_types),
                         newArraySlice(output_shapes))

converter windowDatasetToOut*(op: WindowDataset): ovariant {.inline.} = return op.output

type ResourceApplyRMSPropT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyRMSProp*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyRMSProp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyRMSProp(scope: Scope,
                           nvar: oresource,
                           ms: oresource,
                           mom: oresource,
                           lr: ResourceApplyRMSPropT,
                           rho: ResourceApplyRMSPropT,
                           momentum: ResourceApplyRMSPropT,
                           epsilon: ResourceApplyRMSPropT,
                           grad: ResourceApplyRMSPropT,
                           use_locking: bool): ResourceApplyRMSProp {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyRMSProp(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyRMSProp*(scope: Scope,
                           nvar: oresource,
                           ms: oresource,
                           mom: oresource,
                           lr: ResourceApplyRMSPropT,
                           rho: ResourceApplyRMSPropT,
                           momentum: ResourceApplyRMSPropT,
                           epsilon: ResourceApplyRMSPropT,
                           grad: ResourceApplyRMSPropT,
                           use_locking: bool = false): ResourceApplyRMSProp =
  return iiresourceApplyRMSProp(scope,
                                nvar,
                                ms,
                                mom,
                                lr,
                                rho,
                                momentum,
                                epsilon,
                                grad,
                                use_locking)



type MaxPool3DGradTInput* = ohalf | obfloat16 | ofloat

type MaxPool3DGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool3DGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPool3DGrad[oT: oall](scope: Scope,
                    orig_input: MaxPool3DGradTInput,
                    orig_output: MaxPool3DGradTInput,
                    grad: oT,
                    ksize: ArraySlice[int],
                    strides: ArraySlice[int],
                    padding: cstring,
                    data_format: cstring,
                    T: DType): MaxPool3DGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool3DGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc maxPool3DGrad*[oT: oall](scope: Scope,
                    orig_input: MaxPool3DGradTInput,
                    orig_output: MaxPool3DGradTInput,
                    grad: oT,
                    ksize: openArray[int],
                    strides: openArray[int],
                    padding: cstring,
                    data_format: cstring = "NDHWC"): MaxPool3DGrad[oT] =
  return iimaxPool3DGrad(scope,
                         orig_input,
                         orig_output,
                         grad,
                         newArraySlice(ksize),
                         newArraySlice(strides),
                         padding,
                         data_format,
                         oT[].oTF)

converter maxPool3DGradToOut*[oT: oall](op: MaxPool3DGrad[oT]): oT {.inline.} = return op.output


type InterleaveDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"InterleaveDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiinterleaveDataset(scope: Scope,
                        input_dataset: ovariant,
                        other_arguments: olist[oall],
                        cycle_length: oint64,
                        block_length: oint64,
                        f: NameAttrList,
                        Targuments: ArraySlice[DType],
                        output_types: ArraySlice[DType],
                        output_shapes: ArraySlice[TensorShape]): InterleaveDataset {.header:"../tensorflow/ops/generated.h", importcpp:"InterleaveDataset(*#, #, #, #, #, #, #, #, #)", constructor.}

proc interleaveDataset*(scope: Scope,
                        input_dataset: ovariant,
                        other_arguments: olist[oall],
                        cycle_length: oint64,
                        block_length: oint64,
                        f: NameAttrList,
                        Targuments: openArray[DType],
                        output_types: openArray[DType],
                        output_shapes: openArray[TensorShape]): InterleaveDataset =
  return iiinterleaveDataset(scope,
                             input_dataset,
                             other_arguments,
                             cycle_length,
                             block_length,
                             f,
                             newArraySlice(Targuments),
                             newArraySlice(output_types),
                             newArraySlice(output_shapes))

converter interleaveDatasetToOut*(op: InterleaveDataset): ovariant {.inline.} = return op.output


type TanhGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TanhGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitanhGrad[oT: oall](scope: Scope,
               y: oT,
               dy: oT,
               T: DType): TanhGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TanhGrad(*#, #, #, #)", constructor.}

proc tanhGrad*[oT: oall](scope: Scope,
               y: oT,
               dy: oT): TanhGrad[oT] =
  return iitanhGrad(scope,
                    y,
                    dy,
                    oT[].oTF)

converter tanhGradToOut*[oT: oall](op: TanhGrad[oT]): oT {.inline.} = return op.output


type BoostedTreesTrainingPredict* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesTrainingPredict/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiboostedTreesTrainingPredict(scope: Scope,
                                  tree_ensemble_handle: oresource,
                                  cached_tree_ids: oint32,
                                  cached_node_ids: oint32,
                                  bucketized_features: oint32,
                                  num_bucketized_features: int64,
                                  logits_dimension: int64): BoostedTreesTrainingPredict {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesTrainingPredict(*#, #, #, #, #, #, #)", constructor.}

proc boostedTreesTrainingPredict*(scope: Scope,
                                  tree_ensemble_handle: oresource,
                                  cached_tree_ids: oint32,
                                  cached_node_ids: oint32,
                                  bucketized_features: oint32,
                                  num_bucketized_features: int64 = 0.int,
                                  logits_dimension: int64 = 0.int): BoostedTreesTrainingPredict =
  return iiboostedTreesTrainingPredict(scope,
                                       tree_ensemble_handle,
                                       cached_tree_ids,
                                       cached_node_ids,
                                       bucketized_features,
                                       num_bucketized_features,
                                       logits_dimension)

converter boostedTreesTrainingPredictToOut*(op: BoostedTreesTrainingPredict): ofloat {.inline.} = return op.output


type LoopCond* {.header:"../tensorflow/ops/generated.h", importcpp:"LoopCond/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiloopCond(scope: Scope,
               input: obool): LoopCond {.header:"../tensorflow/ops/generated.h", importcpp:"LoopCond(*#, #)", constructor.}

proc loopCond*(scope: Scope,
               input: obool): LoopCond =
  return iiloopCond(scope,
                    input)

converter loopCondToOut*(op: LoopCond): obool {.inline.} = return op.output


type ParallelMapDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelMapDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiparallelMapDataset(scope: Scope,
                         input_dataset: ovariant,
                         other_arguments: olist[oall],
                         num_parallel_calls: oint32,
                         f: NameAttrList,
                         Targuments: ArraySlice[DType],
                         output_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape],
                         use_inter_op_parallelism: bool,
                         sloppy: bool,
                         preserve_cardinality: bool): ParallelMapDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelMapDataset(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parallelMapDataset*(scope: Scope,
                         input_dataset: ovariant,
                         other_arguments: olist[oall],
                         num_parallel_calls: oint32,
                         f: NameAttrList,
                         Targuments: openArray[DType],
                         output_types: openArray[DType],
                         output_shapes: openArray[TensorShape],
                         use_inter_op_parallelism: bool = true,
                         sloppy: bool = false,
                         preserve_cardinality: bool = false): ParallelMapDataset =
  return iiparallelMapDataset(scope,
                              input_dataset,
                              other_arguments,
                              num_parallel_calls,
                              f,
                              newArraySlice(Targuments),
                              newArraySlice(output_types),
                              newArraySlice(output_shapes),
                              use_inter_op_parallelism,
                              sloppy,
                              preserve_cardinality)

converter parallelMapDatasetToOut*(op: ParallelMapDataset): ovariant {.inline.} = return op.output


type ReciprocalGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ReciprocalGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireciprocalGrad[oT: oall](scope: Scope,
                     y: oT,
                     dy: oT,
                     T: DType): ReciprocalGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ReciprocalGrad(*#, #, #, #)", constructor.}

proc reciprocalGrad*[oT: oall](scope: Scope,
                     y: oT,
                     dy: oT): ReciprocalGrad[oT] =
  return iireciprocalGrad(scope,
                          y,
                          dy,
                          oT[].oTF)

converter reciprocalGradToOut*[oT: oall](op: ReciprocalGrad[oT]): oT {.inline.} = return op.output

type QuantizedReshapeTshape* = oint32 | oint64

type QuantizedReshape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedReshape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedReshape[oT: oall](scope: Scope,
                       tensor: oT,
                       shape: QuantizedReshapeTshape,
                       input_min: ofloat,
                       input_max: ofloat,
                       T: DType): QuantizedReshape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedReshape(*#, #, #, #, #, #)", constructor.}

proc quantizedReshape*[oT: oall](scope: Scope,
                       tensor: oT,
                       shape: QuantizedReshapeTshape,
                       input_min: ofloat,
                       input_max: ofloat): QuantizedReshape[oT] =
  return iiquantizedReshape(scope,
                            tensor,
                            shape,
                            input_min,
                            input_max,
                            oT[].oTF)

converter quantizedReshapeToOut*[oT: oall](op: QuantizedReshape[oT]): oT {.inline.} = return op.output


type MapDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"MapDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iimapDataset(scope: Scope,
                 input_dataset: ovariant,
                 other_arguments: olist[oall],
                 f: NameAttrList,
                 Targuments: ArraySlice[DType],
                 output_types: ArraySlice[DType],
                 output_shapes: ArraySlice[TensorShape],
                 use_inter_op_parallelism: bool,
                 preserve_cardinality: bool): MapDataset {.header:"../tensorflow/ops/generated.h", importcpp:"MapDataset(*#, #, #, #, #, #, #, #, #)", constructor.}

proc mapDataset*(scope: Scope,
                 input_dataset: ovariant,
                 other_arguments: olist[oall],
                 f: NameAttrList,
                 Targuments: openArray[DType],
                 output_types: openArray[DType],
                 output_shapes: openArray[TensorShape],
                 use_inter_op_parallelism: bool = true,
                 preserve_cardinality: bool = false): MapDataset =
  return iimapDataset(scope,
                      input_dataset,
                      other_arguments,
                      f,
                      newArraySlice(Targuments),
                      newArraySlice(output_types),
                      newArraySlice(output_shapes),
                      use_inter_op_parallelism,
                      preserve_cardinality)

converter mapDatasetToOut*(op: MapDataset): ovariant {.inline.} = return op.output


type SkipDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"SkipDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiskipDataset(scope: Scope,
                  input_dataset: ovariant,
                  count: oint64,
                  output_types: ArraySlice[DType],
                  output_shapes: ArraySlice[TensorShape]): SkipDataset {.header:"../tensorflow/ops/generated.h", importcpp:"SkipDataset(*#, #, #, #, #)", constructor.}

proc skipDataset*(scope: Scope,
                  input_dataset: ovariant,
                  count: oint64,
                  output_types: openArray[DType],
                  output_shapes: openArray[TensorShape]): SkipDataset =
  return iiskipDataset(scope,
                       input_dataset,
                       count,
                       newArraySlice(output_types),
                       newArraySlice(output_shapes))

converter skipDatasetToOut*(op: SkipDataset): ovariant {.inline.} = return op.output


type Conv2DBackpropFilter*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv2DBackpropFilter/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv2DBackpropFilter[oT: oall](scope: Scope,
                           input: oT,
                           filter_sizes: oint32,
                           out_backprop: oT,
                           strides: ArraySlice[int],
                           padding: cstring,
                           T: DType,
                           use_cudnn_on_gpu: bool,
                           data_format: cstring,
                           dilations: ArraySlice[int]): Conv2DBackpropFilter[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv2DBackpropFilter(*#, #, #, #, #, tensorflow::string(#), #, #, tensorflow::string(#), #)", constructor.}

proc conv2DBackpropFilter*[oT: oall](scope: Scope,
                           input: oT,
                           filter_sizes: oint32,
                           out_backprop: oT,
                           strides: openArray[int],
                           padding: cstring,
                           use_cudnn_on_gpu: bool = true,
                           data_format: cstring = "NHWC",
                           dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int]): Conv2DBackpropFilter[oT] =
  return iiconv2DBackpropFilter(scope,
                                input,
                                filter_sizes,
                                out_backprop,
                                newArraySlice(strides),
                                padding,
                                oT[].oTF,
                                use_cudnn_on_gpu,
                                data_format,
                                newArraySlice(dilations))

converter conv2DBackpropFilterToOut*[oT: oall](op: Conv2DBackpropFilter[oT]): oT {.inline.} = return op.output


type IteratorGetNextSync*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorGetNextSync/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiteratorGetNextSync[oT: oall](scope: Scope,
                          niterator: oresource,
                          output_types: ArraySlice[DType],
                          output_shapes: ArraySlice[TensorShape],
                          explicitT: type(oT)): IteratorGetNextSync[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorGetNextSync(*#, #, #, #)", constructor.}

proc iteratorGetNextSync*(scope: Scope,
                          niterator: oresource,
                          output_types: openArray[DType],
                          output_shapes: openArray[TensorShape],
                          explicitT: type): auto =
  return iiiteratorGetNextSync(scope,
                               niterator,
                               newArraySlice(output_types),
                               newArraySlice(output_shapes),
                               explicitT)

converter iteratorGetNextSyncToOutList*[oT: oall](op: IteratorGetNextSync[oT]): olist[oT] {.inline.} = return op.output


type ReaderNumRecordsProduced* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumRecordsProduced/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iireaderNumRecordsProduced(scope: Scope,
                               reader_handle: ostring): ReaderNumRecordsProduced {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderNumRecordsProduced(*#, #)", constructor.}

proc readerNumRecordsProduced*(scope: Scope,
                               reader_handle: ostring): ReaderNumRecordsProduced =
  return iireaderNumRecordsProduced(scope,
                                    reader_handle)

converter readerNumRecordsProducedToOut*(op: ReaderNumRecordsProduced): oint64 {.inline.} = return op.output


type ModelDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ModelDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iimodelDataset(scope: Scope,
                   input_dataset: ovariant,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): ModelDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ModelDataset(*#, #, #, #)", constructor.}

proc modelDataset*(scope: Scope,
                   input_dataset: ovariant,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): ModelDataset =
  return iimodelDataset(scope,
                        input_dataset,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter modelDatasetToOut*(op: ModelDataset): ovariant {.inline.} = return op.output


type ReaderReadUpToV2* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReadUpToV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireaderReadUpToV2(scope: Scope,
                       reader_handle: oresource,
                       queue_handle: oresource,
                       num_records: oint64): ReaderReadUpToV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReadUpToV2(*#, #, #, #)", constructor.}

proc readerReadUpToV2*(scope: Scope,
                       reader_handle: oresource,
                       queue_handle: oresource,
                       num_records: oint64): ReaderReadUpToV2 =
  return iireaderReadUpToV2(scope,
                            reader_handle,
                            queue_handle,
                            num_records)

converter readerReadUpToV2ToOut*(op: ReaderReadUpToV2): ostring {.inline.} = return op.output


type QueueDequeueV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiqueueDequeueV2[oT: oall](scope: Scope,
                     handle: oresource,
                     component_types: ArraySlice[DType],
                     timeout_ms: int64,
                     explicitT: type(oT)): QueueDequeueV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueV2(*#, #, #, #)", constructor.}

proc queueDequeueV2*(scope: Scope,
                     handle: oresource,
                     component_types: openArray[DType],
                     timeout_ms: int64 = -1.int,
                     explicitT: type): auto =
  return iiqueueDequeueV2(scope,
                          handle,
                          newArraySlice(component_types),
                          timeout_ms,
                          explicitT)

converter queueDequeueV2ToOutList*[oT: oall](op: QueueDequeueV2[oT]): olist[oT] {.inline.} = return op.output


type ReaderReadUpTo* {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReadUpTo/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iireaderReadUpTo(scope: Scope,
                     reader_handle: ostring,
                     queue_handle: ostring,
                     num_records: oint64): ReaderReadUpTo {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReadUpTo(*#, #, #, #)", constructor.}

proc readerReadUpTo*(scope: Scope,
                     reader_handle: ostring,
                     queue_handle: ostring,
                     num_records: oint64): ReaderReadUpTo =
  return iireaderReadUpTo(scope,
                          reader_handle,
                          queue_handle,
                          num_records)

converter readerReadUpToToOut*(op: ReaderReadUpTo): ostring {.inline.} = return op.output


type Unpack*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Unpack/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunpack[oT: oall](scope: Scope,
             value: oT,
             num: int64,
             T: DType,
             axis: int64): Unpack[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Unpack(*#, #, #, #, #)", constructor.}

proc unpack*[oT: oall](scope: Scope,
             value: oT,
             num: int64 = 0.int,
             axis: int64 = 0.int): Unpack[oT] =
  return iiunpack(scope,
                  value,
                  num,
                  oT[].oTF,
                  axis)

converter unpackToOut*[oT: oall](op: Unpack[oT]): oT {.inline.} = return op.output


type ConcatenateDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ConcatenateDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiconcatenateDataset(scope: Scope,
                         input_dataset: ovariant,
                         another_dataset: ovariant,
                         output_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape]): ConcatenateDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ConcatenateDataset(*#, #, #, #, #)", constructor.}

proc concatenateDataset*(scope: Scope,
                         input_dataset: ovariant,
                         another_dataset: ovariant,
                         output_types: openArray[DType],
                         output_shapes: openArray[TensorShape]): ConcatenateDataset =
  return iiconcatenateDataset(scope,
                              input_dataset,
                              another_dataset,
                              newArraySlice(output_types),
                              newArraySlice(output_shapes))

converter concatenateDatasetToOut*(op: ConcatenateDataset): ovariant {.inline.} = return op.output


type PlaceholderV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PlaceholderV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiplaceholderV2[oT: oall](scope: Scope,
                    dtype: DType,
                    shape: TensorShape,
                    explicitT: type(oT)): PlaceholderV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PlaceholderV2(*#, #, #)", constructor.}

proc placeholderV2*(scope: Scope,
                    dtype: type = oinvalid,
                    shape: TensorShape = [].shape): auto =
  return iiplaceholderV2(scope,
                         dtype[].oTF,
                         shape,
                         dtype)

converter placeholderV2ToOut*[oT: oall](op: PlaceholderV2[oT]): oT {.inline.} = return op.output


type GeneratorDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"GeneratorDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iigeneratorDataset(scope: Scope,
                       init_func_other_args: olist[oall],
                       next_func_other_args: olist[oall],
                       finalize_func_other_args: olist[oall],
                       init_func: NameAttrList,
                       next_func: NameAttrList,
                       finalize_func: NameAttrList,
                       Tinit_func_args: ArraySlice[DType],
                       Tnext_func_args: ArraySlice[DType],
                       Tfinalize_func_args: ArraySlice[DType],
                       output_types: ArraySlice[DType],
                       output_shapes: ArraySlice[TensorShape]): GeneratorDataset {.header:"../tensorflow/ops/generated.h", importcpp:"GeneratorDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc generatorDataset*(scope: Scope,
                       init_func_other_args: olist[oall],
                       next_func_other_args: olist[oall],
                       finalize_func_other_args: olist[oall],
                       init_func: NameAttrList,
                       next_func: NameAttrList,
                       finalize_func: NameAttrList,
                       Tinit_func_args: openArray[DType],
                       Tnext_func_args: openArray[DType],
                       Tfinalize_func_args: openArray[DType],
                       output_types: openArray[DType],
                       output_shapes: openArray[TensorShape]): GeneratorDataset =
  return iigeneratorDataset(scope,
                            init_func_other_args,
                            next_func_other_args,
                            finalize_func_other_args,
                            init_func,
                            next_func,
                            finalize_func,
                            newArraySlice(Tinit_func_args),
                            newArraySlice(Tnext_func_args),
                            newArraySlice(Tfinalize_func_args),
                            newArraySlice(output_types),
                            newArraySlice(output_shapes))

converter generatorDatasetToOut*(op: GeneratorDataset): ovariant {.inline.} = return op.output


type TensorSliceDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorSliceDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorSliceDataset(scope: Scope,
                         components: olist[oall],
                         Toutput_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape]): TensorSliceDataset {.header:"../tensorflow/ops/generated.h", importcpp:"TensorSliceDataset(*#, #, #, #)", constructor.}

proc tensorSliceDataset*(scope: Scope,
                         components: olist[oall],
                         Toutput_types: openArray[DType],
                         output_shapes: openArray[TensorShape]): TensorSliceDataset =
  return iitensorSliceDataset(scope,
                              components,
                              newArraySlice(Toutput_types),
                              newArraySlice(output_shapes))

converter tensorSliceDatasetToOut*(op: TensorSliceDataset): ovariant {.inline.} = return op.output


type StringToHashBucket* {.header:"../tensorflow/ops/generated.h", importcpp:"StringToHashBucket/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iistringToHashBucket(scope: Scope,
                         string_tensor: ostring,
                         num_buckets: int64): StringToHashBucket {.header:"../tensorflow/ops/generated.h", importcpp:"StringToHashBucket(*#, #, #)", constructor.}

proc stringToHashBucket*(scope: Scope,
                         string_tensor: ostring,
                         num_buckets: int64 = 0.int): StringToHashBucket =
  return iistringToHashBucket(scope,
                              string_tensor,
                              num_buckets)

converter stringToHashBucketToOut*(op: StringToHashBucket): oint64 {.inline.} = return op.output


type Softsign*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Softsign/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisoftsign[oT: oall](scope: Scope,
               features: oT,
               T: DType): Softsign[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Softsign(*#, #, #)", constructor.}

proc softsign*[oT: oall](scope: Scope,
               features: oT): Softsign[oT] =
  return iisoftsign(scope,
                    features,
                    oT[].oTF)

converter softsignToOut*[oT: oall](op: Softsign[oT]): oT {.inline.} = return op.output

type QuantizedAddT1* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedAddT2* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedAdd[oT: oall](scope: Scope,
                   x: QuantizedAddT1,
                   y: QuantizedAddT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat,
                   Toutput: DType,
                   explicitT: type(oT)): QuantizedAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedAdd(*#, #, #, #, #, #, #, #)", constructor.}

proc quantizedAdd*(scope: Scope,
                   x: QuantizedAddT1,
                   y: QuantizedAddT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat,
                   Toutput: type = oqint32): auto =
  return iiquantizedAdd(scope,
                        x,
                        y,
                        min_x,
                        max_x,
                        min_y,
                        max_y,
                        Toutput[].oTF,
                        Toutput)

converter quantizedAddToOut*[oT: oall](op: QuantizedAdd[oT]): oT {.inline.} = return op.output


type RandomShuffleQueueV2* {.header:"../tensorflow/ops/generated.h", importcpp:"RandomShuffleQueueV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iirandomShuffleQueueV2(scope: Scope,
                           component_types: ArraySlice[DType],
                           shapes: ArraySlice[TensorShape],
                           container: cstring,
                           shared_name: cstring,
                           capacity: int64,
                           min_after_dequeue: int64,
                           seed: int64,
                           seed2: int64): RandomShuffleQueueV2 {.header:"../tensorflow/ops/generated.h", importcpp:"RandomShuffleQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc randomShuffleQueueV2*(scope: Scope,
                           component_types: openArray[DType],
                           shapes: openArray[TensorShape],
                           container: cstring,
                           shared_name: cstring,
                           capacity: int64 = -1.int,
                           min_after_dequeue: int64 = 0.int,
                           seed: int64 = 0.int,
                           seed2: int64 = 0.int): RandomShuffleQueueV2 =
  return iirandomShuffleQueueV2(scope,
                                newArraySlice(component_types),
                                newArraySlice(shapes),
                                container,
                                shared_name,
                                capacity,
                                min_after_dequeue,
                                seed,
                                seed2)

converter randomShuffleQueueV2ToOut*(op: RandomShuffleQueueV2): oresource {.inline.} = return op.output

type SparseTensorSliceDatasetTvalues* = oall

type SparseTensorSliceDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseTensorSliceDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iisparseTensorSliceDataset(scope: Scope,
                               indices: oint64,
                               values: SparseTensorSliceDatasetTvalues,
                               dense_shape: oint64): SparseTensorSliceDataset {.header:"../tensorflow/ops/generated.h", importcpp:"SparseTensorSliceDataset(*#, #, #, #)", constructor.}

proc sparseTensorSliceDataset*(scope: Scope,
                               indices: oint64,
                               values: SparseTensorSliceDatasetTvalues,
                               dense_shape: oint64): SparseTensorSliceDataset =
  return iisparseTensorSliceDataset(scope,
                                    indices,
                                    values,
                                    dense_shape)

converter sparseTensorSliceDatasetToOut*(op: SparseTensorSliceDataset): ovariant {.inline.} = return op.output


type TensorDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorDataset(scope: Scope,
                    components: olist[oall],
                    Toutput_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): TensorDataset {.header:"../tensorflow/ops/generated.h", importcpp:"TensorDataset(*#, #, #, #)", constructor.}

proc tensorDataset*(scope: Scope,
                    components: olist[oall],
                    Toutput_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): TensorDataset =
  return iitensorDataset(scope,
                         components,
                         newArraySlice(Toutput_types),
                         newArraySlice(output_shapes))

converter tensorDatasetToOut*(op: TensorDataset): ovariant {.inline.} = return op.output


type TensorListElementShape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListElementShape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorListElementShape[oT: oall](scope: Scope,
                             input_handle: ovariant,
                             shape_type: DType,
                             explicitT: type(oT)): TensorListElementShape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListElementShape(*#, #, #)", constructor.}

proc tensorListElementShape*(scope: Scope,
                             input_handle: ovariant,
                             shape_type: type = oinvalid): auto =
  return iitensorListElementShape(scope,
                                  input_handle,
                                  shape_type[].oTF,
                                  shape_type)

converter tensorListElementShapeToOut*[oT: oall](op: TensorListElementShape[oT]): oT {.inline.} = return op.output


type NcclReduce*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"NcclReduce/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iincclReduce[oT: oall](scope: Scope,
                 input: oT,
                 reduction: cstring,
                 T: DType,
                 num_devices: int64): NcclReduce[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"NcclReduce(*#, #, tensorflow::string(#), #, #)", constructor.}

proc ncclReduce*[oT: oall](scope: Scope,
                 input: oT,
                 reduction: cstring,
                 num_devices: int64 = 0.int): NcclReduce[oT] =
  return iincclReduce(scope,
                      input,
                      reduction,
                      oT[].oTF,
                      num_devices)

converter ncclReduceToOut*[oT: oall](op: NcclReduce[oT]): oT {.inline.} = return op.output


type ApplyProximalAdagrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyProximalAdagrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyProximalAdagrad[oT: oall](scope: Scope,
                           nvar: oT,
                           accum: oT,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           grad: oT,
                           T: DType,
                           use_locking: bool): ApplyProximalAdagrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyProximalAdagrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc applyProximalAdagrad*[oT: oall](scope: Scope,
                           nvar: oT,
                           accum: oT,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           grad: oT,
                           use_locking: bool = false): ApplyProximalAdagrad[oT] =
  return iiapplyProximalAdagrad(scope,
                                nvar,
                                accum,
                                lr,
                                l1,
                                l2,
                                grad,
                                oT[].oTF,
                                use_locking)

converter applyProximalAdagradToOut*[oT: oall](op: ApplyProximalAdagrad[oT]): oT {.inline.} = return op.output


type Svd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Svd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisvd[oT: oall](scope: Scope,
          input: oT,
          compute_uv: bool,
          full_matrices: bool,
          T: DType): Svd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Svd(*#, #, #, #, #)", constructor.}

proc svd*[oT: oall](scope: Scope,
          input: oT,
          compute_uv: bool = true,
          full_matrices: bool = false): Svd[oT] =
  return iisvd(scope,
               input,
               compute_uv,
               full_matrices,
               oT[].oTF)

converter svdToOut*[oT: oall](op: Svd[oT]): oT {.inline.} = return op.output

type SparseSegmentMeanGradTidx* = oint32 | oint64

type SparseSegmentMeanGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentMeanGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentMeanGrad[oT: oall](scope: Scope,
                            grad: oT,
                            indices: SparseSegmentMeanGradTidx,
                            segment_ids: oint32,
                            output_dim0: oint32,
                            T: DType): SparseSegmentMeanGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentMeanGrad(*#, #, #, #, #, #)", constructor.}

proc sparseSegmentMeanGrad*[oT: oall](scope: Scope,
                            grad: oT,
                            indices: SparseSegmentMeanGradTidx,
                            segment_ids: oint32,
                            output_dim0: oint32): SparseSegmentMeanGrad[oT] =
  return iisparseSegmentMeanGrad(scope,
                                 grad,
                                 indices,
                                 segment_ids,
                                 output_dim0,
                                 oT[].oTF)

converter sparseSegmentMeanGradToOut*[oT: oall](op: SparseSegmentMeanGrad[oT]): oT {.inline.} = return op.output


type MatrixExponential*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixExponential/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixExponential[oT: oall](scope: Scope,
                        input: oT,
                        T: DType): MatrixExponential[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixExponential(*#, #, #)", constructor.}

proc matrixExponential*[oT: oall](scope: Scope,
                        input: oT): MatrixExponential[oT] =
  return iimatrixExponential(scope,
                             input,
                             oT[].oTF)

converter matrixExponentialToOut*[oT: oall](op: MatrixExponential[oT]): oT {.inline.} = return op.output

type GatherNdTindices* = oint32 | oint64

type GatherNd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"GatherNd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iigatherNd[oT: oall](scope: Scope,
               params: oT,
               indices: GatherNdTindices,
               Tparams: DType): GatherNd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"GatherNd(*#, #, #, #)", constructor.}

proc gatherNd*[oT: oall](scope: Scope,
               params: oT,
               indices: GatherNdTindices): GatherNd[oT] =
  return iigatherNd(scope,
                    params,
                    indices,
                    oT[].oTF)

converter gatherNdToOut*[oT: oall](op: GatherNd[oT]): oT {.inline.} = return op.output


type QueueCloseV2*{.header:"../tensorflow/ops/generated.h", importcpp:"QueueCloseV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiqueueCloseV2(scope: Scope,
                   handle: oresource,
                   cancel_pending_enqueues: bool): QueueCloseV2 {.header:"../tensorflow/ops/generated.h", importcpp:"QueueCloseV2(*#, #, #)", constructor.}

proc queueCloseV2*(scope: Scope,
                   handle: oresource,
                   cancel_pending_enqueues: bool = false): QueueCloseV2 =
  return iiqueueCloseV2(scope,
                        handle,
                        cancel_pending_enqueues)




type MaxPool*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPool[oT: oall](scope: Scope,
              input: oT,
              ksize: ArraySlice[int],
              strides: ArraySlice[int],
              padding: cstring,
              T: DType,
              data_format: cstring): MaxPool[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPool(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc maxPool*[oT: oall](scope: Scope,
              input: oT,
              ksize: openArray[int],
              strides: openArray[int],
              padding: cstring,
              data_format: cstring = "NHWC"): MaxPool[oT] =
  return iimaxPool(scope,
                   input,
                   newArraySlice(ksize),
                   newArraySlice(strides),
                   padding,
                   oT[].oTF,
                   data_format)

converter maxPoolToOut*[oT: oall](op: MaxPool[oT]): oT {.inline.} = return op.output


type OrderedMapClear*{.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapClear/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiorderedMapClear(scope: Scope,
                      dtypes: ArraySlice[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64,
                      memory_limit: int64): OrderedMapClear {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapClear(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapClear*(scope: Scope,
                      dtypes: openArray[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = 0.int,
                      memory_limit: int64 = 0.int): OrderedMapClear =
  return iiorderedMapClear(scope,
                           newArraySlice(dtypes),
                           container,
                           shared_name,
                           capacity,
                           memory_limit)




type OrderedMapSize* {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiorderedMapSize(scope: Scope,
                     dtypes: ArraySlice[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64,
                     memory_limit: int64): OrderedMapSize {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapSize*(scope: Scope,
                     dtypes: openArray[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64 = 0.int,
                     memory_limit: int64 = 0.int): OrderedMapSize =
  return iiorderedMapSize(scope,
                          newArraySlice(dtypes),
                          container,
                          shared_name,
                          capacity,
                          memory_limit)

converter orderedMapSizeToOut*(op: OrderedMapSize): oint32 {.inline.} = return op.output


type TensorArrayCloseV3*{.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayCloseV3/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iitensorArrayCloseV3(scope: Scope,
                         handle: oresource): TensorArrayCloseV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayCloseV3(*#, #)", constructor.}

proc tensorArrayCloseV3*(scope: Scope,
                         handle: oresource): TensorArrayCloseV3 =
  return iitensorArrayCloseV3(scope,
                              handle)




type SaveV2*{.header:"../tensorflow/ops/generated.h", importcpp:"SaveV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iisaveV2(scope: Scope,
             prefix: ostring,
             tensor_names: ostring,
             shape_and_slices: ostring,
             tensors: olist[oall],
             dtypes: ArraySlice[DType]): SaveV2 {.header:"../tensorflow/ops/generated.h", importcpp:"SaveV2(*#, #, #, #, #, #)", constructor.}

proc saveV2*(scope: Scope,
             prefix: ostring,
             tensor_names: ostring,
             shape_and_slices: ostring,
             tensors: olist[oall],
             dtypes: openArray[DType]): SaveV2 =
  return iisaveV2(scope,
                  prefix,
                  tensor_names,
                  shape_and_slices,
                  tensors,
                  newArraySlice(dtypes))




type OrderedMapStage*{.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapStage/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiorderedMapStage(scope: Scope,
                      key: oint64,
                      indices: oint32,
                      values: olist[oall],
                      dtypes: ArraySlice[DType],
                      fake_dtypes: ArraySlice[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64,
                      memory_limit: int64): OrderedMapStage {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapStage(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapStage*(scope: Scope,
                      key: oint64,
                      indices: oint32,
                      values: olist[oall],
                      dtypes: openArray[DType],
                      fake_dtypes: openArray[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = 0.int,
                      memory_limit: int64 = 0.int): OrderedMapStage =
  return iiorderedMapStage(scope,
                           key,
                           indices,
                           values,
                           newArraySlice(dtypes),
                           newArraySlice(fake_dtypes),
                           container,
                           shared_name,
                           capacity,
                           memory_limit)



type RandomGammaS* = oint32 | oint64

type RandomGamma*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomGamma/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirandomGamma[oT: oall](scope: Scope,
                  shape: RandomGammaS,
                  alpha: oT,
                  seed: int64,
                  seed2: int64,
                  T: DType): RandomGamma[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RandomGamma(*#, #, #, #, #, #)", constructor.}

proc randomGamma*[oT: oall](scope: Scope,
                  shape: RandomGammaS,
                  alpha: oT,
                  seed: int64 = 0.int,
                  seed2: int64 = 0.int): RandomGamma[oT] =
  return iirandomGamma(scope,
                       shape,
                       alpha,
                       seed,
                       seed2,
                       oT[].oTF)

converter randomGammaToOut*[oT: oall](op: RandomGamma[oT]): oT {.inline.} = return op.output


type QuantizedResizeBilinear*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedResizeBilinear/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedResizeBilinear[oT: oall](scope: Scope,
                              images: oT,
                              size: oint32,
                              min: ofloat,
                              max: ofloat,
                              T: DType,
                              align_corners: bool): QuantizedResizeBilinear[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedResizeBilinear(*#, #, #, #, #, #, #)", constructor.}

proc quantizedResizeBilinear*[oT: oall](scope: Scope,
                              images: oT,
                              size: oint32,
                              min: ofloat,
                              max: ofloat,
                              align_corners: bool = false): QuantizedResizeBilinear[oT] =
  return iiquantizedResizeBilinear(scope,
                                   images,
                                   size,
                                   min,
                                   max,
                                   oT[].oTF,
                                   align_corners)

converter quantizedResizeBilinearToOut*[oT: oall](op: QuantizedResizeBilinear[oT]): oT {.inline.} = return op.output


type OrderedMapIncompleteSize* {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapIncompleteSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiorderedMapIncompleteSize(scope: Scope,
                               dtypes: ArraySlice[DType],
                               container: cstring,
                               shared_name: cstring,
                               capacity: int64,
                               memory_limit: int64): OrderedMapIncompleteSize {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapIncompleteSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapIncompleteSize*(scope: Scope,
                               dtypes: openArray[DType],
                               container: cstring,
                               shared_name: cstring,
                               capacity: int64 = 0.int,
                               memory_limit: int64 = 0.int): OrderedMapIncompleteSize =
  return iiorderedMapIncompleteSize(scope,
                                    newArraySlice(dtypes),
                                    container,
                                    shared_name,
                                    capacity,
                                    memory_limit)

converter orderedMapIncompleteSizeToOut*(op: OrderedMapIncompleteSize): oint32 {.inline.} = return op.output


type MapIncompleteSize* {.header:"../tensorflow/ops/generated.h", importcpp:"MapIncompleteSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iimapIncompleteSize(scope: Scope,
                        dtypes: ArraySlice[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64,
                        memory_limit: int64): MapIncompleteSize {.header:"../tensorflow/ops/generated.h", importcpp:"MapIncompleteSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapIncompleteSize*(scope: Scope,
                        dtypes: openArray[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64 = 0.int,
                        memory_limit: int64 = 0.int): MapIncompleteSize =
  return iimapIncompleteSize(scope,
                             newArraySlice(dtypes),
                             container,
                             shared_name,
                             capacity,
                             memory_limit)

converter mapIncompleteSizeToOut*(op: MapIncompleteSize): oint32 {.inline.} = return op.output


type MatrixInverse*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixInverse/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixInverse[oT: oall](scope: Scope,
                    input: oT,
                    adjoint: bool,
                    T: DType): MatrixInverse[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixInverse(*#, #, #, #)", constructor.}

proc matrixInverse*[oT: oall](scope: Scope,
                    input: oT,
                    adjoint: bool = false): MatrixInverse[oT] =
  return iimatrixInverse(scope,
                         input,
                         adjoint,
                         oT[].oTF)

converter matrixInverseToOut*[oT: oall](op: MatrixInverse[oT]): oT {.inline.} = return op.output


type ApplyMomentum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyMomentum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyMomentum[oT: oall](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    lr: oT,
                    grad: oT,
                    momentum: oT,
                    T: DType,
                    use_locking: bool,
                    use_nesterov: bool): ApplyMomentum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyMomentum(*#, #, #, #, #, #, #, #, #)", constructor.}

proc applyMomentum*[oT: oall](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    lr: oT,
                    grad: oT,
                    momentum: oT,
                    use_locking: bool = false,
                    use_nesterov: bool = false): ApplyMomentum[oT] =
  return iiapplyMomentum(scope,
                         nvar,
                         accum,
                         lr,
                         grad,
                         momentum,
                         oT[].oTF,
                         use_locking,
                         use_nesterov)

converter applyMomentumToOut*[oT: oall](op: ApplyMomentum[oT]): oT {.inline.} = return op.output


type Acos*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Acos/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiacos[oT: oall](scope: Scope,
           x: oT,
           T: DType): Acos[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Acos(*#, #, #)", constructor.}

proc acos*[oT: oall](scope: Scope,
           x: oT): Acos[oT] =
  return iiacos(scope,
                x,
                oT[].oTF)

converter acosToOut*[oT: oall](op: Acos[oT]): oT {.inline.} = return op.output


type ExperimentalGroupByWindowDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalGroupByWindowDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalGroupByWindowDataset(scope: Scope,
                                       input_dataset: ovariant,
                                       key_func_other_arguments: olist[oall],
                                       reduce_func_other_arguments: olist[oall],
                                       window_size_func_other_arguments: olist[oall],
                                       key_func: NameAttrList,
                                       reduce_func: NameAttrList,
                                       window_size_func: NameAttrList,
                                       Tkey_func_other_arguments: ArraySlice[DType],
                                       Treduce_func_other_arguments: ArraySlice[DType],
                                       Twindow_size_func_other_arguments: ArraySlice[DType],
                                       output_types: ArraySlice[DType],
                                       output_shapes: ArraySlice[TensorShape]): ExperimentalGroupByWindowDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalGroupByWindowDataset(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalGroupByWindowDataset*(scope: Scope,
                                       input_dataset: ovariant,
                                       key_func_other_arguments: olist[oall],
                                       reduce_func_other_arguments: olist[oall],
                                       window_size_func_other_arguments: olist[oall],
                                       key_func: NameAttrList,
                                       reduce_func: NameAttrList,
                                       window_size_func: NameAttrList,
                                       Tkey_func_other_arguments: openArray[DType],
                                       Treduce_func_other_arguments: openArray[DType],
                                       Twindow_size_func_other_arguments: openArray[DType],
                                       output_types: openArray[DType],
                                       output_shapes: openArray[TensorShape]): ExperimentalGroupByWindowDataset =
  return iiexperimentalGroupByWindowDataset(scope,
                                            input_dataset,
                                            key_func_other_arguments,
                                            reduce_func_other_arguments,
                                            window_size_func_other_arguments,
                                            key_func,
                                            reduce_func,
                                            window_size_func,
                                            newArraySlice(Tkey_func_other_arguments),
                                            newArraySlice(Treduce_func_other_arguments),
                                            newArraySlice(Twindow_size_func_other_arguments),
                                            newArraySlice(output_types),
                                            newArraySlice(output_shapes))

converter experimentalGroupByWindowDatasetToOut*(op: ExperimentalGroupByWindowDataset): ovariant {.inline.} = return op.output

type ResourceApplyAdamWithAmsgradT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdamWithAmsgrad*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdamWithAmsgrad/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAdamWithAmsgrad(scope: Scope,
                                   nvar: oresource,
                                   m: oresource,
                                   v: oresource,
                                   vhat: oresource,
                                   beta1_power: ResourceApplyAdamWithAmsgradT,
                                   beta2_power: ResourceApplyAdamWithAmsgradT,
                                   lr: ResourceApplyAdamWithAmsgradT,
                                   beta1: ResourceApplyAdamWithAmsgradT,
                                   beta2: ResourceApplyAdamWithAmsgradT,
                                   epsilon: ResourceApplyAdamWithAmsgradT,
                                   grad: ResourceApplyAdamWithAmsgradT,
                                   use_locking: bool): ResourceApplyAdamWithAmsgrad {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdamWithAmsgrad(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdamWithAmsgrad*(scope: Scope,
                                   nvar: oresource,
                                   m: oresource,
                                   v: oresource,
                                   vhat: oresource,
                                   beta1_power: ResourceApplyAdamWithAmsgradT,
                                   beta2_power: ResourceApplyAdamWithAmsgradT,
                                   lr: ResourceApplyAdamWithAmsgradT,
                                   beta1: ResourceApplyAdamWithAmsgradT,
                                   beta2: ResourceApplyAdamWithAmsgradT,
                                   epsilon: ResourceApplyAdamWithAmsgradT,
                                   grad: ResourceApplyAdamWithAmsgradT,
                                   use_locking: bool = false): ResourceApplyAdamWithAmsgrad =
  return iiresourceApplyAdamWithAmsgrad(scope,
                                        nvar,
                                        m,
                                        v,
                                        vhat,
                                        beta1_power,
                                        beta2_power,
                                        lr,
                                        beta1,
                                        beta2,
                                        epsilon,
                                        grad,
                                        use_locking)




type INcclBroadcastRecv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_NcclBroadcastRecv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiNcclBroadcastRecv[oT: oall](scope: Scope,
                         shape: oint32,
                         shared_name: cstring,
                         T: DType,
                         num_devices: int64,
                         explicitT: type(oT)): INcclBroadcastRecv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_NcclBroadcastRecv(*#, #, tensorflow::string(#), #, #)", constructor.}

proc iNcclBroadcastRecv*(scope: Scope,
                         shape: oint32,
                         shared_name: cstring,
                         T: type = oinvalid,
                         num_devices: int64 = 0.int): auto =
  return iiiNcclBroadcastRecv(scope,
                              shape,
                              shared_name,
                              T[].oTF,
                              num_devices,
                              T)

converter iNcclBroadcastRecvToOut*[oT: oall](op: INcclBroadcastRecv[oT]): oT {.inline.} = return op.output

type SegmentSumTindices* = oint32 | oint64

type SegmentSum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentSum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisegmentSum[oT: oall](scope: Scope,
                 data: oT,
                 segment_ids: SegmentSumTindices,
                 T: DType): SegmentSum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentSum(*#, #, #, #)", constructor.}

proc segmentSum*[oT: oall](scope: Scope,
                 data: oT,
                 segment_ids: SegmentSumTindices): SegmentSum[oT] =
  return iisegmentSum(scope,
                      data,
                      segment_ids,
                      oT[].oTF)

converter segmentSumToOut*[oT: oall](op: SegmentSum[oT]): oT {.inline.} = return op.output


type TextLineDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"TextLineDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitextLineDataset(scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TextLineDataset {.header:"../tensorflow/ops/generated.h", importcpp:"TextLineDataset(*#, #, #, #)", constructor.}

proc textLineDataset*(scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TextLineDataset =
  return iitextLineDataset(scope,
                           filenames,
                           compression_type,
                           buffer_size)

converter textLineDatasetToOut*(op: TextLineDataset): ovariant {.inline.} = return op.output

type TensorSummaryV2T* = oall

type TensorSummaryV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorSummaryV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorSummaryV2(scope: Scope,
                      tag: ostring,
                      tensor: TensorSummaryV2T,
                      serialized_summary_metadata: ostring): TensorSummaryV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorSummaryV2(*#, #, #, #)", constructor.}

proc tensorSummaryV2*(scope: Scope,
                      tag: ostring,
                      tensor: TensorSummaryV2T,
                      serialized_summary_metadata: ostring): TensorSummaryV2 =
  return iitensorSummaryV2(scope,
                           tag,
                           tensor,
                           serialized_summary_metadata)

converter tensorSummaryV2ToOut*(op: TensorSummaryV2): ostring {.inline.} = return op.output


type Unbatch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Unbatch/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunbatch[oT: oall](scope: Scope,
              batched_tensor: oT,
              batch_index: oint64,
              id: oint64,
              container: cstring,
              shared_name: cstring,
              timeout_micros: int64,
              T: DType): Unbatch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Unbatch(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unbatch*[oT: oall](scope: Scope,
              batched_tensor: oT,
              batch_index: oint64,
              id: oint64,
              container: cstring,
              shared_name: cstring,
              timeout_micros: int64 = 0.int): Unbatch[oT] =
  return iiunbatch(scope,
                   batched_tensor,
                   batch_index,
                   id,
                   container,
                   shared_name,
                   timeout_micros,
                   oT[].oTF)

converter unbatchToOut*[oT: oall](op: Unbatch[oT]): oT {.inline.} = return op.output


type MapUnstage*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MapUnstage/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iimapUnstage[oT: oall](scope: Scope,
                 key: oint64,
                 indices: oint32,
                 dtypes: ArraySlice[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64,
                 memory_limit: int64,
                 explicitT: type(oT)): MapUnstage[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MapUnstage(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapUnstage*(scope: Scope,
                 key: oint64,
                 indices: oint32,
                 dtypes: openArray[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64 = 0.int,
                 memory_limit: int64 = 0.int,
                 explicitT: type): auto =
  return iimapUnstage(scope,
                      key,
                      indices,
                      newArraySlice(dtypes),
                      container,
                      shared_name,
                      capacity,
                      memory_limit,
                      explicitT)

converter mapUnstageToOutList*[oT: oall](op: MapUnstage[oT]): olist[oT] {.inline.} = return op.output


type TopK*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TopK/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitopK[oT: oall](scope: Scope,
           input: oT,
           k: int64,
           sorted: bool,
           T: DType): TopK[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TopK(*#, #, #, #, #)", constructor.}

proc topK*[oT: oall](scope: Scope,
           input: oT,
           k: int64 = 0.int,
           sorted: bool = true): TopK[oT] =
  return iitopK(scope,
                input,
                k,
                sorted,
                oT[].oTF)

converter topKToOut*[oT: oall](op: TopK[oT]): oT {.inline.} = return op.output

type ConjugateTransposeTperm* = oint32 | oint64

type ConjugateTranspose*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ConjugateTranspose/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconjugateTranspose[oT: oall](scope: Scope,
                         x: oT,
                         perm: ConjugateTransposeTperm,
                         T: DType): ConjugateTranspose[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ConjugateTranspose(*#, #, #, #)", constructor.}

proc conjugateTranspose*[oT: oall](scope: Scope,
                         x: oT,
                         perm: ConjugateTransposeTperm): ConjugateTranspose[oT] =
  return iiconjugateTranspose(scope,
                              x,
                              perm,
                              oT[].oTF)

converter conjugateTransposeToOut*[oT: oall](op: ConjugateTranspose[oT]): oT {.inline.} = return op.output


type MapPeek*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MapPeek/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iimapPeek[oT: oall](scope: Scope,
              key: oint64,
              indices: oint32,
              dtypes: ArraySlice[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64,
              memory_limit: int64,
              explicitT: type(oT)): MapPeek[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MapPeek(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapPeek*(scope: Scope,
              key: oint64,
              indices: oint32,
              dtypes: openArray[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = 0.int,
              memory_limit: int64 = 0.int,
              explicitT: type): auto =
  return iimapPeek(scope,
                   key,
                   indices,
                   newArraySlice(dtypes),
                   container,
                   shared_name,
                   capacity,
                   memory_limit,
                   explicitT)

converter mapPeekToOutList*[oT: oall](op: MapPeek[oT]): olist[oT] {.inline.} = return op.output

type SparseTensorDenseMatMulTindices* = oint32 | oint64

type SparseTensorDenseMatMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseTensorDenseMatMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseTensorDenseMatMul[oT: oall](scope: Scope,
                              a_indices: SparseTensorDenseMatMulTindices,
                              a_values: oT,
                              a_shape: oint64,
                              b: oT,
                              T: DType,
                              adjoint_b: bool,
                              adjoint_a: bool): SparseTensorDenseMatMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseTensorDenseMatMul(*#, #, #, #, #, #, #, #)", constructor.}

proc sparseTensorDenseMatMul*[oT: oall](scope: Scope,
                              a_indices: SparseTensorDenseMatMulTindices,
                              a_values: oT,
                              a_shape: oint64,
                              b: oT,
                              adjoint_b: bool = false,
                              adjoint_a: bool = false): SparseTensorDenseMatMul[oT] =
  return iisparseTensorDenseMatMul(scope,
                                   a_indices,
                                   a_values,
                                   a_shape,
                                   b,
                                   oT[].oTF,
                                   adjoint_b,
                                   adjoint_a)

converter sparseTensorDenseMatMulToOut*[oT: oall](op: SparseTensorDenseMatMul[oT]): oT {.inline.} = return op.output

type FusedBatchNormGradV2U* = ofloat

type FusedBatchNormGradV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNormGradV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifusedBatchNormGradV2[oT: oall](scope: Scope,
                           y_backprop: oT,
                           x: oT,
                           scale: ofloat,
                           reserve_space_1: FusedBatchNormGradV2U,
                           reserve_space_2: FusedBatchNormGradV2U,
                           T: DType,
                           is_training: bool,
                           epsilon: float32,
                           data_format: cstring): FusedBatchNormGradV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNormGradV2(*#, #, #, #, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc fusedBatchNormGradV2*[oT: oall](scope: Scope,
                           y_backprop: oT,
                           x: oT,
                           scale: ofloat,
                           reserve_space_1: FusedBatchNormGradV2U,
                           reserve_space_2: FusedBatchNormGradV2U,
                           is_training: bool = true,
                           epsilon: float32 = 9.999999747378752e-05.float32,
                           data_format: cstring = "NHWC"): FusedBatchNormGradV2[oT] =
  return iifusedBatchNormGradV2(scope,
                                y_backprop,
                                x,
                                scale,
                                reserve_space_1,
                                reserve_space_2,
                                oT[].oTF,
                                is_training,
                                epsilon,
                                data_format)

converter fusedBatchNormGradV2ToOut*[oT: oall](op: FusedBatchNormGradV2[oT]): oT {.inline.} = return op.output


type BarrierReadySize* {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierReadySize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iibarrierReadySize(scope: Scope,
                       handle: ostring): BarrierReadySize {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierReadySize(*#, #)", constructor.}

proc barrierReadySize*(scope: Scope,
                       handle: ostring): BarrierReadySize =
  return iibarrierReadySize(scope,
                            handle)

converter barrierReadySizeToOut*(op: BarrierReadySize): oint32 {.inline.} = return op.output


type MapStage*{.header:"../tensorflow/ops/generated.h", importcpp:"MapStage/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iimapStage(scope: Scope,
               key: oint64,
               indices: oint32,
               values: olist[oall],
               dtypes: ArraySlice[DType],
               fake_dtypes: ArraySlice[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64,
               memory_limit: int64): MapStage {.header:"../tensorflow/ops/generated.h", importcpp:"MapStage(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapStage*(scope: Scope,
               key: oint64,
               indices: oint32,
               values: olist[oall],
               dtypes: openArray[DType],
               fake_dtypes: openArray[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64 = 0.int,
               memory_limit: int64 = 0.int): MapStage =
  return iimapStage(scope,
                    key,
                    indices,
                    values,
                    newArraySlice(dtypes),
                    newArraySlice(fake_dtypes),
                    container,
                    shared_name,
                    capacity,
                    memory_limit)




type Unstage*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Unstage/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiunstage[oT: oall](scope: Scope,
              dtypes: ArraySlice[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64,
              memory_limit: int64,
              explicitT: type(oT)): Unstage[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Unstage(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unstage*(scope: Scope,
              dtypes: openArray[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = 0.int,
              memory_limit: int64 = 0.int,
              explicitT: type): auto =
  return iiunstage(scope,
                   newArraySlice(dtypes),
                   container,
                   shared_name,
                   capacity,
                   memory_limit,
                   explicitT)

converter unstageToOutList*[oT: oall](op: Unstage[oT]): olist[oT] {.inline.} = return op.output


type Variable*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Variable/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iivariable[oT: oall](scope: Scope,
               container: cstring,
               shared_name: cstring,
               shape: TensorShape,
               dtype: DType,
               explicitT: type(oT)): Variable[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Variable(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc variable*(scope: Scope,
               container: cstring,
               shared_name: cstring,
               shape: TensorShape = [].shape,
               dtype: type = oinvalid): auto =
  return iivariable(scope,
                    container,
                    shared_name,
                    shape,
                    dtype[].oTF,
                    dtype)

converter variableToOut*[oT: oall](op: Variable[oT]): oT {.inline.} = return op.output


type TensorArray* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArray/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorArray(scope: Scope,
                  size: oint32,
                  tensor_array_name: cstring,
                  dtype: DType,
                  dynamic_size: bool,
                  clear_after_read: bool,
                  element_shape: TensorShape): TensorArray {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArray(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc tensorArray*(scope: Scope,
                  size: oint32,
                  tensor_array_name: cstring,
                  dtype: type oall = oinvalid,
                  dynamic_size: bool = false,
                  clear_after_read: bool = true,
                  element_shape: TensorShape = [].shape): TensorArray =
  return iitensorArray(scope,
                       size,
                       tensor_array_name,
                       oT[].oTF,
                       dynamic_size,
                       clear_after_read,
                       element_shape)

converter tensorArrayToOut*(op: TensorArray): ostring {.inline.} = return op.output


type SigmoidGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SigmoidGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisigmoidGrad[oT: oall](scope: Scope,
                  y: oT,
                  dy: oT,
                  T: DType): SigmoidGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SigmoidGrad(*#, #, #, #)", constructor.}

proc sigmoidGrad*[oT: oall](scope: Scope,
                  y: oT,
                  dy: oT): SigmoidGrad[oT] =
  return iisigmoidGrad(scope,
                       y,
                       dy,
                       oT[].oTF)

converter sigmoidGradToOut*[oT: oall](op: SigmoidGrad[oT]): oT {.inline.} = return op.output


type TensorListGather*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListGather/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorListGather[oT: oall](scope: Scope,
                       input_handle: ovariant,
                       indices: oint32,
                       element_dtype: DType,
                       explicitT: type(oT)): TensorListGather[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListGather(*#, #, #, #)", constructor.}

proc tensorListGather*(scope: Scope,
                       input_handle: ovariant,
                       indices: oint32,
                       element_dtype: type = oinvalid): auto =
  return iitensorListGather(scope,
                            input_handle,
                            indices,
                            element_dtype[].oTF,
                            element_dtype)

converter tensorListGatherToOut*[oT: oall](op: TensorListGather[oT]): oT {.inline.} = return op.output


type DeleteSessionTensor*{.header:"../tensorflow/ops/generated.h", importcpp:"DeleteSessionTensor/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iideleteSessionTensor(scope: Scope,
                          handle: ostring): DeleteSessionTensor {.header:"../tensorflow/ops/generated.h", importcpp:"DeleteSessionTensor(*#, #)", constructor.}

proc deleteSessionTensor*(scope: Scope,
                          handle: ostring): DeleteSessionTensor =
  return iideleteSessionTensor(scope,
                               handle)



type ResourceApplyAdamT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdam*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdam/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAdam(scope: Scope,
                        nvar: oresource,
                        m: oresource,
                        v: oresource,
                        beta1_power: ResourceApplyAdamT,
                        beta2_power: ResourceApplyAdamT,
                        lr: ResourceApplyAdamT,
                        beta1: ResourceApplyAdamT,
                        beta2: ResourceApplyAdamT,
                        epsilon: ResourceApplyAdamT,
                        grad: ResourceApplyAdamT,
                        use_nesterov: bool,
                        use_locking: bool): ResourceApplyAdam {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdam(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdam*(scope: Scope,
                        nvar: oresource,
                        m: oresource,
                        v: oresource,
                        beta1_power: ResourceApplyAdamT,
                        beta2_power: ResourceApplyAdamT,
                        lr: ResourceApplyAdamT,
                        beta1: ResourceApplyAdamT,
                        beta2: ResourceApplyAdamT,
                        epsilon: ResourceApplyAdamT,
                        grad: ResourceApplyAdamT,
                        use_nesterov: bool = false,
                        use_locking: bool = false): ResourceApplyAdam =
  return iiresourceApplyAdam(scope,
                             nvar,
                             m,
                             v,
                             beta1_power,
                             beta2_power,
                             lr,
                             beta1,
                             beta2,
                             epsilon,
                             grad,
                             use_nesterov,
                             use_locking)



type ResourceSparseApplyAdadeltaT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyAdadeltaTindices* = oint32 | oint64

type ResourceSparseApplyAdadelta*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyAdadelta/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyAdadelta(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  accum_update: oresource,
                                  lr: ResourceSparseApplyAdadeltaT,
                                  rho: ResourceSparseApplyAdadeltaT,
                                  epsilon: ResourceSparseApplyAdadeltaT,
                                  grad: ResourceSparseApplyAdadeltaT,
                                  indices: ResourceSparseApplyAdadeltaTindices,
                                  use_locking: bool): ResourceSparseApplyAdadelta {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyAdadelta(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyAdadelta*(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  accum_update: oresource,
                                  lr: ResourceSparseApplyAdadeltaT,
                                  rho: ResourceSparseApplyAdadeltaT,
                                  epsilon: ResourceSparseApplyAdadeltaT,
                                  grad: ResourceSparseApplyAdadeltaT,
                                  indices: ResourceSparseApplyAdadeltaTindices,
                                  use_locking: bool = false): ResourceSparseApplyAdadelta =
  return iiresourceSparseApplyAdadelta(scope,
                                       nvar,
                                       accum,
                                       accum_update,
                                       lr,
                                       rho,
                                       epsilon,
                                       grad,
                                       indices,
                                       use_locking)




type Sigmoid*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Sigmoid/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisigmoid[oT: oall](scope: Scope,
              x: oT,
              T: DType): Sigmoid[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Sigmoid(*#, #, #)", constructor.}

proc sigmoid*[oT: oall](scope: Scope,
              x: oT): Sigmoid[oT] =
  return iisigmoid(scope,
                   x,
                   oT[].oTF)

converter sigmoidToOut*[oT: oall](op: Sigmoid[oT]): oT {.inline.} = return op.output

type ResourceApplyAdagradDAT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdagradDA*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdagradDA/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAdagradDA(scope: Scope,
                             nvar: oresource,
                             gradient_accumulator: oresource,
                             gradient_squared_accumulator: oresource,
                             grad: ResourceApplyAdagradDAT,
                             lr: ResourceApplyAdagradDAT,
                             l1: ResourceApplyAdagradDAT,
                             l2: ResourceApplyAdagradDAT,
                             global_step: oint64,
                             use_locking: bool): ResourceApplyAdagradDA {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdagradDA*(scope: Scope,
                             nvar: oresource,
                             gradient_accumulator: oresource,
                             gradient_squared_accumulator: oresource,
                             grad: ResourceApplyAdagradDAT,
                             lr: ResourceApplyAdagradDAT,
                             l1: ResourceApplyAdagradDAT,
                             l2: ResourceApplyAdagradDAT,
                             global_step: oint64,
                             use_locking: bool = false): ResourceApplyAdagradDA =
  return iiresourceApplyAdagradDA(scope,
                                  nvar,
                                  gradient_accumulator,
                                  gradient_squared_accumulator,
                                  grad,
                                  lr,
                                  l1,
                                  l2,
                                  global_step,
                                  use_locking)



type SparseToDenseTindices* = oint32 | oint64

type SparseToDense*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseToDense/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseToDense[oT: oall](scope: Scope,
                    sparse_indices: SparseToDenseTindices,
                    output_shape: SparseToDenseTindices,
                    sparse_values: oT,
                    default_value: oT,
                    validate_indices: bool,
                    T: DType): SparseToDense[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseToDense(*#, #, #, #, #, #, #)", constructor.}

proc sparseToDense*[oT: oall](scope: Scope,
                    sparse_indices: SparseToDenseTindices,
                    output_shape: SparseToDenseTindices,
                    sparse_values: oT,
                    default_value: oT,
                    validate_indices: bool = true): SparseToDense[oT] =
  return iisparseToDense(scope,
                         sparse_indices,
                         output_shape,
                         sparse_values,
                         default_value,
                         validate_indices,
                         oT[].oTF)

converter sparseToDenseToOut*[oT: oall](op: SparseToDense[oT]): oT {.inline.} = return op.output

type BitcastT* = obfloat16 | ohalf | ofloat | odouble | oint64 | oint32 | ouint8 | ouint16 | ouint32 | ouint64 | oint8 | oint16 | ocomplex64 | ocomplex128 | oqint8 | oquint8 | oqint16 | oquint16 | oqint32

type Bitcast*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Bitcast/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibitcast[oT: oall](scope: Scope,
              input: BitcastT,
              ntype: DType,
              explicitT: type(oT)): Bitcast[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Bitcast(*#, #, #)", constructor.}

proc bitcast*(scope: Scope,
              input: BitcastT,
              ntype: type = oinvalid): auto =
  return iibitcast(scope,
                   input,
                   ntype[].oTF,
                   ntype)

converter bitcastToOut*[oT: oall](op: Bitcast[oT]): oT {.inline.} = return op.output

type GetSessionHandleV2T* = oall

type GetSessionHandleV2* {.header:"../tensorflow/ops/generated.h", importcpp:"GetSessionHandleV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iigetSessionHandleV2(scope: Scope,
                         value: GetSessionHandleV2T): GetSessionHandleV2 {.header:"../tensorflow/ops/generated.h", importcpp:"GetSessionHandleV2(*#, #)", constructor.}

proc getSessionHandleV2*(scope: Scope,
                         value: GetSessionHandleV2T): GetSessionHandleV2 =
  return iigetSessionHandleV2(scope,
                              value)

converter getSessionHandleV2ToOut*(op: GetSessionHandleV2): oresource {.inline.} = return op.output


type FakeQuantWithMinMaxVars* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVars/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iifakeQuantWithMinMaxVars(scope: Scope,
                              inputs: ofloat,
                              min: ofloat,
                              max: ofloat,
                              num_bits: int64,
                              narrow_range: bool): FakeQuantWithMinMaxVars {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVars(*#, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVars*(scope: Scope,
                              inputs: ofloat,
                              min: ofloat,
                              max: ofloat,
                              num_bits: int64 = 8.int,
                              narrow_range: bool = false): FakeQuantWithMinMaxVars =
  return iifakeQuantWithMinMaxVars(scope,
                                   inputs,
                                   min,
                                   max,
                                   num_bits,
                                   narrow_range)

converter fakeQuantWithMinMaxVarsToOut*(op: FakeQuantWithMinMaxVars): ofloat {.inline.} = return op.output


type BarrierIncompleteSize* {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierIncompleteSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iibarrierIncompleteSize(scope: Scope,
                            handle: ostring): BarrierIncompleteSize {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierIncompleteSize(*#, #)", constructor.}

proc barrierIncompleteSize*(scope: Scope,
                            handle: ostring): BarrierIncompleteSize =
  return iibarrierIncompleteSize(scope,
                                 handle)

converter barrierIncompleteSizeToOut*(op: BarrierIncompleteSize): oint32 {.inline.} = return op.output

type AnyTidx* = oint32 | oint64

type Any* {.header:"../tensorflow/ops/generated.h", importcpp:"Any/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiany(scope: Scope,
          input: obool,
          reduction_indices: AnyTidx,
          keep_dims: bool): Any {.header:"../tensorflow/ops/generated.h", importcpp:"Any(*#, #, #, #)", constructor.}

proc any*(scope: Scope,
          input: obool,
          reduction_indices: AnyTidx,
          keep_dims: bool = false): Any =
  return iiany(scope,
               input,
               reduction_indices,
               keep_dims)

converter anyToOut*(op: Any): obool {.inline.} = return op.output


type TensorForestCreateTreeVariable*{.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestCreateTreeVariable/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iitensorForestCreateTreeVariable(scope: Scope,
                                     tree_handle: oresource,
                                     tree_config: ostring): TensorForestCreateTreeVariable {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestCreateTreeVariable(*#, #, #)", constructor.}

proc tensorForestCreateTreeVariable*(scope: Scope,
                                     tree_handle: oresource,
                                     tree_config: ostring): TensorForestCreateTreeVariable =
  return iitensorForestCreateTreeVariable(scope,
                                          tree_handle,
                                          tree_config)




type BatchFunction*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFunction/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iibatchFunction[oT: oall](scope: Scope,
                    in_tensors: olist[oall],
                    captured_tensors: olist[oall],
                    f: NameAttrList,
                    allowed_batch_sizes: ArraySlice[int],
                    container: cstring,
                    shared_name: cstring,
                    batching_queue: cstring,
                    Tin: ArraySlice[DType],
                    Tcaptured: ArraySlice[DType],
                    Tout: ArraySlice[DType],
                    num_batch_threads: int64,
                    max_batch_size: int64,
                    batch_timeout_micros: int64,
                    max_enqueued_batches: int64,
                    explicitT: type(oT)): BatchFunction[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFunction(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #, #, #, #)", constructor.}

proc batchFunction*(scope: Scope,
                    in_tensors: olist[oall],
                    captured_tensors: olist[oall],
                    f: NameAttrList,
                    allowed_batch_sizes: openArray[int],
                    container: cstring,
                    shared_name: cstring,
                    batching_queue: cstring,
                    Tin: openArray[DType],
                    Tcaptured: openArray[DType],
                    Tout: openArray[DType],
                    num_batch_threads: int64 = 0.int,
                    max_batch_size: int64 = 0.int,
                    batch_timeout_micros: int64 = 0.int,
                    max_enqueued_batches: int64 = 10.int,
                    explicitT: type): auto =
  return iibatchFunction(scope,
                         in_tensors,
                         captured_tensors,
                         f,
                         newArraySlice(allowed_batch_sizes),
                         container,
                         shared_name,
                         batching_queue,
                         newArraySlice(Tin),
                         newArraySlice(Tcaptured),
                         newArraySlice(Tout),
                         num_batch_threads,
                         max_batch_size,
                         batch_timeout_micros,
                         max_enqueued_batches,
                         explicitT)

converter batchFunctionToOutList*[oT: oall](op: BatchFunction[oT]): olist[oT] {.inline.} = return op.output


type BatchDatasetV2* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchDatasetV2/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iibatchDatasetV2(scope: Scope,
                     input_dataset: ovariant,
                     batch_size: oint64,
                     drop_remainder: obool,
                     output_types: ArraySlice[DType],
                     output_shapes: ArraySlice[TensorShape]): BatchDatasetV2 {.header:"../tensorflow/ops/generated.h", importcpp:"BatchDatasetV2(*#, #, #, #, #, #)", constructor.}

proc batchDatasetV2*(scope: Scope,
                     input_dataset: ovariant,
                     batch_size: oint64,
                     drop_remainder: obool,
                     output_types: openArray[DType],
                     output_shapes: openArray[TensorShape]): BatchDatasetV2 =
  return iibatchDatasetV2(scope,
                          input_dataset,
                          batch_size,
                          drop_remainder,
                          newArraySlice(output_types),
                          newArraySlice(output_shapes))

converter batchDatasetV2ToOut*(op: BatchDatasetV2): ovariant {.inline.} = return op.output


type SelfAdjointEigV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SelfAdjointEigV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiselfAdjointEigV2[oT: oall](scope: Scope,
                       input: oT,
                       compute_v: bool,
                       T: DType): SelfAdjointEigV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SelfAdjointEigV2(*#, #, #, #)", constructor.}

proc selfAdjointEigV2*[oT: oall](scope: Scope,
                       input: oT,
                       compute_v: bool = true): SelfAdjointEigV2[oT] =
  return iiselfAdjointEigV2(scope,
                            input,
                            compute_v,
                            oT[].oTF)

converter selfAdjointEigV2ToOut*[oT: oall](op: SelfAdjointEigV2[oT]): oT {.inline.} = return op.output


type Pack*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Pack/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iipack[oT: oall](scope: Scope,
           values: olist[oT],
           T: DType,
           axis: int64): Pack[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Pack(*#, #, #, #)", constructor.}

proc pack*[oT: oall](scope: Scope,
           values: olist[oT],
           axis: int64 = 0.int): Pack[oT] =
  return iipack(scope,
                values,
                oT[].oTF,
                axis)

converter packToOut*[oT: oall](op: Pack[oT]): oT {.inline.} = return op.output


type BarrierClose*{.header:"../tensorflow/ops/generated.h", importcpp:"BarrierClose/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iibarrierClose(scope: Scope,
                   handle: ostring,
                   cancel_pending_enqueues: bool): BarrierClose {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierClose(*#, #, #)", constructor.}

proc barrierClose*(scope: Scope,
                   handle: ostring,
                   cancel_pending_enqueues: bool = false): BarrierClose =
  return iibarrierClose(scope,
                        handle,
                        cancel_pending_enqueues)




type PyFunc*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PyFunc/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iipyFunc[oT: oall](scope: Scope,
             input: olist[oall],
             token: cstring,
             Tin: ArraySlice[DType],
             Tout: ArraySlice[DType],
             explicitT: type(oT)): PyFunc[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PyFunc(*#, #, tensorflow::string(#), #, #)", constructor.}

proc pyFunc*(scope: Scope,
             input: olist[oall],
             token: cstring,
             Tin: openArray[DType],
             Tout: openArray[DType],
             explicitT: type): auto =
  return iipyFunc(scope,
                  input,
                  token,
                  newArraySlice(Tin),
                  newArraySlice(Tout),
                  explicitT)

converter pyFuncToOutList*[oT: oall](op: PyFunc[oT]): olist[oT] {.inline.} = return op.output


type AddN*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AddN/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiaddN[oT: oall](scope: Scope,
           inputs: olist[oT],
           T: DType): AddN[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AddN(*#, #, #)", constructor.}

proc addN*[oT: oall](scope: Scope,
           inputs: olist[oT]): AddN[oT] =
  return iiaddN(scope,
                inputs,
                oT[].oTF)

converter addNToOut*[oT: oall](op: AddN[oT]): oT {.inline.} = return op.output


type TensorArrayV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorArrayV2(scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: DType,
                    element_shape: TensorShape,
                    dynamic_size: bool,
                    clear_after_read: bool): TensorArrayV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayV2(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc tensorArrayV2*(scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: type oall = oinvalid,
                    element_shape: TensorShape = [].shape,
                    dynamic_size: bool = false,
                    clear_after_read: bool = true): TensorArrayV2 =
  return iitensorArrayV2(scope,
                         size,
                         tensor_array_name,
                         oT[].oTF,
                         element_shape,
                         dynamic_size,
                         clear_after_read)

converter tensorArrayV2ToOut*(op: TensorArrayV2): ostring {.inline.} = return op.output

type ResourceApplyGradientDescentT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyGradientDescent*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyGradientDescent/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyGradientDescent(scope: Scope,
                                   nvar: oresource,
                                   alpha: ResourceApplyGradientDescentT,
                                   delta: ResourceApplyGradientDescentT,
                                   use_locking: bool): ResourceApplyGradientDescent {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyGradientDescent(*#, #, #, #, #)", constructor.}

proc resourceApplyGradientDescent*(scope: Scope,
                                   nvar: oresource,
                                   alpha: ResourceApplyGradientDescentT,
                                   delta: ResourceApplyGradientDescentT,
                                   use_locking: bool = false): ResourceApplyGradientDescent =
  return iiresourceApplyGradientDescent(scope,
                                        nvar,
                                        alpha,
                                        delta,
                                        use_locking)




type MatrixLogarithm*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixLogarithm/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixLogarithm[oT: oall](scope: Scope,
                      input: oT,
                      T: DType): MatrixLogarithm[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixLogarithm(*#, #, #)", constructor.}

proc matrixLogarithm*[oT: oall](scope: Scope,
                      input: oT): MatrixLogarithm[oT] =
  return iimatrixLogarithm(scope,
                           input,
                           oT[].oTF)

converter matrixLogarithmToOut*[oT: oall](op: MatrixLogarithm[oT]): oT {.inline.} = return op.output


type BarrierTakeMany* {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierTakeMany/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iibarrierTakeMany(scope: Scope,
                      handle: ostring,
                      num_elements: oint32,
                      component_types: ArraySlice[DType],
                      allow_small_batch: bool,
                      wait_for_incomplete: bool,
                      timeout_ms: int64): BarrierTakeMany {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierTakeMany(*#, #, #, #, #, #, #)", constructor.}

proc barrierTakeMany*(scope: Scope,
                      handle: ostring,
                      num_elements: oint32,
                      component_types: openArray[DType],
                      allow_small_batch: bool = false,
                      wait_for_incomplete: bool = false,
                      timeout_ms: int64 = -1.int): BarrierTakeMany =
  return iibarrierTakeMany(scope,
                           handle,
                           num_elements,
                           newArraySlice(component_types),
                           allow_small_batch,
                           wait_for_incomplete,
                           timeout_ms)

converter barrierTakeManyToOut*(op: BarrierTakeMany): oint64 {.inline.} = return op.output

type ResourceSparseApplyProximalAdagradT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyProximalAdagradTindices* = oint32 | oint64

type ResourceSparseApplyProximalAdagrad*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyProximalAdagrad/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceSparseApplyProximalAdagrad(scope: Scope,
                                         nvar: oresource,
                                         accum: oresource,
                                         lr: ResourceSparseApplyProximalAdagradT,
                                         l1: ResourceSparseApplyProximalAdagradT,
                                         l2: ResourceSparseApplyProximalAdagradT,
                                         grad: ResourceSparseApplyProximalAdagradT,
                                         indices: ResourceSparseApplyProximalAdagradTindices,
                                         use_locking: bool): ResourceSparseApplyProximalAdagrad {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceSparseApplyProximalAdagrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyProximalAdagrad*(scope: Scope,
                                         nvar: oresource,
                                         accum: oresource,
                                         lr: ResourceSparseApplyProximalAdagradT,
                                         l1: ResourceSparseApplyProximalAdagradT,
                                         l2: ResourceSparseApplyProximalAdagradT,
                                         grad: ResourceSparseApplyProximalAdagradT,
                                         indices: ResourceSparseApplyProximalAdagradTindices,
                                         use_locking: bool = false): ResourceSparseApplyProximalAdagrad =
  return iiresourceSparseApplyProximalAdagrad(scope,
                                              nvar,
                                              accum,
                                              lr,
                                              l1,
                                              l2,
                                              grad,
                                              indices,
                                              use_locking)




type Neg*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Neg/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iineg[oT: oall](scope: Scope,
          x: oT,
          T: DType): Neg[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Neg(*#, #, #)", constructor.}

proc neg*[oT: oall](scope: Scope,
          x: oT): Neg[oT] =
  return iineg(scope,
               x,
               oT[].oTF)

converter negToOut*[oT: oall](op: Neg[oT]): oT {.inline.} = return op.output


type Barrier* {.header:"../tensorflow/ops/generated.h", importcpp:"Barrier/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iibarrier(scope: Scope,
              component_types: ArraySlice[DType],
              shapes: ArraySlice[TensorShape],
              container: cstring,
              shared_name: cstring,
              capacity: int64): Barrier {.header:"../tensorflow/ops/generated.h", importcpp:"Barrier(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc barrier*(scope: Scope,
              component_types: openArray[DType],
              shapes: openArray[TensorShape],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = -1.int): Barrier =
  return iibarrier(scope,
                   newArraySlice(component_types),
                   newArraySlice(shapes),
                   container,
                   shared_name,
                   capacity)

converter barrierToOut*(op: Barrier): ostring {.inline.} = return op.output


type Div*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Div/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iindiv[oT: oall](scope: Scope,
           x: oT,
           y: oT,
           T: DType): Div[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Div(*#, #, #, #)", constructor.}

proc ndiv*[oT: oall](scope: Scope,
           x: oT,
           y: oT): Div[oT] =
  return iindiv(scope,
                x,
                y,
                oT[].oTF)

converter ndivToOut*[oT: oall](op: Div[oT]): oT {.inline.} = return op.output


type TensorArraySizeV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySizeV2/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iitensorArraySizeV2(scope: Scope,
                        handle: ostring,
                        flow_in: ofloat): TensorArraySizeV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySizeV2(*#, #, #)", constructor.}

proc tensorArraySizeV2*(scope: Scope,
                        handle: ostring,
                        flow_in: ofloat): TensorArraySizeV2 =
  return iitensorArraySizeV2(scope,
                             handle,
                             flow_in)

converter tensorArraySizeV2ToOut*(op: TensorArraySizeV2): oint32 {.inline.} = return op.output

type AdjustContrastT* = ouint8 | oint8 | oint16 | oint32 | oint64 | ofloat | odouble

type AdjustContrast* {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustContrast/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiadjustContrast(scope: Scope,
                     images: AdjustContrastT,
                     contrast_factor: ofloat,
                     min_value: ofloat,
                     max_value: ofloat): AdjustContrast {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustContrast(*#, #, #, #, #)", constructor.}

proc adjustContrast*(scope: Scope,
                     images: AdjustContrastT,
                     contrast_factor: ofloat,
                     min_value: ofloat,
                     max_value: ofloat): AdjustContrast =
  return iiadjustContrast(scope,
                          images,
                          contrast_factor,
                          min_value,
                          max_value)

converter adjustContrastToOut*(op: AdjustContrast): ofloat {.inline.} = return op.output


type MultiDeviceIteratorInit* {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorInit/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iimultiDeviceIteratorInit(scope: Scope,
                              dataset: ovariant,
                              multi_device_iterator: oresource,
                              max_buffer_size: oint64): MultiDeviceIteratorInit {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorInit(*#, #, #, #)", constructor.}

proc multiDeviceIteratorInit*(scope: Scope,
                              dataset: ovariant,
                              multi_device_iterator: oresource,
                              max_buffer_size: oint64): MultiDeviceIteratorInit =
  return iimultiDeviceIteratorInit(scope,
                                   dataset,
                                   multi_device_iterator,
                                   max_buffer_size)

converter multiDeviceIteratorInitToOut*(op: MultiDeviceIteratorInit): oint64 {.inline.} = return op.output

type ComplexAbsT* = ocomplex64 | ocomplex128

type ComplexAbs*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ComplexAbs/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicomplexAbs[oT: oall](scope: Scope,
                 x: ComplexAbsT,
                 Tout: DType,
                 explicitT: type(oT)): ComplexAbs[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ComplexAbs(*#, #, #)", constructor.}

proc complexAbs*(scope: Scope,
                 x: ComplexAbsT,
                 Tout: type = ofloat): auto =
  return iicomplexAbs(scope,
                      x,
                      Tout[].oTF,
                      Tout)

converter complexAbsToOut*[oT: oall](op: ComplexAbs[oT]): oT {.inline.} = return op.output


type RGBToHSV*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RGBToHSV/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirGBToHSV[oT: oall](scope: Scope,
               images: oT,
               T: DType): RGBToHSV[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RGBToHSV(*#, #, #)", constructor.}

proc rGBToHSV*[oT: oall](scope: Scope,
               images: oT): RGBToHSV[oT] =
  return iirGBToHSV(scope,
                    images,
                    oT[].oTF)

converter rGBToHSVToOut*[oT: oall](op: RGBToHSV[oT]): oT {.inline.} = return op.output


type ListDiff*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ListDiff/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilistDiff[oT: oall](scope: Scope,
               x: oT,
               y: oT,
               T: DType,
               out_idx: DType): ListDiff[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ListDiff(*#, #, #, #, #)", constructor.}

proc listDiff*[oT: oall](scope: Scope,
               x: oT,
               y: oT,
               out_idx: type(oint32) | type(oint64) = oint32): ListDiff[oT] =
  return iilistDiff(scope,
                    x,
                    y,
                    oT[].oTF,
                    oT[].oTF)

converter listDiffToOut*[oT: oall](op: ListDiff[oT]): oT {.inline.} = return op.output

type TensorArrayScatterV2T* = oall

type TensorArrayScatterV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayScatterV2/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayScatterV2(scope: Scope,
                           handle: ostring,
                           indices: oint32,
                           value: TensorArrayScatterV2T,
                           flow_in: ofloat): TensorArrayScatterV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayScatterV2(*#, #, #, #, #)", constructor.}

proc tensorArrayScatterV2*(scope: Scope,
                           handle: ostring,
                           indices: oint32,
                           value: TensorArrayScatterV2T,
                           flow_in: ofloat): TensorArrayScatterV2 =
  return iitensorArrayScatterV2(scope,
                                handle,
                                indices,
                                value,
                                flow_in)

converter tensorArrayScatterV2ToOut*(op: TensorArrayScatterV2): ofloat {.inline.} = return op.output


type RFFT3D* {.header:"../tensorflow/ops/generated.h", importcpp:"RFFT3D/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iirFFT3D(scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT3D {.header:"../tensorflow/ops/generated.h", importcpp:"RFFT3D(*#, #, #)", constructor.}

proc rFFT3D*(scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT3D =
  return iirFFT3D(scope,
                  input,
                  fft_length)

converter rFFT3DToOut*(op: RFFT3D): ocomplex64 {.inline.} = return op.output


type TensorArrayGatherV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGatherV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayGatherV2[oT: oall](scope: Scope,
                          handle: ostring,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape: TensorShape,
                          explicitT: type(oT)): TensorArrayGatherV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGatherV2(*#, #, #, #, #, #)", constructor.}

proc tensorArrayGatherV2*(scope: Scope,
                          handle: ostring,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: type = oinvalid,
                          element_shape: TensorShape = [].shape): auto =
  return iitensorArrayGatherV2(scope,
                               handle,
                               indices,
                               flow_in,
                               dtype[].oTF,
                               element_shape,
                               dtype)

converter tensorArrayGatherV2ToOut*[oT: oall](op: TensorArrayGatherV2[oT]): oT {.inline.} = return op.output


type ReaderRestoreStateV2*{.header:"../tensorflow/ops/generated.h", importcpp:"ReaderRestoreStateV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iireaderRestoreStateV2(scope: Scope,
                           reader_handle: oresource,
                           state: ostring): ReaderRestoreStateV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderRestoreStateV2(*#, #, #)", constructor.}

proc readerRestoreStateV2*(scope: Scope,
                           reader_handle: oresource,
                           state: ostring): ReaderRestoreStateV2 =
  return iireaderRestoreStateV2(scope,
                                reader_handle,
                                state)




type IDeviceArg*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_DeviceArg/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiDeviceArg[oT: oall](scope: Scope,
                 T: DType,
                 index: int64,
                 explicitT: type(oT)): IDeviceArg[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_DeviceArg(*#, #, #)", constructor.}

proc iDeviceArg*(scope: Scope,
                 T: type = oinvalid,
                 index: int64 = 0.int): auto =
  return iiiDeviceArg(scope,
                      T[].oTF,
                      index,
                      T)

converter iDeviceArgToOut*[oT: oall](op: IDeviceArg[oT]): oT {.inline.} = return op.output


type StagePeek*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StagePeek/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iistagePeek[oT: oall](scope: Scope,
                index: oint32,
                dtypes: ArraySlice[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64,
                memory_limit: int64,
                explicitT: type(oT)): StagePeek[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StagePeek(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stagePeek*(scope: Scope,
                index: oint32,
                dtypes: openArray[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64 = 0.int,
                memory_limit: int64 = 0.int,
                explicitT: type): auto =
  return iistagePeek(scope,
                     index,
                     newArraySlice(dtypes),
                     container,
                     shared_name,
                     capacity,
                     memory_limit,
                     explicitT)

converter stagePeekToOutList*[oT: oall](op: StagePeek[oT]): olist[oT] {.inline.} = return op.output


type TensorArrayReadV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayReadV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayReadV2[oT: oall](scope: Scope,
                        handle: ostring,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: DType,
                        explicitT: type(oT)): TensorArrayReadV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayReadV2(*#, #, #, #, #)", constructor.}

proc tensorArrayReadV2*(scope: Scope,
                        handle: ostring,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: type = oinvalid): auto =
  return iitensorArrayReadV2(scope,
                             handle,
                             index,
                             flow_in,
                             dtype[].oTF,
                             dtype)

converter tensorArrayReadV2ToOut*[oT: oall](op: TensorArrayReadV2[oT]): oT {.inline.} = return op.output


type AudioSpectrogram* {.header:"../tensorflow/ops/generated.h", importcpp:"AudioSpectrogram/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiaudioSpectrogram(scope: Scope,
                       input: ofloat,
                       window_size: int64,
                       stride: int64,
                       magnitude_squared: bool): AudioSpectrogram {.header:"../tensorflow/ops/generated.h", importcpp:"AudioSpectrogram(*#, #, #, #, #)", constructor.}

proc audioSpectrogram*(scope: Scope,
                       input: ofloat,
                       window_size: int64 = 0.int,
                       stride: int64 = 0.int,
                       magnitude_squared: bool = false): AudioSpectrogram =
  return iiaudioSpectrogram(scope,
                            input,
                            window_size,
                            stride,
                            magnitude_squared)

converter audioSpectrogramToOut*(op: AudioSpectrogram): ofloat {.inline.} = return op.output


type TensorArrayRead*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayRead/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayRead[oT: oall](scope: Scope,
                      handle: ostring,
                      index: oint32,
                      flow_in: ofloat,
                      dtype: DType,
                      explicitT: type(oT)): TensorArrayRead[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayRead(*#, #, #, #, #)", constructor.}

proc tensorArrayRead*(scope: Scope,
                      handle: ostring,
                      index: oint32,
                      flow_in: ofloat,
                      dtype: type = oinvalid): auto =
  return iitensorArrayRead(scope,
                           handle,
                           index,
                           flow_in,
                           dtype[].oTF,
                           dtype)

converter tensorArrayReadToOut*[oT: oall](op: TensorArrayRead[oT]): oT {.inline.} = return op.output

type SparseAddT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseAddTreal* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseAdd* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAdd/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseAdd(scope: Scope,
                a_indices: oint64,
                a_values: SparseAddT,
                a_shape: oint64,
                b_indices: oint64,
                b_values: SparseAddT,
                b_shape: oint64,
                thresh: SparseAddTreal): SparseAdd {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAdd(*#, #, #, #, #, #, #, #)", constructor.}

proc sparseAdd*(scope: Scope,
                a_indices: oint64,
                a_values: SparseAddT,
                a_shape: oint64,
                b_indices: oint64,
                b_values: SparseAddT,
                b_shape: oint64,
                thresh: SparseAddTreal): SparseAdd =
  return iisparseAdd(scope,
                     a_indices,
                     a_values,
                     a_shape,
                     b_indices,
                     b_values,
                     b_shape,
                     thresh)

converter sparseAddToOut*(op: SparseAdd): oint64 {.inline.} = return op.output


type BitwiseXor*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BitwiseXor/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibitwiseXor[oT: oall](scope: Scope,
                 x: oT,
                 y: oT,
                 T: DType): BitwiseXor[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BitwiseXor(*#, #, #, #)", constructor.}

proc bitwiseXor*[oT: oall](scope: Scope,
                 x: oT,
                 y: oT): BitwiseXor[oT] =
  return iibitwiseXor(scope,
                      x,
                      y,
                      oT[].oTF)

converter bitwiseXorToOut*[oT: oall](op: BitwiseXor[oT]): oT {.inline.} = return op.output

type DenseToSparseSetOperationT* = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type DenseToSparseSetOperation* {.header:"../tensorflow/ops/generated.h", importcpp:"DenseToSparseSetOperation/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iidenseToSparseSetOperation(scope: Scope,
                                set1: DenseToSparseSetOperationT,
                                set2_indices: oint64,
                                set2_values: DenseToSparseSetOperationT,
                                set2_shape: oint64,
                                set_operation: cstring,
                                validate_indices: bool): DenseToSparseSetOperation {.header:"../tensorflow/ops/generated.h", importcpp:"DenseToSparseSetOperation(*#, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc denseToSparseSetOperation*(scope: Scope,
                                set1: DenseToSparseSetOperationT,
                                set2_indices: oint64,
                                set2_values: DenseToSparseSetOperationT,
                                set2_shape: oint64,
                                set_operation: cstring,
                                validate_indices: bool = true): DenseToSparseSetOperation =
  return iidenseToSparseSetOperation(scope,
                                     set1,
                                     set2_indices,
                                     set2_values,
                                     set2_shape,
                                     set_operation,
                                     validate_indices)

converter denseToSparseSetOperationToOut*(op: DenseToSparseSetOperation): oint64 {.inline.} = return op.output

type TensorArrayWriteV2T* = oall

type TensorArrayWriteV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayWriteV2/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayWriteV2(scope: Scope,
                         handle: ostring,
                         index: oint32,
                         value: TensorArrayWriteV2T,
                         flow_in: ofloat): TensorArrayWriteV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayWriteV2(*#, #, #, #, #)", constructor.}

proc tensorArrayWriteV2*(scope: Scope,
                         handle: ostring,
                         index: oint32,
                         value: TensorArrayWriteV2T,
                         flow_in: ofloat): TensorArrayWriteV2 =
  return iitensorArrayWriteV2(scope,
                              handle,
                              index,
                              value,
                              flow_in)

converter tensorArrayWriteV2ToOut*(op: TensorArrayWriteV2): ofloat {.inline.} = return op.output

type TensorArrayWriteT* = oall

type TensorArrayWrite* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayWrite/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayWrite(scope: Scope,
                       handle: ostring,
                       index: oint32,
                       value: TensorArrayWriteT,
                       flow_in: ofloat): TensorArrayWrite {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayWrite(*#, #, #, #, #)", constructor.}

proc tensorArrayWrite*(scope: Scope,
                       handle: ostring,
                       index: oint32,
                       value: TensorArrayWriteT,
                       flow_in: ofloat): TensorArrayWrite =
  return iitensorArrayWrite(scope,
                            handle,
                            index,
                            value,
                            flow_in)

converter tensorArrayWriteToOut*(op: TensorArrayWrite): ofloat {.inline.} = return op.output

type ReverseSequenceTlen* = oint32 | oint64

type ReverseSequence*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ReverseSequence/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireverseSequence[oT: oall](scope: Scope,
                      input: oT,
                      seq_lengths: ReverseSequenceTlen,
                      seq_dim: int64,
                      batch_dim: int64,
                      T: DType): ReverseSequence[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ReverseSequence(*#, #, #, #, #, #)", constructor.}

proc reverseSequence*[oT: oall](scope: Scope,
                      input: oT,
                      seq_lengths: ReverseSequenceTlen,
                      seq_dim: int64 = 0.int,
                      batch_dim: int64 = 0.int): ReverseSequence[oT] =
  return iireverseSequence(scope,
                           input,
                           seq_lengths,
                           seq_dim,
                           batch_dim,
                           oT[].oTF)

converter reverseSequenceToOut*[oT: oall](op: ReverseSequence[oT]): oT {.inline.} = return op.output


type TensorArrayGatherV3*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGatherV3/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayGatherV3[oT: oall](scope: Scope,
                          handle: oresource,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape: TensorShape,
                          explicitT: type(oT)): TensorArrayGatherV3[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGatherV3(*#, #, #, #, #, #)", constructor.}

proc tensorArrayGatherV3*(scope: Scope,
                          handle: oresource,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: type = oinvalid,
                          element_shape: TensorShape = [].shape): auto =
  return iitensorArrayGatherV3(scope,
                               handle,
                               indices,
                               flow_in,
                               dtype[].oTF,
                               element_shape,
                               dtype)

converter tensorArrayGatherV3ToOut*[oT: oall](op: TensorArrayGatherV3[oT]): oT {.inline.} = return op.output


type FilterByLastComponentDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"FilterByLastComponentDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iifilterByLastComponentDataset(scope: Scope,
                                   input_dataset: ovariant,
                                   output_types: ArraySlice[DType],
                                   output_shapes: ArraySlice[TensorShape]): FilterByLastComponentDataset {.header:"../tensorflow/ops/generated.h", importcpp:"FilterByLastComponentDataset(*#, #, #, #)", constructor.}

proc filterByLastComponentDataset*(scope: Scope,
                                   input_dataset: ovariant,
                                   output_types: openArray[DType],
                                   output_shapes: openArray[TensorShape]): FilterByLastComponentDataset =
  return iifilterByLastComponentDataset(scope,
                                        input_dataset,
                                        newArraySlice(output_types),
                                        newArraySlice(output_shapes))

converter filterByLastComponentDatasetToOut*(op: FilterByLastComponentDataset): ovariant {.inline.} = return op.output


type ShuffleDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ShuffleDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iishuffleDataset(scope: Scope,
                     input_dataset: ovariant,
                     buffer_size: oint64,
                     seed: oint64,
                     seed2: oint64,
                     output_types: ArraySlice[DType],
                     output_shapes: ArraySlice[TensorShape],
                     reshuffle_each_iteration: bool): ShuffleDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ShuffleDataset(*#, #, #, #, #, #, #, #)", constructor.}

proc shuffleDataset*(scope: Scope,
                     input_dataset: ovariant,
                     buffer_size: oint64,
                     seed: oint64,
                     seed2: oint64,
                     output_types: openArray[DType],
                     output_shapes: openArray[TensorShape],
                     reshuffle_each_iteration: bool = true): ShuffleDataset =
  return iishuffleDataset(scope,
                          input_dataset,
                          buffer_size,
                          seed,
                          seed2,
                          newArraySlice(output_types),
                          newArraySlice(output_shapes),
                          reshuffle_each_iteration)

converter shuffleDatasetToOut*(op: ShuffleDataset): ovariant {.inline.} = return op.output


type DivNoNan*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DivNoNan/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidivNoNan[oT: oall](scope: Scope,
               x: oT,
               y: oT,
               T: DType): DivNoNan[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DivNoNan(*#, #, #, #)", constructor.}

proc divNoNan*[oT: oall](scope: Scope,
               x: oT,
               y: oT): DivNoNan[oT] =
  return iidivNoNan(scope,
                    x,
                    y,
                    oT[].oTF)

converter divNoNanToOut*[oT: oall](op: DivNoNan[oT]): oT {.inline.} = return op.output

type EditDistanceT* = oall

type EditDistance* {.header:"../tensorflow/ops/generated.h", importcpp:"EditDistance/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iieditDistance(scope: Scope,
                   hypothesis_indices: oint64,
                   hypothesis_values: EditDistanceT,
                   hypothesis_shape: oint64,
                   truth_indices: oint64,
                   truth_values: EditDistanceT,
                   truth_shape: oint64,
                   normalize: bool): EditDistance {.header:"../tensorflow/ops/generated.h", importcpp:"EditDistance(*#, #, #, #, #, #, #, #)", constructor.}

proc editDistance*(scope: Scope,
                   hypothesis_indices: oint64,
                   hypothesis_values: EditDistanceT,
                   hypothesis_shape: oint64,
                   truth_indices: oint64,
                   truth_values: EditDistanceT,
                   truth_shape: oint64,
                   normalize: bool = true): EditDistance =
  return iieditDistance(scope,
                        hypothesis_indices,
                        hypothesis_values,
                        hypothesis_shape,
                        truth_indices,
                        truth_values,
                        truth_shape,
                        normalize)

converter editDistanceToOut*(op: EditDistance): ofloat {.inline.} = return op.output


type AvgPoolGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPoolGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiavgPoolGrad[oT: oall](scope: Scope,
                  orig_input_shape: oint32,
                  grad: oT,
                  ksize: ArraySlice[int],
                  strides: ArraySlice[int],
                  padding: cstring,
                  data_format: cstring,
                  T: DType): AvgPoolGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPoolGrad(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc avgPoolGrad*[oT: oall](scope: Scope,
                  orig_input_shape: oint32,
                  grad: oT,
                  ksize: openArray[int],
                  strides: openArray[int],
                  padding: cstring,
                  data_format: cstring = "NHWC"): AvgPoolGrad[oT] =
  return iiavgPoolGrad(scope,
                       orig_input_shape,
                       grad,
                       newArraySlice(ksize),
                       newArraySlice(strides),
                       padding,
                       data_format,
                       oT[].oTF)

converter avgPoolGradToOut*[oT: oall](op: AvgPoolGrad[oT]): oT {.inline.} = return op.output


type ParallelConcat*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelConcat/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiparallelConcat[oT: oall](scope: Scope,
                     values: olist[oT],
                     T: DType,
                     shape: TensorShape): ParallelConcat[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelConcat(*#, #, #, #)", constructor.}

proc parallelConcat*[oT: oall](scope: Scope,
                     values: olist[oT],
                     shape: TensorShape = [].shape): ParallelConcat[oT] =
  return iiparallelConcat(scope,
                          values,
                          oT[].oTF,
                          shape)

converter parallelConcatToOut*[oT: oall](op: ParallelConcat[oT]): oT {.inline.} = return op.output


type RangeDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"RangeDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iirangeDataset(scope: Scope,
                   start: oint64,
                   stop: oint64,
                   step: oint64,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): RangeDataset {.header:"../tensorflow/ops/generated.h", importcpp:"RangeDataset(*#, #, #, #, #, #)", constructor.}

proc rangeDataset*(scope: Scope,
                   start: oint64,
                   stop: oint64,
                   step: oint64,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): RangeDataset =
  return iirangeDataset(scope,
                        start,
                        stop,
                        step,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter rangeDatasetToOut*(op: RangeDataset): ovariant {.inline.} = return op.output

type UnsortedSegmentMaxTindices* = oint32 | oint64
type UnsortedSegmentMaxTnumsegments* = oint32 | oint64

type UnsortedSegmentMax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentMax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunsortedSegmentMax[oT: oall](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMaxTindices,
                         num_segments: UnsortedSegmentMaxTnumsegments,
                         T: DType): UnsortedSegmentMax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UnsortedSegmentMax(*#, #, #, #, #)", constructor.}

proc unsortedSegmentMax*[oT: oall](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMaxTindices,
                         num_segments: UnsortedSegmentMaxTnumsegments): UnsortedSegmentMax[oT] =
  return iiunsortedSegmentMax(scope,
                              data,
                              segment_ids,
                              num_segments,
                              oT[].oTF)

converter unsortedSegmentMaxToOut*[oT: oall](op: UnsortedSegmentMax[oT]): oT {.inline.} = return op.output


type TensorArrayGradWithShape* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGradWithShape/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iitensorArrayGradWithShape(scope: Scope,
                               handle: oresource,
                               flow_in: ofloat,
                               shape_to_prepend: oint32,
                               source: cstring): TensorArrayGradWithShape {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGradWithShape(*#, #, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGradWithShape*(scope: Scope,
                               handle: oresource,
                               flow_in: ofloat,
                               shape_to_prepend: oint32,
                               source: cstring): TensorArrayGradWithShape =
  return iitensorArrayGradWithShape(scope,
                                    handle,
                                    flow_in,
                                    shape_to_prepend,
                                    source)

converter tensorArrayGradWithShapeToOut*(op: TensorArrayGradWithShape): oresource {.inline.} = return op.output


type MultiDeviceIteratorToStringHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorToStringHandle/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iimultiDeviceIteratorToStringHandle(scope: Scope,
                                        multi_device_iterator: oresource): MultiDeviceIteratorToStringHandle {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorToStringHandle(*#, #)", constructor.}

proc multiDeviceIteratorToStringHandle*(scope: Scope,
                                        multi_device_iterator: oresource): MultiDeviceIteratorToStringHandle =
  return iimultiDeviceIteratorToStringHandle(scope,
                                             multi_device_iterator)

converter multiDeviceIteratorToStringHandleToOut*(op: MultiDeviceIteratorToStringHandle): ostring {.inline.} = return op.output


type TensorArrayGradV3* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGradV3/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iitensorArrayGradV3(scope: Scope,
                        handle: oresource,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGradV3(*#, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGradV3*(scope: Scope,
                        handle: oresource,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV3 =
  return iitensorArrayGradV3(scope,
                             handle,
                             flow_in,
                             source)

converter tensorArrayGradV3ToOut*(op: TensorArrayGradV3): oresource {.inline.} = return op.output

type SparseApplyFtrlV2Tindices* = oint32 | oint64

type SparseApplyFtrlV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyFtrlV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyFtrlV2[oT: oall](scope: Scope,
                        nvar: oT,
                        accum: oT,
                        linear: oT,
                        grad: oT,
                        indices: SparseApplyFtrlV2Tindices,
                        lr: oT,
                        l1: oT,
                        l2: oT,
                        l2_shrinkage: oT,
                        lr_power: oT,
                        T: DType,
                        use_locking: bool): SparseApplyFtrlV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyFtrlV2*[oT: oall](scope: Scope,
                        nvar: oT,
                        accum: oT,
                        linear: oT,
                        grad: oT,
                        indices: SparseApplyFtrlV2Tindices,
                        lr: oT,
                        l1: oT,
                        l2: oT,
                        l2_shrinkage: oT,
                        lr_power: oT,
                        use_locking: bool = false): SparseApplyFtrlV2[oT] =
  return iisparseApplyFtrlV2(scope,
                             nvar,
                             accum,
                             linear,
                             grad,
                             indices,
                             lr,
                             l1,
                             l2,
                             l2_shrinkage,
                             lr_power,
                             oT[].oTF,
                             use_locking)

converter sparseApplyFtrlV2ToOut*[oT: oall](op: SparseApplyFtrlV2[oT]): oT {.inline.} = return op.output


type StackPop*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPop/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistackPop[oT: oall](scope: Scope,
               handle: ostring,
               elem_type: DType,
               explicitT: type(oT)): StackPop[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPop(*#, #, #)", constructor.}

proc stackPop*(scope: Scope,
               handle: ostring,
               elem_type: type = oinvalid): auto =
  return iistackPop(scope,
                    handle,
                    elem_type[].oTF,
                    elem_type)

converter stackPopToOut*[oT: oall](op: StackPop[oT]): oT {.inline.} = return op.output


type Stack* {.header:"../tensorflow/ops/generated.h", importcpp:"Stack/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iistack(scope: Scope,
            stack_name: cstring,
            elem_type: DType): Stack {.header:"../tensorflow/ops/generated.h", importcpp:"Stack(*#, tensorflow::string(#), #)", constructor.}

proc stack*(scope: Scope,
            stack_name: cstring,
            elem_type: type oall = oinvalid): Stack =
  return iistack(scope,
                 stack_name,
                 oT[].oTF)

converter stackToOut*(op: Stack): ostring {.inline.} = return op.output


type Abs*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Abs/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiabs[oT: oall](scope: Scope,
          x: oT,
          T: DType): Abs[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Abs(*#, #, #)", constructor.}

proc abs*[oT: oall](scope: Scope,
          x: oT): Abs[oT] =
  return iiabs(scope,
               x,
               oT[].oTF)

converter absToOut*[oT: oall](op: Abs[oT]): oT {.inline.} = return op.output

type GatherTindices* = oint32 | oint64

type Gather*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Gather/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iigather[oT: oall](scope: Scope,
             params: oT,
             indices: GatherTindices,
             validate_indices: bool,
             Tparams: DType): Gather[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Gather(*#, #, #, #, #)", constructor.}

proc gather*[oT: oall](scope: Scope,
             params: oT,
             indices: GatherTindices,
             validate_indices: bool = true): Gather[oT] =
  return iigather(scope,
                  params,
                  indices,
                  validate_indices,
                  oT[].oTF)

converter gatherToOut*[oT: oall](op: Gather[oT]): oT {.inline.} = return op.output


type TensorArrayReadV3*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayReadV3/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayReadV3[oT: oall](scope: Scope,
                        handle: oresource,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: DType,
                        explicitT: type(oT)): TensorArrayReadV3[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayReadV3(*#, #, #, #, #)", constructor.}

proc tensorArrayReadV3*(scope: Scope,
                        handle: oresource,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: type = oinvalid): auto =
  return iitensorArrayReadV3(scope,
                             handle,
                             index,
                             flow_in,
                             dtype[].oTF,
                             dtype)

converter tensorArrayReadV3ToOut*[oT: oall](op: TensorArrayReadV3[oT]): oT {.inline.} = return op.output


type AvgPool3DGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPool3DGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiavgPool3DGrad[oT: oall](scope: Scope,
                    orig_input_shape: oint32,
                    grad: oT,
                    ksize: ArraySlice[int],
                    strides: ArraySlice[int],
                    padding: cstring,
                    data_format: cstring,
                    T: DType): AvgPool3DGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPool3DGrad(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc avgPool3DGrad*[oT: oall](scope: Scope,
                    orig_input_shape: oint32,
                    grad: oT,
                    ksize: openArray[int],
                    strides: openArray[int],
                    padding: cstring,
                    data_format: cstring = "NDHWC"): AvgPool3DGrad[oT] =
  return iiavgPool3DGrad(scope,
                         orig_input_shape,
                         grad,
                         newArraySlice(ksize),
                         newArraySlice(strides),
                         padding,
                         data_format,
                         oT[].oTF)

converter avgPool3DGradToOut*[oT: oall](op: AvgPool3DGrad[oT]): oT {.inline.} = return op.output


type TensorArrayCloseV2*{.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayCloseV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iitensorArrayCloseV2(scope: Scope,
                         handle: ostring): TensorArrayCloseV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayCloseV2(*#, #)", constructor.}

proc tensorArrayCloseV2*(scope: Scope,
                         handle: ostring): TensorArrayCloseV2 =
  return iitensorArrayCloseV2(scope,
                              handle)




type ThreadUnsafeUnigramCandidateSampler* {.header:"../tensorflow/ops/generated.h", importcpp:"ThreadUnsafeUnigramCandidateSampler/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iithreadUnsafeUnigramCandidateSampler(scope: Scope,
                                          true_classes: oint64,
                                          num_true: int64,
                                          num_sampled: int64,
                                          unique: bool,
                                          range_max: int64,
                                          seed: int64,
                                          seed2: int64): ThreadUnsafeUnigramCandidateSampler {.header:"../tensorflow/ops/generated.h", importcpp:"ThreadUnsafeUnigramCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc threadUnsafeUnigramCandidateSampler*(scope: Scope,
                                          true_classes: oint64,
                                          num_true: int64 = 0.int,
                                          num_sampled: int64 = 0.int,
                                          unique: bool = false,
                                          range_max: int64 = 0.int,
                                          seed: int64 = 0.int,
                                          seed2: int64 = 0.int): ThreadUnsafeUnigramCandidateSampler =
  return iithreadUnsafeUnigramCandidateSampler(scope,
                                               true_classes,
                                               num_true,
                                               num_sampled,
                                               unique,
                                               range_max,
                                               seed,
                                               seed2)

converter threadUnsafeUnigramCandidateSamplerToOut*(op: ThreadUnsafeUnigramCandidateSampler): oint64 {.inline.} = return op.output


type StackCloseV2*{.header:"../tensorflow/ops/generated.h", importcpp:"StackCloseV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iistackCloseV2(scope: Scope,
                   handle: oresource): StackCloseV2 {.header:"../tensorflow/ops/generated.h", importcpp:"StackCloseV2(*#, #)", constructor.}

proc stackCloseV2*(scope: Scope,
                   handle: oresource): StackCloseV2 =
  return iistackCloseV2(scope,
                        handle)




type StackPopV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPopV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistackPopV2[oT: oall](scope: Scope,
                 handle: oresource,
                 elem_type: DType,
                 explicitT: type(oT)): StackPopV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPopV2(*#, #, #)", constructor.}

proc stackPopV2*(scope: Scope,
                 handle: oresource,
                 elem_type: type = oinvalid): auto =
  return iistackPopV2(scope,
                      handle,
                      elem_type[].oTF,
                      elem_type)

converter stackPopV2ToOut*[oT: oall](op: StackPopV2[oT]): oT {.inline.} = return op.output


type StackPushV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPushV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistackPushV2[oT: oall](scope: Scope,
                  handle: oresource,
                  elem: oT,
                  T: DType,
                  swap_memory: bool): StackPushV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StackPushV2(*#, #, #, #, #)", constructor.}

proc stackPushV2*[oT: oall](scope: Scope,
                  handle: oresource,
                  elem: oT,
                  swap_memory: bool = false): StackPushV2[oT] =
  return iistackPushV2(scope,
                       handle,
                       elem,
                       oT[].oTF,
                       swap_memory)

converter stackPushV2ToOut*[oT: oall](op: StackPushV2[oT]): oT {.inline.} = return op.output


type TileGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TileGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitileGrad[oT: oall](scope: Scope,
               input: oT,
               multiples: oint32,
               T: DType): TileGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TileGrad(*#, #, #, #)", constructor.}

proc tileGrad*[oT: oall](scope: Scope,
               input: oT,
               multiples: oint32): TileGrad[oT] =
  return iitileGrad(scope,
                    input,
                    multiples,
                    oT[].oTF)

converter tileGradToOut*[oT: oall](op: TileGrad[oT]): oT {.inline.} = return op.output


type QueueDequeueUpTo*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueUpTo/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiqueueDequeueUpTo[oT: oall](scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: ArraySlice[DType],
                       timeout_ms: int64,
                       explicitT: type(oT)): QueueDequeueUpTo[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueUpTo(*#, #, #, #, #)", constructor.}

proc queueDequeueUpTo*(scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: openArray[DType],
                       timeout_ms: int64 = -1.int,
                       explicitT: type): auto =
  return iiqueueDequeueUpTo(scope,
                            handle,
                            n,
                            newArraySlice(component_types),
                            timeout_ms,
                            explicitT)

converter queueDequeueUpToToOutList*[oT: oall](op: QueueDequeueUpTo[oT]): olist[oT] {.inline.} = return op.output


type AudioSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"AudioSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiaudioSummary(scope: Scope,
                   tag: ostring,
                   tensor: ofloat,
                   sample_rate: float32,
                   max_outputs: int64): AudioSummary {.header:"../tensorflow/ops/generated.h", importcpp:"AudioSummary(*#, #, #, #, #)", constructor.}

proc audioSummary*(scope: Scope,
                   tag: ostring,
                   tensor: ofloat,
                   sample_rate: float32 = 0.0.float32,
                   max_outputs: int64 = 3.int): AudioSummary =
  return iiaudioSummary(scope,
                        tag,
                        tensor,
                        sample_rate,
                        max_outputs)

converter audioSummaryToOut*(op: AudioSummary): ostring {.inline.} = return op.output


type PaddedBatchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"PaddedBatchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iipaddedBatchDataset(scope: Scope,
                         input_dataset: ovariant,
                         batch_size: oint64,
                         padded_shapes: olist[oint64],
                         padding_values: olist[oall],
                         Toutput_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape]): PaddedBatchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"PaddedBatchDataset(*#, #, #, #, #, #, #)", constructor.}

proc paddedBatchDataset*(scope: Scope,
                         input_dataset: ovariant,
                         batch_size: oint64,
                         padded_shapes: olist[oint64],
                         padding_values: olist[oall],
                         Toutput_types: openArray[DType],
                         output_shapes: openArray[TensorShape]): PaddedBatchDataset =
  return iipaddedBatchDataset(scope,
                              input_dataset,
                              batch_size,
                              padded_shapes,
                              padding_values,
                              newArraySlice(Toutput_types),
                              newArraySlice(output_shapes))

converter paddedBatchDatasetToOut*(op: PaddedBatchDataset): ovariant {.inline.} = return op.output


type StackV2* {.header:"../tensorflow/ops/generated.h", importcpp:"StackV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iistackV2(scope: Scope,
              max_size: oint32,
              stack_name: cstring,
              elem_type: DType): StackV2 {.header:"../tensorflow/ops/generated.h", importcpp:"StackV2(*#, #, tensorflow::string(#), #)", constructor.}

proc stackV2*(scope: Scope,
              max_size: oint32,
              stack_name: cstring,
              elem_type: type oall = oinvalid): StackV2 =
  return iistackV2(scope,
                   max_size,
                   stack_name,
                   oT[].oTF)

converter stackV2ToOut*(op: StackV2): oresource {.inline.} = return op.output


type SparseConditionalAccumulator* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseConditionalAccumulator/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iisparseConditionalAccumulator(scope: Scope,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: DType,
                                   shape: TensorShape,
                                   reduction_type: cstring): SparseConditionalAccumulator {.header:"../tensorflow/ops/generated.h", importcpp:"SparseConditionalAccumulator(*#, tensorflow::string(#), tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc sparseConditionalAccumulator*(scope: Scope,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: type(ofloat) | type(odouble) | type(oint32) | type(ouint8) | type(oint16) | type(oint8) | type(ocomplex64) | type(oint64) | type(oqint8) | type(oquint8) | type(oqint32) | type(obfloat16) | type(ouint16) | type(ocomplex128) | type(ohalf) | type(ouint32) | type(ouint64) = oinvalid,
                                   shape: TensorShape = [].shape,
                                   reduction_type: cstring = "MEAN"): SparseConditionalAccumulator =
  return iisparseConditionalAccumulator(scope,
                                        container,
                                        shared_name,
                                        oT[].oTF,
                                        shape,
                                        reduction_type)

converter sparseConditionalAccumulatorToOut*(op: SparseConditionalAccumulator): ostring {.inline.} = return op.output


type OrderedMapUnstage*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapUnstage/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiorderedMapUnstage[oT: oall](scope: Scope,
                        key: oint64,
                        indices: oint32,
                        dtypes: ArraySlice[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64,
                        memory_limit: int64,
                        explicitT: type(oT)): OrderedMapUnstage[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapUnstage(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapUnstage*(scope: Scope,
                        key: oint64,
                        indices: oint32,
                        dtypes: openArray[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64 = 0.int,
                        memory_limit: int64 = 0.int,
                        explicitT: type): auto =
  return iiorderedMapUnstage(scope,
                             key,
                             indices,
                             newArraySlice(dtypes),
                             container,
                             shared_name,
                             capacity,
                             memory_limit,
                             explicitT)

converter orderedMapUnstageToOutList*[oT: oall](op: OrderedMapUnstage[oT]): olist[oT] {.inline.} = return op.output


type IVarHandlesOp* {.header:"../tensorflow/ops/generated.h", importcpp:"_VarHandlesOp/*'0*/".} = object
  operation*: Operation[oresource]
  output*: olist[oresource]

proc iiiVarHandlesOp(scope: Scope,
                    containers: ArraySlice[cstring],
                    shared_names: ArraySlice[cstring],
                    dtypes: ArraySlice[DType],
                    shapes: ArraySlice[TensorShape]): IVarHandlesOp {.header:"../tensorflow/ops/generated.h", importcpp:"_VarHandlesOp(*#, #, #, #, #)", constructor.}

proc iVarHandlesOp*(scope: Scope,
                    containers: openArray[cstring],
                    shared_names: openArray[cstring],
                    dtypes: openArray[DType],
                    shapes: openArray[TensorShape]): IVarHandlesOp =
  return iiiVarHandlesOp(scope,
                         newArraySlice(containers),
                         newArraySlice(shared_names),
                         newArraySlice(dtypes),
                         newArraySlice(shapes))

converter iVarHandlesOpToOutList*(op: IVarHandlesOp): olist[oresource] {.inline.} = return op.output

type TensorArraySplitV2T* = oall

type TensorArraySplitV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySplitV2/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArraySplitV2(scope: Scope,
                         handle: ostring,
                         value: TensorArraySplitV2T,
                         lengths: oint64,
                         flow_in: ofloat): TensorArraySplitV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySplitV2(*#, #, #, #, #)", constructor.}

proc tensorArraySplitV2*(scope: Scope,
                         handle: ostring,
                         value: TensorArraySplitV2T,
                         lengths: oint64,
                         flow_in: ofloat): TensorArraySplitV2 =
  return iitensorArraySplitV2(scope,
                              handle,
                              value,
                              lengths,
                              flow_in)

converter tensorArraySplitV2ToOut*(op: TensorArraySplitV2): ofloat {.inline.} = return op.output


type AccumulatorTakeGradient*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorTakeGradient/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiaccumulatorTakeGradient[oT: oall](scope: Scope,
                              handle: ostring,
                              num_required: oint32,
                              dtype: DType,
                              explicitT: type(oT)): AccumulatorTakeGradient[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorTakeGradient(*#, #, #, #)", constructor.}

proc accumulatorTakeGradient*(scope: Scope,
                              handle: ostring,
                              num_required: oint32,
                              dtype: type = oinvalid): auto =
  return iiaccumulatorTakeGradient(scope,
                                   handle,
                                   num_required,
                                   dtype[].oTF,
                                   dtype)

converter accumulatorTakeGradientToOut*[oT: oall](op: AccumulatorTakeGradient[oT]): oT {.inline.} = return op.output


type ExtractJpegShape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractJpegShape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiextractJpegShape[oT: oall](scope: Scope,
                       contents: ostring,
                       output_type: DType,
                       explicitT: type(oT)): ExtractJpegShape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractJpegShape(*#, #, #)", constructor.}

proc extractJpegShape*(scope: Scope,
                       contents: ostring,
                       output_type: type = oint32): auto =
  return iiextractJpegShape(scope,
                            contents,
                            output_type[].oTF,
                            output_type)

converter extractJpegShapeToOut*[oT: oall](op: ExtractJpegShape[oT]): oT {.inline.} = return op.output


type ConditionalAccumulator* {.header:"../tensorflow/ops/generated.h", importcpp:"ConditionalAccumulator/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiconditionalAccumulator(scope: Scope,
                             container: cstring,
                             shared_name: cstring,
                             dtype: DType,
                             shape: TensorShape,
                             reduction_type: cstring): ConditionalAccumulator {.header:"../tensorflow/ops/generated.h", importcpp:"ConditionalAccumulator(*#, tensorflow::string(#), tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc conditionalAccumulator*(scope: Scope,
                             container: cstring,
                             shared_name: cstring,
                             dtype: type(ofloat) | type(odouble) | type(oint32) | type(ouint8) | type(oint16) | type(oint8) | type(ocomplex64) | type(oint64) | type(oqint8) | type(oquint8) | type(oqint32) | type(obfloat16) | type(ouint16) | type(ocomplex128) | type(ohalf) | type(ouint32) | type(ouint64) = oinvalid,
                             shape: TensorShape = [].shape,
                             reduction_type: cstring = "MEAN"): ConditionalAccumulator =
  return iiconditionalAccumulator(scope,
                                  container,
                                  shared_name,
                                  oT[].oTF,
                                  shape,
                                  reduction_type)

converter conditionalAccumulatorToOut*(op: ConditionalAccumulator): ostring {.inline.} = return op.output


type AccumulatorNumAccumulated* {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorNumAccumulated/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiaccumulatorNumAccumulated(scope: Scope,
                                handle: ostring): AccumulatorNumAccumulated {.header:"../tensorflow/ops/generated.h", importcpp:"AccumulatorNumAccumulated(*#, #)", constructor.}

proc accumulatorNumAccumulated*(scope: Scope,
                                handle: ostring): AccumulatorNumAccumulated =
  return iiaccumulatorNumAccumulated(scope,
                                     handle)

converter accumulatorNumAccumulatedToOut*(op: AccumulatorNumAccumulated): oint32 {.inline.} = return op.output


type LogicalNot* {.header:"../tensorflow/ops/generated.h", importcpp:"LogicalNot/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iilogicalNot(scope: Scope,
                 x: obool): LogicalNot {.header:"../tensorflow/ops/generated.h", importcpp:"LogicalNot(*#, #)", constructor.}

proc logicalNot*(scope: Scope,
                 x: obool): LogicalNot =
  return iilogicalNot(scope,
                      x)

converter logicalNotToOut*(op: LogicalNot): obool {.inline.} = return op.output


type Lu*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Lu/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilu[oT: oall](scope: Scope,
         input: oT,
         T: DType,
         output_idx_type: DType): Lu[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Lu(*#, #, #, #)", constructor.}

proc lu*[oT: oall](scope: Scope,
         input: oT,
         output_idx_type: type(oint32) | type(oint64) = oint32): Lu[oT] =
  return iilu(scope,
              input,
              oT[].oTF,
              oT[].oTF)

converter luToOut*[oT: oall](op: Lu[oT]): oT {.inline.} = return op.output


type QueueSize* {.header:"../tensorflow/ops/generated.h", importcpp:"QueueSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiqueueSize(scope: Scope,
                handle: ostring): QueueSize {.header:"../tensorflow/ops/generated.h", importcpp:"QueueSize(*#, #)", constructor.}

proc queueSize*(scope: Scope,
                handle: ostring): QueueSize =
  return iiqueueSize(scope,
                     handle)

converter queueSizeToOut*(op: QueueSize): oint32 {.inline.} = return op.output

type TensorArraySplitV3T* = oall

type TensorArraySplitV3* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySplitV3/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArraySplitV3(scope: Scope,
                         handle: oresource,
                         value: TensorArraySplitV3T,
                         lengths: oint64,
                         flow_in: ofloat): TensorArraySplitV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySplitV3(*#, #, #, #, #)", constructor.}

proc tensorArraySplitV3*(scope: Scope,
                         handle: oresource,
                         value: TensorArraySplitV3T,
                         lengths: oint64,
                         flow_in: ofloat): TensorArraySplitV3 =
  return iitensorArraySplitV3(scope,
                              handle,
                              value,
                              lengths,
                              flow_in)

converter tensorArraySplitV3ToOut*(op: TensorArraySplitV3): ofloat {.inline.} = return op.output


type IteratorGetNextAsOptional* {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorGetNextAsOptional/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiiteratorGetNextAsOptional(scope: Scope,
                                niterator: oresource,
                                output_types: ArraySlice[DType],
                                output_shapes: ArraySlice[TensorShape]): IteratorGetNextAsOptional {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorGetNextAsOptional(*#, #, #, #)", constructor.}

proc iteratorGetNextAsOptional*(scope: Scope,
                                niterator: oresource,
                                output_types: openArray[DType],
                                output_shapes: openArray[TensorShape]): IteratorGetNextAsOptional =
  return iiiteratorGetNextAsOptional(scope,
                                     niterator,
                                     newArraySlice(output_types),
                                     newArraySlice(output_shapes))

converter iteratorGetNextAsOptionalToOut*(op: IteratorGetNextAsOptional): ovariant {.inline.} = return op.output


type GcsConfigureCredentials*{.header:"../tensorflow/ops/generated.h", importcpp:"GcsConfigureCredentials/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iigcsConfigureCredentials(scope: Scope,
                              json: ostring): GcsConfigureCredentials {.header:"../tensorflow/ops/generated.h", importcpp:"GcsConfigureCredentials(*#, #)", constructor.}

proc gcsConfigureCredentials*(scope: Scope,
                              json: ostring): GcsConfigureCredentials =
  return iigcsConfigureCredentials(scope,
                                   json)




type QueueDequeueManyV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueManyV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiqueueDequeueManyV2[oT: oall](scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: ArraySlice[DType],
                         timeout_ms: int64,
                         explicitT: type(oT)): QueueDequeueManyV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueManyV2(*#, #, #, #, #)", constructor.}

proc queueDequeueManyV2*(scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: openArray[DType],
                         timeout_ms: int64 = -1.int,
                         explicitT: type): auto =
  return iiqueueDequeueManyV2(scope,
                              handle,
                              n,
                              newArraySlice(component_types),
                              timeout_ms,
                              explicitT)

converter queueDequeueManyV2ToOutList*[oT: oall](op: QueueDequeueManyV2[oT]): olist[oT] {.inline.} = return op.output


type VarHandleOp* {.header:"../tensorflow/ops/generated.h", importcpp:"VarHandleOp/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iivarHandleOp(scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  dtype: DType,
                  shape: TensorShape): VarHandleOp {.header:"../tensorflow/ops/generated.h", importcpp:"VarHandleOp(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc varHandleOp*(scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  dtype: type oall = oinvalid,
                  shape: TensorShape = [].shape): VarHandleOp =
  return iivarHandleOp(scope,
                       container,
                       shared_name,
                       oT[].oTF,
                       shape)

converter varHandleOpToOut*(op: VarHandleOp): oresource {.inline.} = return op.output


type ComputeAccidentalHits* {.header:"../tensorflow/ops/generated.h", importcpp:"ComputeAccidentalHits/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iicomputeAccidentalHits(scope: Scope,
                            true_classes: oint64,
                            sampled_candidates: oint64,
                            num_true: int64,
                            seed: int64,
                            seed2: int64): ComputeAccidentalHits {.header:"../tensorflow/ops/generated.h", importcpp:"ComputeAccidentalHits(*#, #, #, #, #, #)", constructor.}

proc computeAccidentalHits*(scope: Scope,
                            true_classes: oint64,
                            sampled_candidates: oint64,
                            num_true: int64 = 0.int,
                            seed: int64 = 0.int,
                            seed2: int64 = 0.int): ComputeAccidentalHits =
  return iicomputeAccidentalHits(scope,
                                 true_classes,
                                 sampled_candidates,
                                 num_true,
                                 seed,
                                 seed2)

converter computeAccidentalHitsToOut*(op: ComputeAccidentalHits): oint32 {.inline.} = return op.output


type QueueDequeueMany*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueMany/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiqueueDequeueMany[oT: oall](scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: ArraySlice[DType],
                       timeout_ms: int64,
                       explicitT: type(oT)): QueueDequeueMany[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueMany(*#, #, #, #, #)", constructor.}

proc queueDequeueMany*(scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: openArray[DType],
                       timeout_ms: int64 = -1.int,
                       explicitT: type): auto =
  return iiqueueDequeueMany(scope,
                            handle,
                            n,
                            newArraySlice(component_types),
                            timeout_ms,
                            explicitT)

converter queueDequeueManyToOutList*[oT: oall](op: QueueDequeueMany[oT]): olist[oT] {.inline.} = return op.output


type ExperimentalMaxIntraOpParallelismDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMaxIntraOpParallelismDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalMaxIntraOpParallelismDataset(scope: Scope,
                                               input_dataset: ovariant,
                                               max_intra_op_parallelism: oint64,
                                               output_types: ArraySlice[DType],
                                               output_shapes: ArraySlice[TensorShape]): ExperimentalMaxIntraOpParallelismDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMaxIntraOpParallelismDataset(*#, #, #, #, #)", constructor.}

proc experimentalMaxIntraOpParallelismDataset*(scope: Scope,
                                               input_dataset: ovariant,
                                               max_intra_op_parallelism: oint64,
                                               output_types: openArray[DType],
                                               output_shapes: openArray[TensorShape]): ExperimentalMaxIntraOpParallelismDataset =
  return iiexperimentalMaxIntraOpParallelismDataset(scope,
                                                    input_dataset,
                                                    max_intra_op_parallelism,
                                                    newArraySlice(output_types),
                                                    newArraySlice(output_shapes))

converter experimentalMaxIntraOpParallelismDatasetToOut*(op: ExperimentalMaxIntraOpParallelismDataset): ovariant {.inline.} = return op.output


type QueueEnqueueMany*{.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueueMany/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiqueueEnqueueMany(scope: Scope,
                       handle: ostring,
                       components: olist[oall],
                       Tcomponents: ArraySlice[DType],
                       timeout_ms: int64): QueueEnqueueMany {.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueueMany(*#, #, #, #, #)", constructor.}

proc queueEnqueueMany*(scope: Scope,
                       handle: ostring,
                       components: olist[oall],
                       Tcomponents: openArray[DType],
                       timeout_ms: int64 = -1.int): QueueEnqueueMany =
  return iiqueueEnqueueMany(scope,
                            handle,
                            components,
                            newArraySlice(Tcomponents),
                            timeout_ms)




type PaddingFIFOQueue* {.header:"../tensorflow/ops/generated.h", importcpp:"PaddingFIFOQueue/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iipaddingFIFOQueue(scope: Scope,
                       component_types: ArraySlice[DType],
                       shapes: ArraySlice[TensorShape],
                       container: cstring,
                       shared_name: cstring,
                       capacity: int64): PaddingFIFOQueue {.header:"../tensorflow/ops/generated.h", importcpp:"PaddingFIFOQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc paddingFIFOQueue*(scope: Scope,
                       component_types: openArray[DType],
                       shapes: openArray[TensorShape],
                       container: cstring,
                       shared_name: cstring,
                       capacity: int64 = -1.int): PaddingFIFOQueue =
  return iipaddingFIFOQueue(scope,
                            newArraySlice(component_types),
                            newArraySlice(shapes),
                            container,
                            shared_name,
                            capacity)

converter paddingFIFOQueueToOut*(op: PaddingFIFOQueue): ostring {.inline.} = return op.output


type OrderedMapUnstageNoKey* {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapUnstageNoKey/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiorderedMapUnstageNoKey(scope: Scope,
                             indices: oint32,
                             dtypes: ArraySlice[DType],
                             container: cstring,
                             shared_name: cstring,
                             capacity: int64,
                             memory_limit: int64): OrderedMapUnstageNoKey {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapUnstageNoKey(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapUnstageNoKey*(scope: Scope,
                             indices: oint32,
                             dtypes: openArray[DType],
                             container: cstring,
                             shared_name: cstring,
                             capacity: int64 = 0.int,
                             memory_limit: int64 = 0.int): OrderedMapUnstageNoKey =
  return iiorderedMapUnstageNoKey(scope,
                                  indices,
                                  newArraySlice(dtypes),
                                  container,
                                  shared_name,
                                  capacity,
                                  memory_limit)

converter orderedMapUnstageNoKeyToOut*(op: OrderedMapUnstageNoKey): oint64 {.inline.} = return op.output


type TensorForestTreeResourceHandleOp* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeResourceHandleOp/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iitensorForestTreeResourceHandleOp(scope: Scope,
                                       container: cstring,
                                       shared_name: cstring): TensorForestTreeResourceHandleOp {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeResourceHandleOp(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc tensorForestTreeResourceHandleOp*(scope: Scope,
                                       container: cstring,
                                       shared_name: cstring): TensorForestTreeResourceHandleOp =
  return iitensorForestTreeResourceHandleOp(scope,
                                            container,
                                            shared_name)

converter tensorForestTreeResourceHandleOpToOut*(op: TensorForestTreeResourceHandleOp): oresource {.inline.} = return op.output

type SparseSegmentSumTidx* = oint32 | oint64

type SparseSegmentSum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseSegmentSum[oT: oall](scope: Scope,
                       data: oT,
                       indices: SparseSegmentSumTidx,
                       segment_ids: oint32,
                       T: DType): SparseSegmentSum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseSegmentSum(*#, #, #, #, #)", constructor.}

proc sparseSegmentSum*[oT: oall](scope: Scope,
                       data: oT,
                       indices: SparseSegmentSumTidx,
                       segment_ids: oint32): SparseSegmentSum[oT] =
  return iisparseSegmentSum(scope,
                            data,
                            indices,
                            segment_ids,
                            oT[].oTF)

converter sparseSegmentSumToOut*[oT: oall](op: SparseSegmentSum[oT]): oT {.inline.} = return op.output


type FIFOQueue* {.header:"../tensorflow/ops/generated.h", importcpp:"FIFOQueue/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iifIFOQueue(scope: Scope,
                component_types: ArraySlice[DType],
                shapes: ArraySlice[TensorShape],
                container: cstring,
                shared_name: cstring,
                capacity: int64): FIFOQueue {.header:"../tensorflow/ops/generated.h", importcpp:"FIFOQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc fIFOQueue*(scope: Scope,
                component_types: openArray[DType],
                shapes: openArray[TensorShape],
                container: cstring,
                shared_name: cstring,
                capacity: int64 = -1.int): FIFOQueue =
  return iifIFOQueue(scope,
                     newArraySlice(component_types),
                     newArraySlice(shapes),
                     container,
                     shared_name,
                     capacity)

converter fIFOQueueToOut*(op: FIFOQueue): ostring {.inline.} = return op.output

type TensorArrayWriteV3T* = oall

type TensorArrayWriteV3* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayWriteV3/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayWriteV3(scope: Scope,
                         handle: oresource,
                         index: oint32,
                         value: TensorArrayWriteV3T,
                         flow_in: ofloat): TensorArrayWriteV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayWriteV3(*#, #, #, #, #)", constructor.}

proc tensorArrayWriteV3*(scope: Scope,
                         handle: oresource,
                         index: oint32,
                         value: TensorArrayWriteV3T,
                         flow_in: ofloat): TensorArrayWriteV3 =
  return iitensorArrayWriteV3(scope,
                              handle,
                              index,
                              value,
                              flow_in)

converter tensorArrayWriteV3ToOut*(op: TensorArrayWriteV3): ofloat {.inline.} = return op.output


type RefMerge*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefMerge/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefMerge[oT: oall](scope: Scope,
               inputs: olist[oT],
               T: DType): RefMerge[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefMerge(*#, #, #)", constructor.}

proc refMerge*[oT: oall](scope: Scope,
               inputs: olist[oT]): RefMerge[oT] =
  return iirefMerge(scope,
                    inputs,
                    oT[].oTF)

converter refMergeToOut*[oT: oall](op: RefMerge[oT]): oT {.inline.} = return op.output


type BitwiseOr*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BitwiseOr/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibitwiseOr[oT: oall](scope: Scope,
                x: oT,
                y: oT,
                T: DType): BitwiseOr[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BitwiseOr(*#, #, #, #)", constructor.}

proc bitwiseOr*[oT: oall](scope: Scope,
                x: oT,
                y: oT): BitwiseOr[oT] =
  return iibitwiseOr(scope,
                     x,
                     y,
                     oT[].oTF)

converter bitwiseOrToOut*[oT: oall](op: BitwiseOr[oT]): oT {.inline.} = return op.output

type TensorArrayScatterT* = oall

type TensorArrayScatter* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayScatter/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArrayScatter(scope: Scope,
                         handle: ostring,
                         indices: oint32,
                         value: TensorArrayScatterT,
                         flow_in: ofloat): TensorArrayScatter {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayScatter(*#, #, #, #, #)", constructor.}

proc tensorArrayScatter*(scope: Scope,
                         handle: ostring,
                         indices: oint32,
                         value: TensorArrayScatterT,
                         flow_in: ofloat): TensorArrayScatter =
  return iitensorArrayScatter(scope,
                              handle,
                              indices,
                              value,
                              flow_in)

converter tensorArrayScatterToOut*(op: TensorArrayScatter): ofloat {.inline.} = return op.output


type RestoreV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RestoreV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iirestoreV2[oT: oall](scope: Scope,
                prefix: ostring,
                tensor_names: ostring,
                shape_and_slices: ostring,
                dtypes: ArraySlice[DType],
                explicitT: type(oT)): RestoreV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RestoreV2(*#, #, #, #, #)", constructor.}

proc restoreV2*(scope: Scope,
                prefix: ostring,
                tensor_names: ostring,
                shape_and_slices: ostring,
                dtypes: openArray[DType],
                explicitT: type): auto =
  return iirestoreV2(scope,
                     prefix,
                     tensor_names,
                     shape_and_slices,
                     newArraySlice(dtypes),
                     explicitT)

converter restoreV2ToOutList*[oT: oall](op: RestoreV2[oT]): olist[oT] {.inline.} = return op.output


type RandomShuffleQueue* {.header:"../tensorflow/ops/generated.h", importcpp:"RandomShuffleQueue/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iirandomShuffleQueue(scope: Scope,
                         component_types: ArraySlice[DType],
                         shapes: ArraySlice[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64,
                         min_after_dequeue: int64,
                         seed: int64,
                         seed2: int64): RandomShuffleQueue {.header:"../tensorflow/ops/generated.h", importcpp:"RandomShuffleQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc randomShuffleQueue*(scope: Scope,
                         component_types: openArray[DType],
                         shapes: openArray[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64 = -1.int,
                         min_after_dequeue: int64 = 0.int,
                         seed: int64 = 0.int,
                         seed2: int64 = 0.int): RandomShuffleQueue =
  return iirandomShuffleQueue(scope,
                              newArraySlice(component_types),
                              newArraySlice(shapes),
                              container,
                              shared_name,
                              capacity,
                              min_after_dequeue,
                              seed,
                              seed2)

converter randomShuffleQueueToOut*(op: RandomShuffleQueue): ostring {.inline.} = return op.output


type Invert*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Invert/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinvert[oT: oall](scope: Scope,
             x: oT,
             T: DType): Invert[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Invert(*#, #, #)", constructor.}

proc invert*[oT: oall](scope: Scope,
             x: oT): Invert[oT] =
  return iiinvert(scope,
                  x,
                  oT[].oTF)

converter invertToOut*[oT: oall](op: Invert[oT]): oT {.inline.} = return op.output


type DecodePng*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DecodePng/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidecodePng[oT: oall](scope: Scope,
                contents: ostring,
                channels: int64,
                dtype: DType,
                explicitT: type(oT)): DecodePng[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DecodePng(*#, #, #, #)", constructor.}

proc decodePng*(scope: Scope,
                contents: ostring,
                channels: int64 = 0.int,
                dtype: type = ouint8): auto =
  return iidecodePng(scope,
                     contents,
                     channels,
                     dtype[].oTF,
                     dtype)

converter decodePngToOut*[oT: oall](op: DecodePng[oT]): oT {.inline.} = return op.output


type ControlTrigger*{.header:"../tensorflow/ops/generated.h", importcpp:"ControlTrigger/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iicontrolTrigger(scope: Scope): ControlTrigger {.header:"../tensorflow/ops/generated.h", importcpp:"ControlTrigger(*#)", constructor.}

proc controlTrigger*(scope: Scope): ControlTrigger =
  return iicontrolTrigger(scope)




type ParallelDynamicStitch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelDynamicStitch/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiparallelDynamicStitch[oT: oall](scope: Scope,
                            indices: olist[oint32],
                            data: olist[oT],
                            T: DType): ParallelDynamicStitch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ParallelDynamicStitch(*#, #, #, #)", constructor.}

proc parallelDynamicStitch*[oT: oall](scope: Scope,
                            indices: olist[oint32],
                            data: olist[oT]): ParallelDynamicStitch[oT] =
  return iiparallelDynamicStitch(scope,
                                 indices,
                                 data,
                                 oT[].oTF)

converter parallelDynamicStitchToOut*[oT: oall](op: ParallelDynamicStitch[oT]): oT {.inline.} = return op.output


type MapSize* {.header:"../tensorflow/ops/generated.h", importcpp:"MapSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iimapSize(scope: Scope,
              dtypes: ArraySlice[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64,
              memory_limit: int64): MapSize {.header:"../tensorflow/ops/generated.h", importcpp:"MapSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapSize*(scope: Scope,
              dtypes: openArray[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = 0.int,
              memory_limit: int64 = 0.int): MapSize =
  return iimapSize(scope,
                   newArraySlice(dtypes),
                   container,
                   shared_name,
                   capacity,
                   memory_limit)

converter mapSizeToOut*(op: MapSize): oint32 {.inline.} = return op.output


type SparseReduceSum*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceSum/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseReduceSum[oT: oall](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool,
                      T: DType): SparseReduceSum[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseReduceSum(*#, #, #, #, #, #, #)", constructor.}

proc sparseReduceSum*[oT: oall](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool = false): SparseReduceSum[oT] =
  return iisparseReduceSum(scope,
                           input_indices,
                           input_values,
                           input_shape,
                           reduction_axes,
                           keep_dims,
                           oT[].oTF)

converter sparseReduceSumToOut*[oT: oall](op: SparseReduceSum[oT]): oT {.inline.} = return op.output


type Zeta*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Zeta/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iizeta[oT: oall](scope: Scope,
           x: oT,
           q: oT,
           T: DType): Zeta[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Zeta(*#, #, #, #)", constructor.}

proc zeta*[oT: oall](scope: Scope,
           x: oT,
           q: oT): Zeta[oT] =
  return iizeta(scope,
                x,
                q,
                oT[].oTF)

converter zetaToOut*[oT: oall](op: Zeta[oT]): oT {.inline.} = return op.output


type TensorArrayGradV2* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGradV2/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorArrayGradV2(scope: Scope,
                        handle: ostring,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV2 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGradV2(*#, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGradV2*(scope: Scope,
                        handle: ostring,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV2 =
  return iitensorArrayGradV2(scope,
                             handle,
                             flow_in,
                             source)

converter tensorArrayGradV2ToOut*(op: TensorArrayGradV2): ostring {.inline.} = return op.output

type MaxPoolGradGradWithArgmaxTargmax* = oint32 | oint64

type MaxPoolGradGradWithArgmax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradGradWithArgmax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolGradGradWithArgmax[oT: oall](scope: Scope,
                                input: oT,
                                grad: oT,
                                argmax: MaxPoolGradGradWithArgmaxTargmax,
                                ksize: ArraySlice[int],
                                strides: ArraySlice[int],
                                padding: cstring,
                                T: DType): MaxPoolGradGradWithArgmax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolGradGradWithArgmax(*#, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc maxPoolGradGradWithArgmax*[oT: oall](scope: Scope,
                                input: oT,
                                grad: oT,
                                argmax: MaxPoolGradGradWithArgmaxTargmax,
                                ksize: openArray[int],
                                strides: openArray[int],
                                padding: cstring): MaxPoolGradGradWithArgmax[oT] =
  return iimaxPoolGradGradWithArgmax(scope,
                                     input,
                                     grad,
                                     argmax,
                                     newArraySlice(ksize),
                                     newArraySlice(strides),
                                     padding,
                                     oT[].oTF)

converter maxPoolGradGradWithArgmaxToOut*[oT: oall](op: MaxPoolGradGradWithArgmax[oT]): oT {.inline.} = return op.output

type LessT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Less* {.header:"../tensorflow/ops/generated.h", importcpp:"Less/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiless(scope: Scope,
           x: LessT,
           y: LessT): Less {.header:"../tensorflow/ops/generated.h", importcpp:"Less(*#, #, #)", constructor.}

proc less*(scope: Scope,
           x: LessT,
           y: LessT): Less =
  return iiless(scope,
                x,
                y)

converter lessToOut*(op: Less): obool {.inline.} = return op.output


type ApplyGradientDescent*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyGradientDescent/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyGradientDescent[oT: oall](scope: Scope,
                           nvar: oT,
                           alpha: oT,
                           delta: oT,
                           T: DType,
                           use_locking: bool): ApplyGradientDescent[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyGradientDescent(*#, #, #, #, #, #)", constructor.}

proc applyGradientDescent*[oT: oall](scope: Scope,
                           nvar: oT,
                           alpha: oT,
                           delta: oT,
                           use_locking: bool = false): ApplyGradientDescent[oT] =
  return iiapplyGradientDescent(scope,
                                nvar,
                                alpha,
                                delta,
                                oT[].oTF,
                                use_locking)

converter applyGradientDescentToOut*[oT: oall](op: ApplyGradientDescent[oT]): oT {.inline.} = return op.output


type CollectiveReduce*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CollectiveReduce/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicollectiveReduce[oT: oall](scope: Scope,
                       input: oT,
                       merge_op: cstring,
                       final_op: cstring,
                       subdiv_offsets: ArraySlice[int],
                       T: DType,
                       group_size: int64,
                       group_key: int64,
                       instance_key: int64): CollectiveReduce[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CollectiveReduce(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc collectiveReduce*[oT: oall](scope: Scope,
                       input: oT,
                       merge_op: cstring,
                       final_op: cstring,
                       subdiv_offsets: openArray[int],
                       group_size: int64 = 0.int,
                       group_key: int64 = 0.int,
                       instance_key: int64 = 0.int): CollectiveReduce[oT] =
  return iicollectiveReduce(scope,
                            input,
                            merge_op,
                            final_op,
                            newArraySlice(subdiv_offsets),
                            oT[].oTF,
                            group_size,
                            group_key,
                            instance_key)

converter collectiveReduceToOut*[oT: oall](op: CollectiveReduce[oT]): oT {.inline.} = return op.output


type CreateSummaryFileWriter*{.header:"../tensorflow/ops/generated.h", importcpp:"CreateSummaryFileWriter/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iicreateSummaryFileWriter(scope: Scope,
                              writer: oresource,
                              logdir: ostring,
                              max_queue: oint32,
                              flush_millis: oint32,
                              filename_suffix: ostring): CreateSummaryFileWriter {.header:"../tensorflow/ops/generated.h", importcpp:"CreateSummaryFileWriter(*#, #, #, #, #, #)", constructor.}

proc createSummaryFileWriter*(scope: Scope,
                              writer: oresource,
                              logdir: ostring,
                              max_queue: oint32,
                              flush_millis: oint32,
                              filename_suffix: ostring): CreateSummaryFileWriter =
  return iicreateSummaryFileWriter(scope,
                                   writer,
                                   logdir,
                                   max_queue,
                                   flush_millis,
                                   filename_suffix)




type QueueIsClosedV2* {.header:"../tensorflow/ops/generated.h", importcpp:"QueueIsClosedV2/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiqueueIsClosedV2(scope: Scope,
                      handle: oresource): QueueIsClosedV2 {.header:"../tensorflow/ops/generated.h", importcpp:"QueueIsClosedV2(*#, #)", constructor.}

proc queueIsClosedV2*(scope: Scope,
                      handle: oresource): QueueIsClosedV2 =
  return iiqueueIsClosedV2(scope,
                           handle)

converter queueIsClosedV2ToOut*(op: QueueIsClosedV2): obool {.inline.} = return op.output


type IParallelConcatUpdate*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ParallelConcatUpdate/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiParallelConcatUpdate[oT: oall](scope: Scope,
                            value: oT,
                            update: oT,
                            T: DType,
                            loc: int64): IParallelConcatUpdate[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ParallelConcatUpdate(*#, #, #, #, #)", constructor.}

proc iParallelConcatUpdate*[oT: oall](scope: Scope,
                            value: oT,
                            update: oT,
                            loc: int64 = 0.int): IParallelConcatUpdate[oT] =
  return iiiParallelConcatUpdate(scope,
                                 value,
                                 update,
                                 oT[].oTF,
                                 loc)

converter iParallelConcatUpdateToOut*[oT: oall](op: IParallelConcatUpdate[oT]): oT {.inline.} = return op.output


type CudnnRNNCanonicalToParams*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNCanonicalToParams/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNNCanonicalToParams[oT: oall](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                weights: oT,
                                biases: oT,
                                T: DType,
                                num_params: int64,
                                rnn_mode: cstring,
                                input_mode: cstring,
                                direction: cstring,
                                dropout: float32,
                                seed: int64,
                                seed2: int64): CudnnRNNCanonicalToParams[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNCanonicalToParams(*#, #, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNNCanonicalToParams*[oT: oall](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                weights: oT,
                                biases: oT,
                                num_params: int64 = 0.int,
                                rnn_mode: cstring = "lstm",
                                input_mode: cstring = "linear_input",
                                direction: cstring = "unidirectional",
                                dropout: float32 = 0.0.float32,
                                seed: int64 = 0.int,
                                seed2: int64 = 0.int): CudnnRNNCanonicalToParams[oT] =
  return iicudnnRNNCanonicalToParams(scope,
                                     num_layers,
                                     num_units,
                                     input_size,
                                     weights,
                                     biases,
                                     oT[].oTF,
                                     num_params,
                                     rnn_mode,
                                     input_mode,
                                     direction,
                                     dropout,
                                     seed,
                                     seed2)

converter cudnnRNNCanonicalToParamsToOut*[oT: oall](op: CudnnRNNCanonicalToParams[oT]): oT {.inline.} = return op.output


type TensorArraySizeV3* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySizeV3/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iitensorArraySizeV3(scope: Scope,
                        handle: oresource,
                        flow_in: ofloat): TensorArraySizeV3 {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySizeV3(*#, #, #)", constructor.}

proc tensorArraySizeV3*(scope: Scope,
                        handle: oresource,
                        flow_in: ofloat): TensorArraySizeV3 =
  return iitensorArraySizeV3(scope,
                             handle,
                             flow_in)

converter tensorArraySizeV3ToOut*(op: TensorArraySizeV3): oint32 {.inline.} = return op.output


type DiagPart*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DiagPart/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidiagPart[oT: oall](scope: Scope,
               input: oT,
               T: DType): DiagPart[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DiagPart(*#, #, #)", constructor.}

proc diagPart*[oT: oall](scope: Scope,
               input: oT): DiagPart[oT] =
  return iidiagPart(scope,
                    input,
                    oT[].oTF)

converter diagPartToOut*[oT: oall](op: DiagPart[oT]): oT {.inline.} = return op.output


type CudnnRNNParamsToCanonical*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNParamsToCanonical/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNNParamsToCanonical[oT: oall](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                params: oT,
                                T: DType,
                                num_params: int64,
                                rnn_mode: cstring,
                                input_mode: cstring,
                                direction: cstring,
                                dropout: float32,
                                seed: int64,
                                seed2: int64): CudnnRNNParamsToCanonical[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNParamsToCanonical(*#, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNNParamsToCanonical*[oT: oall](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                params: oT,
                                num_params: int64 = 0.int,
                                rnn_mode: cstring = "lstm",
                                input_mode: cstring = "linear_input",
                                direction: cstring = "unidirectional",
                                dropout: float32 = 0.0.float32,
                                seed: int64 = 0.int,
                                seed2: int64 = 0.int): CudnnRNNParamsToCanonical[oT] =
  return iicudnnRNNParamsToCanonical(scope,
                                     num_layers,
                                     num_units,
                                     input_size,
                                     params,
                                     oT[].oTF,
                                     num_params,
                                     rnn_mode,
                                     input_mode,
                                     direction,
                                     dropout,
                                     seed,
                                     seed2)

converter cudnnRNNParamsToCanonicalToOut*[oT: oall](op: CudnnRNNParamsToCanonical[oT]): oT {.inline.} = return op.output


type IParallelConcatStart*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ParallelConcatStart/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiParallelConcatStart[oT: oall](scope: Scope,
                           shape: TensorShape,
                           dtype: DType,
                           explicitT: type(oT)): IParallelConcatStart[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ParallelConcatStart(*#, #, #)", constructor.}

proc iParallelConcatStart*(scope: Scope,
                           shape: TensorShape = [].shape,
                           dtype: type = oinvalid): auto =
  return iiiParallelConcatStart(scope,
                                shape,
                                dtype[].oTF,
                                dtype)

converter iParallelConcatStartToOut*[oT: oall](op: IParallelConcatStart[oT]): oT {.inline.} = return op.output

type SizeT* = oall

type Size*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Size/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisize[oT: oall](scope: Scope,
           input: SizeT,
           out_type: DType,
           explicitT: type(oT)): Size[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Size(*#, #, #)", constructor.}

proc size*(scope: Scope,
           input: SizeT,
           out_type: type = oint32): auto =
  return iisize(scope,
                input,
                out_type[].oTF,
                out_type)

converter sizeToOut*[oT: oall](op: Size[oT]): oT {.inline.} = return op.output


type FakeQuantWithMinMaxVarsGradient* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVarsGradient/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iifakeQuantWithMinMaxVarsGradient(scope: Scope,
                                      gradients: ofloat,
                                      inputs: ofloat,
                                      min: ofloat,
                                      max: ofloat,
                                      num_bits: int64,
                                      narrow_range: bool): FakeQuantWithMinMaxVarsGradient {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxVarsGradient(*#, #, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVarsGradient*(scope: Scope,
                                      gradients: ofloat,
                                      inputs: ofloat,
                                      min: ofloat,
                                      max: ofloat,
                                      num_bits: int64 = 8.int,
                                      narrow_range: bool = false): FakeQuantWithMinMaxVarsGradient =
  return iifakeQuantWithMinMaxVarsGradient(scope,
                                           gradients,
                                           inputs,
                                           min,
                                           max,
                                           num_bits,
                                           narrow_range)

converter fakeQuantWithMinMaxVarsGradientToOut*(op: FakeQuantWithMinMaxVarsGradient): ofloat {.inline.} = return op.output

type NonMaxSuppressionV4T* = ohalf | ofloat

type NonMaxSuppressionV4* {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionV4/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iinonMaxSuppressionV4(scope: Scope,
                          boxes: NonMaxSuppressionV4T,
                          scores: NonMaxSuppressionV4T,
                          max_output_size: oint32,
                          iou_threshold: ofloat,
                          score_threshold: ofloat,
                          pad_to_max_output_size: bool): NonMaxSuppressionV4 {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionV4(*#, #, #, #, #, #, #)", constructor.}

proc nonMaxSuppressionV4*(scope: Scope,
                          boxes: NonMaxSuppressionV4T,
                          scores: NonMaxSuppressionV4T,
                          max_output_size: oint32,
                          iou_threshold: ofloat,
                          score_threshold: ofloat,
                          pad_to_max_output_size: bool = false): NonMaxSuppressionV4 =
  return iinonMaxSuppressionV4(scope,
                               boxes,
                               scores,
                               max_output_size,
                               iou_threshold,
                               score_threshold,
                               pad_to_max_output_size)

converter nonMaxSuppressionV4ToOut*(op: NonMaxSuppressionV4): oint32 {.inline.} = return op.output


type CudnnRNNBackprop*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNBackprop/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNNBackprop[oT: oall](scope: Scope,
                       input: oT,
                       input_h: oT,
                       input_c: oT,
                       params: oT,
                       output: oT,
                       output_h: oT,
                       output_c: oT,
                       output_backprop: oT,
                       output_h_backprop: oT,
                       output_c_backprop: oT,
                       reserve_space: oT,
                       T: DType,
                       rnn_mode: cstring,
                       input_mode: cstring,
                       direction: cstring,
                       dropout: float32,
                       seed: int64,
                       seed2: int64): CudnnRNNBackprop[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNBackprop(*#, #, #, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNNBackprop*[oT: oall](scope: Scope,
                       input: oT,
                       input_h: oT,
                       input_c: oT,
                       params: oT,
                       output: oT,
                       output_h: oT,
                       output_c: oT,
                       output_backprop: oT,
                       output_h_backprop: oT,
                       output_c_backprop: oT,
                       reserve_space: oT,
                       rnn_mode: cstring = "lstm",
                       input_mode: cstring = "linear_input",
                       direction: cstring = "unidirectional",
                       dropout: float32 = 0.0.float32,
                       seed: int64 = 0.int,
                       seed2: int64 = 0.int): CudnnRNNBackprop[oT] =
  return iicudnnRNNBackprop(scope,
                            input,
                            input_h,
                            input_c,
                            params,
                            output,
                            output_h,
                            output_c,
                            output_backprop,
                            output_h_backprop,
                            output_c_backprop,
                            reserve_space,
                            oT[].oTF,
                            rnn_mode,
                            input_mode,
                            direction,
                            dropout,
                            seed,
                            seed2)

converter cudnnRNNBackpropToOut*[oT: oall](op: CudnnRNNBackprop[oT]): oT {.inline.} = return op.output

type PadTpaddings* = oint32 | oint64

type Pad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Pad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iipad[oT: oall](scope: Scope,
          input: oT,
          paddings: PadTpaddings,
          T: DType): Pad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Pad(*#, #, #, #)", constructor.}

proc pad*[oT: oall](scope: Scope,
          input: oT,
          paddings: PadTpaddings): Pad[oT] =
  return iipad(scope,
               input,
               paddings,
               oT[].oTF)

converter padToOut*[oT: oall](op: Pad[oT]): oT {.inline.} = return op.output


type CudnnRNNV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNNV2[oT: oall](scope: Scope,
                 input: oT,
                 input_h: oT,
                 input_c: oT,
                 params: oT,
                 T: DType,
                 rnn_mode: cstring,
                 input_mode: cstring,
                 direction: cstring,
                 dropout: float32,
                 seed: int64,
                 seed2: int64,
                 is_training: bool): CudnnRNNV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNV2(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc cudnnRNNV2*[oT: oall](scope: Scope,
                 input: oT,
                 input_h: oT,
                 input_c: oT,
                 params: oT,
                 rnn_mode: cstring = "lstm",
                 input_mode: cstring = "linear_input",
                 direction: cstring = "unidirectional",
                 dropout: float32 = 0.0.float32,
                 seed: int64 = 0.int,
                 seed2: int64 = 0.int,
                 is_training: bool = true): CudnnRNNV2[oT] =
  return iicudnnRNNV2(scope,
                      input,
                      input_h,
                      input_c,
                      params,
                      oT[].oTF,
                      rnn_mode,
                      input_mode,
                      direction,
                      dropout,
                      seed,
                      seed2,
                      is_training)

converter cudnnRNNV2ToOut*[oT: oall](op: CudnnRNNV2[oT]): oT {.inline.} = return op.output


type DynamicStitch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DynamicStitch/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidynamicStitch[oT: oall](scope: Scope,
                    indices: olist[oint32],
                    data: olist[oT],
                    T: DType): DynamicStitch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DynamicStitch(*#, #, #, #)", constructor.}

proc dynamicStitch*[oT: oall](scope: Scope,
                    indices: olist[oint32],
                    data: olist[oT]): DynamicStitch[oT] =
  return iidynamicStitch(scope,
                         indices,
                         data,
                         oT[].oTF)

converter dynamicStitchToOut*[oT: oall](op: DynamicStitch[oT]): oT {.inline.} = return op.output

type IRetvalT* = oall

type IRetval*{.header:"../tensorflow/ops/generated.h", importcpp:"_Retval/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiiRetval(scope: Scope,
              input: IRetvalT,
              index: int64): IRetval {.header:"../tensorflow/ops/generated.h", importcpp:"_Retval(*#, #, #)", constructor.}

proc iRetval*(scope: Scope,
              input: IRetvalT,
              index: int64 = 0.int): IRetval =
  return iiiRetval(scope,
                   input,
                   index)




type CTCBeamSearchDecoder* {.header:"../tensorflow/ops/generated.h", importcpp:"CTCBeamSearchDecoder/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iicTCBeamSearchDecoder(scope: Scope,
                           inputs: ofloat,
                           sequence_length: oint32,
                           beam_width: int64,
                           top_paths: int64,
                           merge_repeated: bool): CTCBeamSearchDecoder {.header:"../tensorflow/ops/generated.h", importcpp:"CTCBeamSearchDecoder(*#, #, #, #, #, #)", constructor.}

proc cTCBeamSearchDecoder*(scope: Scope,
                           inputs: ofloat,
                           sequence_length: oint32,
                           beam_width: int64 = 0.int,
                           top_paths: int64 = 0.int,
                           merge_repeated: bool = true): CTCBeamSearchDecoder =
  return iicTCBeamSearchDecoder(scope,
                                inputs,
                                sequence_length,
                                beam_width,
                                top_paths,
                                merge_repeated)

converter cTCBeamSearchDecoderToOut*(op: CTCBeamSearchDecoder): oint64 {.inline.} = return op.output


type OrderedMapPeek*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapPeek/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiorderedMapPeek[oT: oall](scope: Scope,
                     key: oint64,
                     indices: oint32,
                     dtypes: ArraySlice[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64,
                     memory_limit: int64,
                     explicitT: type(oT)): OrderedMapPeek[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"OrderedMapPeek(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapPeek*(scope: Scope,
                     key: oint64,
                     indices: oint32,
                     dtypes: openArray[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64 = 0.int,
                     memory_limit: int64 = 0.int,
                     explicitT: type): auto =
  return iiorderedMapPeek(scope,
                          key,
                          indices,
                          newArraySlice(dtypes),
                          container,
                          shared_name,
                          capacity,
                          memory_limit,
                          explicitT)

converter orderedMapPeekToOutList*[oT: oall](op: OrderedMapPeek[oT]): olist[oT] {.inline.} = return op.output


type FusedResizeAndPadConv2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedResizeAndPadConv2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifusedResizeAndPadConv2D[oT: oall](scope: Scope,
                              input: oT,
                              size: oint32,
                              paddings: oint32,
                              filter: oT,
                              mode: cstring,
                              strides: ArraySlice[int],
                              padding: cstring,
                              T: DType,
                              resize_align_corners: bool): FusedResizeAndPadConv2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedResizeAndPadConv2D(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #, #)", constructor.}

proc fusedResizeAndPadConv2D*[oT: oall](scope: Scope,
                              input: oT,
                              size: oint32,
                              paddings: oint32,
                              filter: oT,
                              mode: cstring,
                              strides: openArray[int],
                              padding: cstring,
                              resize_align_corners: bool = false): FusedResizeAndPadConv2D[oT] =
  return iifusedResizeAndPadConv2D(scope,
                                   input,
                                   size,
                                   paddings,
                                   filter,
                                   mode,
                                   newArraySlice(strides),
                                   padding,
                                   oT[].oTF,
                                   resize_align_corners)

converter fusedResizeAndPadConv2DToOut*[oT: oall](op: FusedResizeAndPadConv2D[oT]): oT {.inline.} = return op.output


type Xdivy*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Xdivy/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iixdivy[oT: oall](scope: Scope,
            x: oT,
            y: oT,
            T: DType): Xdivy[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Xdivy(*#, #, #, #)", constructor.}

proc xdivy*[oT: oall](scope: Scope,
            x: oT,
            y: oT): Xdivy[oT] =
  return iixdivy(scope,
                 x,
                 y,
                 oT[].oTF)

converter xdivyToOut*[oT: oall](op: Xdivy[oT]): oT {.inline.} = return op.output


type RefNextIteration*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefNextIteration/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefNextIteration[oT: oall](scope: Scope,
                       data: oT,
                       T: DType): RefNextIteration[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefNextIteration(*#, #, #)", constructor.}

proc refNextIteration*[oT: oall](scope: Scope,
                       data: oT): RefNextIteration[oT] =
  return iirefNextIteration(scope,
                            data,
                            oT[].oTF)

converter refNextIterationToOut*[oT: oall](op: RefNextIteration[oT]): oT {.inline.} = return op.output


type LogMatrixDeterminant*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LogMatrixDeterminant/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilogMatrixDeterminant[oT: oall](scope: Scope,
                           input: oT,
                           T: DType): LogMatrixDeterminant[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LogMatrixDeterminant(*#, #, #)", constructor.}

proc logMatrixDeterminant*[oT: oall](scope: Scope,
                           input: oT): LogMatrixDeterminant[oT] =
  return iilogMatrixDeterminant(scope,
                                input,
                                oT[].oTF)

converter logMatrixDeterminantToOut*[oT: oall](op: LogMatrixDeterminant[oT]): oT {.inline.} = return op.output


type ExperimentalNonSerializableDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalNonSerializableDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalNonSerializableDataset(scope: Scope,
                                         input_dataset: ovariant,
                                         output_types: ArraySlice[DType],
                                         output_shapes: ArraySlice[TensorShape]): ExperimentalNonSerializableDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalNonSerializableDataset(*#, #, #, #)", constructor.}

proc experimentalNonSerializableDataset*(scope: Scope,
                                         input_dataset: ovariant,
                                         output_types: openArray[DType],
                                         output_shapes: openArray[TensorShape]): ExperimentalNonSerializableDataset =
  return iiexperimentalNonSerializableDataset(scope,
                                              input_dataset,
                                              newArraySlice(output_types),
                                              newArraySlice(output_shapes))

converter experimentalNonSerializableDatasetToOut*(op: ExperimentalNonSerializableDataset): ovariant {.inline.} = return op.output


type Exit*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Exit/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiexit[oT: oall](scope: Scope,
           data: oT,
           T: DType): Exit[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Exit(*#, #, #)", constructor.}

proc exit*[oT: oall](scope: Scope,
           data: oT): Exit[oT] =
  return iiexit(scope,
                data,
                oT[].oTF)

converter exitToOut*[oT: oall](op: Exit[oT]): oT {.inline.} = return op.output


type StringStrip* {.header:"../tensorflow/ops/generated.h", importcpp:"StringStrip/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iistringStrip(scope: Scope,
                  input: ostring): StringStrip {.header:"../tensorflow/ops/generated.h", importcpp:"StringStrip(*#, #)", constructor.}

proc stringStrip*(scope: Scope,
                  input: ostring): StringStrip =
  return iistringStrip(scope,
                       input)

converter stringStripToOut*(op: StringStrip): ostring {.inline.} = return op.output


type RefSelect*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefSelect/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefSelect[oT: oall](scope: Scope,
                index: oint32,
                inputs: olist[oT],
                T: DType): RefSelect[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefSelect(*#, #, #, #)", constructor.}

proc refSelect*[oT: oall](scope: Scope,
                index: oint32,
                inputs: olist[oT]): RefSelect[oT] =
  return iirefSelect(scope,
                     index,
                     inputs,
                     oT[].oTF)

converter refSelectToOut*[oT: oall](op: RefSelect[oT]): oT {.inline.} = return op.output


type Softmax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Softmax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisoftmax[oT: oall](scope: Scope,
              logits: oT,
              T: DType): Softmax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Softmax(*#, #, #)", constructor.}

proc softmax*[oT: oall](scope: Scope,
              logits: oT): Softmax[oT] =
  return iisoftmax(scope,
                   logits,
                   oT[].oTF)

converter softmaxToOut*[oT: oall](op: Softmax[oT]): oT {.inline.} = return op.output

type ScalarSummaryT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type ScalarSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"ScalarSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiscalarSummary(scope: Scope,
                    tags: ostring,
                    values: ScalarSummaryT): ScalarSummary {.header:"../tensorflow/ops/generated.h", importcpp:"ScalarSummary(*#, #, #)", constructor.}

proc scalarSummary*(scope: Scope,
                    tags: ostring,
                    values: ScalarSummaryT): ScalarSummary =
  return iiscalarSummary(scope,
                         tags,
                         values)

converter scalarSummaryToOut*(op: ScalarSummary): ostring {.inline.} = return op.output


type Identity*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Identity/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiidentity[oT: oall](scope: Scope,
               input: oT,
               T: DType): Identity[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Identity(*#, #, #)", constructor.}

proc identity*[oT: oall](scope: Scope,
               input: oT): Identity[oT] =
  return iiidentity(scope,
                    input,
                    oT[].oTF)

converter identityToOut*[oT: oall](op: Identity[oT]): oT {.inline.} = return op.output

type ReverseV2Tidx* = oint32 | oint64

type ReverseV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ReverseV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireverseV2[oT: oall](scope: Scope,
                tensor: oT,
                axis: ReverseV2Tidx,
                T: DType): ReverseV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ReverseV2(*#, #, #, #)", constructor.}

proc reverseV2*[oT: oall](scope: Scope,
                tensor: oT,
                axis: ReverseV2Tidx): ReverseV2[oT] =
  return iireverseV2(scope,
                     tensor,
                     axis,
                     oT[].oTF)

converter reverseV2ToOut*[oT: oall](op: ReverseV2[oT]): oT {.inline.} = return op.output


type RefSwitch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefSwitch/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefSwitch[oT: oall](scope: Scope,
                data: oT,
                pred: obool,
                T: DType): RefSwitch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefSwitch(*#, #, #, #)", constructor.}

proc refSwitch*[oT: oall](scope: Scope,
                data: oT,
                pred: obool): RefSwitch[oT] =
  return iirefSwitch(scope,
                     data,
                     pred,
                     oT[].oTF)

converter refSwitchToOut*[oT: oall](op: RefSwitch[oT]): oT {.inline.} = return op.output


type NoOp*{.header:"../tensorflow/ops/generated.h", importcpp:"NoOp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iinoOp(scope: Scope): NoOp {.header:"../tensorflow/ops/generated.h", importcpp:"NoOp(*#)", constructor.}

proc noOp*(scope: Scope): NoOp =
  return iinoOp(scope)




type LoadAndRemapMatrix* {.header:"../tensorflow/ops/generated.h", importcpp:"LoadAndRemapMatrix/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiloadAndRemapMatrix(scope: Scope,
                         ckpt_path: ostring,
                         old_tensor_name: ostring,
                         row_remapping: oint64,
                         col_remapping: oint64,
                         initializing_values: ofloat,
                         num_rows: int64,
                         num_cols: int64,
                         max_rows_in_memory: int64): LoadAndRemapMatrix {.header:"../tensorflow/ops/generated.h", importcpp:"LoadAndRemapMatrix(*#, #, #, #, #, #, #, #, #)", constructor.}

proc loadAndRemapMatrix*(scope: Scope,
                         ckpt_path: ostring,
                         old_tensor_name: ostring,
                         row_remapping: oint64,
                         col_remapping: oint64,
                         initializing_values: ofloat,
                         num_rows: int64 = 0.int,
                         num_cols: int64 = 0.int,
                         max_rows_in_memory: int64 = -1.int): LoadAndRemapMatrix =
  return iiloadAndRemapMatrix(scope,
                              ckpt_path,
                              old_tensor_name,
                              row_remapping,
                              col_remapping,
                              initializing_values,
                              num_rows,
                              num_cols,
                              max_rows_in_memory)

converter loadAndRemapMatrixToOut*(op: LoadAndRemapMatrix): ofloat {.inline.} = return op.output


type IteratorFromStringHandleV2* {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorFromStringHandleV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiiteratorFromStringHandleV2(scope: Scope,
                                 string_handle: ostring,
                                 output_types: ArraySlice[DType],
                                 output_shapes: ArraySlice[TensorShape]): IteratorFromStringHandleV2 {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorFromStringHandleV2(*#, #, #, #)", constructor.}

proc iteratorFromStringHandleV2*(scope: Scope,
                                 string_handle: ostring,
                                 output_types: openArray[DType],
                                 output_shapes: openArray[TensorShape]): IteratorFromStringHandleV2 =
  return iiiteratorFromStringHandleV2(scope,
                                      string_handle,
                                      newArraySlice(output_types),
                                      newArraySlice(output_shapes))

converter iteratorFromStringHandleV2ToOut*(op: IteratorFromStringHandleV2): oresource {.inline.} = return op.output


type GenerateVocabRemapping* {.header:"../tensorflow/ops/generated.h", importcpp:"GenerateVocabRemapping/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iigenerateVocabRemapping(scope: Scope,
                             new_vocab_file: ostring,
                             old_vocab_file: ostring,
                             new_vocab_offset: int64,
                             num_new_vocab: int64,
                             old_vocab_size: int64): GenerateVocabRemapping {.header:"../tensorflow/ops/generated.h", importcpp:"GenerateVocabRemapping(*#, #, #, #, #, #)", constructor.}

proc generateVocabRemapping*(scope: Scope,
                             new_vocab_file: ostring,
                             old_vocab_file: ostring,
                             new_vocab_offset: int64 = 0.int,
                             num_new_vocab: int64 = 0.int,
                             old_vocab_size: int64 = -1.int): GenerateVocabRemapping =
  return iigenerateVocabRemapping(scope,
                                  new_vocab_file,
                                  old_vocab_file,
                                  new_vocab_offset,
                                  num_new_vocab,
                                  old_vocab_size)

converter generateVocabRemappingToOut*(op: GenerateVocabRemapping): oint64 {.inline.} = return op.output

type IfTcond* = oall

type If*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"If/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iinif[oT: oall](scope: Scope,
          cond: IfTcond,
          input: olist[oall],
          Tin: ArraySlice[DType],
          Tout: ArraySlice[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList,
          output_shapes: ArraySlice[TensorShape],
          explicitT: type(oT)): If[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"If(*#, #, #, #, #, #, #, #)", constructor.}

proc nif*(scope: Scope,
          cond: IfTcond,
          input: olist[oall],
          Tin: openArray[DType],
          Tout: openArray[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList,
          output_shapes: openArray[TensorShape],
          explicitT: type): auto =
  return iinif(scope,
               cond,
               input,
               newArraySlice(Tin),
               newArraySlice(Tout),
               then_branch,
               else_branch,
               newArraySlice(output_shapes),
               explicitT)

converter nifToOutList*[oT: oall](op: If[oT]): olist[oT] {.inline.} = return op.output


type TensorForestTreeDeserialize*{.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeDeserialize/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iitensorForestTreeDeserialize(scope: Scope,
                                  tree_handle: oresource,
                                  tree_config: ostring): TensorForestTreeDeserialize {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeDeserialize(*#, #, #)", constructor.}

proc tensorForestTreeDeserialize*(scope: Scope,
                                  tree_handle: oresource,
                                  tree_config: ostring): TensorForestTreeDeserialize =
  return iitensorForestTreeDeserialize(scope,
                                       tree_handle,
                                       tree_config)



type ResourceScatterNdAddT* = oall
type ResourceScatterNdAddTindices* = oint32 | oint64

type ResourceScatterNdAdd*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterNdAdd/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterNdAdd(scope: Scope,
                           nref: oresource,
                           indices: ResourceScatterNdAddTindices,
                           updates: ResourceScatterNdAddT,
                           use_locking: bool): ResourceScatterNdAdd {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterNdAdd(*#, #, #, #, #)", constructor.}

proc resourceScatterNdAdd*(scope: Scope,
                           nref: oresource,
                           indices: ResourceScatterNdAddTindices,
                           updates: ResourceScatterNdAddT,
                           use_locking: bool = true): ResourceScatterNdAdd =
  return iiresourceScatterNdAdd(scope,
                                nref,
                                indices,
                                updates,
                                use_locking)




type BoostedTreesGetEnsembleStates* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesGetEnsembleStates/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiboostedTreesGetEnsembleStates(scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesGetEnsembleStates {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesGetEnsembleStates(*#, #)", constructor.}

proc boostedTreesGetEnsembleStates*(scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesGetEnsembleStates =
  return iiboostedTreesGetEnsembleStates(scope,
                                         tree_ensemble_handle)

converter boostedTreesGetEnsembleStatesToOut*(op: BoostedTreesGetEnsembleStates): oint64 {.inline.} = return op.output


type TensorForestTreeSerialize* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeSerialize/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorForestTreeSerialize(scope: Scope,
                                tree_handle: oresource): TensorForestTreeSerialize {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeSerialize(*#, #)", constructor.}

proc tensorForestTreeSerialize*(scope: Scope,
                                tree_handle: oresource): TensorForestTreeSerialize =
  return iitensorForestTreeSerialize(scope,
                                     tree_handle)

converter tensorForestTreeSerializeToOut*(op: TensorForestTreeSerialize): ostring {.inline.} = return op.output


type MultiDeviceIterator* {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIterator/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iimultiDeviceIterator(scope: Scope,
                          devices: ArraySlice[cstring],
                          shared_name: cstring,
                          container: cstring,
                          output_types: ArraySlice[DType],
                          output_shapes: ArraySlice[TensorShape]): MultiDeviceIterator {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIterator(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc multiDeviceIterator*(scope: Scope,
                          devices: openArray[cstring],
                          shared_name: cstring,
                          container: cstring,
                          output_types: openArray[DType],
                          output_shapes: openArray[TensorShape]): MultiDeviceIterator =
  return iimultiDeviceIterator(scope,
                               newArraySlice(devices),
                               shared_name,
                               container,
                               newArraySlice(output_types),
                               newArraySlice(output_shapes))

converter multiDeviceIteratorToOut*(op: MultiDeviceIterator): oresource {.inline.} = return op.output


type CudnnRNNParamsSize*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNParamsSize/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNNParamsSize[oT: oall](scope: Scope,
                         num_layers: oint32,
                         num_units: oint32,
                         input_size: oint32,
                         T: DType,
                         S: DType,
                         rnn_mode: cstring,
                         input_mode: cstring,
                         direction: cstring,
                         dropout: float32,
                         seed: int64,
                         seed2: int64,
                         explicitT: type(oT)): CudnnRNNParamsSize[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNParamsSize(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNNParamsSize*(scope: Scope,
                         num_layers: oint32,
                         num_units: oint32,
                         input_size: oint32,
                         T: type(ohalf) | type(ofloat) | type(odouble) = oinvalid,
                         S: type = oinvalid,
                         rnn_mode: cstring = "lstm",
                         input_mode: cstring = "linear_input",
                         direction: cstring = "unidirectional",
                         dropout: float32 = 0.0.float32,
                         seed: int64 = 0.int,
                         seed2: int64 = 0.int): auto =
  return iicudnnRNNParamsSize(scope,
                              num_layers,
                              num_units,
                              input_size,
                              T[].oTF,
                              S[].oTF,
                              rnn_mode,
                              input_mode,
                              direction,
                              dropout,
                              seed,
                              seed2,
                              S)

converter cudnnRNNParamsSizeToOut*[oT: oall](op: CudnnRNNParamsSize[oT]): oT {.inline.} = return op.output


type ExperimentalDenseToSparseBatchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDenseToSparseBatchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalDenseToSparseBatchDataset(scope: Scope,
                                            input_dataset: ovariant,
                                            batch_size: oint64,
                                            row_shape: oint64,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalDenseToSparseBatchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalDenseToSparseBatchDataset(*#, #, #, #, #, #)", constructor.}

proc experimentalDenseToSparseBatchDataset*(scope: Scope,
                                            input_dataset: ovariant,
                                            batch_size: oint64,
                                            row_shape: oint64,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalDenseToSparseBatchDataset =
  return iiexperimentalDenseToSparseBatchDataset(scope,
                                                 input_dataset,
                                                 batch_size,
                                                 row_shape,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalDenseToSparseBatchDatasetToOut*(op: ExperimentalDenseToSparseBatchDataset): ovariant {.inline.} = return op.output


type InplaceAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"InplaceAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinplaceAdd[oT: oall](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT,
                 T: DType): InplaceAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"InplaceAdd(*#, #, #, #, #)", constructor.}

proc inplaceAdd*[oT: oall](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT): InplaceAdd[oT] =
  return iiinplaceAdd(scope,
                      x,
                      i,
                      v,
                      oT[].oTF)

converter inplaceAddToOut*[oT: oall](op: InplaceAdd[oT]): oT {.inline.} = return op.output


type EnsureShape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"EnsureShape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiensureShape[oT: oall](scope: Scope,
                  input: oT,
                  shape: TensorShape,
                  T: DType): EnsureShape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"EnsureShape(*#, #, #, #)", constructor.}

proc ensureShape*[oT: oall](scope: Scope,
                  input: oT,
                  shape: TensorShape = [].shape): EnsureShape[oT] =
  return iiensureShape(scope,
                       input,
                       shape,
                       oT[].oTF)

converter ensureShapeToOut*[oT: oall](op: EnsureShape[oT]): oT {.inline.} = return op.output


type TensorForestTreeIsInitializedOp* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeIsInitializedOp/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iitensorForestTreeIsInitializedOp(scope: Scope,
                                      tree_handle: oresource): TensorForestTreeIsInitializedOp {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeIsInitializedOp(*#, #)", constructor.}

proc tensorForestTreeIsInitializedOp*(scope: Scope,
                                      tree_handle: oresource): TensorForestTreeIsInitializedOp =
  return iitensorForestTreeIsInitializedOp(scope,
                                           tree_handle)

converter tensorForestTreeIsInitializedOpToOut*(op: TensorForestTreeIsInitializedOp): obool {.inline.} = return op.output


type BatchSvd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchSvd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchSvd[oT: oall](scope: Scope,
               input: oT,
               compute_uv: bool,
               full_matrices: bool,
               T: DType): BatchSvd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchSvd(*#, #, #, #, #)", constructor.}

proc batchSvd*[oT: oall](scope: Scope,
               input: oT,
               compute_uv: bool = true,
               full_matrices: bool = false): BatchSvd[oT] =
  return iibatchSvd(scope,
                    input,
                    compute_uv,
                    full_matrices,
                    oT[].oTF)

converter batchSvdToOut*[oT: oall](op: BatchSvd[oT]): oT {.inline.} = return op.output

type GatherV2Taxis* = oint32 | oint64
type GatherV2Tindices* = oint32 | oint64

type GatherV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"GatherV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iigatherV2[oT: oall](scope: Scope,
               params: oT,
               indices: GatherV2Tindices,
               axis: GatherV2Taxis,
               Tparams: DType): GatherV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"GatherV2(*#, #, #, #, #)", constructor.}

proc gatherV2*[oT: oall](scope: Scope,
               params: oT,
               indices: GatherV2Tindices,
               axis: GatherV2Taxis): GatherV2[oT] =
  return iigatherV2(scope,
                    params,
                    indices,
                    axis,
                    oT[].oTF)

converter gatherV2ToOut*[oT: oall](op: GatherV2[oT]): oT {.inline.} = return op.output


type ExperimentalParseExampleDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalParseExampleDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalParseExampleDataset(scope: Scope,
                                      input_dataset: ovariant,
                                      num_parallel_calls: oint64,
                                      dense_defaults: olist[oall],
                                      sparse_keys: ArraySlice[cstring],
                                      dense_keys: ArraySlice[cstring],
                                      sparse_types: ArraySlice[DType],
                                      Tdense: ArraySlice[DType],
                                      dense_shapes: ArraySlice[TensorShape],
                                      output_types: ArraySlice[DType],
                                      output_shapes: ArraySlice[TensorShape],
                                      sloppy: bool): ExperimentalParseExampleDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalParseExampleDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalParseExampleDataset*(scope: Scope,
                                      input_dataset: ovariant,
                                      num_parallel_calls: oint64,
                                      dense_defaults: olist[oall],
                                      sparse_keys: openArray[cstring],
                                      dense_keys: openArray[cstring],
                                      sparse_types: openArray[DType],
                                      Tdense: openArray[DType],
                                      dense_shapes: openArray[TensorShape],
                                      output_types: openArray[DType],
                                      output_shapes: openArray[TensorShape],
                                      sloppy: bool = false): ExperimentalParseExampleDataset =
  return iiexperimentalParseExampleDataset(scope,
                                           input_dataset,
                                           num_parallel_calls,
                                           dense_defaults,
                                           newArraySlice(sparse_keys),
                                           newArraySlice(dense_keys),
                                           newArraySlice(sparse_types),
                                           newArraySlice(Tdense),
                                           newArraySlice(dense_shapes),
                                           newArraySlice(output_types),
                                           newArraySlice(output_shapes),
                                           sloppy)

converter experimentalParseExampleDatasetToOut*(op: ExperimentalParseExampleDataset): ovariant {.inline.} = return op.output


type BoostedTreesBucketize* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesBucketize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiboostedTreesBucketize(scope: Scope,
                            float_values: ofloat,
                            bucket_boundaries: ofloat,
                            num_features: int64): BoostedTreesBucketize {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesBucketize(*#, #, #, #)", constructor.}

proc boostedTreesBucketize*(scope: Scope,
                            float_values: ofloat,
                            bucket_boundaries: ofloat,
                            num_features: int64 = 0.int): BoostedTreesBucketize =
  return iiboostedTreesBucketize(scope,
                                 float_values,
                                 bucket_boundaries,
                                 num_features)

converter boostedTreesBucketizeToOut*(op: BoostedTreesBucketize): oint32 {.inline.} = return op.output

type ScatterNdNonAliasingAddTindices* = oint32 | oint64

type ScatterNdNonAliasingAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdNonAliasingAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterNdNonAliasingAdd[oT: oall](scope: Scope,
                              input: oT,
                              indices: ScatterNdNonAliasingAddTindices,
                              updates: oT,
                              T: DType): ScatterNdNonAliasingAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNdNonAliasingAdd(*#, #, #, #, #)", constructor.}

proc scatterNdNonAliasingAdd*[oT: oall](scope: Scope,
                              input: oT,
                              indices: ScatterNdNonAliasingAddTindices,
                              updates: oT): ScatterNdNonAliasingAdd[oT] =
  return iiscatterNdNonAliasingAdd(scope,
                                   input,
                                   indices,
                                   updates,
                                   oT[].oTF)

converter scatterNdNonAliasingAddToOut*[oT: oall](op: ScatterNdNonAliasingAdd[oT]): oT {.inline.} = return op.output


type BoostedTreesQuantileStreamResourceGetBucketBoundaries* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceGetBucketBoundaries/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiboostedTreesQuantileStreamResourceGetBucketBoundaries(scope: Scope,
                                                            quantile_stream_resource_handle: oresource,
                                                            num_features: int64): BoostedTreesQuantileStreamResourceGetBucketBoundaries {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceGetBucketBoundaries(*#, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceGetBucketBoundaries*(scope: Scope,
                                                            quantile_stream_resource_handle: oresource,
                                                            num_features: int64 = 0.int): BoostedTreesQuantileStreamResourceGetBucketBoundaries =
  return iiboostedTreesQuantileStreamResourceGetBucketBoundaries(scope,
                                                                 quantile_stream_resource_handle,
                                                                 num_features)

converter boostedTreesQuantileStreamResourceGetBucketBoundariesToOut*(op: BoostedTreesQuantileStreamResourceGetBucketBoundaries): ofloat {.inline.} = return op.output

type PopulationCountT* = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type PopulationCount* {.header:"../tensorflow/ops/generated.h", importcpp:"PopulationCount/*'0*/".} = object
  operation*: Operation[ouint8]
  output*: ouint8

proc iipopulationCount(scope: Scope,
                      x: PopulationCountT): PopulationCount {.header:"../tensorflow/ops/generated.h", importcpp:"PopulationCount(*#, #)", constructor.}

proc populationCount*(scope: Scope,
                      x: PopulationCountT): PopulationCount =
  return iipopulationCount(scope,
                           x)

converter populationCountToOut*(op: PopulationCount): ouint8 {.inline.} = return op.output


type WholeFileReaderV2* {.header:"../tensorflow/ops/generated.h", importcpp:"WholeFileReaderV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiwholeFileReaderV2(scope: Scope,
                        container: cstring,
                        shared_name: cstring): WholeFileReaderV2 {.header:"../tensorflow/ops/generated.h", importcpp:"WholeFileReaderV2(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc wholeFileReaderV2*(scope: Scope,
                        container: cstring,
                        shared_name: cstring): WholeFileReaderV2 =
  return iiwholeFileReaderV2(scope,
                             container,
                             shared_name)

converter wholeFileReaderV2ToOut*(op: WholeFileReaderV2): oresource {.inline.} = return op.output


type BoostedTreesQuantileStreamResourceFlush*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceFlush/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesQuantileStreamResourceFlush(scope: Scope,
                                              quantile_stream_resource_handle: oresource,
                                              num_buckets: oint64,
                                              generate_quantiles: bool): BoostedTreesQuantileStreamResourceFlush {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceFlush(*#, #, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceFlush*(scope: Scope,
                                              quantile_stream_resource_handle: oresource,
                                              num_buckets: oint64,
                                              generate_quantiles: bool = false): BoostedTreesQuantileStreamResourceFlush =
  return iiboostedTreesQuantileStreamResourceFlush(scope,
                                                   quantile_stream_resource_handle,
                                                   num_buckets,
                                                   generate_quantiles)




type Atan*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Atan/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiatan[oT: oall](scope: Scope,
           x: oT,
           T: DType): Atan[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Atan(*#, #, #)", constructor.}

proc atan*[oT: oall](scope: Scope,
           x: oT): Atan[oT] =
  return iiatan(scope,
                x,
                oT[].oTF)

converter atanToOut*[oT: oall](op: Atan[oT]): oT {.inline.} = return op.output


type FakeQueue* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQueue/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iifakeQueue(scope: Scope,
                resource: oresource): FakeQueue {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQueue(*#, #)", constructor.}

proc fakeQueue*(scope: Scope,
                resource: oresource): FakeQueue =
  return iifakeQueue(scope,
                     resource)

converter fakeQueueToOut*(op: FakeQueue): ostring {.inline.} = return op.output


type BoostedTreesPredict* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesPredict/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiboostedTreesPredict(scope: Scope,
                          tree_ensemble_handle: oresource,
                          bucketized_features: oint32,
                          num_bucketized_features: int64,
                          logits_dimension: int64): BoostedTreesPredict {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesPredict(*#, #, #, #, #)", constructor.}

proc boostedTreesPredict*(scope: Scope,
                          tree_ensemble_handle: oresource,
                          bucketized_features: oint32,
                          num_bucketized_features: int64 = 0.int,
                          logits_dimension: int64 = 0.int): BoostedTreesPredict =
  return iiboostedTreesPredict(scope,
                               tree_ensemble_handle,
                               bucketized_features,
                               num_bucketized_features,
                               logits_dimension)

converter boostedTreesPredictToOut*(op: BoostedTreesPredict): ofloat {.inline.} = return op.output


type BoostedTreesMakeStatsSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesMakeStatsSummary/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiboostedTreesMakeStatsSummary(scope: Scope,
                                   node_ids: oint32,
                                   gradients: ofloat,
                                   hessians: ofloat,
                                   bucketized_features_list: oint32,
                                   max_splits: int64,
                                   num_buckets: int64,
                                   num_features: int64): BoostedTreesMakeStatsSummary {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesMakeStatsSummary(*#, #, #, #, #, #, #, #)", constructor.}

proc boostedTreesMakeStatsSummary*(scope: Scope,
                                   node_ids: oint32,
                                   gradients: ofloat,
                                   hessians: ofloat,
                                   bucketized_features_list: oint32,
                                   max_splits: int64 = 0.int,
                                   num_buckets: int64 = 0.int,
                                   num_features: int64 = 0.int): BoostedTreesMakeStatsSummary =
  return iiboostedTreesMakeStatsSummary(scope,
                                        node_ids,
                                        gradients,
                                        hessians,
                                        bucketized_features_list,
                                        max_splits,
                                        num_buckets,
                                        num_features)

converter boostedTreesMakeStatsSummaryToOut*(op: BoostedTreesMakeStatsSummary): ofloat {.inline.} = return op.output


type BiasAddV1*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BiasAddV1/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibiasAddV1[oT: oall](scope: Scope,
                value: oT,
                bias: oT,
                T: DType): BiasAddV1[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BiasAddV1(*#, #, #, #)", constructor.}

proc biasAddV1*[oT: oall](scope: Scope,
                value: oT,
                bias: oT): BiasAddV1[oT] =
  return iibiasAddV1(scope,
                     value,
                     bias,
                     oT[].oTF)

converter biasAddV1ToOut*[oT: oall](op: BiasAddV1[oT]): oT {.inline.} = return op.output


type LogicalOr* {.header:"../tensorflow/ops/generated.h", importcpp:"LogicalOr/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iilogicalOr(scope: Scope,
                x: obool,
                y: obool): LogicalOr {.header:"../tensorflow/ops/generated.h", importcpp:"LogicalOr(*#, #, #)", constructor.}

proc logicalOr*(scope: Scope,
                x: obool,
                y: obool): LogicalOr =
  return iilogicalOr(scope,
                     x,
                     y)

converter logicalOrToOut*(op: LogicalOr): obool {.inline.} = return op.output


type BoostedTreesDeserializeEnsemble*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesDeserializeEnsemble/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesDeserializeEnsemble(scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      stamp_token: oint64,
                                      tree_ensemble_serialized: ostring): BoostedTreesDeserializeEnsemble {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesDeserializeEnsemble(*#, #, #, #)", constructor.}

proc boostedTreesDeserializeEnsemble*(scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      stamp_token: oint64,
                                      tree_ensemble_serialized: ostring): BoostedTreesDeserializeEnsemble =
  return iiboostedTreesDeserializeEnsemble(scope,
                                           tree_ensemble_handle,
                                           stamp_token,
                                           tree_ensemble_serialized)




type NegTrain*{.header:"../tensorflow/ops/generated.h", importcpp:"NegTrain/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iinegTrain(scope: Scope,
               w_in: ofloat,
               w_out: ofloat,
               examples: oint32,
               labels: oint32,
               lr: ofloat,
               vocab_count: ArraySlice[int],
               num_negative_samples: int64): NegTrain {.header:"../tensorflow/ops/generated.h", importcpp:"NegTrain(*#, #, #, #, #, #, #, #)", constructor.}

proc negTrain*(scope: Scope,
               w_in: ofloat,
               w_out: ofloat,
               examples: oint32,
               labels: oint32,
               lr: ofloat,
               vocab_count: openArray[int],
               num_negative_samples: int64 = 0.int): NegTrain =
  return iinegTrain(scope,
                    w_in,
                    w_out,
                    examples,
                    labels,
                    lr,
                    newArraySlice(vocab_count),
                    num_negative_samples)



type ConcatV2Tidx* = oint32 | oint64

type ConcatV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ConcatV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconcatV2[oT: oall](scope: Scope,
               values: olist[oT],
               axis: ConcatV2Tidx,
               T: DType): ConcatV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ConcatV2(*#, #, #, #)", constructor.}

proc concatV2*[oT: oall](scope: Scope,
               values: olist[oT],
               axis: ConcatV2Tidx): ConcatV2[oT] =
  return iiconcatV2(scope,
                    values,
                    axis,
                    oT[].oTF)

converter concatV2ToOut*[oT: oall](op: ConcatV2[oT]): oT {.inline.} = return op.output


type ConcatOffset* {.header:"../tensorflow/ops/generated.h", importcpp:"ConcatOffset/*'0*/".} = object
  operation*: Operation[oint32]
  output*: olist[oint32]

proc iiconcatOffset(scope: Scope,
                   concat_dim: oint32,
                   shape: olist[oint32]): ConcatOffset {.header:"../tensorflow/ops/generated.h", importcpp:"ConcatOffset(*#, #, #)", constructor.}

proc concatOffset*(scope: Scope,
                   concat_dim: oint32,
                   shape: olist[oint32]): ConcatOffset =
  return iiconcatOffset(scope,
                        concat_dim,
                        shape)

converter concatOffsetToOutList*(op: ConcatOffset): olist[oint32] {.inline.} = return op.output


type BoostedTreesExampleDebugOutputs* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesExampleDebugOutputs/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiboostedTreesExampleDebugOutputs(scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      bucketized_features: oint32,
                                      num_bucketized_features: int64,
                                      logits_dimension: int64): BoostedTreesExampleDebugOutputs {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesExampleDebugOutputs(*#, #, #, #, #)", constructor.}

proc boostedTreesExampleDebugOutputs*(scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      bucketized_features: oint32,
                                      num_bucketized_features: int64 = 0.int,
                                      logits_dimension: int64 = 0.int): BoostedTreesExampleDebugOutputs =
  return iiboostedTreesExampleDebugOutputs(scope,
                                           tree_ensemble_handle,
                                           bucketized_features,
                                           num_bucketized_features,
                                           logits_dimension)

converter boostedTreesExampleDebugOutputsToOut*(op: BoostedTreesExampleDebugOutputs): ostring {.inline.} = return op.output


type DecodeGif* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeGif/*'0*/".} = object
  operation*: Operation[ouint8]
  output*: ouint8

proc iidecodeGif(scope: Scope,
                contents: ostring): DecodeGif {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeGif(*#, #)", constructor.}

proc decodeGif*(scope: Scope,
                contents: ostring): DecodeGif =
  return iidecodeGif(scope,
                     contents)

converter decodeGifToOut*(op: DecodeGif): ouint8 {.inline.} = return op.output


type BoostedTreesCalculateBestGainsPerFeature* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCalculateBestGainsPerFeature/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiboostedTreesCalculateBestGainsPerFeature(scope: Scope,
                                               node_id_range: oint32,
                                               stats_summary_list: ofloat,
                                               l1: ofloat,
                                               l2: ofloat,
                                               tree_complexity: ofloat,
                                               min_node_weight: ofloat,
                                               max_splits: int64,
                                               num_features: int64): BoostedTreesCalculateBestGainsPerFeature {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCalculateBestGainsPerFeature(*#, #, #, #, #, #, #, #, #)", constructor.}

proc boostedTreesCalculateBestGainsPerFeature*(scope: Scope,
                                               node_id_range: oint32,
                                               stats_summary_list: ofloat,
                                               l1: ofloat,
                                               l2: ofloat,
                                               tree_complexity: ofloat,
                                               min_node_weight: ofloat,
                                               max_splits: int64 = 0.int,
                                               num_features: int64 = 0.int): BoostedTreesCalculateBestGainsPerFeature =
  return iiboostedTreesCalculateBestGainsPerFeature(scope,
                                                    node_id_range,
                                                    stats_summary_list,
                                                    l1,
                                                    l2,
                                                    tree_complexity,
                                                    min_node_weight,
                                                    max_splits,
                                                    num_features)

converter boostedTreesCalculateBestGainsPerFeatureToOut*(op: BoostedTreesCalculateBestGainsPerFeature): oint32 {.inline.} = return op.output


type SampleDistortedBoundingBox*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SampleDistortedBoundingBox/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisampleDistortedBoundingBox[oT: oall](scope: Scope,
                                 image_size: oT,
                                 bounding_boxes: ofloat,
                                 T: DType,
                                 seed: int64,
                                 seed2: int64,
                                 min_object_covered: float32,
                                 aspect_ratio_range: ArraySlice[float32],
                                 area_range: ArraySlice[float32],
                                 max_attempts: int64,
                                 use_image_if_no_bounding_boxes: bool): SampleDistortedBoundingBox[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SampleDistortedBoundingBox(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sampleDistortedBoundingBox*[oT: oall](scope: Scope,
                                 image_size: oT,
                                 bounding_boxes: ofloat,
                                 seed: int64 = 0.int,
                                 seed2: int64 = 0.int,
                                 min_object_covered: float32 = 0.1000000014901161.float32,
                                 aspect_ratio_range: openArray[float32] = [0.75.float32, 1.330000042915344.float32],
                                 area_range: openArray[float32] = [0.05000000074505806.float32, 1.0.float32],
                                 max_attempts: int64 = 100.int,
                                 use_image_if_no_bounding_boxes: bool = false): SampleDistortedBoundingBox[oT] =
  return iisampleDistortedBoundingBox(scope,
                                      image_size,
                                      bounding_boxes,
                                      oT[].oTF,
                                      seed,
                                      seed2,
                                      min_object_covered,
                                      newArraySlice(aspect_ratio_range),
                                      newArraySlice(area_range),
                                      max_attempts,
                                      use_image_if_no_bounding_boxes)

converter sampleDistortedBoundingBoxToOut*[oT: oall](op: SampleDistortedBoundingBox[oT]): oT {.inline.} = return op.output


type DecodeBmp* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeBmp/*'0*/".} = object
  operation*: Operation[ouint8]
  output*: ouint8

proc iidecodeBmp(scope: Scope,
                contents: ostring,
                channels: int64): DecodeBmp {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeBmp(*#, #, #)", constructor.}

proc decodeBmp*(scope: Scope,
                contents: ostring,
                channels: int64 = 0.int): DecodeBmp =
  return iidecodeBmp(scope,
                     contents,
                     channels)

converter decodeBmpToOut*(op: DecodeBmp): ouint8 {.inline.} = return op.output


type RightShift*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RightShift/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirightShift[oT: oall](scope: Scope,
                 x: oT,
                 y: oT,
                 T: DType): RightShift[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RightShift(*#, #, #, #)", constructor.}

proc rightShift*[oT: oall](scope: Scope,
                 x: oT,
                 y: oT): RightShift[oT] =
  return iirightShift(scope,
                      x,
                      y,
                      oT[].oTF)

converter rightShiftToOut*[oT: oall](op: RightShift[oT]): oT {.inline.} = return op.output

type ImagT* = ocomplex64 | ocomplex128

type Imag*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Imag/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiimag[oT: oall](scope: Scope,
           input: ImagT,
           Tout: DType,
           explicitT: type(oT)): Imag[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Imag(*#, #, #)", constructor.}

proc imag*(scope: Scope,
           input: ImagT,
           Tout: type = ofloat): auto =
  return iiimag(scope,
                input,
                Tout[].oTF,
                Tout)

converter imagToOut*[oT: oall](op: Imag[oT]): oT {.inline.} = return op.output

type MutableDenseHashTablekey_dtype* = oall

type MutableDenseHashTable* {.header:"../tensorflow/ops/generated.h", importcpp:"MutableDenseHashTable/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iimutableDenseHashTable(scope: Scope,
                            empty_key: MutableDenseHashTablekey_dtype,
                            container: cstring,
                            shared_name: cstring,
                            use_node_name_sharing: bool,
                            max_load_factor: float32,
                            value_dtype: DType,
                            value_shape: TensorShape,
                            initial_num_buckets: int64): MutableDenseHashTable {.header:"../tensorflow/ops/generated.h", importcpp:"MutableDenseHashTable(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc mutableDenseHashTable*(scope: Scope,
                            empty_key: MutableDenseHashTablekey_dtype,
                            container: cstring,
                            shared_name: cstring,
                            use_node_name_sharing: bool = false,
                            max_load_factor: float32 = 0.800000011920929.float32,
                            value_dtype: type oall = oinvalid,
                            value_shape: TensorShape = [].shape,
                            initial_num_buckets: int64 = 131072.int): MutableDenseHashTable =
  return iimutableDenseHashTable(scope,
                                 empty_key,
                                 container,
                                 shared_name,
                                 use_node_name_sharing,
                                 max_load_factor,
                                 oT[].oTF,
                                 value_shape,
                                 initial_num_buckets)

converter mutableDenseHashTableToOut*(op: MutableDenseHashTable): ostring {.inline.} = return op.output


type TensorArrayGrad* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGrad/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorArrayGrad(scope: Scope,
                      handle: ostring,
                      flow_in: ofloat,
                      source: cstring): TensorArrayGrad {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGrad(*#, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGrad*(scope: Scope,
                      handle: ostring,
                      flow_in: ofloat,
                      source: cstring): TensorArrayGrad =
  return iitensorArrayGrad(scope,
                           handle,
                           flow_in,
                           source)

converter tensorArrayGradToOut*(op: TensorArrayGrad): ostring {.inline.} = return op.output


type IMklSquaredDifference*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklSquaredDifference/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiMklSquaredDifference[oT: oall](scope: Scope,
                            x: oT,
                            y: oT,
                            mkl_x: ouint8,
                            mkl_y: ouint8,
                            T: DType): IMklSquaredDifference[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_MklSquaredDifference(*#, #, #, #, #, #)", constructor.}

proc iMklSquaredDifference*[oT: oall](scope: Scope,
                            x: oT,
                            y: oT,
                            mkl_x: ouint8,
                            mkl_y: ouint8): IMklSquaredDifference[oT] =
  return iiiMklSquaredDifference(scope,
                                 x,
                                 y,
                                 mkl_x,
                                 mkl_y,
                                 oT[].oTF)

converter iMklSquaredDifferenceToOut*[oT: oall](op: IMklSquaredDifference[oT]): oT {.inline.} = return op.output


type UnbatchGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UnbatchGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunbatchGrad[oT: oall](scope: Scope,
                  original_input: oT,
                  batch_index: oint64,
                  grad: oT,
                  id: oint64,
                  container: cstring,
                  shared_name: cstring,
                  T: DType): UnbatchGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UnbatchGrad(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc unbatchGrad*[oT: oall](scope: Scope,
                  original_input: oT,
                  batch_index: oint64,
                  grad: oT,
                  id: oint64,
                  container: cstring,
                  shared_name: cstring): UnbatchGrad[oT] =
  return iiunbatchGrad(scope,
                       original_input,
                       batch_index,
                       grad,
                       id,
                       container,
                       shared_name,
                       oT[].oTF)

converter unbatchGradToOut*[oT: oall](op: UnbatchGrad[oT]): oT {.inline.} = return op.output


type Mfcc* {.header:"../tensorflow/ops/generated.h", importcpp:"Mfcc/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iimfcc(scope: Scope,
           spectrogram: ofloat,
           sample_rate: oint32,
           upper_frequency_limit: float32,
           lower_frequency_limit: float32,
           filterbank_channel_count: int64,
           dct_coefficient_count: int64): Mfcc {.header:"../tensorflow/ops/generated.h", importcpp:"Mfcc(*#, #, #, #, #, #, #)", constructor.}

proc mfcc*(scope: Scope,
           spectrogram: ofloat,
           sample_rate: oint32,
           upper_frequency_limit: float32 = 4000.0.float32,
           lower_frequency_limit: float32 = 20.0.float32,
           filterbank_channel_count: int64 = 40.int,
           dct_coefficient_count: int64 = 13.int): Mfcc =
  return iimfcc(scope,
                spectrogram,
                sample_rate,
                upper_frequency_limit,
                lower_frequency_limit,
                filterbank_channel_count,
                dct_coefficient_count)

converter mfccToOut*(op: Mfcc): ofloat {.inline.} = return op.output


type BroadcastGradientArgs*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BroadcastGradientArgs/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibroadcastGradientArgs[oT: oall](scope: Scope,
                            s0: oT,
                            s1: oT,
                            T: DType): BroadcastGradientArgs[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BroadcastGradientArgs(*#, #, #, #)", constructor.}

proc broadcastGradientArgs*[oT: oall](scope: Scope,
                            s0: oT,
                            s1: oT): BroadcastGradientArgs[oT] =
  return iibroadcastGradientArgs(scope,
                                 s0,
                                 s1,
                                 oT[].oTF)

converter broadcastGradientArgsToOut*[oT: oall](op: BroadcastGradientArgs[oT]): oT {.inline.} = return op.output

type NonMaxSuppressionV3T* = ohalf | ofloat

type NonMaxSuppressionV3* {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionV3/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iinonMaxSuppressionV3(scope: Scope,
                          boxes: NonMaxSuppressionV3T,
                          scores: NonMaxSuppressionV3T,
                          max_output_size: oint32,
                          iou_threshold: ofloat,
                          score_threshold: ofloat): NonMaxSuppressionV3 {.header:"../tensorflow/ops/generated.h", importcpp:"NonMaxSuppressionV3(*#, #, #, #, #, #)", constructor.}

proc nonMaxSuppressionV3*(scope: Scope,
                          boxes: NonMaxSuppressionV3T,
                          scores: NonMaxSuppressionV3T,
                          max_output_size: oint32,
                          iou_threshold: ofloat,
                          score_threshold: ofloat): NonMaxSuppressionV3 =
  return iinonMaxSuppressionV3(scope,
                               boxes,
                               scores,
                               max_output_size,
                               iou_threshold,
                               score_threshold)

converter nonMaxSuppressionV3ToOut*(op: NonMaxSuppressionV3): oint32 {.inline.} = return op.output

type IIfTcond* = oall

type IIf*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_If/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiIf[oT: oall](scope: Scope,
          cond: IIfTcond,
          input: olist[oall],
          Tin: ArraySlice[DType],
          Tout: ArraySlice[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList,
          explicitT: type(oT)): IIf[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_If(*#, #, #, #, #, #, #)", constructor.}

proc iIf*(scope: Scope,
          cond: IIfTcond,
          input: olist[oall],
          Tin: openArray[DType],
          Tout: openArray[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList,
          explicitT: type): auto =
  return iiiIf(scope,
               cond,
               input,
               newArraySlice(Tin),
               newArraySlice(Tout),
               then_branch,
               else_branch,
               explicitT)

converter iIfToOutList*[oT: oall](op: IIf[oT]): olist[oT] {.inline.} = return op.output


type BatchIFFT* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchIFFT/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iibatchIFFT(scope: Scope,
                input: ocomplex64): BatchIFFT {.header:"../tensorflow/ops/generated.h", importcpp:"BatchIFFT(*#, #)", constructor.}

proc batchIFFT*(scope: Scope,
                input: ocomplex64): BatchIFFT =
  return iibatchIFFT(scope,
                     input)

converter batchIFFTToOut*(op: BatchIFFT): ocomplex64 {.inline.} = return op.output


type QueueDequeueUpToV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueUpToV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiqueueDequeueUpToV2[oT: oall](scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: ArraySlice[DType],
                         timeout_ms: int64,
                         explicitT: type(oT)): QueueDequeueUpToV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QueueDequeueUpToV2(*#, #, #, #, #)", constructor.}

proc queueDequeueUpToV2*(scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: openArray[DType],
                         timeout_ms: int64 = -1.int,
                         explicitT: type): auto =
  return iiqueueDequeueUpToV2(scope,
                              handle,
                              n,
                              newArraySlice(component_types),
                              timeout_ms,
                              explicitT)

converter queueDequeueUpToV2ToOutList*[oT: oall](op: QueueDequeueUpToV2[oT]): olist[oT] {.inline.} = return op.output


type DecodeWav* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeWav/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iidecodeWav(scope: Scope,
                contents: ostring,
                desired_channels: int64,
                desired_samples: int64): DecodeWav {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeWav(*#, #, #, #)", constructor.}

proc decodeWav*(scope: Scope,
                contents: ostring,
                desired_channels: int64 = -1.int,
                desired_samples: int64 = -1.int): DecodeWav =
  return iidecodeWav(scope,
                     contents,
                     desired_channels,
                     desired_samples)

converter decodeWavToOut*(op: DecodeWav): ofloat {.inline.} = return op.output

type SparseAccumulatorApplyGradientdtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseAccumulatorApplyGradient*{.header:"../tensorflow/ops/generated.h", importcpp:"SparseAccumulatorApplyGradient/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iisparseAccumulatorApplyGradient(scope: Scope,
                                     handle: ostring,
                                     local_step: oint64,
                                     gradient_indices: oint64,
                                     gradient_values: SparseAccumulatorApplyGradientdtype,
                                     gradient_shape: oint64,
                                     has_known_shape: bool): SparseAccumulatorApplyGradient {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAccumulatorApplyGradient(*#, #, #, #, #, #, #)", constructor.}

proc sparseAccumulatorApplyGradient*(scope: Scope,
                                     handle: ostring,
                                     local_step: oint64,
                                     gradient_indices: oint64,
                                     gradient_values: SparseAccumulatorApplyGradientdtype,
                                     gradient_shape: oint64,
                                     has_known_shape: bool = false): SparseAccumulatorApplyGradient =
  return iisparseAccumulatorApplyGradient(scope,
                                          handle,
                                          local_step,
                                          gradient_indices,
                                          gradient_values,
                                          gradient_shape,
                                          has_known_shape)



type AssignSubVariableOpdtype* = oall

type AssignSubVariableOp*{.header:"../tensorflow/ops/generated.h", importcpp:"AssignSubVariableOp/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiassignSubVariableOp(scope: Scope,
                          resource: oresource,
                          value: AssignSubVariableOpdtype): AssignSubVariableOp {.header:"../tensorflow/ops/generated.h", importcpp:"AssignSubVariableOp(*#, #, #)", constructor.}

proc assignSubVariableOp*(scope: Scope,
                          resource: oresource,
                          value: AssignSubVariableOpdtype): AssignSubVariableOp =
  return iiassignSubVariableOp(scope,
                               resource,
                               value)




type FusedBatchNormGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNormGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifusedBatchNormGrad[oT: oall](scope: Scope,
                         y_backprop: oT,
                         x: oT,
                         scale: oT,
                         reserve_space_1: oT,
                         reserve_space_2: oT,
                         T: DType,
                         epsilon: float32,
                         data_format: cstring,
                         is_training: bool): FusedBatchNormGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedBatchNormGrad(*#, #, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc fusedBatchNormGrad*[oT: oall](scope: Scope,
                         y_backprop: oT,
                         x: oT,
                         scale: oT,
                         reserve_space_1: oT,
                         reserve_space_2: oT,
                         epsilon: float32 = 9.999999747378752e-05.float32,
                         data_format: cstring = "NHWC",
                         is_training: bool = true): FusedBatchNormGrad[oT] =
  return iifusedBatchNormGrad(scope,
                              y_backprop,
                              x,
                              scale,
                              reserve_space_1,
                              reserve_space_2,
                              oT[].oTF,
                              epsilon,
                              data_format,
                              is_training)

converter fusedBatchNormGradToOut*[oT: oall](op: FusedBatchNormGrad[oT]): oT {.inline.} = return op.output


type UnravelIndex*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UnravelIndex/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunravelIndex[oT: oall](scope: Scope,
                   indices: oT,
                   dims: oT,
                   Tidx: DType): UnravelIndex[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UnravelIndex(*#, #, #, #)", constructor.}

proc unravelIndex*[oT: oall](scope: Scope,
                   indices: oT,
                   dims: oT): UnravelIndex[oT] =
  return iiunravelIndex(scope,
                        indices,
                        dims,
                        oT[].oTF)

converter unravelIndexToOut*[oT: oall](op: UnravelIndex[oT]): oT {.inline.} = return op.output

type MatrixBandPartTindex* = oint32 | oint64

type MatrixBandPart*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixBandPart/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixBandPart[oT: oall](scope: Scope,
                     input: oT,
                     num_lower: MatrixBandPartTindex,
                     num_upper: MatrixBandPartTindex,
                     T: DType): MatrixBandPart[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixBandPart(*#, #, #, #, #)", constructor.}

proc matrixBandPart*[oT: oall](scope: Scope,
                     input: oT,
                     num_lower: MatrixBandPartTindex,
                     num_upper: MatrixBandPartTindex): MatrixBandPart[oT] =
  return iimatrixBandPart(scope,
                          input,
                          num_lower,
                          num_upper,
                          oT[].oTF)

converter matrixBandPartToOut*[oT: oall](op: MatrixBandPart[oT]): oT {.inline.} = return op.output


type TensorArrayClose*{.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayClose/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iitensorArrayClose(scope: Scope,
                       handle: ostring): TensorArrayClose {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayClose(*#, #)", constructor.}

proc tensorArrayClose*(scope: Scope,
                       handle: ostring): TensorArrayClose =
  return iitensorArrayClose(scope,
                            handle)




type BatchMatrixBandPart*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixBandPart/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixBandPart[oT: oall](scope: Scope,
                          input: oT,
                          num_lower: oint64,
                          num_upper: oint64,
                          T: DType): BatchMatrixBandPart[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixBandPart(*#, #, #, #, #)", constructor.}

proc batchMatrixBandPart*[oT: oall](scope: Scope,
                          input: oT,
                          num_lower: oint64,
                          num_upper: oint64): BatchMatrixBandPart[oT] =
  return iibatchMatrixBandPart(scope,
                               input,
                               num_lower,
                               num_upper,
                               oT[].oTF)

converter batchMatrixBandPartToOut*[oT: oall](op: BatchMatrixBandPart[oT]): oT {.inline.} = return op.output


type ResizeNearestNeighbor*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeNearestNeighbor/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiresizeNearestNeighbor[oT: oall](scope: Scope,
                            images: oT,
                            size: oint32,
                            T: DType,
                            align_corners: bool): ResizeNearestNeighbor[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ResizeNearestNeighbor(*#, #, #, #, #)", constructor.}

proc resizeNearestNeighbor*[oT: oall](scope: Scope,
                            images: oT,
                            size: oint32,
                            align_corners: bool = false): ResizeNearestNeighbor[oT] =
  return iiresizeNearestNeighbor(scope,
                                 images,
                                 size,
                                 oT[].oTF,
                                 align_corners)

converter resizeNearestNeighborToOut*[oT: oall](op: ResizeNearestNeighbor[oT]): oT {.inline.} = return op.output


type BatchMatrixDiagPart*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixDiagPart/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixDiagPart[oT: oall](scope: Scope,
                          input: oT,
                          T: DType): BatchMatrixDiagPart[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixDiagPart(*#, #, #)", constructor.}

proc batchMatrixDiagPart*[oT: oall](scope: Scope,
                          input: oT): BatchMatrixDiagPart[oT] =
  return iibatchMatrixDiagPart(scope,
                               input,
                               oT[].oTF)

converter batchMatrixDiagPartToOut*[oT: oall](op: BatchMatrixDiagPart[oT]): oT {.inline.} = return op.output


type BatchMatrixSetDiag*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixSetDiag/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixSetDiag[oT: oall](scope: Scope,
                         input: oT,
                         diagonal: oT,
                         T: DType): BatchMatrixSetDiag[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixSetDiag(*#, #, #, #)", constructor.}

proc batchMatrixSetDiag*[oT: oall](scope: Scope,
                         input: oT,
                         diagonal: oT): BatchMatrixSetDiag[oT] =
  return iibatchMatrixSetDiag(scope,
                              input,
                              diagonal,
                              oT[].oTF)

converter batchMatrixSetDiagToOut*[oT: oall](op: BatchMatrixSetDiag[oT]): oT {.inline.} = return op.output


type OnesLike*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"OnesLike/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iionesLike[oT: oall](scope: Scope,
               x: oT,
               T: DType): OnesLike[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"OnesLike(*#, #, #)", constructor.}

proc onesLike*[oT: oall](scope: Scope,
               x: oT): OnesLike[oT] =
  return iionesLike(scope,
                    x,
                    oT[].oTF)

converter onesLikeToOut*[oT: oall](op: OnesLike[oT]): oT {.inline.} = return op.output


type EncodeWav* {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeWav/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiencodeWav(scope: Scope,
                audio: ofloat,
                sample_rate: oint32): EncodeWav {.header:"../tensorflow/ops/generated.h", importcpp:"EncodeWav(*#, #, #)", constructor.}

proc encodeWav*(scope: Scope,
                audio: ofloat,
                sample_rate: oint32): EncodeWav =
  return iiencodeWav(scope,
                     audio,
                     sample_rate)

converter encodeWavToOut*(op: EncodeWav): ostring {.inline.} = return op.output


type FixedLengthRecordDatasetV2* {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordDatasetV2/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iifixedLengthRecordDatasetV2(scope: Scope,
                                 filenames: ostring,
                                 header_bytes: oint64,
                                 record_bytes: oint64,
                                 footer_bytes: oint64,
                                 buffer_size: oint64,
                                 compression_type: ostring): FixedLengthRecordDatasetV2 {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordDatasetV2(*#, #, #, #, #, #, #)", constructor.}

proc fixedLengthRecordDatasetV2*(scope: Scope,
                                 filenames: ostring,
                                 header_bytes: oint64,
                                 record_bytes: oint64,
                                 footer_bytes: oint64,
                                 buffer_size: oint64,
                                 compression_type: ostring): FixedLengthRecordDatasetV2 =
  return iifixedLengthRecordDatasetV2(scope,
                                      filenames,
                                      header_bytes,
                                      record_bytes,
                                      footer_bytes,
                                      buffer_size,
                                      compression_type)

converter fixedLengthRecordDatasetV2ToOut*(op: FixedLengthRecordDatasetV2): ovariant {.inline.} = return op.output


type IteratorGetNext*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorGetNext/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iiiteratorGetNext[oT: oall](scope: Scope,
                      niterator: oresource,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape],
                      explicitT: type(oT)): IteratorGetNext[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"IteratorGetNext(*#, #, #, #)", constructor.}

proc iteratorGetNext*(scope: Scope,
                      niterator: oresource,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape],
                      explicitT: type): auto =
  return iiiteratorGetNext(scope,
                           niterator,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes),
                           explicitT)

converter iteratorGetNextToOutList*[oT: oall](op: IteratorGetNext[oT]): olist[oT] {.inline.} = return op.output


type FakeQuantWithMinMaxArgsGradient* {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxArgsGradient/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iifakeQuantWithMinMaxArgsGradient(scope: Scope,
                                      gradients: ofloat,
                                      inputs: ofloat,
                                      min: float32,
                                      max: float32,
                                      num_bits: int64,
                                      narrow_range: bool): FakeQuantWithMinMaxArgsGradient {.header:"../tensorflow/ops/generated.h", importcpp:"FakeQuantWithMinMaxArgsGradient(*#, #, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxArgsGradient*(scope: Scope,
                                      gradients: ofloat,
                                      inputs: ofloat,
                                      min: float32 = -6.0.float32,
                                      max: float32 = 6.0.float32,
                                      num_bits: int64 = 8.int,
                                      narrow_range: bool = false): FakeQuantWithMinMaxArgsGradient =
  return iifakeQuantWithMinMaxArgsGradient(scope,
                                           gradients,
                                           inputs,
                                           min,
                                           max,
                                           num_bits,
                                           narrow_range)

converter fakeQuantWithMinMaxArgsGradientToOut*(op: FakeQuantWithMinMaxArgsGradient): ofloat {.inline.} = return op.output

type ResourceApplyAdadeltaT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdadelta*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdadelta/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyAdadelta(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            accum_update: oresource,
                            lr: ResourceApplyAdadeltaT,
                            rho: ResourceApplyAdadeltaT,
                            epsilon: ResourceApplyAdadeltaT,
                            grad: ResourceApplyAdadeltaT,
                            use_locking: bool): ResourceApplyAdadelta {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyAdadelta(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdadelta*(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            accum_update: oresource,
                            lr: ResourceApplyAdadeltaT,
                            rho: ResourceApplyAdadeltaT,
                            epsilon: ResourceApplyAdadeltaT,
                            grad: ResourceApplyAdadeltaT,
                            use_locking: bool = false): ResourceApplyAdadelta =
  return iiresourceApplyAdadelta(scope,
                                 nvar,
                                 accum,
                                 accum_update,
                                 lr,
                                 rho,
                                 epsilon,
                                 grad,
                                 use_locking)




type BoostedTreesQuantileStreamResourceDeserialize*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceDeserialize/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesQuantileStreamResourceDeserialize(scope: Scope,
                                                    quantile_stream_resource_handle: oresource,
                                                    bucket_boundaries: ofloat,
                                                    num_streams: int64): BoostedTreesQuantileStreamResourceDeserialize {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceDeserialize(*#, #, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceDeserialize*(scope: Scope,
                                                    quantile_stream_resource_handle: oresource,
                                                    bucket_boundaries: ofloat,
                                                    num_streams: int64 = 0.int): BoostedTreesQuantileStreamResourceDeserialize =
  return iiboostedTreesQuantileStreamResourceDeserialize(scope,
                                                         quantile_stream_resource_handle,
                                                         bucket_boundaries,
                                                         num_streams)



type GetSessionHandleT* = oall

type GetSessionHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"GetSessionHandle/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iigetSessionHandle(scope: Scope,
                       value: GetSessionHandleT): GetSessionHandle {.header:"../tensorflow/ops/generated.h", importcpp:"GetSessionHandle(*#, #)", constructor.}

proc getSessionHandle*(scope: Scope,
                       value: GetSessionHandleT): GetSessionHandle =
  return iigetSessionHandle(scope,
                            value)

converter getSessionHandleToOut*(op: GetSessionHandle): ostring {.inline.} = return op.output


type TensorListConcat*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListConcat/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorListConcat[oT: oall](scope: Scope,
                       input_handle: ovariant,
                       element_dtype: DType,
                       explicitT: type(oT)): TensorListConcat[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListConcat(*#, #, #)", constructor.}

proc tensorListConcat*(scope: Scope,
                       input_handle: ovariant,
                       element_dtype: type = oinvalid): auto =
  return iitensorListConcat(scope,
                            input_handle,
                            element_dtype[].oTF,
                            element_dtype)

converter tensorListConcatToOut*[oT: oall](op: TensorListConcat[oT]): oT {.inline.} = return op.output


type FixedLengthRecordReader* {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iifixedLengthRecordReader(scope: Scope,
                              container: cstring,
                              shared_name: cstring,
                              header_bytes: int64,
                              record_bytes: int64,
                              footer_bytes: int64,
                              hop_bytes: int64): FixedLengthRecordReader {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordReader(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc fixedLengthRecordReader*(scope: Scope,
                              container: cstring,
                              shared_name: cstring,
                              header_bytes: int64 = 0.int,
                              record_bytes: int64 = 0.int,
                              footer_bytes: int64 = 0.int,
                              hop_bytes: int64 = 0.int): FixedLengthRecordReader =
  return iifixedLengthRecordReader(scope,
                                   container,
                                   shared_name,
                                   header_bytes,
                                   record_bytes,
                                   footer_bytes,
                                   hop_bytes)

converter fixedLengthRecordReaderToOut*(op: FixedLengthRecordReader): ostring {.inline.} = return op.output


type AssignAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AssignAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiassignAdd[oT: oall](scope: Scope,
                nref: oT,
                value: oT,
                T: DType,
                use_locking: bool): AssignAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AssignAdd(*#, #, #, #, #)", constructor.}

proc assignAdd*[oT: oall](scope: Scope,
                nref: oT,
                value: oT,
                use_locking: bool = false): AssignAdd[oT] =
  return iiassignAdd(scope,
                     nref,
                     value,
                     oT[].oTF,
                     use_locking)

converter assignAddToOut*[oT: oall](op: AssignAdd[oT]): oT {.inline.} = return op.output


type IsBoostedTreesQuantileStreamResourceInitialized* {.header:"../tensorflow/ops/generated.h", importcpp:"IsBoostedTreesQuantileStreamResourceInitialized/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiisBoostedTreesQuantileStreamResourceInitialized(scope: Scope,
                                                      quantile_stream_resource_handle: oresource): IsBoostedTreesQuantileStreamResourceInitialized {.header:"../tensorflow/ops/generated.h", importcpp:"IsBoostedTreesQuantileStreamResourceInitialized(*#, #)", constructor.}

proc isBoostedTreesQuantileStreamResourceInitialized*(scope: Scope,
                                                      quantile_stream_resource_handle: oresource): IsBoostedTreesQuantileStreamResourceInitialized =
  return iiisBoostedTreesQuantileStreamResourceInitialized(scope,
                                                           quantile_stream_resource_handle)

converter isBoostedTreesQuantileStreamResourceInitializedToOut*(op: IsBoostedTreesQuantileStreamResourceInitialized): obool {.inline.} = return op.output


type LeftShift*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LeftShift/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iileftShift[oT: oall](scope: Scope,
                x: oT,
                y: oT,
                T: DType): LeftShift[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LeftShift(*#, #, #, #)", constructor.}

proc leftShift*[oT: oall](scope: Scope,
                x: oT,
                y: oT): LeftShift[oT] =
  return iileftShift(scope,
                     x,
                     y,
                     oT[].oTF)

converter leftShiftToOut*[oT: oall](op: LeftShift[oT]): oT {.inline.} = return op.output

type EncodePngT* = ouint8 | ouint16

type EncodePng* {.header:"../tensorflow/ops/generated.h", importcpp:"EncodePng/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiencodePng(scope: Scope,
                image: EncodePngT,
                compression: int64): EncodePng {.header:"../tensorflow/ops/generated.h", importcpp:"EncodePng(*#, #, #)", constructor.}

proc encodePng*(scope: Scope,
                image: EncodePngT,
                compression: int64 = -1.int): EncodePng =
  return iiencodePng(scope,
                     image,
                     compression)

converter encodePngToOut*(op: EncodePng): ostring {.inline.} = return op.output


type Enter*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Enter/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iienter[oT: oall](scope: Scope,
            data: oT,
            frame_name: cstring,
            T: DType,
            is_constant: bool,
            parallel_iterations: int64): Enter[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Enter(*#, #, tensorflow::string(#), #, #, #)", constructor.}

proc enter*[oT: oall](scope: Scope,
            data: oT,
            frame_name: cstring,
            is_constant: bool = false,
            parallel_iterations: int64 = 10.int): Enter[oT] =
  return iienter(scope,
                 data,
                 frame_name,
                 oT[].oTF,
                 is_constant,
                 parallel_iterations)

converter enterToOut*[oT: oall](op: Enter[oT]): oT {.inline.} = return op.output


type StageSize* {.header:"../tensorflow/ops/generated.h", importcpp:"StageSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iistageSize(scope: Scope,
                dtypes: ArraySlice[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64,
                memory_limit: int64): StageSize {.header:"../tensorflow/ops/generated.h", importcpp:"StageSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stageSize*(scope: Scope,
                dtypes: openArray[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64 = 0.int,
                memory_limit: int64 = 0.int): StageSize =
  return iistageSize(scope,
                     newArraySlice(dtypes),
                     container,
                     shared_name,
                     capacity,
                     memory_limit)

converter stageSizeToOut*(op: StageSize): oint32 {.inline.} = return op.output

type RaggedTensorToSparseT* = oall

type RaggedTensorToSparse* {.header:"../tensorflow/ops/generated.h", importcpp:"RaggedTensorToSparse/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiraggedTensorToSparse(scope: Scope,
                           rt_nested_splits: oint64,
                           rt_dense_values: RaggedTensorToSparseT,
                           RAGGED_RANK: int64): RaggedTensorToSparse {.header:"../tensorflow/ops/generated.h", importcpp:"RaggedTensorToSparse(*#, #, #, #)", constructor.}

proc raggedTensorToSparse*(scope: Scope,
                           rt_nested_splits: oint64,
                           rt_dense_values: RaggedTensorToSparseT,
                           RAGGED_RANK: int64 = 0.int): RaggedTensorToSparse =
  return iiraggedTensorToSparse(scope,
                                rt_nested_splits,
                                rt_dense_values,
                                RAGGED_RANK)

converter raggedTensorToSparseToOut*(op: RaggedTensorToSparse): oint64 {.inline.} = return op.output


type Unique*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Unique/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiunique[oT: oall](scope: Scope,
             x: oT,
             T: DType,
             out_idx: DType): Unique[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Unique(*#, #, #, #)", constructor.}

proc unique*[oT: oall](scope: Scope,
             x: oT,
             out_idx: type(oint32) | type(oint64) = oint32): Unique[oT] =
  return iiunique(scope,
                  x,
                  oT[].oTF,
                  oT[].oTF)

converter uniqueToOut*[oT: oall](op: Unique[oT]): oT {.inline.} = return op.output

type ScatterNdTindices* = oint32 | oint64

type ScatterNd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterNd[oT: oall](scope: Scope,
                indices: ScatterNdTindices,
                updates: oT,
                shape: ScatterNdTindices,
                T: DType): ScatterNd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterNd(*#, #, #, #, #)", constructor.}

proc scatterNd*[oT: oall](scope: Scope,
                indices: ScatterNdTindices,
                updates: oT,
                shape: ScatterNdTindices): ScatterNd[oT] =
  return iiscatterNd(scope,
                     indices,
                     updates,
                     shape,
                     oT[].oTF)

converter scatterNdToOut*[oT: oall](op: ScatterNd[oT]): oT {.inline.} = return op.output


type TensorArrayConcatV3*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayConcatV3/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayConcatV3[oT: oall](scope: Scope,
                          handle: oresource,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape_except0: TensorShape,
                          explicitT: type(oT)): TensorArrayConcatV3[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayConcatV3(*#, #, #, #, #)", constructor.}

proc tensorArrayConcatV3*(scope: Scope,
                          handle: oresource,
                          flow_in: ofloat,
                          dtype: type = oinvalid,
                          element_shape_except0: TensorShape = [].shape): auto =
  return iitensorArrayConcatV3(scope,
                               handle,
                               flow_in,
                               dtype[].oTF,
                               element_shape_except0,
                               dtype)

converter tensorArrayConcatV3ToOut*[oT: oall](op: TensorArrayConcatV3[oT]): oT {.inline.} = return op.output

type ResourceApplyFtrlV2T* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyFtrlV2*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyFtrlV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyFtrlV2(scope: Scope,
                          nvar: oresource,
                          accum: oresource,
                          linear: oresource,
                          grad: ResourceApplyFtrlV2T,
                          lr: ResourceApplyFtrlV2T,
                          l1: ResourceApplyFtrlV2T,
                          l2: ResourceApplyFtrlV2T,
                          l2_shrinkage: ResourceApplyFtrlV2T,
                          lr_power: ResourceApplyFtrlV2T,
                          use_locking: bool): ResourceApplyFtrlV2 {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyFtrlV2*(scope: Scope,
                          nvar: oresource,
                          accum: oresource,
                          linear: oresource,
                          grad: ResourceApplyFtrlV2T,
                          lr: ResourceApplyFtrlV2T,
                          l1: ResourceApplyFtrlV2T,
                          l2: ResourceApplyFtrlV2T,
                          l2_shrinkage: ResourceApplyFtrlV2T,
                          lr_power: ResourceApplyFtrlV2T,
                          use_locking: bool = false): ResourceApplyFtrlV2 =
  return iiresourceApplyFtrlV2(scope,
                               nvar,
                               accum,
                               linear,
                               grad,
                               lr,
                               l1,
                               l2,
                               l2_shrinkage,
                               lr_power,
                               use_locking)



type UpperBoundT* = oall

type UpperBound*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UpperBound/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiupperBound[oT: oall](scope: Scope,
                 sorted_inputs: UpperBoundT,
                 values: UpperBoundT,
                 out_type: DType,
                 explicitT: type(oT)): UpperBound[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UpperBound(*#, #, #, #)", constructor.}

proc upperBound*(scope: Scope,
                 sorted_inputs: UpperBoundT,
                 values: UpperBoundT,
                 out_type: type = oint32): auto =
  return iiupperBound(scope,
                      sorted_inputs,
                      values,
                      out_type[].oTF,
                      out_type)

converter upperBoundToOut*[oT: oall](op: UpperBound[oT]): oT {.inline.} = return op.output

type StridedSliceAssignIndex* = oint32 | oint64

type StridedSliceAssign*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StridedSliceAssign/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistridedSliceAssign[oT: oall](scope: Scope,
                         nref: oT,
                         begin: StridedSliceAssignIndex,
                         nend: StridedSliceAssignIndex,
                         strides: StridedSliceAssignIndex,
                         value: oT,
                         T: DType,
                         shrink_axis_mask: int64,
                         begin_mask: int64,
                         end_mask: int64,
                         ellipsis_mask: int64,
                         new_axis_mask: int64): StridedSliceAssign[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StridedSliceAssign(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc stridedSliceAssign*[oT: oall](scope: Scope,
                         nref: oT,
                         begin: StridedSliceAssignIndex,
                         nend: StridedSliceAssignIndex,
                         strides: StridedSliceAssignIndex,
                         value: oT,
                         shrink_axis_mask: int64 = 0.int,
                         begin_mask: int64 = 0.int,
                         end_mask: int64 = 0.int,
                         ellipsis_mask: int64 = 0.int,
                         new_axis_mask: int64 = 0.int): StridedSliceAssign[oT] =
  return iistridedSliceAssign(scope,
                              nref,
                              begin,
                              nend,
                              strides,
                              value,
                              oT[].oTF,
                              shrink_axis_mask,
                              begin_mask,
                              end_mask,
                              ellipsis_mask,
                              new_axis_mask)

converter stridedSliceAssignToOut*[oT: oall](op: StridedSliceAssign[oT]): oT {.inline.} = return op.output


type QuantizedConcat*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedConcat/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedConcat[oT: oall](scope: Scope,
                      concat_dim: oint32,
                      values: olist[oT],
                      input_mins: olist[ofloat],
                      input_maxes: olist[ofloat],
                      T: DType): QuantizedConcat[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedConcat(*#, #, #, #, #, #)", constructor.}

proc quantizedConcat*[oT: oall](scope: Scope,
                      concat_dim: oint32,
                      values: olist[oT],
                      input_mins: olist[ofloat],
                      input_maxes: olist[ofloat]): QuantizedConcat[oT] =
  return iiquantizedConcat(scope,
                           concat_dim,
                           values,
                           input_mins,
                           input_maxes,
                           oT[].oTF)

converter quantizedConcatToOut*[oT: oall](op: QuantizedConcat[oT]): oT {.inline.} = return op.output

type LookupTableInsertTout* = oall
type LookupTableInsertTin* = oall

type LookupTableInsert*{.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableInsert/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iilookupTableInsert(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableInsertTin,
                        values: LookupTableInsertTout): LookupTableInsert {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableInsert(*#, #, #, #)", constructor.}

proc lookupTableInsert*(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableInsertTin,
                        values: LookupTableInsertTout): LookupTableInsert =
  return iilookupTableInsert(scope,
                             table_handle,
                             keys,
                             values)




type ExtractVolumePatches*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractVolumePatches/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiextractVolumePatches[oT: oall](scope: Scope,
                           input: oT,
                           ksizes: ArraySlice[int],
                           strides: ArraySlice[int],
                           padding: cstring,
                           T: DType): ExtractVolumePatches[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractVolumePatches(*#, #, #, #, tensorflow::string(#), #)", constructor.}

proc extractVolumePatches*[oT: oall](scope: Scope,
                           input: oT,
                           ksizes: openArray[int],
                           strides: openArray[int],
                           padding: cstring): ExtractVolumePatches[oT] =
  return iiextractVolumePatches(scope,
                                input,
                                newArraySlice(ksizes),
                                newArraySlice(strides),
                                padding,
                                oT[].oTF)

converter extractVolumePatchesToOut*[oT: oall](op: ExtractVolumePatches[oT]): oT {.inline.} = return op.output


type FixedUnigramCandidateSampler* {.header:"../tensorflow/ops/generated.h", importcpp:"FixedUnigramCandidateSampler/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iifixedUnigramCandidateSampler(scope: Scope,
                                   true_classes: oint64,
                                   vocab_file: cstring,
                                   unigrams: ArraySlice[float32],
                                   num_true: int64,
                                   num_sampled: int64,
                                   unique: bool,
                                   range_max: int64,
                                   distortion: float32,
                                   num_reserved_ids: int64,
                                   num_shards: int64,
                                   shard: int64,
                                   seed: int64,
                                   seed2: int64): FixedUnigramCandidateSampler {.header:"../tensorflow/ops/generated.h", importcpp:"FixedUnigramCandidateSampler(*#, #, tensorflow::string(#), #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc fixedUnigramCandidateSampler*(scope: Scope,
                                   true_classes: oint64,
                                   vocab_file: cstring,
                                   unigrams: openArray[float32],
                                   num_true: int64 = 0.int,
                                   num_sampled: int64 = 0.int,
                                   unique: bool = false,
                                   range_max: int64 = 0.int,
                                   distortion: float32 = 1.0.float32,
                                   num_reserved_ids: int64 = 0.int,
                                   num_shards: int64 = 1.int,
                                   shard: int64 = 0.int,
                                   seed: int64 = 0.int,
                                   seed2: int64 = 0.int): FixedUnigramCandidateSampler =
  return iifixedUnigramCandidateSampler(scope,
                                        true_classes,
                                        vocab_file,
                                        newArraySlice(unigrams),
                                        num_true,
                                        num_sampled,
                                        unique,
                                        range_max,
                                        distortion,
                                        num_reserved_ids,
                                        num_shards,
                                        shard,
                                        seed,
                                        seed2)

converter fixedUnigramCandidateSamplerToOut*(op: FixedUnigramCandidateSampler): oint64 {.inline.} = return op.output


type Merge*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Merge/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimerge[oT: oall](scope: Scope,
            inputs: olist[oT],
            T: DType): Merge[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Merge(*#, #, #)", constructor.}

proc merge*[oT: oall](scope: Scope,
            inputs: olist[oT]): Merge[oT] =
  return iimerge(scope,
                 inputs,
                 oT[].oTF)

converter mergeToOut*[oT: oall](op: Merge[oT]): oT {.inline.} = return op.output


type PaddedBatchDatasetV2* {.header:"../tensorflow/ops/generated.h", importcpp:"PaddedBatchDatasetV2/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iipaddedBatchDatasetV2(scope: Scope,
                           input_dataset: ovariant,
                           batch_size: oint64,
                           padded_shapes: olist[oint64],
                           padding_values: olist[oall],
                           drop_remainder: obool,
                           Toutput_types: ArraySlice[DType],
                           output_shapes: ArraySlice[TensorShape]): PaddedBatchDatasetV2 {.header:"../tensorflow/ops/generated.h", importcpp:"PaddedBatchDatasetV2(*#, #, #, #, #, #, #, #)", constructor.}

proc paddedBatchDatasetV2*(scope: Scope,
                           input_dataset: ovariant,
                           batch_size: oint64,
                           padded_shapes: olist[oint64],
                           padding_values: olist[oall],
                           drop_remainder: obool,
                           Toutput_types: openArray[DType],
                           output_shapes: openArray[TensorShape]): PaddedBatchDatasetV2 =
  return iipaddedBatchDatasetV2(scope,
                                input_dataset,
                                batch_size,
                                padded_shapes,
                                padding_values,
                                drop_remainder,
                                newArraySlice(Toutput_types),
                                newArraySlice(output_shapes))

converter paddedBatchDatasetV2ToOut*(op: PaddedBatchDatasetV2): ovariant {.inline.} = return op.output


type ExtractImagePatches*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractImagePatches/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiextractImagePatches[oT: oall](scope: Scope,
                          images: oT,
                          ksizes: ArraySlice[int],
                          strides: ArraySlice[int],
                          rates: ArraySlice[int],
                          padding: cstring,
                          T: DType): ExtractImagePatches[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ExtractImagePatches(*#, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc extractImagePatches*[oT: oall](scope: Scope,
                          images: oT,
                          ksizes: openArray[int],
                          strides: openArray[int],
                          rates: openArray[int],
                          padding: cstring): ExtractImagePatches[oT] =
  return iiextractImagePatches(scope,
                               images,
                               newArraySlice(ksizes),
                               newArraySlice(strides),
                               newArraySlice(rates),
                               padding,
                               oT[].oTF)

converter extractImagePatchesToOut*[oT: oall](op: ExtractImagePatches[oT]): oT {.inline.} = return op.output


type AllCandidateSampler* {.header:"../tensorflow/ops/generated.h", importcpp:"AllCandidateSampler/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiallCandidateSampler(scope: Scope,
                          true_classes: oint64,
                          num_true: int64,
                          num_sampled: int64,
                          unique: bool,
                          seed: int64,
                          seed2: int64): AllCandidateSampler {.header:"../tensorflow/ops/generated.h", importcpp:"AllCandidateSampler(*#, #, #, #, #, #, #)", constructor.}

proc allCandidateSampler*(scope: Scope,
                          true_classes: oint64,
                          num_true: int64 = 0.int,
                          num_sampled: int64 = 0.int,
                          unique: bool = false,
                          seed: int64 = 0.int,
                          seed2: int64 = 0.int): AllCandidateSampler =
  return iiallCandidateSampler(scope,
                               true_classes,
                               num_true,
                               num_sampled,
                               unique,
                               seed,
                               seed2)

converter allCandidateSamplerToOut*(op: AllCandidateSampler): oint64 {.inline.} = return op.output


type DepthToSpace*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthToSpace/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidepthToSpace[oT: oall](scope: Scope,
                   input: oT,
                   T: DType,
                   block_size: int64,
                   data_format: cstring): DepthToSpace[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthToSpace(*#, #, #, #, tensorflow::string(#))", constructor.}

proc depthToSpace*[oT: oall](scope: Scope,
                   input: oT,
                   block_size: int64 = 0.int,
                   data_format: cstring = "NHWC"): DepthToSpace[oT] =
  return iidepthToSpace(scope,
                        input,
                        oT[].oTF,
                        block_size,
                        data_format)

converter depthToSpaceToOut*[oT: oall](op: DepthToSpace[oT]): oT {.inline.} = return op.output


type SpaceToDepth*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SpaceToDepth/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iispaceToDepth[oT: oall](scope: Scope,
                   input: oT,
                   T: DType,
                   block_size: int64,
                   data_format: cstring): SpaceToDepth[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SpaceToDepth(*#, #, #, #, tensorflow::string(#))", constructor.}

proc spaceToDepth*[oT: oall](scope: Scope,
                   input: oT,
                   block_size: int64 = 0.int,
                   data_format: cstring = "NHWC"): SpaceToDepth[oT] =
  return iispaceToDepth(scope,
                        input,
                        oT[].oTF,
                        block_size,
                        data_format)

converter spaceToDepthToOut*[oT: oall](op: SpaceToDepth[oT]): oT {.inline.} = return op.output


type InplaceSub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"InplaceSub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinplaceSub[oT: oall](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT,
                 T: DType): InplaceSub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"InplaceSub(*#, #, #, #, #)", constructor.}

proc inplaceSub*[oT: oall](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT): InplaceSub[oT] =
  return iiinplaceSub(scope,
                      x,
                      i,
                      v,
                      oT[].oTF)

converter inplaceSubToOut*[oT: oall](op: InplaceSub[oT]): oT {.inline.} = return op.output


type RefIdentity*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefIdentity/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefIdentity[oT: oall](scope: Scope,
                  input: oT,
                  T: DType): RefIdentity[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefIdentity(*#, #, #)", constructor.}

proc refIdentity*[oT: oall](scope: Scope,
                  input: oT): RefIdentity[oT] =
  return iirefIdentity(scope,
                       input,
                       oT[].oTF)

converter refIdentityToOut*[oT: oall](op: RefIdentity[oT]): oT {.inline.} = return op.output


type FilterDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"FilterDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iifilterDataset(scope: Scope,
                    input_dataset: ovariant,
                    other_arguments: olist[oall],
                    predicate: NameAttrList,
                    Targuments: ArraySlice[DType],
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): FilterDataset {.header:"../tensorflow/ops/generated.h", importcpp:"FilterDataset(*#, #, #, #, #, #, #)", constructor.}

proc filterDataset*(scope: Scope,
                    input_dataset: ovariant,
                    other_arguments: olist[oall],
                    predicate: NameAttrList,
                    Targuments: openArray[DType],
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): FilterDataset =
  return iifilterDataset(scope,
                         input_dataset,
                         other_arguments,
                         predicate,
                         newArraySlice(Targuments),
                         newArraySlice(output_types),
                         newArraySlice(output_shapes))

converter filterDatasetToOut*(op: FilterDataset): ovariant {.inline.} = return op.output

type DeserializeSparseTserialized* = ostring | ovariant

type DeserializeSparse* {.header:"../tensorflow/ops/generated.h", importcpp:"DeserializeSparse/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iideserializeSparse(scope: Scope,
                        serialized_sparse: DeserializeSparseTserialized,
                        dtype: DType): DeserializeSparse {.header:"../tensorflow/ops/generated.h", importcpp:"DeserializeSparse(*#, #, #)", constructor.}

proc deserializeSparse*(scope: Scope,
                        serialized_sparse: DeserializeSparseTserialized,
                        dtype: type oall = oinvalid): DeserializeSparse =
  return iideserializeSparse(scope,
                             serialized_sparse,
                             oT[].oTF)

converter deserializeSparseToOut*(op: DeserializeSparse): oint64 {.inline.} = return op.output


type MapClear*{.header:"../tensorflow/ops/generated.h", importcpp:"MapClear/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iimapClear(scope: Scope,
               dtypes: ArraySlice[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64,
               memory_limit: int64): MapClear {.header:"../tensorflow/ops/generated.h", importcpp:"MapClear(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapClear*(scope: Scope,
               dtypes: openArray[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64 = 0.int,
               memory_limit: int64 = 0.int): MapClear =
  return iimapClear(scope,
                    newArraySlice(dtypes),
                    container,
                    shared_name,
                    capacity,
                    memory_limit)



type QuantizedRelu6Tinput* = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedRelu6*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedRelu6/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedRelu6[oT: oall](scope: Scope,
                     features: QuantizedRelu6Tinput,
                     min_features: ofloat,
                     max_features: ofloat,
                     out_type: DType,
                     explicitT: type(oT)): QuantizedRelu6[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedRelu6(*#, #, #, #, #)", constructor.}

proc quantizedRelu6*(scope: Scope,
                     features: QuantizedRelu6Tinput,
                     min_features: ofloat,
                     max_features: ofloat,
                     out_type: type = oquint8): auto =
  return iiquantizedRelu6(scope,
                          features,
                          min_features,
                          max_features,
                          out_type[].oTF,
                          out_type)

converter quantizedRelu6ToOut*[oT: oall](op: QuantizedRelu6[oT]): oT {.inline.} = return op.output

type ResourceStridedSliceAssignT* = oall
type ResourceStridedSliceAssignIndex* = oint32 | oint64

type ResourceStridedSliceAssign*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceStridedSliceAssign/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceStridedSliceAssign(scope: Scope,
                                 nref: oresource,
                                 begin: ResourceStridedSliceAssignIndex,
                                 nend: ResourceStridedSliceAssignIndex,
                                 strides: ResourceStridedSliceAssignIndex,
                                 value: ResourceStridedSliceAssignT,
                                 new_axis_mask: int64,
                                 shrink_axis_mask: int64,
                                 begin_mask: int64,
                                 end_mask: int64,
                                 ellipsis_mask: int64): ResourceStridedSliceAssign {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceStridedSliceAssign(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceStridedSliceAssign*(scope: Scope,
                                 nref: oresource,
                                 begin: ResourceStridedSliceAssignIndex,
                                 nend: ResourceStridedSliceAssignIndex,
                                 strides: ResourceStridedSliceAssignIndex,
                                 value: ResourceStridedSliceAssignT,
                                 new_axis_mask: int64 = 0.int,
                                 shrink_axis_mask: int64 = 0.int,
                                 begin_mask: int64 = 0.int,
                                 end_mask: int64 = 0.int,
                                 ellipsis_mask: int64 = 0.int): ResourceStridedSliceAssign =
  return iiresourceStridedSliceAssign(scope,
                                      nref,
                                      begin,
                                      nend,
                                      strides,
                                      value,
                                      new_axis_mask,
                                      shrink_axis_mask,
                                      begin_mask,
                                      end_mask,
                                      ellipsis_mask)




type Squeeze*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Squeeze/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisqueeze[oT: oall](scope: Scope,
              input: oT,
              squeeze_dims: ArraySlice[int],
              T: DType): Squeeze[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Squeeze(*#, #, #, #)", constructor.}

proc squeeze*[oT: oall](scope: Scope,
              input: oT,
              squeeze_dims: openArray[int]): Squeeze[oT] =
  return iisqueeze(scope,
                   input,
                   newArraySlice(squeeze_dims),
                   oT[].oTF)

converter squeezeToOut*[oT: oall](op: Squeeze[oT]): oT {.inline.} = return op.output


type InplaceUpdate*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"InplaceUpdate/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinplaceUpdate[oT: oall](scope: Scope,
                    x: oT,
                    i: oint32,
                    v: oT,
                    T: DType): InplaceUpdate[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"InplaceUpdate(*#, #, #, #, #)", constructor.}

proc inplaceUpdate*[oT: oall](scope: Scope,
                    x: oT,
                    i: oint32,
                    v: oT): InplaceUpdate[oT] =
  return iiinplaceUpdate(scope,
                         x,
                         i,
                         v,
                         oT[].oTF)

converter inplaceUpdateToOut*[oT: oall](op: InplaceUpdate[oT]): oT {.inline.} = return op.output

type InitializeTableV2Tval* = oall
type InitializeTableV2Tkey* = oall

type InitializeTableV2*{.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTableV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiinitializeTableV2(scope: Scope,
                        table_handle: oresource,
                        keys: InitializeTableV2Tkey,
                        values: InitializeTableV2Tval): InitializeTableV2 {.header:"../tensorflow/ops/generated.h", importcpp:"InitializeTableV2(*#, #, #, #)", constructor.}

proc initializeTableV2*(scope: Scope,
                        table_handle: oresource,
                        keys: InitializeTableV2Tkey,
                        values: InitializeTableV2Tval): InitializeTableV2 =
  return iiinitializeTableV2(scope,
                             table_handle,
                             keys,
                             values)




type NextIteration*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"NextIteration/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iinextIteration[oT: oall](scope: Scope,
                    data: oT,
                    T: DType): NextIteration[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"NextIteration(*#, #, #)", constructor.}

proc nextIteration*[oT: oall](scope: Scope,
                    data: oT): NextIteration[oT] =
  return iinextIteration(scope,
                         data,
                         oT[].oTF)

converter nextIterationToOut*[oT: oall](op: NextIteration[oT]): oT {.inline.} = return op.output


type Copy*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Copy/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicopy[oT: oall](scope: Scope,
           input: oT,
           tensor_name: cstring,
           debug_ops_spec: ArraySlice[cstring],
           T: DType): Copy[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Copy(*#, #, tensorflow::string(#), #, #)", constructor.}

proc copy*[oT: oall](scope: Scope,
           input: oT,
           tensor_name: cstring,
           debug_ops_spec: openArray[cstring]): Copy[oT] =
  return iicopy(scope,
                input,
                tensor_name,
                newArraySlice(debug_ops_spec),
                oT[].oTF)

converter copyToOut*[oT: oall](op: Copy[oT]): oT {.inline.} = return op.output


type StringLength* {.header:"../tensorflow/ops/generated.h", importcpp:"StringLength/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iistringLength(scope: Scope,
                   input: ostring,
                   unit: cstring): StringLength {.header:"../tensorflow/ops/generated.h", importcpp:"StringLength(*#, #, tensorflow::string(#))", constructor.}

proc stringLength*(scope: Scope,
                   input: ostring,
                   unit: cstring = "BYTE"): StringLength =
  return iistringLength(scope,
                        input,
                        unit)

converter stringLengthToOut*(op: StringLength): oint32 {.inline.} = return op.output

type ScatterDivTindices* = oint32 | oint64

type ScatterDiv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterDiv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiscatterDiv[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterDivTindices,
                 updates: oT,
                 T: DType,
                 use_locking: bool): ScatterDiv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ScatterDiv(*#, #, #, #, #, #)", constructor.}

proc scatterDiv*[oT: oall](scope: Scope,
                 nref: oT,
                 indices: ScatterDivTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterDiv[oT] =
  return iiscatterDiv(scope,
                      nref,
                      indices,
                      updates,
                      oT[].oTF,
                      use_locking)

converter scatterDivToOut*[oT: oall](op: ScatterDiv[oT]): oT {.inline.} = return op.output

type TensorSummaryT* = oall

type TensorSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitensorSummary(scope: Scope,
                    tensor: TensorSummaryT,
                    description: cstring,
                    labels: ArraySlice[cstring],
                    display_name: cstring): TensorSummary {.header:"../tensorflow/ops/generated.h", importcpp:"TensorSummary(*#, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc tensorSummary*(scope: Scope,
                    tensor: TensorSummaryT,
                    description: cstring,
                    labels: openArray[cstring],
                    display_name: cstring): TensorSummary =
  return iitensorSummary(scope,
                         tensor,
                         description,
                         newArraySlice(labels),
                         display_name)

converter tensorSummaryToOut*(op: TensorSummary): ostring {.inline.} = return op.output

type SparseApplyProximalGradientDescentTindices* = oint32 | oint64

type SparseApplyProximalGradientDescent*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyProximalGradientDescent/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseApplyProximalGradientDescent[oT: oall](scope: Scope,
                                         nvar: oT,
                                         alpha: oT,
                                         l1: oT,
                                         l2: oT,
                                         grad: oT,
                                         indices: SparseApplyProximalGradientDescentTindices,
                                         T: DType,
                                         use_locking: bool): SparseApplyProximalGradientDescent[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseApplyProximalGradientDescent(*#, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyProximalGradientDescent*[oT: oall](scope: Scope,
                                         nvar: oT,
                                         alpha: oT,
                                         l1: oT,
                                         l2: oT,
                                         grad: oT,
                                         indices: SparseApplyProximalGradientDescentTindices,
                                         use_locking: bool = false): SparseApplyProximalGradientDescent[oT] =
  return iisparseApplyProximalGradientDescent(scope,
                                              nvar,
                                              alpha,
                                              l1,
                                              l2,
                                              grad,
                                              indices,
                                              oT[].oTF,
                                              use_locking)

converter sparseApplyProximalGradientDescentToOut*[oT: oall](op: SparseApplyProximalGradientDescent[oT]): oT {.inline.} = return op.output

type TileTmultiples* = oint32 | oint64

type Tile*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Tile/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitile[oT: oall](scope: Scope,
           input: oT,
           multiples: TileTmultiples,
           T: DType): Tile[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Tile(*#, #, #, #)", constructor.}

proc tile*[oT: oall](scope: Scope,
           input: oT,
           multiples: TileTmultiples): Tile[oT] =
  return iitile(scope,
                input,
                multiples,
                oT[].oTF)

converter tileToOut*[oT: oall](op: Tile[oT]): oT {.inline.} = return op.output

type IHostSendT* = oall

type IHostSend*{.header:"../tensorflow/ops/generated.h", importcpp:"_HostSend/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiiHostSend(scope: Scope,
                tensor: IHostSendT,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                client_terminated: bool,
                send_device_incarnation: int64): IHostSend {.header:"../tensorflow/ops/generated.h", importcpp:"_HostSend(*#, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iHostSend*(scope: Scope,
                tensor: IHostSendT,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                client_terminated: bool = false,
                send_device_incarnation: int64 = 0.int): IHostSend =
  return iiiHostSend(scope,
                     tensor,
                     tensor_name,
                     send_device,
                     recv_device,
                     client_terminated,
                     send_device_incarnation)



type ExpandDimsTdim* = oint32 | oint64

type ExpandDims*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ExpandDims/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiexpandDims[oT: oall](scope: Scope,
                 input: oT,
                 dim: ExpandDimsTdim,
                 T: DType): ExpandDims[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ExpandDims(*#, #, #, #)", constructor.}

proc expandDims*[oT: oall](scope: Scope,
                 input: oT,
                 dim: ExpandDimsTdim): ExpandDims[oT] =
  return iiexpandDims(scope,
                      input,
                      dim,
                      oT[].oTF)

converter expandDimsToOut*[oT: oall](op: ExpandDims[oT]): oT {.inline.} = return op.output

type SpaceToBatchTpaddings* = oint32 | oint64

type SpaceToBatch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SpaceToBatch/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iispaceToBatch[oT: oall](scope: Scope,
                   input: oT,
                   paddings: SpaceToBatchTpaddings,
                   T: DType,
                   block_size: int64): SpaceToBatch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SpaceToBatch(*#, #, #, #, #)", constructor.}

proc spaceToBatch*[oT: oall](scope: Scope,
                   input: oT,
                   paddings: SpaceToBatchTpaddings,
                   block_size: int64 = 0.int): SpaceToBatch[oT] =
  return iispaceToBatch(scope,
                        input,
                        paddings,
                        oT[].oTF,
                        block_size)

converter spaceToBatchToOut*[oT: oall](op: SpaceToBatch[oT]): oT {.inline.} = return op.output


type MaxPoolWithArgmax*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolWithArgmax/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimaxPoolWithArgmax[oT: oall](scope: Scope,
                        input: oT,
                        ksize: ArraySlice[int],
                        strides: ArraySlice[int],
                        padding: cstring,
                        Targmax: DType,
                        T: DType): MaxPoolWithArgmax[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MaxPoolWithArgmax(*#, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc maxPoolWithArgmax*[oT: oall](scope: Scope,
                        input: oT,
                        ksize: openArray[int],
                        strides: openArray[int],
                        padding: cstring,
                        Targmax: type(oint32) | type(oint64) = oint64): MaxPoolWithArgmax[oT] =
  return iimaxPoolWithArgmax(scope,
                             input,
                             newArraySlice(ksize),
                             newArraySlice(strides),
                             padding,
                             oT[].oTF,
                             oT[].oTF)

converter maxPoolWithArgmaxToOut*[oT: oall](op: MaxPoolWithArgmax[oT]): oT {.inline.} = return op.output


type RefEnter*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"RefEnter/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirefEnter[oT: oall](scope: Scope,
               data: oT,
               frame_name: cstring,
               T: DType,
               is_constant: bool,
               parallel_iterations: int64): RefEnter[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"RefEnter(*#, #, tensorflow::string(#), #, #, #)", constructor.}

proc refEnter*[oT: oall](scope: Scope,
               data: oT,
               frame_name: cstring,
               is_constant: bool = false,
               parallel_iterations: int64 = 10.int): RefEnter[oT] =
  return iirefEnter(scope,
                    data,
                    frame_name,
                    oT[].oTF,
                    is_constant,
                    parallel_iterations)

converter refEnterToOut*[oT: oall](op: RefEnter[oT]): oT {.inline.} = return op.output


type PriorityQueueV2* {.header:"../tensorflow/ops/generated.h", importcpp:"PriorityQueueV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iipriorityQueueV2(scope: Scope,
                      component_types: ArraySlice[DType],
                      shapes: ArraySlice[TensorShape],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64): PriorityQueueV2 {.header:"../tensorflow/ops/generated.h", importcpp:"PriorityQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc priorityQueueV2*(scope: Scope,
                      component_types: openArray[DType],
                      shapes: openArray[TensorShape],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = -1.int): PriorityQueueV2 =
  return iipriorityQueueV2(scope,
                           newArraySlice(component_types),
                           newArraySlice(shapes),
                           container,
                           shared_name,
                           capacity)

converter priorityQueueV2ToOut*(op: PriorityQueueV2): oresource {.inline.} = return op.output


type IsBoostedTreesEnsembleInitialized* {.header:"../tensorflow/ops/generated.h", importcpp:"IsBoostedTreesEnsembleInitialized/*'0*/".} = object
  operation*: Operation[obool]
  output*: obool

proc iiisBoostedTreesEnsembleInitialized(scope: Scope,
                                        tree_ensemble_handle: oresource): IsBoostedTreesEnsembleInitialized {.header:"../tensorflow/ops/generated.h", importcpp:"IsBoostedTreesEnsembleInitialized(*#, #)", constructor.}

proc isBoostedTreesEnsembleInitialized*(scope: Scope,
                                        tree_ensemble_handle: oresource): IsBoostedTreesEnsembleInitialized =
  return iiisBoostedTreesEnsembleInitialized(scope,
                                             tree_ensemble_handle)

converter isBoostedTreesEnsembleInitializedToOut*(op: IsBoostedTreesEnsembleInitialized): obool {.inline.} = return op.output


type RepeatDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"RepeatDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iirepeatDataset(scope: Scope,
                    input_dataset: ovariant,
                    count: oint64,
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): RepeatDataset {.header:"../tensorflow/ops/generated.h", importcpp:"RepeatDataset(*#, #, #, #, #)", constructor.}

proc repeatDataset*(scope: Scope,
                    input_dataset: ovariant,
                    count: oint64,
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): RepeatDataset =
  return iirepeatDataset(scope,
                         input_dataset,
                         count,
                         newArraySlice(output_types),
                         newArraySlice(output_shapes))

converter repeatDatasetToOut*(op: RepeatDataset): ovariant {.inline.} = return op.output


type BoostedTreesCreateEnsemble*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCreateEnsemble/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesCreateEnsemble(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 stamp_token: oint64,
                                 tree_ensemble_serialized: ostring): BoostedTreesCreateEnsemble {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCreateEnsemble(*#, #, #, #)", constructor.}

proc boostedTreesCreateEnsemble*(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 stamp_token: oint64,
                                 tree_ensemble_serialized: ostring): BoostedTreesCreateEnsemble =
  return iiboostedTreesCreateEnsemble(scope,
                                      tree_ensemble_handle,
                                      stamp_token,
                                      tree_ensemble_serialized)



type Fillindex_type* = oint32 | oint64

type Fill*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Fill/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifill[oT: oall](scope: Scope,
           dims: Fillindex_type,
           value: oT,
           T: DType): Fill[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Fill(*#, #, #, #)", constructor.}

proc fill*[oT: oall](scope: Scope,
           dims: Fillindex_type,
           value: oT): Fill[oT] =
  return iifill(scope,
                dims,
                value,
                oT[].oTF)

converter fillToOut*[oT: oall](op: Fill[oT]): oT {.inline.} = return op.output


type ApplyCenteredRMSProp*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyCenteredRMSProp/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyCenteredRMSProp[oT: oall](scope: Scope,
                           nvar: oT,
                           mg: oT,
                           ms: oT,
                           mom: oT,
                           lr: oT,
                           rho: oT,
                           momentum: oT,
                           epsilon: oT,
                           grad: oT,
                           T: DType,
                           use_locking: bool): ApplyCenteredRMSProp[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyCenteredRMSProp*[oT: oall](scope: Scope,
                           nvar: oT,
                           mg: oT,
                           ms: oT,
                           mom: oT,
                           lr: oT,
                           rho: oT,
                           momentum: oT,
                           epsilon: oT,
                           grad: oT,
                           use_locking: bool = false): ApplyCenteredRMSProp[oT] =
  return iiapplyCenteredRMSProp(scope,
                                nvar,
                                mg,
                                ms,
                                mom,
                                lr,
                                rho,
                                momentum,
                                epsilon,
                                grad,
                                oT[].oTF,
                                use_locking)

converter applyCenteredRMSPropToOut*[oT: oall](op: ApplyCenteredRMSProp[oT]): oT {.inline.} = return op.output


type Const*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Const/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iinconst[oT: oall](scope: Scope,
             value: Tensor[oT],
             dtype: DType): Const[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Const(*#, *#, #)", constructor.}

proc nconst*[oT: oall](scope: Scope,
             value: Tensor[oT]): Const[oT] =
  return iinconst(scope,
                  value,
                  oT[].oTF)

converter nconstToOut*[oT: oall](op: Const[oT]): oT {.inline.} = return op.output


type PlaceholderWithDefault*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PlaceholderWithDefault/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiplaceholderWithDefault[oT: oall](scope: Scope,
                             input: oT,
                             dtype: DType,
                             shape: TensorShape): PlaceholderWithDefault[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PlaceholderWithDefault(*#, #, #, #)", constructor.}

proc placeholderWithDefault*[oT: oall](scope: Scope,
                             input: oT,
                             shape: TensorShape = [].shape): PlaceholderWithDefault[oT] =
  return iiplaceholderWithDefault(scope,
                                  input,
                                  oT[].oTF,
                                  shape)

converter placeholderWithDefaultToOut*[oT: oall](op: PlaceholderWithDefault[oT]): oT {.inline.} = return op.output


type Placeholder*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Placeholder/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiplaceholder[oT: oall](scope: Scope,
                  dtype: DType,
                  shape: TensorShape,
                  explicitT: type(oT)): Placeholder[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Placeholder(*#, #, #)", constructor.}

proc placeholder*(scope: Scope,
                  dtype: type = oinvalid,
                  shape: TensorShape = [].shape): auto =
  return iiplaceholder(scope,
                       dtype[].oTF,
                       shape,
                       dtype)

converter placeholderToOut*[oT: oall](op: Placeholder[oT]): oT {.inline.} = return op.output


type QueueEnqueueManyV2*{.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueueManyV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiqueueEnqueueManyV2(scope: Scope,
                         handle: oresource,
                         components: olist[oall],
                         Tcomponents: ArraySlice[DType],
                         timeout_ms: int64): QueueEnqueueManyV2 {.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueueManyV2(*#, #, #, #, #)", constructor.}

proc queueEnqueueManyV2*(scope: Scope,
                         handle: oresource,
                         components: olist[oall],
                         Tcomponents: openArray[DType],
                         timeout_ms: int64 = -1.int): QueueEnqueueManyV2 =
  return iiqueueEnqueueManyV2(scope,
                              handle,
                              components,
                              newArraySlice(Tcomponents),
                              timeout_ms)



type ShapeT* = oall

type Shape*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Shape/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iishape[oT: oall](scope: Scope,
            input: ShapeT,
            out_type: DType,
            explicitT: type(oT)): Shape[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Shape(*#, #, #)", constructor.}

proc shape*(scope: Scope,
            input: ShapeT,
            out_type: type = oint32): auto =
  return iishape(scope,
                 input,
                 out_type[].oTF,
                 out_type)

converter shapeToOut*[oT: oall](op: Shape[oT]): oT {.inline.} = return op.output


type Dilation2DBackpropFilter*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Dilation2DBackpropFilter/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidilation2DBackpropFilter[oT: oall](scope: Scope,
                               input: oT,
                               filter: oT,
                               out_backprop: oT,
                               strides: ArraySlice[int],
                               rates: ArraySlice[int],
                               padding: cstring,
                               T: DType): Dilation2DBackpropFilter[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Dilation2DBackpropFilter(*#, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc dilation2DBackpropFilter*[oT: oall](scope: Scope,
                               input: oT,
                               filter: oT,
                               out_backprop: oT,
                               strides: openArray[int],
                               rates: openArray[int],
                               padding: cstring): Dilation2DBackpropFilter[oT] =
  return iidilation2DBackpropFilter(scope,
                                    input,
                                    filter,
                                    out_backprop,
                                    newArraySlice(strides),
                                    newArraySlice(rates),
                                    padding,
                                    oT[].oTF)

converter dilation2DBackpropFilterToOut*[oT: oall](op: Dilation2DBackpropFilter[oT]): oT {.inline.} = return op.output


type BatchIFFT3D* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchIFFT3D/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iibatchIFFT3D(scope: Scope,
                  input: ocomplex64): BatchIFFT3D {.header:"../tensorflow/ops/generated.h", importcpp:"BatchIFFT3D(*#, #)", constructor.}

proc batchIFFT3D*(scope: Scope,
                  input: ocomplex64): BatchIFFT3D =
  return iibatchIFFT3D(scope,
                       input)

converter batchIFFT3DToOut*(op: BatchIFFT3D): ocomplex64 {.inline.} = return op.output


type AvgPool3D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPool3D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiavgPool3D[oT: oall](scope: Scope,
                input: oT,
                ksize: ArraySlice[int],
                strides: ArraySlice[int],
                padding: cstring,
                data_format: cstring,
                T: DType): AvgPool3D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"AvgPool3D(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc avgPool3D*[oT: oall](scope: Scope,
                input: oT,
                ksize: openArray[int],
                strides: openArray[int],
                padding: cstring,
                data_format: cstring = "NDHWC"): AvgPool3D[oT] =
  return iiavgPool3D(scope,
                     input,
                     newArraySlice(ksize),
                     newArraySlice(strides),
                     padding,
                     data_format,
                     oT[].oTF)

converter avgPool3DToOut*[oT: oall](op: AvgPool3D[oT]): oT {.inline.} = return op.output


type DataFormatDimMap*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DataFormatDimMap/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidataFormatDimMap[oT: oall](scope: Scope,
                       x: oT,
                       T: DType,
                       src_format: cstring,
                       dst_format: cstring): DataFormatDimMap[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DataFormatDimMap(*#, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc dataFormatDimMap*[oT: oall](scope: Scope,
                       x: oT,
                       src_format: cstring = "NHWC",
                       dst_format: cstring = "NCHW"): DataFormatDimMap[oT] =
  return iidataFormatDimMap(scope,
                            x,
                            oT[].oTF,
                            src_format,
                            dst_format)

converter dataFormatDimMapToOut*[oT: oall](op: DataFormatDimMap[oT]): oT {.inline.} = return op.output


type StackClose*{.header:"../tensorflow/ops/generated.h", importcpp:"StackClose/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iistackClose(scope: Scope,
                 handle: ostring): StackClose {.header:"../tensorflow/ops/generated.h", importcpp:"StackClose(*#, #)", constructor.}

proc stackClose*(scope: Scope,
                 handle: ostring): StackClose =
  return iistackClose(scope,
                      handle)




type QueueSizeV2* {.header:"../tensorflow/ops/generated.h", importcpp:"QueueSizeV2/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiqueueSizeV2(scope: Scope,
                  handle: oresource): QueueSizeV2 {.header:"../tensorflow/ops/generated.h", importcpp:"QueueSizeV2(*#, #)", constructor.}

proc queueSizeV2*(scope: Scope,
                  handle: oresource): QueueSizeV2 =
  return iiqueueSizeV2(scope,
                       handle)

converter queueSizeV2ToOut*(op: QueueSizeV2): oint32 {.inline.} = return op.output


type StatelessWhile*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessWhile/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iistatelessWhile[oT: oall](scope: Scope,
                     input: olist[oT],
                     T: ArraySlice[DType],
                     cond: NameAttrList,
                     body: NameAttrList): StatelessWhile[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessWhile(*#, #, #, #, #)", constructor.}

proc statelessWhile*[oT: oall](scope: Scope,
                     input: olist[oT],
                     T: openArray[DType],
                     cond: NameAttrList,
                     body: NameAttrList): StatelessWhile[oT] =
  return iistatelessWhile(scope,
                          input,
                          newArraySlice(T),
                          cond,
                          body)

converter statelessWhileToOutList*[oT: oall](op: StatelessWhile[oT]): olist[oT] {.inline.} = return op.output


type MatrixDiagPart*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixDiagPart/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixDiagPart[oT: oall](scope: Scope,
                     input: oT,
                     T: DType): MatrixDiagPart[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixDiagPart(*#, #, #)", constructor.}

proc matrixDiagPart*[oT: oall](scope: Scope,
                     input: oT): MatrixDiagPart[oT] =
  return iimatrixDiagPart(scope,
                          input,
                          oT[].oTF)

converter matrixDiagPartToOut*[oT: oall](op: MatrixDiagPart[oT]): oT {.inline.} = return op.output


type DecodeProtoV2* {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeProtoV2/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iidecodeProtoV2(scope: Scope,
                    bytes: ostring,
                    message_type: cstring,
                    field_names: ArraySlice[cstring],
                    output_types: ArraySlice[DType],
                    descriptor_source: cstring,
                    message_format: cstring,
                    sanitize: bool): DecodeProtoV2 {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeProtoV2(*#, #, tensorflow::string(#), #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc decodeProtoV2*(scope: Scope,
                    bytes: ostring,
                    message_type: cstring,
                    field_names: openArray[cstring],
                    output_types: openArray[DType],
                    descriptor_source: cstring = "local://",
                    message_format: cstring = "binary",
                    sanitize: bool = false): DecodeProtoV2 =
  return iidecodeProtoV2(scope,
                         bytes,
                         message_type,
                         newArraySlice(field_names),
                         newArraySlice(output_types),
                         descriptor_source,
                         message_format,
                         sanitize)

converter decodeProtoV2ToOut*(op: DecodeProtoV2): oint32 {.inline.} = return op.output


type Print*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Print/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiprint[oT: oall](scope: Scope,
            input: oT,
            data: olist[oall],
            U: ArraySlice[DType],
            message: cstring,
            T: DType,
            first_n: int64,
            summarize: int64): Print[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Print(*#, #, #, #, tensorflow::string(#), #, #, #)", constructor.}

proc print*[oT: oall](scope: Scope,
            input: oT,
            data: olist[oall],
            U: openArray[DType],
            message: cstring,
            first_n: int64 = -1.int,
            summarize: int64 = 3.int): Print[oT] =
  return iiprint(scope,
                 input,
                 data,
                 newArraySlice(U),
                 message,
                 oT[].oTF,
                 first_n,
                 summarize)

converter printToOut*[oT: oall](op: Print[oT]): oT {.inline.} = return op.output


type QuantizeAndDequantizeV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeAndDequantizeV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizeAndDequantizeV2[oT: oall](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              signed_input: bool,
                              num_bits: int64,
                              range_given: bool,
                              T: DType,
                              round_mode: cstring): QuantizeAndDequantizeV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeAndDequantizeV2(*#, #, #, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc quantizeAndDequantizeV2*[oT: oall](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              signed_input: bool = true,
                              num_bits: int64 = 8.int,
                              range_given: bool = false,
                              round_mode: cstring = "HALF_TO_EVEN"): QuantizeAndDequantizeV2[oT] =
  return iiquantizeAndDequantizeV2(scope,
                                   input,
                                   input_min,
                                   input_max,
                                   signed_input,
                                   num_bits,
                                   range_given,
                                   oT[].oTF,
                                   round_mode)

converter quantizeAndDequantizeV2ToOut*[oT: oall](op: QuantizeAndDequantizeV2[oT]): oT {.inline.} = return op.output


type FractionalAvgPool*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalAvgPool/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifractionalAvgPool[oT: oall](scope: Scope,
                        value: oT,
                        pooling_ratio: ArraySlice[float32],
                        pseudo_random: bool,
                        overlapping: bool,
                        deterministic: bool,
                        seed: int64,
                        seed2: int64,
                        T: DType): FractionalAvgPool[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalAvgPool(*#, #, #, #, #, #, #, #, #)", constructor.}

proc fractionalAvgPool*[oT: oall](scope: Scope,
                        value: oT,
                        pooling_ratio: openArray[float32],
                        pseudo_random: bool = false,
                        overlapping: bool = false,
                        deterministic: bool = false,
                        seed: int64 = 0.int,
                        seed2: int64 = 0.int): FractionalAvgPool[oT] =
  return iifractionalAvgPool(scope,
                             value,
                             newArraySlice(pooling_ratio),
                             pseudo_random,
                             overlapping,
                             deterministic,
                             seed,
                             seed2,
                             oT[].oTF)

converter fractionalAvgPoolToOut*[oT: oall](op: FractionalAvgPool[oT]): oT {.inline.} = return op.output


type SparseAccumulatorTakeGradient* {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAccumulatorTakeGradient/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iisparseAccumulatorTakeGradient(scope: Scope,
                                    handle: ostring,
                                    num_required: oint32,
                                    dtype: DType): SparseAccumulatorTakeGradient {.header:"../tensorflow/ops/generated.h", importcpp:"SparseAccumulatorTakeGradient(*#, #, #, #)", constructor.}

proc sparseAccumulatorTakeGradient*(scope: Scope,
                                    handle: ostring,
                                    num_required: oint32,
                                    dtype: type(ofloat) | type(odouble) | type(oint32) | type(ouint8) | type(oint16) | type(oint8) | type(ocomplex64) | type(oint64) | type(oqint8) | type(oquint8) | type(oqint32) | type(obfloat16) | type(ouint16) | type(ocomplex128) | type(ohalf) | type(ouint32) | type(ouint64) = oinvalid): SparseAccumulatorTakeGradient =
  return iisparseAccumulatorTakeGradient(scope,
                                         handle,
                                         num_required,
                                         oT[].oTF)

converter sparseAccumulatorTakeGradientToOut*(op: SparseAccumulatorTakeGradient): oint64 {.inline.} = return op.output


type TruncateMod*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TruncateMod/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitruncateMod[oT: oall](scope: Scope,
                  x: oT,
                  y: oT,
                  T: DType): TruncateMod[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TruncateMod(*#, #, #, #)", constructor.}

proc truncateMod*[oT: oall](scope: Scope,
                  x: oT,
                  y: oT): TruncateMod[oT] =
  return iitruncateMod(scope,
                       x,
                       y,
                       oT[].oTF)

converter truncateModToOut*[oT: oall](op: TruncateMod[oT]): oT {.inline.} = return op.output

type ResourceApplyFtrlT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyFtrl*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyFtrl/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyFtrl(scope: Scope,
                        nvar: oresource,
                        accum: oresource,
                        linear: oresource,
                        grad: ResourceApplyFtrlT,
                        lr: ResourceApplyFtrlT,
                        l1: ResourceApplyFtrlT,
                        l2: ResourceApplyFtrlT,
                        lr_power: ResourceApplyFtrlT,
                        use_locking: bool): ResourceApplyFtrl {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyFtrl(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyFtrl*(scope: Scope,
                        nvar: oresource,
                        accum: oresource,
                        linear: oresource,
                        grad: ResourceApplyFtrlT,
                        lr: ResourceApplyFtrlT,
                        l1: ResourceApplyFtrlT,
                        l2: ResourceApplyFtrlT,
                        lr_power: ResourceApplyFtrlT,
                        use_locking: bool = false): ResourceApplyFtrl =
  return iiresourceApplyFtrl(scope,
                             nvar,
                             accum,
                             linear,
                             grad,
                             lr,
                             l1,
                             l2,
                             lr_power,
                             use_locking)



type StridedSliceGradIndex* = oint32 | oint64

type StridedSliceGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StridedSliceGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistridedSliceGrad[oT: oall](scope: Scope,
                       shape: StridedSliceGradIndex,
                       begin: StridedSliceGradIndex,
                       nend: StridedSliceGradIndex,
                       strides: StridedSliceGradIndex,
                       dy: oT,
                       T: DType,
                       shrink_axis_mask: int64,
                       begin_mask: int64,
                       end_mask: int64,
                       ellipsis_mask: int64,
                       new_axis_mask: int64): StridedSliceGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StridedSliceGrad(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc stridedSliceGrad*[oT: oall](scope: Scope,
                       shape: StridedSliceGradIndex,
                       begin: StridedSliceGradIndex,
                       nend: StridedSliceGradIndex,
                       strides: StridedSliceGradIndex,
                       dy: oT,
                       shrink_axis_mask: int64 = 0.int,
                       begin_mask: int64 = 0.int,
                       end_mask: int64 = 0.int,
                       ellipsis_mask: int64 = 0.int,
                       new_axis_mask: int64 = 0.int): StridedSliceGrad[oT] =
  return iistridedSliceGrad(scope,
                            shape,
                            begin,
                            nend,
                            strides,
                            dy,
                            oT[].oTF,
                            shrink_axis_mask,
                            begin_mask,
                            end_mask,
                            ellipsis_mask,
                            new_axis_mask)

converter stridedSliceGradToOut*[oT: oall](op: StridedSliceGrad[oT]): oT {.inline.} = return op.output


type QuantizeAndDequantize*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeAndDequantize/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizeAndDequantize[oT: oall](scope: Scope,
                            input: oT,
                            signed_input: bool,
                            num_bits: int64,
                            range_given: bool,
                            input_min: float32,
                            input_max: float32,
                            T: DType): QuantizeAndDequantize[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizeAndDequantize(*#, #, #, #, #, #, #, #)", constructor.}

proc quantizeAndDequantize*[oT: oall](scope: Scope,
                            input: oT,
                            signed_input: bool = true,
                            num_bits: int64 = 8.int,
                            range_given: bool = false,
                            input_min: float32 = 0.0.float32,
                            input_max: float32 = 0.0.float32): QuantizeAndDequantize[oT] =
  return iiquantizeAndDequantize(scope,
                                 input,
                                 signed_input,
                                 num_bits,
                                 range_given,
                                 input_min,
                                 input_max,
                                 oT[].oTF)

converter quantizeAndDequantizeToOut*[oT: oall](op: QuantizeAndDequantize[oT]): oT {.inline.} = return op.output


type BoostedTreesUpdateEnsemble*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesUpdateEnsemble/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesUpdateEnsemble(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 feature_ids: oint32,
                                 node_ids: oint32,
                                 gains: ofloat,
                                 thresholds: oint32,
                                 left_node_contribs: ofloat,
                                 right_node_contribs: ofloat,
                                 max_depth: oint32,
                                 learning_rate: ofloat,
                                 pruning_mode: int64,
                                 num_features: int64): BoostedTreesUpdateEnsemble {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesUpdateEnsemble(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc boostedTreesUpdateEnsemble*(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 feature_ids: oint32,
                                 node_ids: oint32,
                                 gains: ofloat,
                                 thresholds: oint32,
                                 left_node_contribs: ofloat,
                                 right_node_contribs: ofloat,
                                 max_depth: oint32,
                                 learning_rate: ofloat,
                                 pruning_mode: int64 = 0.int,
                                 num_features: int64 = 0.int): BoostedTreesUpdateEnsemble =
  return iiboostedTreesUpdateEnsemble(scope,
                                      tree_ensemble_handle,
                                      feature_ids,
                                      node_ids,
                                      gains,
                                      thresholds,
                                      left_node_contribs,
                                      right_node_contribs,
                                      max_depth,
                                      learning_rate,
                                      pruning_mode,
                                      num_features)




type Relu6Grad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Relu6Grad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirelu6Grad[oT: oall](scope: Scope,
                gradients: oT,
                features: oT,
                T: DType): Relu6Grad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Relu6Grad(*#, #, #, #)", constructor.}

proc relu6Grad*[oT: oall](scope: Scope,
                gradients: oT,
                features: oT): Relu6Grad[oT] =
  return iirelu6Grad(scope,
                     gradients,
                     features,
                     oT[].oTF)

converter relu6GradToOut*[oT: oall](op: Relu6Grad[oT]): oT {.inline.} = return op.output


type Range*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Range/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirange[oT: oall](scope: Scope,
            start: oT,
            limit: oT,
            delta: oT,
            Tidx: DType): Range[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Range(*#, #, #, #, #)", constructor.}

proc range*[oT: oall](scope: Scope,
            start: oT,
            limit: oT,
            delta: oT): Range[oT] =
  return iirange(scope,
                 start,
                 limit,
                 delta,
                 oT[].oTF)

converter rangeToOut*[oT: oall](op: Range[oT]): oT {.inline.} = return op.output


type PrefetchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"PrefetchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiprefetchDataset(scope: Scope,
                      input_dataset: ovariant,
                      buffer_size: oint64,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape]): PrefetchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"PrefetchDataset(*#, #, #, #, #)", constructor.}

proc prefetchDataset*(scope: Scope,
                      input_dataset: ovariant,
                      buffer_size: oint64,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape]): PrefetchDataset =
  return iiprefetchDataset(scope,
                           input_dataset,
                           buffer_size,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes))

converter prefetchDatasetToOut*(op: PrefetchDataset): ovariant {.inline.} = return op.output


type DeepCopy*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DeepCopy/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iideepCopy[oT: oall](scope: Scope,
               x: oT,
               T: DType): DeepCopy[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DeepCopy(*#, #, #)", constructor.}

proc deepCopy*[oT: oall](scope: Scope,
               x: oT): DeepCopy[oT] =
  return iideepCopy(scope,
                    x,
                    oT[].oTF)

converter deepCopyToOut*[oT: oall](op: DeepCopy[oT]): oT {.inline.} = return op.output


type ExperimentalLatencyStatsDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalLatencyStatsDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalLatencyStatsDataset(scope: Scope,
                                      input_dataset: ovariant,
                                      tag: ostring,
                                      output_types: ArraySlice[DType],
                                      output_shapes: ArraySlice[TensorShape]): ExperimentalLatencyStatsDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalLatencyStatsDataset(*#, #, #, #, #)", constructor.}

proc experimentalLatencyStatsDataset*(scope: Scope,
                                      input_dataset: ovariant,
                                      tag: ostring,
                                      output_types: openArray[DType],
                                      output_shapes: openArray[TensorShape]): ExperimentalLatencyStatsDataset =
  return iiexperimentalLatencyStatsDataset(scope,
                                           input_dataset,
                                           tag,
                                           newArraySlice(output_types),
                                           newArraySlice(output_shapes))

converter experimentalLatencyStatsDatasetToOut*(op: ExperimentalLatencyStatsDataset): ovariant {.inline.} = return op.output


type MultiDeviceIteratorGetNextFromShard*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorGetNextFromShard/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iimultiDeviceIteratorGetNextFromShard[oT: oall](scope: Scope,
                                          multi_device_iterator: oresource,
                                          shard_num: oint32,
                                          incarnation_id: oint64,
                                          output_types: ArraySlice[DType],
                                          output_shapes: ArraySlice[TensorShape],
                                          explicitT: type(oT)): MultiDeviceIteratorGetNextFromShard[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MultiDeviceIteratorGetNextFromShard(*#, #, #, #, #, #)", constructor.}

proc multiDeviceIteratorGetNextFromShard*(scope: Scope,
                                          multi_device_iterator: oresource,
                                          shard_num: oint32,
                                          incarnation_id: oint64,
                                          output_types: openArray[DType],
                                          output_shapes: openArray[TensorShape],
                                          explicitT: type): auto =
  return iimultiDeviceIteratorGetNextFromShard(scope,
                                               multi_device_iterator,
                                               shard_num,
                                               incarnation_id,
                                               newArraySlice(output_types),
                                               newArraySlice(output_shapes),
                                               explicitT)

converter multiDeviceIteratorGetNextFromShardToOutList*[oT: oall](op: MultiDeviceIteratorGetNextFromShard[oT]): olist[oT] {.inline.} = return op.output


type BatchCholesky*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchCholesky/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchCholesky[oT: oall](scope: Scope,
                    input: oT,
                    T: DType): BatchCholesky[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchCholesky(*#, #, #)", constructor.}

proc batchCholesky*[oT: oall](scope: Scope,
                    input: oT): BatchCholesky[oT] =
  return iibatchCholesky(scope,
                         input,
                         oT[].oTF)

converter batchCholeskyToOut*[oT: oall](op: BatchCholesky[oT]): oT {.inline.} = return op.output


type TensorArrayGather*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGather/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorArrayGather[oT: oall](scope: Scope,
                        handle: ostring,
                        indices: oint32,
                        flow_in: ofloat,
                        dtype: DType,
                        element_shape: TensorShape,
                        explicitT: type(oT)): TensorArrayGather[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArrayGather(*#, #, #, #, #, #)", constructor.}

proc tensorArrayGather*(scope: Scope,
                        handle: ostring,
                        indices: oint32,
                        flow_in: ofloat,
                        dtype: type = oinvalid,
                        element_shape: TensorShape = [].shape): auto =
  return iitensorArrayGather(scope,
                             handle,
                             indices,
                             flow_in,
                             dtype[].oTF,
                             element_shape,
                             dtype)

converter tensorArrayGatherToOut*[oT: oall](op: TensorArrayGather[oT]): oT {.inline.} = return op.output


type Round*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Round/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiround[oT: oall](scope: Scope,
            x: oT,
            T: DType): Round[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Round(*#, #, #)", constructor.}

proc round*[oT: oall](scope: Scope,
            x: oT): Round[oT] =
  return iiround(scope,
                 x,
                 oT[].oTF)

converter roundToOut*[oT: oall](op: Round[oT]): oT {.inline.} = return op.output


type ZipDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ZipDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iizipDataset(scope: Scope,
                 input_datasets: olist[ovariant],
                 output_types: ArraySlice[DType],
                 output_shapes: ArraySlice[TensorShape]): ZipDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ZipDataset(*#, #, #, #)", constructor.}

proc zipDataset*(scope: Scope,
                 input_datasets: olist[ovariant],
                 output_types: openArray[DType],
                 output_shapes: openArray[TensorShape]): ZipDataset =
  return iizipDataset(scope,
                      input_datasets,
                      newArraySlice(output_types),
                      newArraySlice(output_shapes))

converter zipDatasetToOut*(op: ZipDataset): ovariant {.inline.} = return op.output


type QueueClose*{.header:"../tensorflow/ops/generated.h", importcpp:"QueueClose/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiqueueClose(scope: Scope,
                 handle: ostring,
                 cancel_pending_enqueues: bool): QueueClose {.header:"../tensorflow/ops/generated.h", importcpp:"QueueClose(*#, #, #)", constructor.}

proc queueClose*(scope: Scope,
                 handle: ostring,
                 cancel_pending_enqueues: bool = false): QueueClose =
  return iiqueueClose(scope,
                      handle,
                      cancel_pending_enqueues)



type SparseTensorDenseAddTindices* = oint32 | oint64

type SparseTensorDenseAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseTensorDenseAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseTensorDenseAdd[oT: oall](scope: Scope,
                           a_indices: SparseTensorDenseAddTindices,
                           a_values: oT,
                           a_shape: SparseTensorDenseAddTindices,
                           b: oT,
                           T: DType): SparseTensorDenseAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseTensorDenseAdd(*#, #, #, #, #, #)", constructor.}

proc sparseTensorDenseAdd*[oT: oall](scope: Scope,
                           a_indices: SparseTensorDenseAddTindices,
                           a_values: oT,
                           a_shape: SparseTensorDenseAddTindices,
                           b: oT): SparseTensorDenseAdd[oT] =
  return iisparseTensorDenseAdd(scope,
                                a_indices,
                                a_values,
                                a_shape,
                                b,
                                oT[].oTF)

converter sparseTensorDenseAddToOut*[oT: oall](op: SparseTensorDenseAdd[oT]): oT {.inline.} = return op.output


type Snapshot*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Snapshot/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisnapshot[oT: oall](scope: Scope,
               input: oT,
               T: DType): Snapshot[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Snapshot(*#, #, #)", constructor.}

proc snapshot*[oT: oall](scope: Scope,
               input: oT): Snapshot[oT] =
  return iisnapshot(scope,
                    input,
                    oT[].oTF)

converter snapshotToOut*[oT: oall](op: Snapshot[oT]): oT {.inline.} = return op.output

type UniqueV2Taxis* = oint32 | oint64

type UniqueV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"UniqueV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiuniqueV2[oT: oall](scope: Scope,
               x: oT,
               axis: UniqueV2Taxis,
               T: DType,
               out_idx: DType): UniqueV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"UniqueV2(*#, #, #, #, #)", constructor.}

proc uniqueV2*[oT: oall](scope: Scope,
               x: oT,
               axis: UniqueV2Taxis,
               out_idx: type(oint32) | type(oint64) = oint32): UniqueV2[oT] =
  return iiuniqueV2(scope,
                    x,
                    axis,
                    oT[].oTF,
                    oT[].oTF)

converter uniqueV2ToOut*[oT: oall](op: UniqueV2[oT]): oT {.inline.} = return op.output


type CudnnRNNBackpropV2*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNBackpropV2/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicudnnRNNBackpropV2[oT: oall](scope: Scope,
                         input: oT,
                         input_h: oT,
                         input_c: oT,
                         params: oT,
                         output: oT,
                         output_h: oT,
                         output_c: oT,
                         output_backprop: oT,
                         output_h_backprop: oT,
                         output_c_backprop: oT,
                         reserve_space: oT,
                         host_reserved: oint8,
                         T: DType,
                         rnn_mode: cstring,
                         input_mode: cstring,
                         direction: cstring,
                         dropout: float32,
                         seed: int64,
                         seed2: int64): CudnnRNNBackpropV2[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CudnnRNNBackpropV2(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNNBackpropV2*[oT: oall](scope: Scope,
                         input: oT,
                         input_h: oT,
                         input_c: oT,
                         params: oT,
                         output: oT,
                         output_h: oT,
                         output_c: oT,
                         output_backprop: oT,
                         output_h_backprop: oT,
                         output_c_backprop: oT,
                         reserve_space: oT,
                         host_reserved: oint8,
                         rnn_mode: cstring = "lstm",
                         input_mode: cstring = "linear_input",
                         direction: cstring = "unidirectional",
                         dropout: float32 = 0.0.float32,
                         seed: int64 = 0.int,
                         seed2: int64 = 0.int): CudnnRNNBackpropV2[oT] =
  return iicudnnRNNBackpropV2(scope,
                              input,
                              input_h,
                              input_c,
                              params,
                              output,
                              output_h,
                              output_c,
                              output_backprop,
                              output_h_backprop,
                              output_c_backprop,
                              reserve_space,
                              host_reserved,
                              oT[].oTF,
                              rnn_mode,
                              input_mode,
                              direction,
                              dropout,
                              seed,
                              seed2)

converter cudnnRNNBackpropV2ToOut*[oT: oall](op: CudnnRNNBackpropV2[oT]): oT {.inline.} = return op.output


type InvertPermutation*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"InvertPermutation/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiinvertPermutation[oT: oall](scope: Scope,
                        x: oT,
                        T: DType): InvertPermutation[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"InvertPermutation(*#, #, #)", constructor.}

proc invertPermutation*[oT: oall](scope: Scope,
                        x: oT): InvertPermutation[oT] =
  return iiinvertPermutation(scope,
                             x,
                             oT[].oTF)

converter invertPermutationToOut*[oT: oall](op: InvertPermutation[oT]): oT {.inline.} = return op.output


type ReaderReset*{.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReset/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iireaderReset(scope: Scope,
                  reader_handle: ostring): ReaderReset {.header:"../tensorflow/ops/generated.h", importcpp:"ReaderReset(*#, #)", constructor.}

proc readerReset*(scope: Scope,
                  reader_handle: ostring): ReaderReset =
  return iireaderReset(scope,
                       reader_handle)




type StopGradient*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StopGradient/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistopGradient[oT: oall](scope: Scope,
                   input: oT,
                   T: DType): StopGradient[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StopGradient(*#, #, #)", constructor.}

proc stopGradient*[oT: oall](scope: Scope,
                   input: oT): StopGradient[oT] =
  return iistopGradient(scope,
                        input,
                        oT[].oTF)

converter stopGradientToOut*[oT: oall](op: StopGradient[oT]): oT {.inline.} = return op.output

type ResourceScatterSubdtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceScatterSubTindices* = oint32 | oint64

type ResourceScatterSub*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterSub/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterSub(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterSubTindices,
                         updates: ResourceScatterSubdtype): ResourceScatterSub {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterSub(*#, #, #, #)", constructor.}

proc resourceScatterSub*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterSubTindices,
                         updates: ResourceScatterSubdtype): ResourceScatterSub =
  return iiresourceScatterSub(scope,
                              resource,
                              indices,
                              updates)




type TensorForestTreeSize* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeSize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iitensorForestTreeSize(scope: Scope,
                           tree_handle: oresource): TensorForestTreeSize {.header:"../tensorflow/ops/generated.h", importcpp:"TensorForestTreeSize(*#, #)", constructor.}

proc tensorForestTreeSize*(scope: Scope,
                           tree_handle: oresource): TensorForestTreeSize =
  return iitensorForestTreeSize(scope,
                                tree_handle)

converter tensorForestTreeSizeToOut*(op: TensorForestTreeSize): oint32 {.inline.} = return op.output


type Rint*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Rint/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iirint[oT: oall](scope: Scope,
           x: oT,
           T: DType): Rint[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Rint(*#, #, #)", constructor.}

proc rint*[oT: oall](scope: Scope,
           x: oT): Rint[oT] =
  return iirint(scope,
                x,
                oT[].oTF)

converter rintToOut*[oT: oall](op: Rint[oT]): oT {.inline.} = return op.output


type Abort*{.header:"../tensorflow/ops/generated.h", importcpp:"Abort/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiabort(scope: Scope,
            error_msg: cstring,
            exit_without_error: bool): Abort {.header:"../tensorflow/ops/generated.h", importcpp:"Abort(*#, tensorflow::string(#), #)", constructor.}

proc abort*(scope: Scope,
            error_msg: cstring,
            exit_without_error: bool = false): Abort =
  return iiabort(scope,
                 error_msg,
                 exit_without_error)




type MutableHashTableOfTensorsV2* {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTableOfTensorsV2/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iimutableHashTableOfTensorsV2(scope: Scope,
                                  container: cstring,
                                  shared_name: cstring,
                                  use_node_name_sharing: bool,
                                  key_dtype: DType,
                                  value_dtype: DType,
                                  value_shape: TensorShape): MutableHashTableOfTensorsV2 {.header:"../tensorflow/ops/generated.h", importcpp:"MutableHashTableOfTensorsV2(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc mutableHashTableOfTensorsV2*(scope: Scope,
                                  container: cstring,
                                  shared_name: cstring,
                                  use_node_name_sharing: bool = false,
                                  key_dtype: type oall = oinvalid,
                                  value_dtype: type oall = oinvalid,
                                  value_shape: TensorShape = [].shape): MutableHashTableOfTensorsV2 =
  return iimutableHashTableOfTensorsV2(scope,
                                       container,
                                       shared_name,
                                       use_node_name_sharing,
                                       oT[].oTF,
                                       oT[].oTF,
                                       value_shape)

converter mutableHashTableOfTensorsV2ToOut*(op: MutableHashTableOfTensorsV2): oresource {.inline.} = return op.output


type TensorListConcatLists* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListConcatLists/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iitensorListConcatLists(scope: Scope,
                            input_a: ovariant,
                            input_b: ovariant,
                            element_dtype: DType): TensorListConcatLists {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListConcatLists(*#, #, #, #)", constructor.}

proc tensorListConcatLists*(scope: Scope,
                            input_a: ovariant,
                            input_b: ovariant,
                            element_dtype: type oall = oinvalid): TensorListConcatLists =
  return iitensorListConcatLists(scope,
                                 input_a,
                                 input_b,
                                 oT[].oTF)

converter tensorListConcatListsToOut*(op: TensorListConcatLists): ovariant {.inline.} = return op.output

type OneHotTI* = ouint8 | oint32 | oint64

type OneHot*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"OneHot/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iioneHot[oT: oall](scope: Scope,
             indices: OneHotTI,
             depth: oint32,
             on_value: oT,
             off_value: oT,
             axis: int64,
             T: DType): OneHot[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"OneHot(*#, #, #, #, #, #, #)", constructor.}

proc oneHot*[oT: oall](scope: Scope,
             indices: OneHotTI,
             depth: oint32,
             on_value: oT,
             off_value: oT,
             axis: int64 = -1.int): OneHot[oT] =
  return iioneHot(scope,
                  indices,
                  depth,
                  on_value,
                  off_value,
                  axis,
                  oT[].oTF)

converter oneHotToOut*[oT: oall](op: OneHot[oT]): oT {.inline.} = return op.output


type Reverse*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Reverse/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iireverse[oT: oall](scope: Scope,
              tensor: oT,
              dims: obool,
              T: DType): Reverse[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Reverse(*#, #, #, #)", constructor.}

proc reverse*[oT: oall](scope: Scope,
              tensor: oT,
              dims: obool): Reverse[oT] =
  return iireverse(scope,
                   tensor,
                   dims,
                   oT[].oTF)

converter reverseToOut*[oT: oall](op: Reverse[oT]): oT {.inline.} = return op.output


type BoostedTreesCreateQuantileStreamResource*{.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCreateQuantileStreamResource/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiboostedTreesCreateQuantileStreamResource(scope: Scope,
                                               quantile_stream_resource_handle: oresource,
                                               epsilon: ofloat,
                                               num_streams: oint64,
                                               max_elements: int64): BoostedTreesCreateQuantileStreamResource {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesCreateQuantileStreamResource(*#, #, #, #, #)", constructor.}

proc boostedTreesCreateQuantileStreamResource*(scope: Scope,
                                               quantile_stream_resource_handle: oresource,
                                               epsilon: ofloat,
                                               num_streams: oint64,
                                               max_elements: int64 = 1099511627776.int): BoostedTreesCreateQuantileStreamResource =
  return iiboostedTreesCreateQuantileStreamResource(scope,
                                                    quantile_stream_resource_handle,
                                                    epsilon,
                                                    num_streams,
                                                    max_elements)




type ParseSingleExample* {.header:"../tensorflow/ops/generated.h", importcpp:"ParseSingleExample/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iiparseSingleExample(scope: Scope,
                         serialized: ostring,
                         dense_defaults: olist[oall],
                         sparse_keys: ArraySlice[cstring],
                         dense_keys: ArraySlice[cstring],
                         sparse_types: ArraySlice[DType],
                         Tdense: ArraySlice[DType],
                         dense_shapes: ArraySlice[TensorShape],
                         num_sparse: int64): ParseSingleExample {.header:"../tensorflow/ops/generated.h", importcpp:"ParseSingleExample(*#, #, #, #, #, #, #, #, #)", constructor.}

proc parseSingleExample*(scope: Scope,
                         serialized: ostring,
                         dense_defaults: olist[oall],
                         sparse_keys: openArray[cstring],
                         dense_keys: openArray[cstring],
                         sparse_types: openArray[DType],
                         Tdense: openArray[DType],
                         dense_shapes: openArray[TensorShape],
                         num_sparse: int64 = 0.int): ParseSingleExample =
  return iiparseSingleExample(scope,
                              serialized,
                              dense_defaults,
                              newArraySlice(sparse_keys),
                              newArraySlice(dense_keys),
                              newArraySlice(sparse_types),
                              newArraySlice(Tdense),
                              newArraySlice(dense_shapes),
                              num_sparse)

converter parseSingleExampleToOut*(op: ParseSingleExample): oint64 {.inline.} = return op.output


type GuaranteeConst*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"GuaranteeConst/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiguaranteeConst[oT: oall](scope: Scope,
                     input: oT,
                     T: DType): GuaranteeConst[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"GuaranteeConst(*#, #, #)", constructor.}

proc guaranteeConst*[oT: oall](scope: Scope,
                     input: oT): GuaranteeConst[oT] =
  return iiguaranteeConst(scope,
                          input,
                          oT[].oTF)

converter guaranteeConstToOut*[oT: oall](op: GuaranteeConst[oT]): oT {.inline.} = return op.output


type QueueEnqueueV2*{.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueueV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiqueueEnqueueV2(scope: Scope,
                     handle: oresource,
                     components: olist[oall],
                     Tcomponents: ArraySlice[DType],
                     timeout_ms: int64): QueueEnqueueV2 {.header:"../tensorflow/ops/generated.h", importcpp:"QueueEnqueueV2(*#, #, #, #, #)", constructor.}

proc queueEnqueueV2*(scope: Scope,
                     handle: oresource,
                     components: olist[oall],
                     Tcomponents: openArray[DType],
                     timeout_ms: int64 = -1.int): QueueEnqueueV2 =
  return iiqueueEnqueueV2(scope,
                          handle,
                          components,
                          newArraySlice(Tcomponents),
                          timeout_ms)




type IScopedAllocatorConcat*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_ScopedAllocatorConcat/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiScopedAllocatorConcat[oT: oall](scope: Scope,
                             backing: oT,
                             inputs: olist[oT],
                             sa_name: cstring,
                             shape: TensorShape,
                             T: DType,
                             reshape: bool,
                             id: int64): IScopedAllocatorConcat[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_ScopedAllocatorConcat(*#, #, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc iScopedAllocatorConcat*[oT: oall](scope: Scope,
                             backing: oT,
                             inputs: olist[oT],
                             sa_name: cstring,
                             shape: TensorShape = [].shape,
                             reshape: bool = false,
                             id: int64 = 0.int): IScopedAllocatorConcat[oT] =
  return iiiScopedAllocatorConcat(scope,
                                  backing,
                                  inputs,
                                  sa_name,
                                  shape,
                                  oT[].oTF,
                                  reshape,
                                  id)

converter iScopedAllocatorConcatToOut*[oT: oall](op: IScopedAllocatorConcat[oT]): oT {.inline.} = return op.output


type BoostedTreesQuantileStreamResourceHandleOp* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceHandleOp/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiboostedTreesQuantileStreamResourceHandleOp(scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring): BoostedTreesQuantileStreamResourceHandleOp {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesQuantileStreamResourceHandleOp(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc boostedTreesQuantileStreamResourceHandleOp*(scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring): BoostedTreesQuantileStreamResourceHandleOp =
  return iiboostedTreesQuantileStreamResourceHandleOp(scope,
                                                      container,
                                                      shared_name)

converter boostedTreesQuantileStreamResourceHandleOpToOut*(op: BoostedTreesQuantileStreamResourceHandleOp): oresource {.inline.} = return op.output

type StatelessTruncatedNormalT* = oint32 | oint64
type StatelessTruncatedNormalTseed* = oint32 | oint64

type StatelessTruncatedNormal*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessTruncatedNormal/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistatelessTruncatedNormal[oT: oall](scope: Scope,
                               shape: StatelessTruncatedNormalT,
                               seed: StatelessTruncatedNormalTseed,
                               dtype: DType,
                               explicitT: type(oT)): StatelessTruncatedNormal[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StatelessTruncatedNormal(*#, #, #, #)", constructor.}

proc statelessTruncatedNormal*(scope: Scope,
                               shape: StatelessTruncatedNormalT,
                               seed: StatelessTruncatedNormalTseed,
                               dtype: type = ofloat): auto =
  return iistatelessTruncatedNormal(scope,
                                    shape,
                                    seed,
                                    dtype[].oTF,
                                    dtype)

converter statelessTruncatedNormalToOut*[oT: oall](op: StatelessTruncatedNormal[oT]): oT {.inline.} = return op.output


type MatrixDiag*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixDiag/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixDiag[oT: oall](scope: Scope,
                 diagonal: oT,
                 T: DType): MatrixDiag[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixDiag(*#, #, #)", constructor.}

proc matrixDiag*[oT: oall](scope: Scope,
                 diagonal: oT): MatrixDiag[oT] =
  return iimatrixDiag(scope,
                      diagonal,
                      oT[].oTF)

converter matrixDiagToOut*[oT: oall](op: MatrixDiag[oT]): oT {.inline.} = return op.output

type TensorScatterSubTindices* = oint32 | oint64

type TensorScatterSub*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorScatterSub/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorScatterSub[oT: oall](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterSubTindices,
                       updates: oT,
                       T: DType): TensorScatterSub[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorScatterSub(*#, #, #, #, #)", constructor.}

proc tensorScatterSub*[oT: oall](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterSubTindices,
                       updates: oT): TensorScatterSub[oT] =
  return iitensorScatterSub(scope,
                            tensor,
                            indices,
                            updates,
                            oT[].oTF)

converter tensorScatterSubToOut*[oT: oall](op: TensorScatterSub[oT]): oT {.inline.} = return op.output


type FloorDiv*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FloorDiv/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifloorDiv[oT: oall](scope: Scope,
               x: oT,
               y: oT,
               T: DType): FloorDiv[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FloorDiv(*#, #, #, #)", constructor.}

proc floorDiv*[oT: oall](scope: Scope,
               x: oT,
               y: oT): FloorDiv[oT] =
  return iifloorDiv(scope,
                    x,
                    y,
                    oT[].oTF)

converter floorDivToOut*[oT: oall](op: FloorDiv[oT]): oT {.inline.} = return op.output

type StridedSliceIndex* = oint32 | oint64

type StridedSlice*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"StridedSlice/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iistridedSlice[oT: oall](scope: Scope,
                   input: oT,
                   begin: StridedSliceIndex,
                   nend: StridedSliceIndex,
                   strides: StridedSliceIndex,
                   T: DType,
                   shrink_axis_mask: int64,
                   begin_mask: int64,
                   end_mask: int64,
                   ellipsis_mask: int64,
                   new_axis_mask: int64): StridedSlice[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"StridedSlice(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc stridedSlice*[oT: oall](scope: Scope,
                   input: oT,
                   begin: StridedSliceIndex,
                   nend: StridedSliceIndex,
                   strides: StridedSliceIndex,
                   shrink_axis_mask: int64 = 0.int,
                   begin_mask: int64 = 0.int,
                   end_mask: int64 = 0.int,
                   ellipsis_mask: int64 = 0.int,
                   new_axis_mask: int64 = 0.int): StridedSlice[oT] =
  return iistridedSlice(scope,
                        input,
                        begin,
                        nend,
                        strides,
                        oT[].oTF,
                        shrink_axis_mask,
                        begin_mask,
                        end_mask,
                        ellipsis_mask,
                        new_axis_mask)

converter stridedSliceToOut*[oT: oall](op: StridedSlice[oT]): oT {.inline.} = return op.output


type PreventGradient*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"PreventGradient/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iipreventGradient[oT: oall](scope: Scope,
                      input: oT,
                      message: cstring,
                      T: DType): PreventGradient[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"PreventGradient(*#, #, tensorflow::string(#), #)", constructor.}

proc preventGradient*[oT: oall](scope: Scope,
                      input: oT,
                      message: cstring): PreventGradient[oT] =
  return iipreventGradient(scope,
                           input,
                           message,
                           oT[].oTF)

converter preventGradientToOut*[oT: oall](op: PreventGradient[oT]): oT {.inline.} = return op.output


type SparseDenseCwiseMul*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseDenseCwiseMul/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisparseDenseCwiseMul[oT: oall](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT,
                          T: DType): SparseDenseCwiseMul[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SparseDenseCwiseMul(*#, #, #, #, #, #)", constructor.}

proc sparseDenseCwiseMul*[oT: oall](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseMul[oT] =
  return iisparseDenseCwiseMul(scope,
                               sp_indices,
                               sp_values,
                               sp_shape,
                               dense,
                               oT[].oTF)

converter sparseDenseCwiseMulToOut*[oT: oall](op: SparseDenseCwiseMul[oT]): oT {.inline.} = return op.output


type FusedPadConv2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedPadConv2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifusedPadConv2D[oT: oall](scope: Scope,
                     input: oT,
                     paddings: oint32,
                     filter: oT,
                     mode: cstring,
                     strides: ArraySlice[int],
                     padding: cstring,
                     T: DType): FusedPadConv2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FusedPadConv2D(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc fusedPadConv2D*[oT: oall](scope: Scope,
                     input: oT,
                     paddings: oint32,
                     filter: oT,
                     mode: cstring,
                     strides: openArray[int],
                     padding: cstring): FusedPadConv2D[oT] =
  return iifusedPadConv2D(scope,
                          input,
                          paddings,
                          filter,
                          mode,
                          newArraySlice(strides),
                          padding,
                          oT[].oTF)

converter fusedPadConv2DToOut*[oT: oall](op: FusedPadConv2D[oT]): oT {.inline.} = return op.output

type LookupTableInsertV2Tout* = oall
type LookupTableInsertV2Tin* = oall

type LookupTableInsertV2*{.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableInsertV2/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iilookupTableInsertV2(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableInsertV2Tin,
                          values: LookupTableInsertV2Tout): LookupTableInsertV2 {.header:"../tensorflow/ops/generated.h", importcpp:"LookupTableInsertV2(*#, #, #, #)", constructor.}

proc lookupTableInsertV2*(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableInsertV2Tin,
                          values: LookupTableInsertV2Tout): LookupTableInsertV2 =
  return iilookupTableInsertV2(scope,
                               table_handle,
                               keys,
                               values)



type BarrierInsertManyT* = oall

type BarrierInsertMany*{.header:"../tensorflow/ops/generated.h", importcpp:"BarrierInsertMany/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iibarrierInsertMany(scope: Scope,
                        handle: ostring,
                        keys: ostring,
                        values: BarrierInsertManyT,
                        component_index: int64): BarrierInsertMany {.header:"../tensorflow/ops/generated.h", importcpp:"BarrierInsertMany(*#, #, #, #, #)", constructor.}

proc barrierInsertMany*(scope: Scope,
                        handle: ostring,
                        keys: ostring,
                        values: BarrierInsertManyT,
                        component_index: int64 = 0.int): BarrierInsertMany =
  return iibarrierInsertMany(scope,
                             handle,
                             keys,
                             values,
                             component_index)



type SplitVTlen* = oint32 | oint64

type SplitV*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SplitV/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisplitV[oT: oall](scope: Scope,
             value: oT,
             size_splits: SplitVTlen,
             split_dim: oint32,
             num_split: int64,
             T: DType): SplitV[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SplitV(*#, #, #, #, #, #)", constructor.}

proc splitV*[oT: oall](scope: Scope,
             value: oT,
             size_splits: SplitVTlen,
             split_dim: oint32,
             num_split: int64 = 0.int): SplitV[oT] =
  return iisplitV(scope,
                  value,
                  size_splits,
                  split_dim,
                  num_split,
                  oT[].oTF)

converter splitVToOut*[oT: oall](op: SplitV[oT]): oT {.inline.} = return op.output


type BatchMatrixDiag*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixDiag/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibatchMatrixDiag[oT: oall](scope: Scope,
                      diagonal: oT,
                      T: DType): BatchMatrixDiag[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BatchMatrixDiag(*#, #, #)", constructor.}

proc batchMatrixDiag*[oT: oall](scope: Scope,
                      diagonal: oT): BatchMatrixDiag[oT] =
  return iibatchMatrixDiag(scope,
                           diagonal,
                           oT[].oTF)

converter batchMatrixDiagToOut*[oT: oall](op: BatchMatrixDiag[oT]): oT {.inline.} = return op.output

type BucketizeT* = oint32 | oint64 | ofloat | odouble

type Bucketize* {.header:"../tensorflow/ops/generated.h", importcpp:"Bucketize/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iibucketize(scope: Scope,
                input: BucketizeT,
                boundaries: ArraySlice[float32]): Bucketize {.header:"../tensorflow/ops/generated.h", importcpp:"Bucketize(*#, #, #)", constructor.}

proc bucketize*(scope: Scope,
                input: BucketizeT,
                boundaries: openArray[float32]): Bucketize =
  return iibucketize(scope,
                     input,
                     newArraySlice(boundaries))

converter bucketizeToOut*(op: Bucketize): oint32 {.inline.} = return op.output


type DrawBoundingBoxes*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DrawBoundingBoxes/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidrawBoundingBoxes[oT: oall](scope: Scope,
                        images: oT,
                        boxes: ofloat,
                        T: DType): DrawBoundingBoxes[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DrawBoundingBoxes(*#, #, #, #)", constructor.}

proc drawBoundingBoxes*[oT: oall](scope: Scope,
                        images: oT,
                        boxes: ofloat): DrawBoundingBoxes[oT] =
  return iidrawBoundingBoxes(scope,
                             images,
                             boxes,
                             oT[].oTF)

converter drawBoundingBoxesToOut*[oT: oall](op: DrawBoundingBoxes[oT]): oT {.inline.} = return op.output


type ZerosLike*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ZerosLike/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iizerosLike[oT: oall](scope: Scope,
                x: oT,
                T: DType): ZerosLike[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ZerosLike(*#, #, #)", constructor.}

proc zerosLike*[oT: oall](scope: Scope,
                x: oT): ZerosLike[oT] =
  return iizerosLike(scope,
                     x,
                     oT[].oTF)

converter zerosLikeToOut*[oT: oall](op: ZerosLike[oT]): oT {.inline.} = return op.output

type ImageSummaryT* = ouint8 | ofloat | ohalf | odouble

type ImageSummary* {.header:"../tensorflow/ops/generated.h", importcpp:"ImageSummary/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiimageSummary(scope: Scope,
                   tag: ostring,
                   tensor: ImageSummaryT,
                   max_images: int64,
                   bad_color: Tensor[oall]): ImageSummary {.header:"../tensorflow/ops/generated.h", importcpp:"ImageSummary(*#, #, #, #, *#)", constructor.}

proc imageSummary*(scope: Scope,
                   tag: ostring,
                   tensor: ImageSummaryT,
                   max_images: int64 = 3.int,
                   bad_color: Tensor[oall] = tensor([255, 0, 0, 255], uint8)): ImageSummary =
  return iiimageSummary(scope,
                        tag,
                        tensor,
                        max_images,
                        bad_color)

converter imageSummaryToOut*(op: ImageSummary): ostring {.inline.} = return op.output

type ShapeNT* = oall

type ShapeN*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ShapeN/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iishapeN[oT: oall](scope: Scope,
             input: olist[ShapeNT],
             out_type: DType,
             explicitT: type(oT)): ShapeN[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ShapeN(*#, #, #)", constructor.}

proc shapeN*(scope: Scope,
             input: olist[ShapeNT],
             out_type: type = oint32): auto =
  return iishapeN(scope,
                  input,
                  out_type[].oTF,
                  out_type)

converter shapeNToOutList*[oT: oall](op: ShapeN[oT]): olist[oT] {.inline.} = return op.output


type HostConst*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"HostConst/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iihostConst[oT: oall](scope: Scope,
                value: Tensor[oT],
                dtype: DType): HostConst[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"HostConst(*#, *#, #)", constructor.}

proc hostConst*[oT: oall](scope: Scope,
                value: Tensor[oT]): HostConst[oT] =
  return iihostConst(scope,
                     value,
                     oT[].oTF)

converter hostConstToOut*[oT: oall](op: HostConst[oT]): oT {.inline.} = return op.output


type Empty*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Empty/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiempty[oT: oall](scope: Scope,
            shape: oint32,
            dtype: DType,
            init: bool,
            explicitT: type(oT)): Empty[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Empty(*#, #, #, #)", constructor.}

proc empty*(scope: Scope,
            shape: oint32,
            dtype: type = oinvalid,
            init: bool = false): auto =
  return iiempty(scope,
                 shape,
                 dtype[].oTF,
                 init,
                 dtype)

converter emptyToOut*[oT: oall](op: Empty[oT]): oT {.inline.} = return op.output


type Split*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Split/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisplit[oT: oall](scope: Scope,
            split_dim: oint32,
            value: oT,
            num_split: int64,
            T: DType): Split[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Split(*#, #, #, #, #)", constructor.}

proc split*[oT: oall](scope: Scope,
            split_dim: oint32,
            value: oT,
            num_split: int64 = 0.int): Split[oT] =
  return iisplit(scope,
                 split_dim,
                 value,
                 num_split,
                 oT[].oTF)

converter splitToOut*[oT: oall](op: Split[oT]): oT {.inline.} = return op.output


type Conv3DBackpropInput*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropInput/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconv3DBackpropInput[oT: oall](scope: Scope,
                          input: oT,
                          filter: oT,
                          out_backprop: oT,
                          strides: ArraySlice[int],
                          padding: cstring,
                          T: DType,
                          dilations: ArraySlice[int]): Conv3DBackpropInput[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Conv3DBackpropInput(*#, #, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc conv3DBackpropInput*[oT: oall](scope: Scope,
                          input: oT,
                          filter: oT,
                          out_backprop: oT,
                          strides: openArray[int],
                          padding: cstring,
                          dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int, 1.int]): Conv3DBackpropInput[oT] =
  return iiconv3DBackpropInput(scope,
                               input,
                               filter,
                               out_backprop,
                               newArraySlice(strides),
                               padding,
                               oT[].oTF,
                               newArraySlice(dilations))

converter conv3DBackpropInputToOut*[oT: oall](op: Conv3DBackpropInput[oT]): oT {.inline.} = return op.output


type DepthwiseConv2dNative*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthwiseConv2dNative/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidepthwiseConv2dNative[oT: oall](scope: Scope,
                            input: oT,
                            filter: oT,
                            strides: ArraySlice[int],
                            padding: cstring,
                            T: DType,
                            data_format: cstring,
                            dilations: ArraySlice[int]): DepthwiseConv2dNative[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DepthwiseConv2dNative(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc depthwiseConv2dNative*[oT: oall](scope: Scope,
                            input: oT,
                            filter: oT,
                            strides: openArray[int],
                            padding: cstring,
                            data_format: cstring = "NHWC",
                            dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int]): DepthwiseConv2dNative[oT] =
  return iidepthwiseConv2dNative(scope,
                                 input,
                                 filter,
                                 newArraySlice(strides),
                                 padding,
                                 oT[].oTF,
                                 data_format,
                                 newArraySlice(dilations))

converter depthwiseConv2dNativeToOut*[oT: oall](op: DepthwiseConv2dNative[oT]): oT {.inline.} = return op.output


type LearnedUnigramCandidateSampler* {.header:"../tensorflow/ops/generated.h", importcpp:"LearnedUnigramCandidateSampler/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iilearnedUnigramCandidateSampler(scope: Scope,
                                     true_classes: oint64,
                                     num_true: int64,
                                     num_sampled: int64,
                                     unique: bool,
                                     range_max: int64,
                                     seed: int64,
                                     seed2: int64): LearnedUnigramCandidateSampler {.header:"../tensorflow/ops/generated.h", importcpp:"LearnedUnigramCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc learnedUnigramCandidateSampler*(scope: Scope,
                                     true_classes: oint64,
                                     num_true: int64 = 0.int,
                                     num_sampled: int64 = 0.int,
                                     unique: bool = false,
                                     range_max: int64 = 0.int,
                                     seed: int64 = 0.int,
                                     seed2: int64 = 0.int): LearnedUnigramCandidateSampler =
  return iilearnedUnigramCandidateSampler(scope,
                                          true_classes,
                                          num_true,
                                          num_sampled,
                                          unique,
                                          range_max,
                                          seed,
                                          seed2)

converter learnedUnigramCandidateSamplerToOut*(op: LearnedUnigramCandidateSampler): oint64 {.inline.} = return op.output

type DebugNanCountT* = oall

type DebugNanCount* {.header:"../tensorflow/ops/generated.h", importcpp:"DebugNanCount/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iidebugNanCount(scope: Scope,
                    input: DebugNanCountT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: ArraySlice[cstring],
                    gated_grpc: bool): DebugNanCount {.header:"../tensorflow/ops/generated.h", importcpp:"DebugNanCount(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc debugNanCount*(scope: Scope,
                    input: DebugNanCountT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: openArray[cstring],
                    gated_grpc: bool = false): DebugNanCount =
  return iidebugNanCount(scope,
                         input,
                         device_name,
                         tensor_name,
                         newArraySlice(debug_urls),
                         gated_grpc)

converter debugNanCountToOut*(op: DebugNanCount): oint64 {.inline.} = return op.output


type UnicodeScript* {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeScript/*'0*/".} = object
  operation*: Operation[oint32]
  output*: oint32

proc iiunicodeScript(scope: Scope,
                    input: oint32): UnicodeScript {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeScript(*#, #)", constructor.}

proc unicodeScript*(scope: Scope,
                    input: oint32): UnicodeScript =
  return iiunicodeScript(scope,
                         input)

converter unicodeScriptToOut*(op: UnicodeScript): oint32 {.inline.} = return op.output


type OptionalGetValue*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalGetValue/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iioptionalGetValue[oT: oall](scope: Scope,
                       optional: ovariant,
                       output_types: ArraySlice[DType],
                       output_shapes: ArraySlice[TensorShape],
                       explicitT: type(oT)): OptionalGetValue[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalGetValue(*#, #, #, #)", constructor.}

proc optionalGetValue*(scope: Scope,
                       optional: ovariant,
                       output_types: openArray[DType],
                       output_shapes: openArray[TensorShape],
                       explicitT: type): auto =
  return iioptionalGetValue(scope,
                            optional,
                            newArraySlice(output_types),
                            newArraySlice(output_shapes),
                            explicitT)

converter optionalGetValueToOutList*[oT: oall](op: OptionalGetValue[oT]): olist[oT] {.inline.} = return op.output


type TensorListGetItem*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListGetItem/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorListGetItem[oT: oall](scope: Scope,
                        input_handle: ovariant,
                        index: oint32,
                        element_dtype: DType,
                        explicitT: type(oT)): TensorListGetItem[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorListGetItem(*#, #, #, #)", constructor.}

proc tensorListGetItem*(scope: Scope,
                        input_handle: ovariant,
                        index: oint32,
                        element_dtype: type = oinvalid): auto =
  return iitensorListGetItem(scope,
                             input_handle,
                             index,
                             element_dtype[].oTF,
                             element_dtype)

converter tensorListGetItemToOut*[oT: oall](op: TensorListGetItem[oT]): oT {.inline.} = return op.output


type Diag*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Diag/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidiag[oT: oall](scope: Scope,
           diagonal: oT,
           T: DType): Diag[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Diag(*#, #, #)", constructor.}

proc diag*[oT: oall](scope: Scope,
           diagonal: oT): Diag[oT] =
  return iidiag(scope,
                diagonal,
                oT[].oTF)

converter diagToOut*[oT: oall](op: Diag[oT]): oT {.inline.} = return op.output


type OneShotIterator* {.header:"../tensorflow/ops/generated.h", importcpp:"OneShotIterator/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iioneShotIterator(scope: Scope,
                      dataset_factory: NameAttrList,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape],
                      container: cstring,
                      shared_name: cstring): OneShotIterator {.header:"../tensorflow/ops/generated.h", importcpp:"OneShotIterator(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc oneShotIterator*(scope: Scope,
                      dataset_factory: NameAttrList,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape],
                      container: cstring,
                      shared_name: cstring): OneShotIterator =
  return iioneShotIterator(scope,
                           dataset_factory,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes),
                           container,
                           shared_name)

converter oneShotIteratorToOut*(op: OneShotIterator): oresource {.inline.} = return op.output

type ResourceApplyPowerSignT* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyPowerSign*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyPowerSign/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceApplyPowerSign(scope: Scope,
                             nvar: oresource,
                             m: oresource,
                             lr: ResourceApplyPowerSignT,
                             logbase: ResourceApplyPowerSignT,
                             sign_decay: ResourceApplyPowerSignT,
                             beta: ResourceApplyPowerSignT,
                             grad: ResourceApplyPowerSignT,
                             use_locking: bool): ResourceApplyPowerSign {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceApplyPowerSign(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyPowerSign*(scope: Scope,
                             nvar: oresource,
                             m: oresource,
                             lr: ResourceApplyPowerSignT,
                             logbase: ResourceApplyPowerSignT,
                             sign_decay: ResourceApplyPowerSignT,
                             beta: ResourceApplyPowerSignT,
                             grad: ResourceApplyPowerSignT,
                             use_locking: bool = false): ResourceApplyPowerSign =
  return iiresourceApplyPowerSign(scope,
                                  nvar,
                                  m,
                                  lr,
                                  logbase,
                                  sign_decay,
                                  beta,
                                  grad,
                                  use_locking)




type Concat*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Concat/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiconcat[oT: oall](scope: Scope,
             concat_dim: oint32,
             values: olist[oT],
             T: DType): Concat[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Concat(*#, #, #, #)", constructor.}

proc concat*[oT: oall](scope: Scope,
             concat_dim: oint32,
             values: olist[oT]): Concat[oT] =
  return iiconcat(scope,
                  concat_dim,
                  values,
                  oT[].oTF)

converter concatToOut*[oT: oall](op: Concat[oT]): oT {.inline.} = return op.output


type TextLineReader* {.header:"../tensorflow/ops/generated.h", importcpp:"TextLineReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iitextLineReader(scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     skip_header_lines: int64): TextLineReader {.header:"../tensorflow/ops/generated.h", importcpp:"TextLineReader(*#, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc textLineReader*(scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     skip_header_lines: int64 = 0.int): TextLineReader =
  return iitextLineReader(scope,
                          container,
                          shared_name,
                          skip_header_lines)

converter textLineReaderToOut*(op: TextLineReader): ostring {.inline.} = return op.output


type RecordInput* {.header:"../tensorflow/ops/generated.h", importcpp:"RecordInput/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iirecordInput(scope: Scope,
                  file_pattern: cstring,
                  compression_type: cstring,
                  file_random_seed: int64,
                  file_shuffle_shift_ratio: float32,
                  file_buffer_size: int64,
                  file_parallelism: int64,
                  batch_size: int64): RecordInput {.header:"../tensorflow/ops/generated.h", importcpp:"RecordInput(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc recordInput*(scope: Scope,
                  file_pattern: cstring,
                  compression_type: cstring,
                  file_random_seed: int64 = 301.int,
                  file_shuffle_shift_ratio: float32 = 0.0.float32,
                  file_buffer_size: int64 = 10000.int,
                  file_parallelism: int64 = 16.int,
                  batch_size: int64 = 32.int): RecordInput =
  return iirecordInput(scope,
                       file_pattern,
                       compression_type,
                       file_random_seed,
                       file_shuffle_shift_ratio,
                       file_buffer_size,
                       file_parallelism,
                       batch_size)

converter recordInputToOut*(op: RecordInput): ostring {.inline.} = return op.output


type ApplyAddSign*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAddSign/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiapplyAddSign[oT: oall](scope: Scope,
                   nvar: oT,
                   m: oT,
                   lr: oT,
                   alpha: oT,
                   sign_decay: oT,
                   beta: oT,
                   grad: oT,
                   T: DType,
                   use_locking: bool): ApplyAddSign[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"ApplyAddSign(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAddSign*[oT: oall](scope: Scope,
                   nvar: oT,
                   m: oT,
                   lr: oT,
                   alpha: oT,
                   sign_decay: oT,
                   beta: oT,
                   grad: oT,
                   use_locking: bool = false): ApplyAddSign[oT] =
  return iiapplyAddSign(scope,
                        nvar,
                        m,
                        lr,
                        alpha,
                        sign_decay,
                        beta,
                        grad,
                        oT[].oTF,
                        use_locking)

converter applyAddSignToOut*[oT: oall](op: ApplyAddSign[oT]): oT {.inline.} = return op.output


type BitwiseAnd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BitwiseAnd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibitwiseAnd[oT: oall](scope: Scope,
                 x: oT,
                 y: oT,
                 T: DType): BitwiseAnd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BitwiseAnd(*#, #, #, #)", constructor.}

proc bitwiseAnd*[oT: oall](scope: Scope,
                 x: oT,
                 y: oT): BitwiseAnd[oT] =
  return iibitwiseAnd(scope,
                      x,
                      y,
                      oT[].oTF)

converter bitwiseAndToOut*[oT: oall](op: BitwiseAnd[oT]): oT {.inline.} = return op.output


type MatrixSetDiag*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSetDiag/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimatrixSetDiag[oT: oall](scope: Scope,
                    input: oT,
                    diagonal: oT,
                    T: DType): MatrixSetDiag[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MatrixSetDiag(*#, #, #, #)", constructor.}

proc matrixSetDiag*[oT: oall](scope: Scope,
                    input: oT,
                    diagonal: oT): MatrixSetDiag[oT] =
  return iimatrixSetDiag(scope,
                         input,
                         diagonal,
                         oT[].oTF)

converter matrixSetDiagToOut*[oT: oall](op: MatrixSetDiag[oT]): oT {.inline.} = return op.output


type IFusedConv2D*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"_FusedConv2D/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiiFusedConv2D[oT: oall](scope: Scope,
                   input: oT,
                   filter: oT,
                   args: oT,
                   strides: ArraySlice[int],
                   padding: cstring,
                   fused_ops: ArraySlice[cstring],
                   T: DType,
                   num_args: int64,
                   data_format: cstring,
                   dilations: ArraySlice[int],
                   epsilon: float32): IFusedConv2D[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"_FusedConv2D(*#, #, #, #, #, tensorflow::string(#), #, #, #, tensorflow::string(#), #, #)", constructor.}

proc iFusedConv2D*[oT: oall](scope: Scope,
                   input: oT,
                   filter: oT,
                   args: oT,
                   strides: openArray[int],
                   padding: cstring,
                   fused_ops: openArray[cstring],
                   num_args: int64 = 0.int,
                   data_format: cstring = "NHWC",
                   dilations: openArray[int] = [1.int, 1.int, 1.int, 1.int],
                   epsilon: float32 = 9.999999747378752e-05.float32): IFusedConv2D[oT] =
  return iiiFusedConv2D(scope,
                        input,
                        filter,
                        args,
                        newArraySlice(strides),
                        padding,
                        newArraySlice(fused_ops),
                        oT[].oTF,
                        num_args,
                        data_format,
                        newArraySlice(dilations),
                        epsilon)

converter iFusedConv2DToOut*[oT: oall](op: IFusedConv2D[oT]): oT {.inline.} = return op.output


type BatchFFT3D* {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFFT3D/*'0*/".} = object
  operation*: Operation[ocomplex64]
  output*: ocomplex64

proc iibatchFFT3D(scope: Scope,
                 input: ocomplex64): BatchFFT3D {.header:"../tensorflow/ops/generated.h", importcpp:"BatchFFT3D(*#, #)", constructor.}

proc batchFFT3D*(scope: Scope,
                 input: ocomplex64): BatchFFT3D =
  return iibatchFFT3D(scope,
                      input)

converter batchFFT3DToOut*(op: BatchFFT3D): ocomplex64 {.inline.} = return op.output


type AdjustHue* {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustHue/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiadjustHue(scope: Scope,
                images: ofloat,
                delta: ofloat): AdjustHue {.header:"../tensorflow/ops/generated.h", importcpp:"AdjustHue(*#, #, #)", constructor.}

proc adjustHue*(scope: Scope,
                images: ofloat,
                delta: ofloat): AdjustHue =
  return iiadjustHue(scope,
                     images,
                     delta)

converter adjustHueToOut*(op: AdjustHue): ofloat {.inline.} = return op.output

type SpaceToBatchNDTblock_shape* = oint32 | oint64
type SpaceToBatchNDTpaddings* = oint32 | oint64

type SpaceToBatchND*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SpaceToBatchND/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iispaceToBatchND[oT: oall](scope: Scope,
                     input: oT,
                     block_shape: SpaceToBatchNDTblock_shape,
                     paddings: SpaceToBatchNDTpaddings,
                     T: DType): SpaceToBatchND[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SpaceToBatchND(*#, #, #, #, #)", constructor.}

proc spaceToBatchND*[oT: oall](scope: Scope,
                     input: oT,
                     block_shape: SpaceToBatchNDTblock_shape,
                     paddings: SpaceToBatchNDTpaddings): SpaceToBatchND[oT] =
  return iispaceToBatchND(scope,
                          input,
                          block_shape,
                          paddings,
                          oT[].oTF)

converter spaceToBatchNDToOut*[oT: oall](op: SpaceToBatchND[oT]): oT {.inline.} = return op.output


type QuantizedMaxPool*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedMaxPool/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiquantizedMaxPool[oT: oall](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: ArraySlice[int],
                       strides: ArraySlice[int],
                       padding: cstring,
                       T: DType): QuantizedMaxPool[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"QuantizedMaxPool(*#, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc quantizedMaxPool*[oT: oall](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: openArray[int],
                       strides: openArray[int],
                       padding: cstring): QuantizedMaxPool[oT] =
  return iiquantizedMaxPool(scope,
                            input,
                            min_input,
                            max_input,
                            newArraySlice(ksize),
                            newArraySlice(strides),
                            padding,
                            oT[].oTF)

converter quantizedMaxPoolToOut*[oT: oall](op: QuantizedMaxPool[oT]): oT {.inline.} = return op.output

type MirrorPadGradTpaddings* = oint32 | oint64

type MirrorPadGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"MirrorPadGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iimirrorPadGrad[oT: oall](scope: Scope,
                    input: oT,
                    paddings: MirrorPadGradTpaddings,
                    mode: cstring,
                    T: DType): MirrorPadGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"MirrorPadGrad(*#, #, #, tensorflow::string(#), #)", constructor.}

proc mirrorPadGrad*[oT: oall](scope: Scope,
                    input: oT,
                    paddings: MirrorPadGradTpaddings,
                    mode: cstring): MirrorPadGrad[oT] =
  return iimirrorPadGrad(scope,
                         input,
                         paddings,
                         mode,
                         oT[].oTF)

converter mirrorPadGradToOut*[oT: oall](op: MirrorPadGrad[oT]): oT {.inline.} = return op.output


type CTCGreedyDecoder* {.header:"../tensorflow/ops/generated.h", importcpp:"CTCGreedyDecoder/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iicTCGreedyDecoder(scope: Scope,
                       inputs: ofloat,
                       sequence_length: oint32,
                       merge_repeated: bool): CTCGreedyDecoder {.header:"../tensorflow/ops/generated.h", importcpp:"CTCGreedyDecoder(*#, #, #, #)", constructor.}

proc cTCGreedyDecoder*(scope: Scope,
                       inputs: ofloat,
                       sequence_length: oint32,
                       merge_repeated: bool = false): CTCGreedyDecoder =
  return iicTCGreedyDecoder(scope,
                            inputs,
                            sequence_length,
                            merge_repeated)

converter cTCGreedyDecoderToOut*(op: CTCGreedyDecoder): oint64 {.inline.} = return op.output


type CopyHost*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"CopyHost/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iicopyHost[oT: oall](scope: Scope,
               input: oT,
               tensor_name: cstring,
               debug_ops_spec: ArraySlice[cstring],
               T: DType): CopyHost[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"CopyHost(*#, #, tensorflow::string(#), #, #)", constructor.}

proc copyHost*[oT: oall](scope: Scope,
               input: oT,
               tensor_name: cstring,
               debug_ops_spec: openArray[cstring]): CopyHost[oT] =
  return iicopyHost(scope,
                    input,
                    tensor_name,
                    newArraySlice(debug_ops_spec),
                    oT[].oTF)

converter copyHostToOut*[oT: oall](op: CopyHost[oT]): oT {.inline.} = return op.output


type MapUnstageNoKey* {.header:"../tensorflow/ops/generated.h", importcpp:"MapUnstageNoKey/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iimapUnstageNoKey(scope: Scope,
                      indices: oint32,
                      dtypes: ArraySlice[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64,
                      memory_limit: int64): MapUnstageNoKey {.header:"../tensorflow/ops/generated.h", importcpp:"MapUnstageNoKey(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapUnstageNoKey*(scope: Scope,
                      indices: oint32,
                      dtypes: openArray[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = 0.int,
                      memory_limit: int64 = 0.int): MapUnstageNoKey =
  return iimapUnstageNoKey(scope,
                           indices,
                           newArraySlice(dtypes),
                           container,
                           shared_name,
                           capacity,
                           memory_limit)

converter mapUnstageNoKeyToOut*(op: MapUnstageNoKey): oint64 {.inline.} = return op.output

type TensorScatterAddTindices* = oint32 | oint64

type TensorScatterAdd*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorScatterAdd/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iitensorScatterAdd[oT: oall](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterAddTindices,
                       updates: oT,
                       T: DType): TensorScatterAdd[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"TensorScatterAdd(*#, #, #, #, #)", constructor.}

proc tensorScatterAdd*[oT: oall](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterAddTindices,
                       updates: oT): TensorScatterAdd[oT] =
  return iitensorScatterAdd(scope,
                            tensor,
                            indices,
                            updates,
                            oT[].oTF)

converter tensorScatterAddToOut*[oT: oall](op: TensorScatterAdd[oT]): oT {.inline.} = return op.output


type ExperimentalMaterializedIndexDatasetHandle* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMaterializedIndexDatasetHandle/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiexperimentalMaterializedIndexDatasetHandle(scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring,
                                                 output_types: ArraySlice[DType],
                                                 output_shapes: ArraySlice[TensorShape]): ExperimentalMaterializedIndexDatasetHandle {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalMaterializedIndexDatasetHandle(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc experimentalMaterializedIndexDatasetHandle*(scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring,
                                                 output_types: openArray[DType],
                                                 output_shapes: openArray[TensorShape]): ExperimentalMaterializedIndexDatasetHandle =
  return iiexperimentalMaterializedIndexDatasetHandle(scope,
                                                      container,
                                                      shared_name,
                                                      newArraySlice(output_types),
                                                      newArraySlice(output_shapes))

converter experimentalMaterializedIndexDatasetHandleToOut*(op: ExperimentalMaterializedIndexDatasetHandle): oresource {.inline.} = return op.output


type BoostedTreesEnsembleResourceHandleOp* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesEnsembleResourceHandleOp/*'0*/".} = object
  operation*: Operation[oresource]
  output*: oresource

proc iiboostedTreesEnsembleResourceHandleOp(scope: Scope,
                                           container: cstring,
                                           shared_name: cstring): BoostedTreesEnsembleResourceHandleOp {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesEnsembleResourceHandleOp(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc boostedTreesEnsembleResourceHandleOp*(scope: Scope,
                                           container: cstring,
                                           shared_name: cstring): BoostedTreesEnsembleResourceHandleOp =
  return iiboostedTreesEnsembleResourceHandleOp(scope,
                                                container,
                                                shared_name)

converter boostedTreesEnsembleResourceHandleOpToOut*(op: BoostedTreesEnsembleResourceHandleOp): oresource {.inline.} = return op.output

type SegmentMeanTindices* = oint32 | oint64

type SegmentMean*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentMean/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iisegmentMean[oT: oall](scope: Scope,
                  data: oT,
                  segment_ids: SegmentMeanTindices,
                  T: DType): SegmentMean[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"SegmentMean(*#, #, #, #)", constructor.}

proc segmentMean*[oT: oall](scope: Scope,
                  data: oT,
                  segment_ids: SegmentMeanTindices): SegmentMean[oT] =
  return iisegmentMean(scope,
                       data,
                       segment_ids,
                       oT[].oTF)

converter segmentMeanToOut*[oT: oall](op: SegmentMean[oT]): oT {.inline.} = return op.output


type OptimizeDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"OptimizeDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iioptimizeDataset(scope: Scope,
                      input_dataset: ovariant,
                      optimizations: ostring,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape]): OptimizeDataset {.header:"../tensorflow/ops/generated.h", importcpp:"OptimizeDataset(*#, #, #, #, #)", constructor.}

proc optimizeDataset*(scope: Scope,
                      input_dataset: ovariant,
                      optimizations: ostring,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape]): OptimizeDataset =
  return iioptimizeDataset(scope,
                           input_dataset,
                           optimizations,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes))

converter optimizeDatasetToOut*(op: OptimizeDataset): ovariant {.inline.} = return op.output


type DebugIdentity*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DebugIdentity/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidebugIdentity[oT: oall](scope: Scope,
                    input: oT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: ArraySlice[cstring],
                    T: DType,
                    gated_grpc: bool): DebugIdentity[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DebugIdentity(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc debugIdentity*[oT: oall](scope: Scope,
                    input: oT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: openArray[cstring],
                    gated_grpc: bool = false): DebugIdentity[oT] =
  return iidebugIdentity(scope,
                         input,
                         device_name,
                         tensor_name,
                         newArraySlice(debug_urls),
                         oT[].oTF,
                         gated_grpc)

converter debugIdentityToOut*[oT: oall](op: DebugIdentity[oT]): oT {.inline.} = return op.output


type BroadcastArgs*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"BroadcastArgs/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iibroadcastArgs[oT: oall](scope: Scope,
                    s0: oT,
                    s1: oT,
                    T: DType): BroadcastArgs[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"BroadcastArgs(*#, #, #, #)", constructor.}

proc broadcastArgs*[oT: oall](scope: Scope,
                    s0: oT,
                    s1: oT): BroadcastArgs[oT] =
  return iibroadcastArgs(scope,
                         s0,
                         s1,
                         oT[].oTF)

converter broadcastArgsToOut*[oT: oall](op: BroadcastArgs[oT]): oT {.inline.} = return op.output


type DecodeCSV*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeCSV/*'0*/".} = object
  operation*: Operation[oT]
  output*: olist[oT]

proc iidecodeCSV[oT: oall](scope: Scope,
                records: ostring,
                record_defaults: olist[oT],
                OUT_TYPE: ArraySlice[DType],
                na_value: cstring,
                select_cols: ArraySlice[int],
                field_delim: cstring,
                use_quote_delim: bool): DecodeCSV[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DecodeCSV(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc decodeCSV*[oT: oall](scope: Scope,
                records: ostring,
                record_defaults: olist[oT],
                OUT_TYPE: openArray[DType],
                na_value: cstring,
                select_cols: openArray[int],
                field_delim: cstring = ",",
                use_quote_delim: bool = true): DecodeCSV[oT] =
  return iidecodeCSV(scope,
                     records,
                     record_defaults,
                     newArraySlice(OUT_TYPE),
                     na_value,
                     newArraySlice(select_cols),
                     field_delim,
                     use_quote_delim)

converter decodeCSVToOutList*[oT: oall](op: DecodeCSV[oT]): olist[oT] {.inline.} = return op.output


type ExperimentalLMDBDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalLMDBDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalLMDBDataset(scope: Scope,
                              filenames: ostring,
                              output_types: ArraySlice[DType],
                              output_shapes: ArraySlice[TensorShape]): ExperimentalLMDBDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalLMDBDataset(*#, #, #, #)", constructor.}

proc experimentalLMDBDataset*(scope: Scope,
                              filenames: ostring,
                              output_types: openArray[DType],
                              output_shapes: openArray[TensorShape]): ExperimentalLMDBDataset =
  return iiexperimentalLMDBDataset(scope,
                                   filenames,
                                   newArraySlice(output_types),
                                   newArraySlice(output_shapes))

converter experimentalLMDBDatasetToOut*(op: ExperimentalLMDBDataset): ovariant {.inline.} = return op.output


type OptionalNone* {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalNone/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iioptionalNone(scope: Scope): OptionalNone {.header:"../tensorflow/ops/generated.h", importcpp:"OptionalNone(*#)", constructor.}

proc optionalNone*(scope: Scope): OptionalNone =
  return iioptionalNone(scope)

converter optionalNoneToOut*(op: OptionalNone): ovariant {.inline.} = return op.output


type ExperimentalNumaMapAndBatchDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalNumaMapAndBatchDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalNumaMapAndBatchDataset(scope: Scope,
                                         input_dataset: ovariant,
                                         other_arguments: olist[oall],
                                         batch_size: oint64,
                                         num_parallel_calls: oint64,
                                         drop_remainder: obool,
                                         f: NameAttrList,
                                         Targuments: ArraySlice[DType],
                                         output_types: ArraySlice[DType],
                                         output_shapes: ArraySlice[TensorShape],
                                         preserve_cardinality: bool): ExperimentalNumaMapAndBatchDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalNumaMapAndBatchDataset(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalNumaMapAndBatchDataset*(scope: Scope,
                                         input_dataset: ovariant,
                                         other_arguments: olist[oall],
                                         batch_size: oint64,
                                         num_parallel_calls: oint64,
                                         drop_remainder: obool,
                                         f: NameAttrList,
                                         Targuments: openArray[DType],
                                         output_types: openArray[DType],
                                         output_shapes: openArray[TensorShape],
                                         preserve_cardinality: bool = false): ExperimentalNumaMapAndBatchDataset =
  return iiexperimentalNumaMapAndBatchDataset(scope,
                                              input_dataset,
                                              other_arguments,
                                              batch_size,
                                              num_parallel_calls,
                                              drop_remainder,
                                              f,
                                              newArraySlice(Targuments),
                                              newArraySlice(output_types),
                                              newArraySlice(output_shapes),
                                              preserve_cardinality)

converter experimentalNumaMapAndBatchDatasetToOut*(op: ExperimentalNumaMapAndBatchDataset): ovariant {.inline.} = return op.output


type DynamicPartition*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DynamicPartition/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidynamicPartition[oT: oall](scope: Scope,
                       data: oT,
                       partitions: oint32,
                       num_partitions: int64,
                       T: DType): DynamicPartition[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DynamicPartition(*#, #, #, #, #)", constructor.}

proc dynamicPartition*[oT: oall](scope: Scope,
                       data: oT,
                       partitions: oint32,
                       num_partitions: int64 = 0.int): DynamicPartition[oT] =
  return iidynamicPartition(scope,
                            data,
                            partitions,
                            num_partitions,
                            oT[].oTF)

converter dynamicPartitionToOut*[oT: oall](op: DynamicPartition[oT]): oT {.inline.} = return op.output

type LinSpaceTidx* = oint32 | oint64

type LinSpace*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"LinSpace/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iilinSpace[oT: oall](scope: Scope,
               start: oT,
               stop: oT,
               num: LinSpaceTidx,
               T: DType): LinSpace[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"LinSpace(*#, #, #, #, #)", constructor.}

proc linSpace*[oT: oall](scope: Scope,
               start: oT,
               stop: oT,
               num: LinSpaceTidx): LinSpace[oT] =
  return iilinSpace(scope,
                    start,
                    stop,
                    num,
                    oT[].oTF)

converter linSpaceToOut*[oT: oall](op: LinSpace[oT]): oT {.inline.} = return op.output


type FixedLengthRecordDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iifixedLengthRecordDataset(scope: Scope,
                               filenames: ostring,
                               header_bytes: oint64,
                               record_bytes: oint64,
                               footer_bytes: oint64,
                               buffer_size: oint64): FixedLengthRecordDataset {.header:"../tensorflow/ops/generated.h", importcpp:"FixedLengthRecordDataset(*#, #, #, #, #, #)", constructor.}

proc fixedLengthRecordDataset*(scope: Scope,
                               filenames: ostring,
                               header_bytes: oint64,
                               record_bytes: oint64,
                               footer_bytes: oint64,
                               buffer_size: oint64): FixedLengthRecordDataset =
  return iifixedLengthRecordDataset(scope,
                                    filenames,
                                    header_bytes,
                                    record_bytes,
                                    footer_bytes,
                                    buffer_size)

converter fixedLengthRecordDatasetToOut*(op: FixedLengthRecordDataset): ovariant {.inline.} = return op.output


type CTCLoss* {.header:"../tensorflow/ops/generated.h", importcpp:"CTCLoss/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iicTCLoss(scope: Scope,
              inputs: ofloat,
              labels_indices: oint64,
              labels_values: oint32,
              sequence_length: oint32,
              preprocess_collapse_repeated: bool,
              ctc_merge_repeated: bool,
              ignore_longer_outputs_than_inputs: bool): CTCLoss {.header:"../tensorflow/ops/generated.h", importcpp:"CTCLoss(*#, #, #, #, #, #, #, #)", constructor.}

proc cTCLoss*(scope: Scope,
              inputs: ofloat,
              labels_indices: oint64,
              labels_values: oint32,
              sequence_length: oint32,
              preprocess_collapse_repeated: bool = false,
              ctc_merge_repeated: bool = true,
              ignore_longer_outputs_than_inputs: bool = false): CTCLoss =
  return iicTCLoss(scope,
                   inputs,
                   labels_indices,
                   labels_values,
                   sequence_length,
                   preprocess_collapse_repeated,
                   ctc_merge_repeated,
                   ignore_longer_outputs_than_inputs)

converter cTCLossToOut*(op: CTCLoss): ofloat {.inline.} = return op.output


type DebugGradientIdentity*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"DebugGradientIdentity/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iidebugGradientIdentity[oT: oall](scope: Scope,
                            input: oT,
                            T: DType): DebugGradientIdentity[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"DebugGradientIdentity(*#, #, #)", constructor.}

proc debugGradientIdentity*[oT: oall](scope: Scope,
                            input: oT): DebugGradientIdentity[oT] =
  return iidebugGradientIdentity(scope,
                                 input,
                                 oT[].oTF)

converter debugGradientIdentityToOut*[oT: oall](op: DebugGradientIdentity[oT]): oT {.inline.} = return op.output

type TensorArraySplitT* = oall

type TensorArraySplit* {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySplit/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iitensorArraySplit(scope: Scope,
                       handle: ostring,
                       value: TensorArraySplitT,
                       lengths: oint64,
                       flow_in: ofloat): TensorArraySplit {.header:"../tensorflow/ops/generated.h", importcpp:"TensorArraySplit(*#, #, #, #, #)", constructor.}

proc tensorArraySplit*(scope: Scope,
                       handle: ostring,
                       value: TensorArraySplitT,
                       lengths: oint64,
                       flow_in: ofloat): TensorArraySplit =
  return iitensorArraySplit(scope,
                            handle,
                            value,
                            lengths,
                            flow_in)

converter tensorArraySplitToOut*(op: TensorArraySplit): ofloat {.inline.} = return op.output


type UnicodeEncode* {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeEncode/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiunicodeEncode(scope: Scope,
                    input_values: oint32,
                    input_splits: oint64,
                    output_encoding: cstring,
                    errors: cstring,
                    replacement_char: int64): UnicodeEncode {.header:"../tensorflow/ops/generated.h", importcpp:"UnicodeEncode(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc unicodeEncode*(scope: Scope,
                    input_values: oint32,
                    input_splits: oint64,
                    output_encoding: cstring,
                    errors: cstring = "replace",
                    replacement_char: int64 = 65533.int): UnicodeEncode =
  return iiunicodeEncode(scope,
                         input_values,
                         input_splits,
                         output_encoding,
                         errors,
                         replacement_char)

converter unicodeEncodeToOut*(op: UnicodeEncode): ostring {.inline.} = return op.output


type Switch*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"Switch/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iiswitch[oT: oall](scope: Scope,
             data: oT,
             pred: obool,
             T: DType): Switch[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"Switch(*#, #, #, #)", constructor.}

proc switch*[oT: oall](scope: Scope,
             data: oT,
             pred: obool): Switch[oT] =
  return iiswitch(scope,
                  data,
                  pred,
                  oT[].oTF)

converter switchToOut*[oT: oall](op: Switch[oT]): oT {.inline.} = return op.output

type ResourceScatterMuldtype* = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceScatterMulTindices* = oint32 | oint64

type ResourceScatterMul*{.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterMul/*'0*/".} = object
  operation*: Operation[oinvalid]


proc iiresourceScatterMul(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMulTindices,
                         updates: ResourceScatterMuldtype): ResourceScatterMul {.header:"../tensorflow/ops/generated.h", importcpp:"ResourceScatterMul(*#, #, #, #)", constructor.}

proc resourceScatterMul*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMulTindices,
                         updates: ResourceScatterMuldtype): ResourceScatterMul =
  return iiresourceScatterMul(scope,
                              resource,
                              indices,
                              updates)




type WholeFileReader* {.header:"../tensorflow/ops/generated.h", importcpp:"WholeFileReader/*'0*/".} = object
  operation*: Operation[ostring]
  output*: ostring

proc iiwholeFileReader(scope: Scope,
                      container: cstring,
                      shared_name: cstring): WholeFileReader {.header:"../tensorflow/ops/generated.h", importcpp:"WholeFileReader(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc wholeFileReader*(scope: Scope,
                      container: cstring,
                      shared_name: cstring): WholeFileReader =
  return iiwholeFileReader(scope,
                           container,
                           shared_name)

converter wholeFileReaderToOut*(op: WholeFileReader): ostring {.inline.} = return op.output


type ExperimentalSlidingWindowDataset* {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSlidingWindowDataset/*'0*/".} = object
  operation*: Operation[ovariant]
  output*: ovariant

proc iiexperimentalSlidingWindowDataset(scope: Scope,
                                       input_dataset: ovariant,
                                       window_size: oint64,
                                       window_shift: oint64,
                                       window_stride: oint64,
                                       output_types: ArraySlice[DType],
                                       output_shapes: ArraySlice[TensorShape]): ExperimentalSlidingWindowDataset {.header:"../tensorflow/ops/generated.h", importcpp:"ExperimentalSlidingWindowDataset(*#, #, #, #, #, #, #)", constructor.}

proc experimentalSlidingWindowDataset*(scope: Scope,
                                       input_dataset: ovariant,
                                       window_size: oint64,
                                       window_shift: oint64,
                                       window_stride: oint64,
                                       output_types: openArray[DType],
                                       output_shapes: openArray[TensorShape]): ExperimentalSlidingWindowDataset =
  return iiexperimentalSlidingWindowDataset(scope,
                                            input_dataset,
                                            window_size,
                                            window_shift,
                                            window_stride,
                                            newArraySlice(output_types),
                                            newArraySlice(output_shapes))

converter experimentalSlidingWindowDatasetToOut*(op: ExperimentalSlidingWindowDataset): ovariant {.inline.} = return op.output


type TakeManySparseFromTensorsMap* {.header:"../tensorflow/ops/generated.h", importcpp:"TakeManySparseFromTensorsMap/*'0*/".} = object
  operation*: Operation[oint64]
  output*: oint64

proc iitakeManySparseFromTensorsMap(scope: Scope,
                                   sparse_handles: oint64,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: DType): TakeManySparseFromTensorsMap {.header:"../tensorflow/ops/generated.h", importcpp:"TakeManySparseFromTensorsMap(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc takeManySparseFromTensorsMap*(scope: Scope,
                                   sparse_handles: oint64,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: type oall = oinvalid): TakeManySparseFromTensorsMap =
  return iitakeManySparseFromTensorsMap(scope,
                                        sparse_handles,
                                        container,
                                        shared_name,
                                        oT[].oTF)

converter takeManySparseFromTensorsMapToOut*(op: TakeManySparseFromTensorsMap): oint64 {.inline.} = return op.output


type BoostedTreesMakeQuantileSummaries* {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesMakeQuantileSummaries/*'0*/".} = object
  operation*: Operation[ofloat]
  output*: ofloat

proc iiboostedTreesMakeQuantileSummaries(scope: Scope,
                                        float_values: ofloat,
                                        example_weights: ofloat,
                                        epsilon: ofloat,
                                        num_features: int64): BoostedTreesMakeQuantileSummaries {.header:"../tensorflow/ops/generated.h", importcpp:"BoostedTreesMakeQuantileSummaries(*#, #, #, #, #)", constructor.}

proc boostedTreesMakeQuantileSummaries*(scope: Scope,
                                        float_values: ofloat,
                                        example_weights: ofloat,
                                        epsilon: ofloat,
                                        num_features: int64 = 0.int): BoostedTreesMakeQuantileSummaries =
  return iiboostedTreesMakeQuantileSummaries(scope,
                                             float_values,
                                             example_weights,
                                             epsilon,
                                             num_features)

converter boostedTreesMakeQuantileSummariesToOut*(op: BoostedTreesMakeQuantileSummaries): ofloat {.inline.} = return op.output


type FractionalMaxPoolGrad*[oT:oall] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalMaxPoolGrad/*'0*/".} = object
  operation*: Operation[oT]
  output*: oT

proc iifractionalMaxPoolGrad[oT: oall](scope: Scope,
                            orig_input: oT,
                            orig_output: oT,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool,
                            T: DType): FractionalMaxPoolGrad[oT] {.header:"../tensorflow/ops/generated.h", importcpp:"FractionalMaxPoolGrad(*#, #, #, #, #, #, #, #)", constructor.}

proc fractionalMaxPoolGrad*[oT: oall](scope: Scope,
                            orig_input: oT,
                            orig_output: oT,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool = false): FractionalMaxPoolGrad[oT] =
  return iifractionalMaxPoolGrad(scope,
                                 orig_input,
                                 orig_output,
                                 out_backprop,
                                 row_pooling_sequence,
                                 col_pooling_sequence,
                                 overlapping,
                                 oT[].oTF)

converter fractionalMaxPoolGradToOut*[oT: oall](op: FractionalMaxPoolGrad[oT]): oT {.inline.} = return op.output

