import ../core/core

{.compile:"generated.cc".}


type GcsConfigureBlockCache*{.header:"generated.h", importcpp:"GcsConfigureBlockCache/*'0*/".} = object
  operation: Operation[oinvalid]


proc iigcsConfigureBlockCache(scope: Scope,
                             max_cache_size: ouint64,
                             block_size: ouint64,
                             max_staleness: ouint64): GcsConfigureBlockCache {.header:"generated.h", importcpp:"GcsConfigureBlockCache(*#, #, #, #)", constructor.}

proc gcsConfigureBlockCache*(scope: Scope,
                             max_cache_size: ouint64,
                             block_size: ouint64,
                             max_staleness: ouint64): GcsConfigureBlockCache =
  return iigcsConfigureBlockCache(scope,
                                  max_cache_size,
                                  block_size,
                                  max_staleness)




type GenerateBigQueryReaderPartitions*[oT:ostring] {.header:"generated.h", importcpp:"GenerateBigQueryReaderPartitions/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigenerateBigQueryReaderPartitions[oT: ostring](scope: Scope,
                                       project_id: cstring,
                                       dataset_id: cstring,
                                       table_id: cstring,
                                       columns: ArraySlice[cstring],
                                       test_end_point: cstring,
                                       timestamp_millis: int64,
                                       num_partitions: int64): GenerateBigQueryReaderPartitions[oT] {.header:"generated.h", importcpp:"GenerateBigQueryReaderPartitions(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, tensorflow::string(#), #, #)", constructor.}

proc generateBigQueryReaderPartitions*[oT: ostring](scope: Scope,
                                       project_id: cstring,
                                       dataset_id: cstring,
                                       table_id: cstring,
                                       columns: openArray[cstring],
                                       test_end_point: cstring,
                                       timestamp_millis: int64 = 0,
                                       num_partitions: int64 = 0): GenerateBigQueryReaderPartitions[oT] =
  return iigenerateBigQueryReaderPartitions(scope,
                                            project_id,
                                            dataset_id,
                                            table_id,
                                            newArraySlice(columns),
                                            test_end_point,
                                            timestamp_millis,
                                            num_partitions)

converter generateBigQueryReaderPartitionsToOut*[oT: ostring](op: GenerateBigQueryReaderPartitions[oT]): oT = return op.output


type Fact*[oT:ostring] {.header:"generated.h", importcpp:"Fact/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifact[oT: ostring](scope: Scope): Fact[oT] {.header:"generated.h", importcpp:"Fact(*#)", constructor.}

proc fact*[oT: ostring](scope: Scope): Fact[oT] =
  return iifact(scope)

converter factToOut*[oT: ostring](op: Fact[oT]): oT = return op.output

type ResourceApplyAddSignT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAddSign*{.header:"generated.h", importcpp:"ResourceApplyAddSign/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAddSign(scope: Scope,
                           nvar: oresource,
                           m: oresource,
                           lr: ResourceApplyAddSignT,
                           alpha: ResourceApplyAddSignT,
                           sign_decay: ResourceApplyAddSignT,
                           beta: ResourceApplyAddSignT,
                           grad: ResourceApplyAddSignT,
                           use_locking: bool): ResourceApplyAddSign {.header:"generated.h", importcpp:"ResourceApplyAddSign(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAddSign*(scope: Scope,
                           nvar: oresource,
                           m: oresource,
                           lr: ResourceApplyAddSignT,
                           alpha: ResourceApplyAddSignT,
                           sign_decay: ResourceApplyAddSignT,
                           beta: ResourceApplyAddSignT,
                           grad: ResourceApplyAddSignT,
                           use_locking: bool = false): ResourceApplyAddSign =
  return iiresourceApplyAddSign(scope,
                                nvar,
                                m,
                                lr,
                                alpha,
                                sign_decay,
                                beta,
                                grad,
                                use_locking)



type ResourceSparseApplyRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyRMSPropTindices = oint32 | oint64

type ResourceSparseApplyRMSProp*{.header:"generated.h", importcpp:"ResourceSparseApplyRMSProp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyRMSProp(scope: Scope,
                                 nvar: oresource,
                                 ms: oresource,
                                 mom: oresource,
                                 lr: ResourceSparseApplyRMSPropT,
                                 rho: ResourceSparseApplyRMSPropT,
                                 momentum: ResourceSparseApplyRMSPropT,
                                 epsilon: ResourceSparseApplyRMSPropT,
                                 grad: ResourceSparseApplyRMSPropT,
                                 indices: ResourceSparseApplyRMSPropTindices,
                                 use_locking: bool): ResourceSparseApplyRMSProp {.header:"generated.h", importcpp:"ResourceSparseApplyRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyRMSProp*(scope: Scope,
                                 nvar: oresource,
                                 ms: oresource,
                                 mom: oresource,
                                 lr: ResourceSparseApplyRMSPropT,
                                 rho: ResourceSparseApplyRMSPropT,
                                 momentum: ResourceSparseApplyRMSPropT,
                                 epsilon: ResourceSparseApplyRMSPropT,
                                 grad: ResourceSparseApplyRMSPropT,
                                 indices: ResourceSparseApplyRMSPropTindices,
                                 use_locking: bool = false): ResourceSparseApplyRMSProp =
  return iiresourceSparseApplyRMSProp(scope,
                                      nvar,
                                      ms,
                                      mom,
                                      lr,
                                      rho,
                                      momentum,
                                      epsilon,
                                      grad,
                                      indices,
                                      use_locking)



type ResourceSparseApplyCenteredRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyCenteredRMSPropTindices = oint32 | oint64

type ResourceSparseApplyCenteredRMSProp*{.header:"generated.h", importcpp:"ResourceSparseApplyCenteredRMSProp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyCenteredRMSProp(scope: Scope,
                                         nvar: oresource,
                                         mg: oresource,
                                         ms: oresource,
                                         mom: oresource,
                                         lr: ResourceSparseApplyCenteredRMSPropT,
                                         rho: ResourceSparseApplyCenteredRMSPropT,
                                         momentum: ResourceSparseApplyCenteredRMSPropT,
                                         epsilon: ResourceSparseApplyCenteredRMSPropT,
                                         grad: ResourceSparseApplyCenteredRMSPropT,
                                         indices: ResourceSparseApplyCenteredRMSPropTindices,
                                         use_locking: bool): ResourceSparseApplyCenteredRMSProp {.header:"generated.h", importcpp:"ResourceSparseApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyCenteredRMSProp*(scope: Scope,
                                         nvar: oresource,
                                         mg: oresource,
                                         ms: oresource,
                                         mom: oresource,
                                         lr: ResourceSparseApplyCenteredRMSPropT,
                                         rho: ResourceSparseApplyCenteredRMSPropT,
                                         momentum: ResourceSparseApplyCenteredRMSPropT,
                                         epsilon: ResourceSparseApplyCenteredRMSPropT,
                                         grad: ResourceSparseApplyCenteredRMSPropT,
                                         indices: ResourceSparseApplyCenteredRMSPropTindices,
                                         use_locking: bool = false): ResourceSparseApplyCenteredRMSProp =
  return iiresourceSparseApplyCenteredRMSProp(scope,
                                              nvar,
                                              mg,
                                              ms,
                                              mom,
                                              lr,
                                              rho,
                                              momentum,
                                              epsilon,
                                              grad,
                                              indices,
                                              use_locking)



type SparseApplyCenteredRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyCenteredRMSPropTindices = oint32 | oint64

type SparseApplyCenteredRMSProp*[oT:SparseApplyCenteredRMSPropT] {.header:"generated.h", importcpp:"SparseApplyCenteredRMSProp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyCenteredRMSProp[oT: SparseApplyCenteredRMSPropT](scope: Scope,
                                 nvar: oT,
                                 mg: oT,
                                 ms: oT,
                                 mom: oT,
                                 lr: oT,
                                 rho: oT,
                                 momentum: oT,
                                 epsilon: oT,
                                 grad: oT,
                                 indices: SparseApplyCenteredRMSPropTindices,
                                 use_locking: bool): SparseApplyCenteredRMSProp[oT] {.header:"generated.h", importcpp:"SparseApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyCenteredRMSProp*[oT: SparseApplyCenteredRMSPropT](scope: Scope,
                                 nvar: oT,
                                 mg: oT,
                                 ms: oT,
                                 mom: oT,
                                 lr: oT,
                                 rho: oT,
                                 momentum: oT,
                                 epsilon: oT,
                                 grad: oT,
                                 indices: SparseApplyCenteredRMSPropTindices,
                                 use_locking: bool = false): SparseApplyCenteredRMSProp[oT] =
  return iisparseApplyCenteredRMSProp(scope,
                                      nvar,
                                      mg,
                                      ms,
                                      mom,
                                      lr,
                                      rho,
                                      momentum,
                                      epsilon,
                                      grad,
                                      indices,
                                      use_locking)

converter sparseApplyCenteredRMSPropToOut*[oT: SparseApplyCenteredRMSPropT](op: SparseApplyCenteredRMSProp[oT]): oT = return op.output

type SparseApplyRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyRMSPropTindices = oint32 | oint64

type SparseApplyRMSProp*[oT:SparseApplyRMSPropT] {.header:"generated.h", importcpp:"SparseApplyRMSProp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyRMSProp[oT: SparseApplyRMSPropT](scope: Scope,
                         nvar: oT,
                         ms: oT,
                         mom: oT,
                         lr: oT,
                         rho: oT,
                         momentum: oT,
                         epsilon: oT,
                         grad: oT,
                         indices: SparseApplyRMSPropTindices,
                         use_locking: bool): SparseApplyRMSProp[oT] {.header:"generated.h", importcpp:"SparseApplyRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyRMSProp*[oT: SparseApplyRMSPropT](scope: Scope,
                         nvar: oT,
                         ms: oT,
                         mom: oT,
                         lr: oT,
                         rho: oT,
                         momentum: oT,
                         epsilon: oT,
                         grad: oT,
                         indices: SparseApplyRMSPropTindices,
                         use_locking: bool = false): SparseApplyRMSProp[oT] =
  return iisparseApplyRMSProp(scope,
                              nvar,
                              ms,
                              mom,
                              lr,
                              rho,
                              momentum,
                              epsilon,
                              grad,
                              indices,
                              use_locking)

converter sparseApplyRMSPropToOut*[oT: SparseApplyRMSPropT](op: SparseApplyRMSProp[oT]): oT = return op.output

type ApplyRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyRMSProp*[oT:ApplyRMSPropT] {.header:"generated.h", importcpp:"ApplyRMSProp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyRMSProp[oT: ApplyRMSPropT](scope: Scope,
                   nvar: oT,
                   ms: oT,
                   mom: oT,
                   lr: oT,
                   rho: oT,
                   momentum: oT,
                   epsilon: oT,
                   grad: oT,
                   use_locking: bool): ApplyRMSProp[oT] {.header:"generated.h", importcpp:"ApplyRMSProp(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyRMSProp*[oT: ApplyRMSPropT](scope: Scope,
                   nvar: oT,
                   ms: oT,
                   mom: oT,
                   lr: oT,
                   rho: oT,
                   momentum: oT,
                   epsilon: oT,
                   grad: oT,
                   use_locking: bool = false): ApplyRMSProp[oT] =
  return iiapplyRMSProp(scope,
                        nvar,
                        ms,
                        mom,
                        lr,
                        rho,
                        momentum,
                        epsilon,
                        grad,
                        use_locking)

converter applyRMSPropToOut*[oT: ApplyRMSPropT](op: ApplyRMSProp[oT]): oT = return op.output

type ResourceApplyAdaMaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdaMax*{.header:"generated.h", importcpp:"ResourceApplyAdaMax/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAdaMax(scope: Scope,
                          nvar: oresource,
                          m: oresource,
                          v: oresource,
                          beta1_power: ResourceApplyAdaMaxT,
                          lr: ResourceApplyAdaMaxT,
                          beta1: ResourceApplyAdaMaxT,
                          beta2: ResourceApplyAdaMaxT,
                          epsilon: ResourceApplyAdaMaxT,
                          grad: ResourceApplyAdaMaxT,
                          use_locking: bool): ResourceApplyAdaMax {.header:"generated.h", importcpp:"ResourceApplyAdaMax(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdaMax*(scope: Scope,
                          nvar: oresource,
                          m: oresource,
                          v: oresource,
                          beta1_power: ResourceApplyAdaMaxT,
                          lr: ResourceApplyAdaMaxT,
                          beta1: ResourceApplyAdaMaxT,
                          beta2: ResourceApplyAdaMaxT,
                          epsilon: ResourceApplyAdaMaxT,
                          grad: ResourceApplyAdaMaxT,
                          use_locking: bool = false): ResourceApplyAdaMax =
  return iiresourceApplyAdaMax(scope,
                               nvar,
                               m,
                               v,
                               beta1_power,
                               lr,
                               beta1,
                               beta2,
                               epsilon,
                               grad,
                               use_locking)



type ApplyAdaMaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyAdaMax*[oT:ApplyAdaMaxT] {.header:"generated.h", importcpp:"ApplyAdaMax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyAdaMax[oT: ApplyAdaMaxT](scope: Scope,
                  nvar: oT,
                  m: oT,
                  v: oT,
                  beta1_power: oT,
                  lr: oT,
                  beta1: oT,
                  beta2: oT,
                  epsilon: oT,
                  grad: oT,
                  use_locking: bool): ApplyAdaMax[oT] {.header:"generated.h", importcpp:"ApplyAdaMax(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdaMax*[oT: ApplyAdaMaxT](scope: Scope,
                  nvar: oT,
                  m: oT,
                  v: oT,
                  beta1_power: oT,
                  lr: oT,
                  beta1: oT,
                  beta2: oT,
                  epsilon: oT,
                  grad: oT,
                  use_locking: bool = false): ApplyAdaMax[oT] =
  return iiapplyAdaMax(scope,
                       nvar,
                       m,
                       v,
                       beta1_power,
                       lr,
                       beta1,
                       beta2,
                       epsilon,
                       grad,
                       use_locking)

converter applyAdaMaxToOut*[oT: ApplyAdaMaxT](op: ApplyAdaMax[oT]): oT = return op.output

type ApplyAdamT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyAdam*[oT:ApplyAdamT] {.header:"generated.h", importcpp:"ApplyAdam/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyAdam[oT: ApplyAdamT](scope: Scope,
                nvar: oT,
                m: oT,
                v: oT,
                beta1_power: oT,
                beta2_power: oT,
                lr: oT,
                beta1: oT,
                beta2: oT,
                epsilon: oT,
                grad: oT,
                use_nesterov: bool,
                use_locking: bool): ApplyAdam[oT] {.header:"generated.h", importcpp:"ApplyAdam(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdam*[oT: ApplyAdamT](scope: Scope,
                nvar: oT,
                m: oT,
                v: oT,
                beta1_power: oT,
                beta2_power: oT,
                lr: oT,
                beta1: oT,
                beta2: oT,
                epsilon: oT,
                grad: oT,
                use_nesterov: bool = false,
                use_locking: bool = false): ApplyAdam[oT] =
  return iiapplyAdam(scope,
                     nvar,
                     m,
                     v,
                     beta1_power,
                     beta2_power,
                     lr,
                     beta1,
                     beta2,
                     epsilon,
                     grad,
                     use_nesterov,
                     use_locking)

converter applyAdamToOut*[oT: ApplyAdamT](op: ApplyAdam[oT]): oT = return op.output

type ResourceSparseApplyKerasMomentumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyKerasMomentumTindices = oint32 | oint64

type ResourceSparseApplyKerasMomentum*{.header:"generated.h", importcpp:"ResourceSparseApplyKerasMomentum/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyKerasMomentum(scope: Scope,
                                       nvar: oresource,
                                       accum: oresource,
                                       lr: ResourceSparseApplyKerasMomentumT,
                                       grad: ResourceSparseApplyKerasMomentumT,
                                       indices: ResourceSparseApplyKerasMomentumTindices,
                                       momentum: ResourceSparseApplyKerasMomentumT,
                                       use_nesterov: bool,
                                       use_locking: bool): ResourceSparseApplyKerasMomentum {.header:"generated.h", importcpp:"ResourceSparseApplyKerasMomentum(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyKerasMomentum*(scope: Scope,
                                       nvar: oresource,
                                       accum: oresource,
                                       lr: ResourceSparseApplyKerasMomentumT,
                                       grad: ResourceSparseApplyKerasMomentumT,
                                       indices: ResourceSparseApplyKerasMomentumTindices,
                                       momentum: ResourceSparseApplyKerasMomentumT,
                                       use_nesterov: bool = false,
                                       use_locking: bool = false): ResourceSparseApplyKerasMomentum =
  return iiresourceSparseApplyKerasMomentum(scope,
                                            nvar,
                                            accum,
                                            lr,
                                            grad,
                                            indices,
                                            momentum,
                                            use_nesterov,
                                            use_locking)



type ResourceApplyKerasMomentumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyKerasMomentum*{.header:"generated.h", importcpp:"ResourceApplyKerasMomentum/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyKerasMomentum(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceApplyKerasMomentumT,
                                 grad: ResourceApplyKerasMomentumT,
                                 momentum: ResourceApplyKerasMomentumT,
                                 use_nesterov: bool,
                                 use_locking: bool): ResourceApplyKerasMomentum {.header:"generated.h", importcpp:"ResourceApplyKerasMomentum(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyKerasMomentum*(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceApplyKerasMomentumT,
                                 grad: ResourceApplyKerasMomentumT,
                                 momentum: ResourceApplyKerasMomentumT,
                                 use_nesterov: bool = false,
                                 use_locking: bool = false): ResourceApplyKerasMomentum =
  return iiresourceApplyKerasMomentum(scope,
                                      nvar,
                                      accum,
                                      lr,
                                      grad,
                                      momentum,
                                      use_nesterov,
                                      use_locking)



type ResourceSparseApplyMomentumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyMomentumTindices = oint32 | oint64

type ResourceSparseApplyMomentum*{.header:"generated.h", importcpp:"ResourceSparseApplyMomentum/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyMomentum(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  lr: ResourceSparseApplyMomentumT,
                                  grad: ResourceSparseApplyMomentumT,
                                  indices: ResourceSparseApplyMomentumTindices,
                                  momentum: ResourceSparseApplyMomentumT,
                                  use_nesterov: bool,
                                  use_locking: bool): ResourceSparseApplyMomentum {.header:"generated.h", importcpp:"ResourceSparseApplyMomentum(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyMomentum*(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  lr: ResourceSparseApplyMomentumT,
                                  grad: ResourceSparseApplyMomentumT,
                                  indices: ResourceSparseApplyMomentumTindices,
                                  momentum: ResourceSparseApplyMomentumT,
                                  use_nesterov: bool = false,
                                  use_locking: bool = false): ResourceSparseApplyMomentum =
  return iiresourceSparseApplyMomentum(scope,
                                       nvar,
                                       accum,
                                       lr,
                                       grad,
                                       indices,
                                       momentum,
                                       use_nesterov,
                                       use_locking)



type ResourceApplyMomentumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyMomentum*{.header:"generated.h", importcpp:"ResourceApplyMomentum/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyMomentum(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            lr: ResourceApplyMomentumT,
                            grad: ResourceApplyMomentumT,
                            momentum: ResourceApplyMomentumT,
                            use_nesterov: bool,
                            use_locking: bool): ResourceApplyMomentum {.header:"generated.h", importcpp:"ResourceApplyMomentum(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyMomentum*(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            lr: ResourceApplyMomentumT,
                            grad: ResourceApplyMomentumT,
                            momentum: ResourceApplyMomentumT,
                            use_nesterov: bool = false,
                            use_locking: bool = false): ResourceApplyMomentum =
  return iiresourceApplyMomentum(scope,
                                 nvar,
                                 accum,
                                 lr,
                                 grad,
                                 momentum,
                                 use_nesterov,
                                 use_locking)



type ResourceSparseApplyFtrlV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyFtrlV2Tindices = oint32 | oint64

type ResourceSparseApplyFtrlV2*{.header:"generated.h", importcpp:"ResourceSparseApplyFtrlV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyFtrlV2(scope: Scope,
                                nvar: oresource,
                                accum: oresource,
                                linear: oresource,
                                grad: ResourceSparseApplyFtrlV2T,
                                indices: ResourceSparseApplyFtrlV2Tindices,
                                lr: ResourceSparseApplyFtrlV2T,
                                l1: ResourceSparseApplyFtrlV2T,
                                l2: ResourceSparseApplyFtrlV2T,
                                l2_shrinkage: ResourceSparseApplyFtrlV2T,
                                lr_power: ResourceSparseApplyFtrlV2T,
                                use_locking: bool): ResourceSparseApplyFtrlV2 {.header:"generated.h", importcpp:"ResourceSparseApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyFtrlV2*(scope: Scope,
                                nvar: oresource,
                                accum: oresource,
                                linear: oresource,
                                grad: ResourceSparseApplyFtrlV2T,
                                indices: ResourceSparseApplyFtrlV2Tindices,
                                lr: ResourceSparseApplyFtrlV2T,
                                l1: ResourceSparseApplyFtrlV2T,
                                l2: ResourceSparseApplyFtrlV2T,
                                l2_shrinkage: ResourceSparseApplyFtrlV2T,
                                lr_power: ResourceSparseApplyFtrlV2T,
                                use_locking: bool = false): ResourceSparseApplyFtrlV2 =
  return iiresourceSparseApplyFtrlV2(scope,
                                     nvar,
                                     accum,
                                     linear,
                                     grad,
                                     indices,
                                     lr,
                                     l1,
                                     l2,
                                     l2_shrinkage,
                                     lr_power,
                                     use_locking)



type ResourceSparseApplyFtrlT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyFtrlTindices = oint32 | oint64

type ResourceSparseApplyFtrl*{.header:"generated.h", importcpp:"ResourceSparseApplyFtrl/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyFtrl(scope: Scope,
                              nvar: oresource,
                              accum: oresource,
                              linear: oresource,
                              grad: ResourceSparseApplyFtrlT,
                              indices: ResourceSparseApplyFtrlTindices,
                              lr: ResourceSparseApplyFtrlT,
                              l1: ResourceSparseApplyFtrlT,
                              l2: ResourceSparseApplyFtrlT,
                              lr_power: ResourceSparseApplyFtrlT,
                              use_locking: bool): ResourceSparseApplyFtrl {.header:"generated.h", importcpp:"ResourceSparseApplyFtrl(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyFtrl*(scope: Scope,
                              nvar: oresource,
                              accum: oresource,
                              linear: oresource,
                              grad: ResourceSparseApplyFtrlT,
                              indices: ResourceSparseApplyFtrlTindices,
                              lr: ResourceSparseApplyFtrlT,
                              l1: ResourceSparseApplyFtrlT,
                              l2: ResourceSparseApplyFtrlT,
                              lr_power: ResourceSparseApplyFtrlT,
                              use_locking: bool = false): ResourceSparseApplyFtrl =
  return iiresourceSparseApplyFtrl(scope,
                                   nvar,
                                   accum,
                                   linear,
                                   grad,
                                   indices,
                                   lr,
                                   l1,
                                   l2,
                                   lr_power,
                                   use_locking)



type SparseApplyFtrlT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyFtrlTindices = oint32 | oint64

type SparseApplyFtrl*[oT:SparseApplyFtrlT] {.header:"generated.h", importcpp:"SparseApplyFtrl/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyFtrl[oT: SparseApplyFtrlT](scope: Scope,
                      nvar: oT,
                      accum: oT,
                      linear: oT,
                      grad: oT,
                      indices: SparseApplyFtrlTindices,
                      lr: oT,
                      l1: oT,
                      l2: oT,
                      lr_power: oT,
                      use_locking: bool): SparseApplyFtrl[oT] {.header:"generated.h", importcpp:"SparseApplyFtrl(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyFtrl*[oT: SparseApplyFtrlT](scope: Scope,
                      nvar: oT,
                      accum: oT,
                      linear: oT,
                      grad: oT,
                      indices: SparseApplyFtrlTindices,
                      lr: oT,
                      l1: oT,
                      l2: oT,
                      lr_power: oT,
                      use_locking: bool = false): SparseApplyFtrl[oT] =
  return iisparseApplyFtrl(scope,
                           nvar,
                           accum,
                           linear,
                           grad,
                           indices,
                           lr,
                           l1,
                           l2,
                           lr_power,
                           use_locking)

converter sparseApplyFtrlToOut*[oT: SparseApplyFtrlT](op: SparseApplyFtrl[oT]): oT = return op.output

type ApplyFtrlT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyFtrl*[oT:ApplyFtrlT] {.header:"generated.h", importcpp:"ApplyFtrl/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyFtrl[oT: ApplyFtrlT](scope: Scope,
                nvar: oT,
                accum: oT,
                linear: oT,
                grad: oT,
                lr: oT,
                l1: oT,
                l2: oT,
                lr_power: oT,
                use_locking: bool): ApplyFtrl[oT] {.header:"generated.h", importcpp:"ApplyFtrl(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyFtrl*[oT: ApplyFtrlT](scope: Scope,
                nvar: oT,
                accum: oT,
                linear: oT,
                grad: oT,
                lr: oT,
                l1: oT,
                l2: oT,
                lr_power: oT,
                use_locking: bool = false): ApplyFtrl[oT] =
  return iiapplyFtrl(scope,
                     nvar,
                     accum,
                     linear,
                     grad,
                     lr,
                     l1,
                     l2,
                     lr_power,
                     use_locking)

converter applyFtrlToOut*[oT: ApplyFtrlT](op: ApplyFtrl[oT]): oT = return op.output

type ResourceSparseApplyAdagradDAT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyAdagradDATindices = oint32 | oint64

type ResourceSparseApplyAdagradDA*{.header:"generated.h", importcpp:"ResourceSparseApplyAdagradDA/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyAdagradDA(scope: Scope,
                                   nvar: oresource,
                                   gradient_accumulator: oresource,
                                   gradient_squared_accumulator: oresource,
                                   grad: ResourceSparseApplyAdagradDAT,
                                   indices: ResourceSparseApplyAdagradDATindices,
                                   lr: ResourceSparseApplyAdagradDAT,
                                   l1: ResourceSparseApplyAdagradDAT,
                                   l2: ResourceSparseApplyAdagradDAT,
                                   global_step: oint64,
                                   use_locking: bool): ResourceSparseApplyAdagradDA {.header:"generated.h", importcpp:"ResourceSparseApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyAdagradDA*(scope: Scope,
                                   nvar: oresource,
                                   gradient_accumulator: oresource,
                                   gradient_squared_accumulator: oresource,
                                   grad: ResourceSparseApplyAdagradDAT,
                                   indices: ResourceSparseApplyAdagradDATindices,
                                   lr: ResourceSparseApplyAdagradDAT,
                                   l1: ResourceSparseApplyAdagradDAT,
                                   l2: ResourceSparseApplyAdagradDAT,
                                   global_step: oint64,
                                   use_locking: bool = false): ResourceSparseApplyAdagradDA =
  return iiresourceSparseApplyAdagradDA(scope,
                                        nvar,
                                        gradient_accumulator,
                                        gradient_squared_accumulator,
                                        grad,
                                        indices,
                                        lr,
                                        l1,
                                        l2,
                                        global_step,
                                        use_locking)



type SparseApplyProximalAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyProximalAdagradTindices = oint32 | oint64

type SparseApplyProximalAdagrad*[oT:SparseApplyProximalAdagradT] {.header:"generated.h", importcpp:"SparseApplyProximalAdagrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyProximalAdagrad[oT: SparseApplyProximalAdagradT](scope: Scope,
                                 nvar: oT,
                                 accum: oT,
                                 lr: oT,
                                 l1: oT,
                                 l2: oT,
                                 grad: oT,
                                 indices: SparseApplyProximalAdagradTindices,
                                 use_locking: bool): SparseApplyProximalAdagrad[oT] {.header:"generated.h", importcpp:"SparseApplyProximalAdagrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyProximalAdagrad*[oT: SparseApplyProximalAdagradT](scope: Scope,
                                 nvar: oT,
                                 accum: oT,
                                 lr: oT,
                                 l1: oT,
                                 l2: oT,
                                 grad: oT,
                                 indices: SparseApplyProximalAdagradTindices,
                                 use_locking: bool = false): SparseApplyProximalAdagrad[oT] =
  return iisparseApplyProximalAdagrad(scope,
                                      nvar,
                                      accum,
                                      lr,
                                      l1,
                                      l2,
                                      grad,
                                      indices,
                                      use_locking)

converter sparseApplyProximalAdagradToOut*[oT: SparseApplyProximalAdagradT](op: SparseApplyProximalAdagrad[oT]): oT = return op.output

type SparseApplyAdagradDAT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyAdagradDATindices = oint32 | oint64

type SparseApplyAdagradDA*[oT:SparseApplyAdagradDAT] {.header:"generated.h", importcpp:"SparseApplyAdagradDA/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyAdagradDA[oT: SparseApplyAdagradDAT](scope: Scope,
                           nvar: oT,
                           gradient_accumulator: oT,
                           gradient_squared_accumulator: oT,
                           grad: oT,
                           indices: SparseApplyAdagradDATindices,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           global_step: oint64,
                           use_locking: bool): SparseApplyAdagradDA[oT] {.header:"generated.h", importcpp:"SparseApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyAdagradDA*[oT: SparseApplyAdagradDAT](scope: Scope,
                           nvar: oT,
                           gradient_accumulator: oT,
                           gradient_squared_accumulator: oT,
                           grad: oT,
                           indices: SparseApplyAdagradDATindices,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           global_step: oint64,
                           use_locking: bool = false): SparseApplyAdagradDA[oT] =
  return iisparseApplyAdagradDA(scope,
                                nvar,
                                gradient_accumulator,
                                gradient_squared_accumulator,
                                grad,
                                indices,
                                lr,
                                l1,
                                l2,
                                global_step,
                                use_locking)

converter sparseApplyAdagradDAToOut*[oT: SparseApplyAdagradDAT](op: SparseApplyAdagradDA[oT]): oT = return op.output

type ApplyAdagradDAT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyAdagradDA*[oT:ApplyAdagradDAT] {.header:"generated.h", importcpp:"ApplyAdagradDA/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyAdagradDA[oT: ApplyAdagradDAT](scope: Scope,
                     nvar: oT,
                     gradient_accumulator: oT,
                     gradient_squared_accumulator: oT,
                     grad: oT,
                     lr: oT,
                     l1: oT,
                     l2: oT,
                     global_step: oint64,
                     use_locking: bool): ApplyAdagradDA[oT] {.header:"generated.h", importcpp:"ApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdagradDA*[oT: ApplyAdagradDAT](scope: Scope,
                     nvar: oT,
                     gradient_accumulator: oT,
                     gradient_squared_accumulator: oT,
                     grad: oT,
                     lr: oT,
                     l1: oT,
                     l2: oT,
                     global_step: oint64,
                     use_locking: bool = false): ApplyAdagradDA[oT] =
  return iiapplyAdagradDA(scope,
                          nvar,
                          gradient_accumulator,
                          gradient_squared_accumulator,
                          grad,
                          lr,
                          l1,
                          l2,
                          global_step,
                          use_locking)

converter applyAdagradDAToOut*[oT: ApplyAdagradDAT](op: ApplyAdagradDA[oT]): oT = return op.output

type ResourceSparseApplyAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyAdagradTindices = oint32 | oint64

type ResourceSparseApplyAdagrad*{.header:"generated.h", importcpp:"ResourceSparseApplyAdagrad/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyAdagrad(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceSparseApplyAdagradT,
                                 grad: ResourceSparseApplyAdagradT,
                                 indices: ResourceSparseApplyAdagradTindices,
                                 update_slots: bool,
                                 use_locking: bool): ResourceSparseApplyAdagrad {.header:"generated.h", importcpp:"ResourceSparseApplyAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyAdagrad*(scope: Scope,
                                 nvar: oresource,
                                 accum: oresource,
                                 lr: ResourceSparseApplyAdagradT,
                                 grad: ResourceSparseApplyAdagradT,
                                 indices: ResourceSparseApplyAdagradTindices,
                                 update_slots: bool = true,
                                 use_locking: bool = false): ResourceSparseApplyAdagrad =
  return iiresourceSparseApplyAdagrad(scope,
                                      nvar,
                                      accum,
                                      lr,
                                      grad,
                                      indices,
                                      update_slots,
                                      use_locking)



type SparseApplyAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyAdagradTindices = oint32 | oint64

type SparseApplyAdagrad*[oT:SparseApplyAdagradT] {.header:"generated.h", importcpp:"SparseApplyAdagrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyAdagrad[oT: SparseApplyAdagradT](scope: Scope,
                         nvar: oT,
                         accum: oT,
                         lr: oT,
                         grad: oT,
                         indices: SparseApplyAdagradTindices,
                         update_slots: bool,
                         use_locking: bool): SparseApplyAdagrad[oT] {.header:"generated.h", importcpp:"SparseApplyAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyAdagrad*[oT: SparseApplyAdagradT](scope: Scope,
                         nvar: oT,
                         accum: oT,
                         lr: oT,
                         grad: oT,
                         indices: SparseApplyAdagradTindices,
                         update_slots: bool = true,
                         use_locking: bool = false): SparseApplyAdagrad[oT] =
  return iisparseApplyAdagrad(scope,
                              nvar,
                              accum,
                              lr,
                              grad,
                              indices,
                              update_slots,
                              use_locking)

converter sparseApplyAdagradToOut*[oT: SparseApplyAdagradT](op: SparseApplyAdagrad[oT]): oT = return op.output

type ResourceApplyAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdagrad*{.header:"generated.h", importcpp:"ResourceApplyAdagrad/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAdagrad(scope: Scope,
                           nvar: oresource,
                           accum: oresource,
                           lr: ResourceApplyAdagradT,
                           grad: ResourceApplyAdagradT,
                           update_slots: bool,
                           use_locking: bool): ResourceApplyAdagrad {.header:"generated.h", importcpp:"ResourceApplyAdagrad(*#, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdagrad*(scope: Scope,
                           nvar: oresource,
                           accum: oresource,
                           lr: ResourceApplyAdagradT,
                           grad: ResourceApplyAdagradT,
                           update_slots: bool = true,
                           use_locking: bool = false): ResourceApplyAdagrad =
  return iiresourceApplyAdagrad(scope,
                                nvar,
                                accum,
                                lr,
                                grad,
                                update_slots,
                                use_locking)



type ApplyAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyAdagrad*[oT:ApplyAdagradT] {.header:"generated.h", importcpp:"ApplyAdagrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyAdagrad[oT: ApplyAdagradT](scope: Scope,
                   nvar: oT,
                   accum: oT,
                   lr: oT,
                   grad: oT,
                   update_slots: bool,
                   use_locking: bool): ApplyAdagrad[oT] {.header:"generated.h", importcpp:"ApplyAdagrad(*#, #, #, #, #, #, #)", constructor.}

proc applyAdagrad*[oT: ApplyAdagradT](scope: Scope,
                   nvar: oT,
                   accum: oT,
                   lr: oT,
                   grad: oT,
                   update_slots: bool = true,
                   use_locking: bool = false): ApplyAdagrad[oT] =
  return iiapplyAdagrad(scope,
                        nvar,
                        accum,
                        lr,
                        grad,
                        update_slots,
                        use_locking)

converter applyAdagradToOut*[oT: ApplyAdagradT](op: ApplyAdagrad[oT]): oT = return op.output

type SparseApplyAdadeltaT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyAdadeltaTindices = oint32 | oint64

type SparseApplyAdadelta*[oT:SparseApplyAdadeltaT] {.header:"generated.h", importcpp:"SparseApplyAdadelta/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyAdadelta[oT: SparseApplyAdadeltaT](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          accum_update: oT,
                          lr: oT,
                          rho: oT,
                          epsilon: oT,
                          grad: oT,
                          indices: SparseApplyAdadeltaTindices,
                          use_locking: bool): SparseApplyAdadelta[oT] {.header:"generated.h", importcpp:"SparseApplyAdadelta(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyAdadelta*[oT: SparseApplyAdadeltaT](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          accum_update: oT,
                          lr: oT,
                          rho: oT,
                          epsilon: oT,
                          grad: oT,
                          indices: SparseApplyAdadeltaTindices,
                          use_locking: bool = false): SparseApplyAdadelta[oT] =
  return iisparseApplyAdadelta(scope,
                               nvar,
                               accum,
                               accum_update,
                               lr,
                               rho,
                               epsilon,
                               grad,
                               indices,
                               use_locking)

converter sparseApplyAdadeltaToOut*[oT: SparseApplyAdadeltaT](op: SparseApplyAdadelta[oT]): oT = return op.output

type ApplyAdadeltaT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyAdadelta*[oT:ApplyAdadeltaT] {.header:"generated.h", importcpp:"ApplyAdadelta/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyAdadelta[oT: ApplyAdadeltaT](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    accum_update: oT,
                    lr: oT,
                    rho: oT,
                    epsilon: oT,
                    grad: oT,
                    use_locking: bool): ApplyAdadelta[oT] {.header:"generated.h", importcpp:"ApplyAdadelta(*#, #, #, #, #, #, #, #, #)", constructor.}

proc applyAdadelta*[oT: ApplyAdadeltaT](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    accum_update: oT,
                    lr: oT,
                    rho: oT,
                    epsilon: oT,
                    grad: oT,
                    use_locking: bool = false): ApplyAdadelta[oT] =
  return iiapplyAdadelta(scope,
                         nvar,
                         accum,
                         accum_update,
                         lr,
                         rho,
                         epsilon,
                         grad,
                         use_locking)

converter applyAdadeltaToOut*[oT: ApplyAdadeltaT](op: ApplyAdadelta[oT]): oT = return op.output

type ResourceSparseApplyProximalGradientDescentT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyProximalGradientDescentTindices = oint32 | oint64

type ResourceSparseApplyProximalGradientDescent*{.header:"generated.h", importcpp:"ResourceSparseApplyProximalGradientDescent/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyProximalGradientDescent(scope: Scope,
                                                 nvar: oresource,
                                                 alpha: ResourceSparseApplyProximalGradientDescentT,
                                                 l1: ResourceSparseApplyProximalGradientDescentT,
                                                 l2: ResourceSparseApplyProximalGradientDescentT,
                                                 grad: ResourceSparseApplyProximalGradientDescentT,
                                                 indices: ResourceSparseApplyProximalGradientDescentTindices,
                                                 use_locking: bool): ResourceSparseApplyProximalGradientDescent {.header:"generated.h", importcpp:"ResourceSparseApplyProximalGradientDescent(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyProximalGradientDescent*(scope: Scope,
                                                 nvar: oresource,
                                                 alpha: ResourceSparseApplyProximalGradientDescentT,
                                                 l1: ResourceSparseApplyProximalGradientDescentT,
                                                 l2: ResourceSparseApplyProximalGradientDescentT,
                                                 grad: ResourceSparseApplyProximalGradientDescentT,
                                                 indices: ResourceSparseApplyProximalGradientDescentTindices,
                                                 use_locking: bool = false): ResourceSparseApplyProximalGradientDescent =
  return iiresourceSparseApplyProximalGradientDescent(scope,
                                                      nvar,
                                                      alpha,
                                                      l1,
                                                      l2,
                                                      grad,
                                                      indices,
                                                      use_locking)



type ResourceApplyProximalGradientDescentT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyProximalGradientDescent*{.header:"generated.h", importcpp:"ResourceApplyProximalGradientDescent/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyProximalGradientDescent(scope: Scope,
                                           nvar: oresource,
                                           alpha: ResourceApplyProximalGradientDescentT,
                                           l1: ResourceApplyProximalGradientDescentT,
                                           l2: ResourceApplyProximalGradientDescentT,
                                           delta: ResourceApplyProximalGradientDescentT,
                                           use_locking: bool): ResourceApplyProximalGradientDescent {.header:"generated.h", importcpp:"ResourceApplyProximalGradientDescent(*#, #, #, #, #, #, #)", constructor.}

proc resourceApplyProximalGradientDescent*(scope: Scope,
                                           nvar: oresource,
                                           alpha: ResourceApplyProximalGradientDescentT,
                                           l1: ResourceApplyProximalGradientDescentT,
                                           l2: ResourceApplyProximalGradientDescentT,
                                           delta: ResourceApplyProximalGradientDescentT,
                                           use_locking: bool = false): ResourceApplyProximalGradientDescent =
  return iiresourceApplyProximalGradientDescent(scope,
                                                nvar,
                                                alpha,
                                                l1,
                                                l2,
                                                delta,
                                                use_locking)



type ApplyProximalGradientDescentT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyProximalGradientDescent*[oT:ApplyProximalGradientDescentT] {.header:"generated.h", importcpp:"ApplyProximalGradientDescent/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyProximalGradientDescent[oT: ApplyProximalGradientDescentT](scope: Scope,
                                   nvar: oT,
                                   alpha: oT,
                                   l1: oT,
                                   l2: oT,
                                   delta: oT,
                                   use_locking: bool): ApplyProximalGradientDescent[oT] {.header:"generated.h", importcpp:"ApplyProximalGradientDescent(*#, #, #, #, #, #, #)", constructor.}

proc applyProximalGradientDescent*[oT: ApplyProximalGradientDescentT](scope: Scope,
                                   nvar: oT,
                                   alpha: oT,
                                   l1: oT,
                                   l2: oT,
                                   delta: oT,
                                   use_locking: bool = false): ApplyProximalGradientDescent[oT] =
  return iiapplyProximalGradientDescent(scope,
                                        nvar,
                                        alpha,
                                        l1,
                                        l2,
                                        delta,
                                        use_locking)

converter applyProximalGradientDescentToOut*[oT: ApplyProximalGradientDescentT](op: ApplyProximalGradientDescent[oT]): oT = return op.output


type UnicodeDecodeWithOffsets*[oT:oint64] {.header:"generated.h", importcpp:"UnicodeDecodeWithOffsets/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunicodeDecodeWithOffsets[oT: oint64](scope: Scope,
                               input: ostring,
                               input_encoding: cstring,
                               errors: cstring,
                               replacement_char: int64,
                               replace_control_characters: bool): UnicodeDecodeWithOffsets[oT] {.header:"generated.h", importcpp:"UnicodeDecodeWithOffsets(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unicodeDecodeWithOffsets*[oT: oint64](scope: Scope,
                               input: ostring,
                               input_encoding: cstring,
                               errors: cstring = "replace",
                               replacement_char: int64 = 65533,
                               replace_control_characters: bool = false): UnicodeDecodeWithOffsets[oT] =
  return iiunicodeDecodeWithOffsets(scope,
                                    input,
                                    input_encoding,
                                    errors,
                                    replacement_char,
                                    replace_control_characters)

converter unicodeDecodeWithOffsetsToOut*[oT: oint64](op: UnicodeDecodeWithOffsets[oT]): oT = return op.output


type UnicodeTranscode*[oT:ostring] {.header:"generated.h", importcpp:"UnicodeTranscode/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunicodeTranscode[oT: ostring](scope: Scope,
                       input: oT,
                       input_encoding: cstring,
                       output_encoding: cstring,
                       errors: cstring,
                       replacement_char: int64,
                       replace_control_characters: bool): UnicodeTranscode[oT] {.header:"generated.h", importcpp:"UnicodeTranscode(*#, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unicodeTranscode*[oT: ostring](scope: Scope,
                       input: oT,
                       input_encoding: cstring,
                       output_encoding: cstring,
                       errors: cstring = "replace",
                       replacement_char: int64 = 65533,
                       replace_control_characters: bool = false): UnicodeTranscode[oT] =
  return iiunicodeTranscode(scope,
                            input,
                            input_encoding,
                            output_encoding,
                            errors,
                            replacement_char,
                            replace_control_characters)

converter unicodeTranscodeToOut*[oT: ostring](op: UnicodeTranscode[oT]): oT = return op.output

type SubstrT = oint32 | oint64

type Substr*[oT:ostring] {.header:"generated.h", importcpp:"Substr/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisubstr[oT: ostring](scope: Scope,
             input: oT,
             pos: SubstrT,
             len: SubstrT,
             unit: cstring): Substr[oT] {.header:"generated.h", importcpp:"Substr(*#, #, #, #, tensorflow::string(#))", constructor.}

proc substr*[oT: ostring](scope: Scope,
             input: oT,
             pos: SubstrT,
             len: SubstrT,
             unit: cstring = "BYTE"): Substr[oT] =
  return iisubstr(scope,
                  input,
                  pos,
                  len,
                  unit)

converter substrToOut*[oT: ostring](op: Substr[oT]): oT = return op.output


type DecodeBase64*[oT:ostring] {.header:"generated.h", importcpp:"DecodeBase64/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeBase64[oT: ostring](scope: Scope,
                   input: oT): DecodeBase64[oT] {.header:"generated.h", importcpp:"DecodeBase64(*#, #)", constructor.}

proc decodeBase64*[oT: ostring](scope: Scope,
                   input: oT): DecodeBase64[oT] =
  return iidecodeBase64(scope,
                        input)

converter decodeBase64ToOut*[oT: ostring](op: DecodeBase64[oT]): oT = return op.output


type EncodeBase64*[oT:ostring] {.header:"generated.h", importcpp:"EncodeBase64/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiencodeBase64[oT: ostring](scope: Scope,
                   input: oT,
                   pad: bool): EncodeBase64[oT] {.header:"generated.h", importcpp:"EncodeBase64(*#, #, #)", constructor.}

proc encodeBase64*[oT: ostring](scope: Scope,
                   input: oT,
                   pad: bool = false): EncodeBase64[oT] =
  return iiencodeBase64(scope,
                        input,
                        pad)

converter encodeBase64ToOut*[oT: ostring](op: EncodeBase64[oT]): oT = return op.output


type StringSplit*[oT:oint64] {.header:"generated.h", importcpp:"StringSplit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringSplit[oT: oint64](scope: Scope,
                  input: ostring,
                  delimiter: ostring,
                  skip_empty: bool): StringSplit[oT] {.header:"generated.h", importcpp:"StringSplit(*#, #, #, #)", constructor.}

proc stringSplit*[oT: oint64](scope: Scope,
                  input: ostring,
                  delimiter: ostring,
                  skip_empty: bool = true): StringSplit[oT] =
  return iistringSplit(scope,
                       input,
                       delimiter,
                       skip_empty)

converter stringSplitToOut*[oT: oint64](op: StringSplit[oT]): oT = return op.output


type StringJoin*[oT:ostring] {.header:"generated.h", importcpp:"StringJoin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringJoin[oT: ostring](scope: Scope,
                 inputs: oT,
                 separator: cstring): StringJoin[oT] {.header:"generated.h", importcpp:"StringJoin(*#, #, tensorflow::string(#))", constructor.}

proc stringJoin*[oT: ostring](scope: Scope,
                 inputs: oT,
                 separator: cstring): StringJoin[oT] =
  return iistringJoin(scope,
                      inputs,
                      separator)

converter stringJoinToOut*[oT: ostring](op: StringJoin[oT]): oT = return op.output


type ReduceJoin*[oT:ostring] {.header:"generated.h", importcpp:"ReduceJoin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireduceJoin[oT: ostring](scope: Scope,
                 inputs: oT,
                 reduction_indices: oint32,
                 separator: cstring,
                 keep_dims: bool): ReduceJoin[oT] {.header:"generated.h", importcpp:"ReduceJoin(*#, #, #, tensorflow::string(#), #)", constructor.}

proc reduceJoin*[oT: ostring](scope: Scope,
                 inputs: oT,
                 reduction_indices: oint32,
                 separator: cstring,
                 keep_dims: bool = false): ReduceJoin[oT] =
  return iireduceJoin(scope,
                      inputs,
                      reduction_indices,
                      separator,
                      keep_dims)

converter reduceJoinToOut*[oT: ostring](op: ReduceJoin[oT]): oT = return op.output


type StringToHashBucketFast*[oT:oint64] {.header:"generated.h", importcpp:"StringToHashBucketFast/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringToHashBucketFast[oT: oint64](scope: Scope,
                             input: ostring,
                             num_buckets: int64): StringToHashBucketFast[oT] {.header:"generated.h", importcpp:"StringToHashBucketFast(*#, #, #)", constructor.}

proc stringToHashBucketFast*[oT: oint64](scope: Scope,
                             input: ostring,
                             num_buckets: int64 = 0): StringToHashBucketFast[oT] =
  return iistringToHashBucketFast(scope,
                                  input,
                                  num_buckets)

converter stringToHashBucketFastToOut*[oT: oint64](op: StringToHashBucketFast[oT]): oT = return op.output


type StaticRegexReplace*[oT:ostring] {.header:"generated.h", importcpp:"StaticRegexReplace/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistaticRegexReplace[oT: ostring](scope: Scope,
                         input: oT,
                         pattern: cstring,
                         rewrite: cstring,
                         replace_global: bool): StaticRegexReplace[oT] {.header:"generated.h", importcpp:"StaticRegexReplace(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc staticRegexReplace*[oT: ostring](scope: Scope,
                         input: oT,
                         pattern: cstring,
                         rewrite: cstring,
                         replace_global: bool = true): StaticRegexReplace[oT] =
  return iistaticRegexReplace(scope,
                              input,
                              pattern,
                              rewrite,
                              replace_global)

converter staticRegexReplaceToOut*[oT: ostring](op: StaticRegexReplace[oT]): oT = return op.output


type RegexReplace*[oT:ostring] {.header:"generated.h", importcpp:"RegexReplace/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiregexReplace[oT: ostring](scope: Scope,
                   input: oT,
                   pattern: oT,
                   rewrite: oT,
                   replace_global: bool): RegexReplace[oT] {.header:"generated.h", importcpp:"RegexReplace(*#, #, #, #, #)", constructor.}

proc regexReplace*[oT: ostring](scope: Scope,
                   input: oT,
                   pattern: oT,
                   rewrite: oT,
                   replace_global: bool = true): RegexReplace[oT] =
  return iiregexReplace(scope,
                        input,
                        pattern,
                        rewrite,
                        replace_global)

converter regexReplaceToOut*[oT: ostring](op: RegexReplace[oT]): oT = return op.output

type StatelessMultinomialT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type StatelessMultinomialTseed = oint32 | oint64
type StatelessMultinomialoutput_dtype = oint32 | oint64

type StatelessMultinomial*[oT:StatelessMultinomialoutput_dtype] {.header:"generated.h", importcpp:"StatelessMultinomial/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessMultinomial[oT: StatelessMultinomialoutput_dtype](scope: Scope,
                           logits: StatelessMultinomialT,
                           num_samples: oint32,
                           seed: StatelessMultinomialTseed): StatelessMultinomial[oT] {.header:"generated.h", importcpp:"StatelessMultinomial(*#, #, #, #)", constructor.}

proc statelessMultinomial*[oT: StatelessMultinomialoutput_dtype](scope: Scope,
                           logits: StatelessMultinomialT,
                           num_samples: oint32,
                           seed: StatelessMultinomialTseed): StatelessMultinomial[oT] =
  return iistatelessMultinomial(scope,
                                logits,
                                num_samples,
                                seed)

converter statelessMultinomialToOut*[oT: StatelessMultinomialoutput_dtype](op: StatelessMultinomial[oT]): oT = return op.output

type StatelessRandomUniformIntT = oint32 | oint64
type StatelessRandomUniformIntTseed = oint32 | oint64
type StatelessRandomUniformIntdtype = oint32 | oint64

type StatelessRandomUniformInt*[oT:StatelessRandomUniformIntdtype] {.header:"generated.h", importcpp:"StatelessRandomUniformInt/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessRandomUniformInt[oT: StatelessRandomUniformIntdtype](scope: Scope,
                                shape: StatelessRandomUniformIntT,
                                seed: StatelessRandomUniformIntTseed,
                                minval: oT,
                                maxval: oT,
                                dtype: DType): StatelessRandomUniformInt[oT] {.header:"generated.h", importcpp:"StatelessRandomUniformInt(*#, #, #, #, #, #)", constructor.}

proc statelessRandomUniformInt*[oT: StatelessRandomUniformIntdtype](scope: Scope,
                                shape: StatelessRandomUniformIntT,
                                seed: StatelessRandomUniformIntTseed,
                                minval: oT,
                                maxval: oT,
                                dtype: DType = oT[].oTF): StatelessRandomUniformInt[oT] =
  return iistatelessRandomUniformInt(scope,
                                     shape,
                                     seed,
                                     minval,
                                     maxval,
                                     dtype)

converter statelessRandomUniformIntToOut*[oT: StatelessRandomUniformIntdtype](op: StatelessRandomUniformInt[oT]): oT = return op.output

type StatelessRandomNormalT = oint32 | oint64
type StatelessRandomNormalTseed = oint32 | oint64
type StatelessRandomNormaldtype = ohalf | obfloat16 | ofloat | odouble

type StatelessRandomNormal*[oT:StatelessRandomNormaldtype] {.header:"generated.h", importcpp:"StatelessRandomNormal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessRandomNormal[oT: StatelessRandomNormaldtype](scope: Scope,
                            shape: StatelessRandomNormalT,
                            seed: StatelessRandomNormalTseed,
                            dtype: DType): StatelessRandomNormal[oT] {.header:"generated.h", importcpp:"StatelessRandomNormal(*#, #, #, #)", constructor.}

proc statelessRandomNormal*[oT: StatelessRandomNormaldtype](scope: Scope,
                            shape: StatelessRandomNormalT,
                            seed: StatelessRandomNormalTseed,
                            dtype: DType = oT[].oTF): StatelessRandomNormal[oT] =
  return iistatelessRandomNormal(scope,
                                 shape,
                                 seed,
                                 dtype)

converter statelessRandomNormalToOut*[oT: StatelessRandomNormaldtype](op: StatelessRandomNormal[oT]): oT = return op.output

type StatelessRandomUniformT = oint32 | oint64
type StatelessRandomUniformTseed = oint32 | oint64
type StatelessRandomUniformdtype = ohalf | obfloat16 | ofloat | odouble

type StatelessRandomUniform*[oT:StatelessRandomUniformdtype] {.header:"generated.h", importcpp:"StatelessRandomUniform/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessRandomUniform[oT: StatelessRandomUniformdtype](scope: Scope,
                             shape: StatelessRandomUniformT,
                             seed: StatelessRandomUniformTseed,
                             dtype: DType): StatelessRandomUniform[oT] {.header:"generated.h", importcpp:"StatelessRandomUniform(*#, #, #, #)", constructor.}

proc statelessRandomUniform*[oT: StatelessRandomUniformdtype](scope: Scope,
                             shape: StatelessRandomUniformT,
                             seed: StatelessRandomUniformTseed,
                             dtype: DType = oT[].oTF): StatelessRandomUniform[oT] =
  return iistatelessRandomUniform(scope,
                                  shape,
                                  seed,
                                  dtype)

converter statelessRandomUniformToOut*[oT: StatelessRandomUniformdtype](op: StatelessRandomUniform[oT]): oT = return op.output

type CountUpToT = oint32 | oint64

type CountUpTo*[oT:CountUpToT] {.header:"generated.h", importcpp:"CountUpTo/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicountUpTo[oT: CountUpToT](scope: Scope,
                nref: oT,
                limit: int64): CountUpTo[oT] {.header:"generated.h", importcpp:"CountUpTo(*#, #, #)", constructor.}

proc countUpTo*[oT: CountUpToT](scope: Scope,
                nref: oT,
                limit: int64 = 0): CountUpTo[oT] =
  return iicountUpTo(scope,
                     nref,
                     limit)

converter countUpToToOut*[oT: CountUpToT](op: CountUpTo[oT]): oT = return op.output

type ResourceScatterNdUpdateTindices = oint32 | oint64
type ResourceScatterNdUpdateT = oall

type ResourceScatterNdUpdate*{.header:"generated.h", importcpp:"ResourceScatterNdUpdate/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterNdUpdate(scope: Scope,
                              nref: oresource,
                              indices: ResourceScatterNdUpdateTindices,
                              updates: ResourceScatterNdUpdateT,
                              use_locking: bool): ResourceScatterNdUpdate {.header:"generated.h", importcpp:"ResourceScatterNdUpdate(*#, #, #, #, #)", constructor.}

proc resourceScatterNdUpdate*(scope: Scope,
                              nref: oresource,
                              indices: ResourceScatterNdUpdateTindices,
                              updates: ResourceScatterNdUpdateT,
                              use_locking: bool = true): ResourceScatterNdUpdate =
  return iiresourceScatterNdUpdate(scope,
                                   nref,
                                   indices,
                                   updates,
                                   use_locking)



type ScatterNdUpdateT = oall
type ScatterNdUpdateTindices = oint32 | oint64

type ScatterNdUpdate*[oT:ScatterNdUpdateT] {.header:"generated.h", importcpp:"ScatterNdUpdate/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterNdUpdate[oT: ScatterNdUpdateT](scope: Scope,
                      nref: oT,
                      indices: ScatterNdUpdateTindices,
                      updates: oT,
                      use_locking: bool): ScatterNdUpdate[oT] {.header:"generated.h", importcpp:"ScatterNdUpdate(*#, #, #, #, #)", constructor.}

proc scatterNdUpdate*[oT: ScatterNdUpdateT](scope: Scope,
                      nref: oT,
                      indices: ScatterNdUpdateTindices,
                      updates: oT,
                      use_locking: bool = true): ScatterNdUpdate[oT] =
  return iiscatterNdUpdate(scope,
                           nref,
                           indices,
                           updates,
                           use_locking)

converter scatterNdUpdateToOut*[oT: ScatterNdUpdateT](op: ScatterNdUpdate[oT]): oT = return op.output

type ScatterMaxT = ohalf | obfloat16 | ofloat | odouble | oint32 | oint64
type ScatterMaxTindices = oint32 | oint64

type ScatterMax*[oT:ScatterMaxT] {.header:"generated.h", importcpp:"ScatterMax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterMax[oT: ScatterMaxT](scope: Scope,
                 nref: oT,
                 indices: ScatterMaxTindices,
                 updates: oT,
                 use_locking: bool): ScatterMax[oT] {.header:"generated.h", importcpp:"ScatterMax(*#, #, #, #, #)", constructor.}

proc scatterMax*[oT: ScatterMaxT](scope: Scope,
                 nref: oT,
                 indices: ScatterMaxTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterMax[oT] =
  return iiscatterMax(scope,
                      nref,
                      indices,
                      updates,
                      use_locking)

converter scatterMaxToOut*[oT: ScatterMaxT](op: ScatterMax[oT]): oT = return op.output

type ScatterMulT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ScatterMulTindices = oint32 | oint64

type ScatterMul*[oT:ScatterMulT] {.header:"generated.h", importcpp:"ScatterMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterMul[oT: ScatterMulT](scope: Scope,
                 nref: oT,
                 indices: ScatterMulTindices,
                 updates: oT,
                 use_locking: bool): ScatterMul[oT] {.header:"generated.h", importcpp:"ScatterMul(*#, #, #, #, #)", constructor.}

proc scatterMul*[oT: ScatterMulT](scope: Scope,
                 nref: oT,
                 indices: ScatterMulTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterMul[oT] =
  return iiscatterMul(scope,
                      nref,
                      indices,
                      updates,
                      use_locking)

converter scatterMulToOut*[oT: ScatterMulT](op: ScatterMul[oT]): oT = return op.output

type ScatterSubT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ScatterSubTindices = oint32 | oint64

type ScatterSub*[oT:ScatterSubT] {.header:"generated.h", importcpp:"ScatterSub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterSub[oT: ScatterSubT](scope: Scope,
                 nref: oT,
                 indices: ScatterSubTindices,
                 updates: oT,
                 use_locking: bool): ScatterSub[oT] {.header:"generated.h", importcpp:"ScatterSub(*#, #, #, #, #)", constructor.}

proc scatterSub*[oT: ScatterSubT](scope: Scope,
                 nref: oT,
                 indices: ScatterSubTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterSub[oT] =
  return iiscatterSub(scope,
                      nref,
                      indices,
                      updates,
                      use_locking)

converter scatterSubToOut*[oT: ScatterSubT](op: ScatterSub[oT]): oT = return op.output

type ScatterAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ScatterAddTindices = oint32 | oint64

type ScatterAdd*[oT:ScatterAddT] {.header:"generated.h", importcpp:"ScatterAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterAdd[oT: ScatterAddT](scope: Scope,
                 nref: oT,
                 indices: ScatterAddTindices,
                 updates: oT,
                 use_locking: bool): ScatterAdd[oT] {.header:"generated.h", importcpp:"ScatterAdd(*#, #, #, #, #)", constructor.}

proc scatterAdd*[oT: ScatterAddT](scope: Scope,
                 nref: oT,
                 indices: ScatterAddTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterAdd[oT] =
  return iiscatterAdd(scope,
                      nref,
                      indices,
                      updates,
                      use_locking)

converter scatterAddToOut*[oT: ScatterAddT](op: ScatterAdd[oT]): oT = return op.output

type ScatterUpdateT = oall
type ScatterUpdateTindices = oint32 | oint64

type ScatterUpdate*[oT:ScatterUpdateT] {.header:"generated.h", importcpp:"ScatterUpdate/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterUpdate[oT: ScatterUpdateT](scope: Scope,
                    nref: oT,
                    indices: ScatterUpdateTindices,
                    updates: oT,
                    use_locking: bool): ScatterUpdate[oT] {.header:"generated.h", importcpp:"ScatterUpdate(*#, #, #, #, #)", constructor.}

proc scatterUpdate*[oT: ScatterUpdateT](scope: Scope,
                    nref: oT,
                    indices: ScatterUpdateTindices,
                    updates: oT,
                    use_locking: bool = true): ScatterUpdate[oT] =
  return iiscatterUpdate(scope,
                         nref,
                         indices,
                         updates,
                         use_locking)

converter scatterUpdateToOut*[oT: ScatterUpdateT](op: ScatterUpdate[oT]): oT = return op.output

type AssignSubT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type AssignSub*[oT:AssignSubT] {.header:"generated.h", importcpp:"AssignSub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiassignSub[oT: AssignSubT](scope: Scope,
                nref: oT,
                value: oT,
                use_locking: bool): AssignSub[oT] {.header:"generated.h", importcpp:"AssignSub(*#, #, #, #)", constructor.}

proc assignSub*[oT: AssignSubT](scope: Scope,
                nref: oT,
                value: oT,
                use_locking: bool = false): AssignSub[oT] =
  return iiassignSub(scope,
                     nref,
                     value,
                     use_locking)

converter assignSubToOut*[oT: AssignSubT](op: AssignSub[oT]): oT = return op.output

type AssignT = oall

type Assign*[oT:AssignT] {.header:"generated.h", importcpp:"Assign/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiassign[oT: AssignT](scope: Scope,
             nref: oT,
             value: oT,
             use_locking: bool,
             validate_shape: bool): Assign[oT] {.header:"generated.h", importcpp:"Assign(*#, #, #, #, #)", constructor.}

proc assign*[oT: AssignT](scope: Scope,
             nref: oT,
             value: oT,
             use_locking: bool = true,
             validate_shape: bool = true): Assign[oT] =
  return iiassign(scope,
                  nref,
                  value,
                  use_locking,
                  validate_shape)

converter assignToOut*[oT: AssignT](op: Assign[oT]): oT = return op.output

type DestroyTemporaryVariableT = oall

type DestroyTemporaryVariable*[oT:DestroyTemporaryVariableT] {.header:"generated.h", importcpp:"DestroyTemporaryVariable/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidestroyTemporaryVariable[oT: DestroyTemporaryVariableT](scope: Scope,
                               nref: oT,
                               var_name: cstring): DestroyTemporaryVariable[oT] {.header:"generated.h", importcpp:"DestroyTemporaryVariable(*#, #, tensorflow::string(#))", constructor.}

proc destroyTemporaryVariable*[oT: DestroyTemporaryVariableT](scope: Scope,
                               nref: oT,
                               var_name: cstring): DestroyTemporaryVariable[oT] =
  return iidestroyTemporaryVariable(scope,
                                    nref,
                                    var_name)

converter destroyTemporaryVariableToOut*[oT: DestroyTemporaryVariableT](op: DestroyTemporaryVariable[oT]): oT = return op.output

type TemporaryVariabledtype = oall

type TemporaryVariable*[oT:TemporaryVariabledtype] {.header:"generated.h", importcpp:"TemporaryVariable/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitemporaryVariable[oT: TemporaryVariabledtype](scope: Scope,
                        var_name: cstring,
                        shape: TensorShape,
                        dtype: DType): TemporaryVariable[oT] {.header:"generated.h", importcpp:"TemporaryVariable(*#, tensorflow::string(#), #, #)", constructor.}

proc temporaryVariable*[oT: TemporaryVariabledtype](scope: Scope,
                        var_name: cstring,
                        shape: TensorShape = [].shape,
                        dtype: DType = oT[].oTF): TemporaryVariable[oT] =
  return iitemporaryVariable(scope,
                             var_name,
                             shape,
                             dtype)

converter temporaryVariableToOut*[oT: TemporaryVariabledtype](op: TemporaryVariable[oT]): oT = return op.output

type IsVariableInitializeddtype = oall

type IsVariableInitialized*[oT:obool] {.header:"generated.h", importcpp:"IsVariableInitialized/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiisVariableInitialized[oT: obool](scope: Scope,
                            nref: IsVariableInitializeddtype,
                            dtype: DType): IsVariableInitialized[oT] {.header:"generated.h", importcpp:"IsVariableInitialized(*#, #, #)", constructor.}

proc isVariableInitialized*[oT: obool](scope: Scope,
                            nref: IsVariableInitializeddtype,
                            dtype: DType = oT[].oTF): IsVariableInitialized[oT] =
  return iiisVariableInitialized(scope,
                                 nref,
                                 dtype)

converter isVariableInitializedToOut*[oT: obool](op: IsVariableInitialized[oT]): oT = return op.output

type VariableV2dtype = oall

type VariableV2*[oT:VariableV2dtype] {.header:"generated.h", importcpp:"VariableV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iivariableV2[oT: VariableV2dtype](scope: Scope,
                 container: cstring,
                 shared_name: cstring,
                 shape: TensorShape,
                 dtype: DType): VariableV2[oT] {.header:"generated.h", importcpp:"VariableV2(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc variableV2*[oT: VariableV2dtype](scope: Scope,
                 container: cstring,
                 shared_name: cstring,
                 shape: TensorShape = [].shape,
                 dtype: DType = oT[].oTF): VariableV2[oT] =
  return iivariableV2(scope,
                      container,
                      shared_name,
                      shape,
                      dtype)

converter variableV2ToOut*[oT: VariableV2dtype](op: VariableV2[oT]): oT = return op.output


type BatchFFT2D*[oT:ocomplex64] {.header:"generated.h", importcpp:"BatchFFT2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchFFT2D[oT: ocomplex64](scope: Scope,
                 input: oT): BatchFFT2D[oT] {.header:"generated.h", importcpp:"BatchFFT2D(*#, #)", constructor.}

proc batchFFT2D*[oT: ocomplex64](scope: Scope,
                 input: oT): BatchFFT2D[oT] =
  return iibatchFFT2D(scope,
                      input)

converter batchFFT2DToOut*[oT: ocomplex64](op: BatchFFT2D[oT]): oT = return op.output


type BatchFFT*[oT:ocomplex64] {.header:"generated.h", importcpp:"BatchFFT/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchFFT[oT: ocomplex64](scope: Scope,
               input: oT): BatchFFT[oT] {.header:"generated.h", importcpp:"BatchFFT(*#, #)", constructor.}

proc batchFFT*[oT: ocomplex64](scope: Scope,
               input: oT): BatchFFT[oT] =
  return iibatchFFT(scope,
                    input)

converter batchFFTToOut*[oT: ocomplex64](op: BatchFFT[oT]): oT = return op.output


type IRFFT3D*[oT:ofloat] {.header:"generated.h", importcpp:"IRFFT3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiRFFT3D[oT: ofloat](scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT3D[oT] {.header:"generated.h", importcpp:"IRFFT3D(*#, #, #)", constructor.}

proc iRFFT3D*[oT: ofloat](scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT3D[oT] =
  return iiiRFFT3D(scope,
                   input,
                   fft_length)

converter iRFFT3DToOut*[oT: ofloat](op: IRFFT3D[oT]): oT = return op.output


type IRFFT2D*[oT:ofloat] {.header:"generated.h", importcpp:"IRFFT2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiRFFT2D[oT: ofloat](scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT2D[oT] {.header:"generated.h", importcpp:"IRFFT2D(*#, #, #)", constructor.}

proc iRFFT2D*[oT: ofloat](scope: Scope,
              input: ocomplex64,
              fft_length: oint32): IRFFT2D[oT] =
  return iiiRFFT2D(scope,
                   input,
                   fft_length)

converter iRFFT2DToOut*[oT: ofloat](op: IRFFT2D[oT]): oT = return op.output


type RFFT2D*[oT:ocomplex64] {.header:"generated.h", importcpp:"RFFT2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirFFT2D[oT: ocomplex64](scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT2D[oT] {.header:"generated.h", importcpp:"RFFT2D(*#, #, #)", constructor.}

proc rFFT2D*[oT: ocomplex64](scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT2D[oT] =
  return iirFFT2D(scope,
                  input,
                  fft_length)

converter rFFT2DToOut*[oT: ocomplex64](op: RFFT2D[oT]): oT = return op.output


type IRFFT*[oT:ofloat] {.header:"generated.h", importcpp:"IRFFT/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiRFFT[oT: ofloat](scope: Scope,
            input: ocomplex64,
            fft_length: oint32): IRFFT[oT] {.header:"generated.h", importcpp:"IRFFT(*#, #, #)", constructor.}

proc iRFFT*[oT: ofloat](scope: Scope,
            input: ocomplex64,
            fft_length: oint32): IRFFT[oT] =
  return iiiRFFT(scope,
                 input,
                 fft_length)

converter iRFFTToOut*[oT: ofloat](op: IRFFT[oT]): oT = return op.output


type RFFT*[oT:ocomplex64] {.header:"generated.h", importcpp:"RFFT/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirFFT[oT: ocomplex64](scope: Scope,
           input: ofloat,
           fft_length: oint32): RFFT[oT] {.header:"generated.h", importcpp:"RFFT(*#, #, #)", constructor.}

proc rFFT*[oT: ocomplex64](scope: Scope,
           input: ofloat,
           fft_length: oint32): RFFT[oT] =
  return iirFFT(scope,
                input,
                fft_length)

converter rFFTToOut*[oT: ocomplex64](op: RFFT[oT]): oT = return op.output

type FFT3DTcomplex = ocomplex64 | ocomplex128

type FFT3D*[oT:FFT3DTcomplex] {.header:"generated.h", importcpp:"FFT3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifFT3D[oT: FFT3DTcomplex](scope: Scope,
            input: oT): FFT3D[oT] {.header:"generated.h", importcpp:"FFT3D(*#, #)", constructor.}

proc fFT3D*[oT: FFT3DTcomplex](scope: Scope,
            input: oT): FFT3D[oT] =
  return iifFT3D(scope,
                 input)

converter fFT3DToOut*[oT: FFT3DTcomplex](op: FFT3D[oT]): oT = return op.output

type IFFT2DTcomplex = ocomplex64 | ocomplex128

type IFFT2D*[oT:IFFT2DTcomplex] {.header:"generated.h", importcpp:"IFFT2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiFFT2D[oT: IFFT2DTcomplex](scope: Scope,
             input: oT): IFFT2D[oT] {.header:"generated.h", importcpp:"IFFT2D(*#, #)", constructor.}

proc iFFT2D*[oT: IFFT2DTcomplex](scope: Scope,
             input: oT): IFFT2D[oT] =
  return iiiFFT2D(scope,
                  input)

converter iFFT2DToOut*[oT: IFFT2DTcomplex](op: IFFT2D[oT]): oT = return op.output

type FFT2DTcomplex = ocomplex64 | ocomplex128

type FFT2D*[oT:FFT2DTcomplex] {.header:"generated.h", importcpp:"FFT2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifFT2D[oT: FFT2DTcomplex](scope: Scope,
            input: oT): FFT2D[oT] {.header:"generated.h", importcpp:"FFT2D(*#, #)", constructor.}

proc fFT2D*[oT: FFT2DTcomplex](scope: Scope,
            input: oT): FFT2D[oT] =
  return iifFT2D(scope,
                 input)

converter fFT2DToOut*[oT: FFT2DTcomplex](op: FFT2D[oT]): oT = return op.output

type IFFTTcomplex = ocomplex64 | ocomplex128

type IFFT*[oT:IFFTTcomplex] {.header:"generated.h", importcpp:"IFFT/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiFFT[oT: IFFTTcomplex](scope: Scope,
           input: oT): IFFT[oT] {.header:"generated.h", importcpp:"IFFT(*#, #)", constructor.}

proc iFFT*[oT: IFFTTcomplex](scope: Scope,
           input: oT): IFFT[oT] =
  return iiiFFT(scope,
                input)

converter iFFTToOut*[oT: IFFTTcomplex](op: IFFT[oT]): oT = return op.output

type FFTTcomplex = ocomplex64 | ocomplex128

type FFT*[oT:FFTTcomplex] {.header:"generated.h", importcpp:"FFT/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifFT[oT: FFTTcomplex](scope: Scope,
          input: oT): FFT[oT] {.header:"generated.h", importcpp:"FFT(*#, #)", constructor.}

proc fFT*[oT: FFTTcomplex](scope: Scope,
          input: oT): FFT[oT] =
  return iifFT(scope,
               input)

converter fFTToOut*[oT: FFTTcomplex](op: FFT[oT]): oT = return op.output

type WriteScalarSummaryT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type WriteScalarSummary*{.header:"generated.h", importcpp:"WriteScalarSummary/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteScalarSummary(scope: Scope,
                         writer: oresource,
                         step: oint64,
                         tag: ostring,
                         value: WriteScalarSummaryT): WriteScalarSummary {.header:"generated.h", importcpp:"WriteScalarSummary(*#, #, #, #, #)", constructor.}

proc writeScalarSummary*(scope: Scope,
                         writer: oresource,
                         step: oint64,
                         tag: ostring,
                         value: WriteScalarSummaryT): WriteScalarSummary =
  return iiwriteScalarSummary(scope,
                              writer,
                              step,
                              tag,
                              value)




type CloseSummaryWriter*{.header:"generated.h", importcpp:"CloseSummaryWriter/*'0*/".} = object
  operation: Operation[oinvalid]


proc iicloseSummaryWriter(scope: Scope,
                         writer: oresource): CloseSummaryWriter {.header:"generated.h", importcpp:"CloseSummaryWriter(*#, #)", constructor.}

proc closeSummaryWriter*(scope: Scope,
                         writer: oresource): CloseSummaryWriter =
  return iicloseSummaryWriter(scope,
                              writer)




type FlushSummaryWriter*{.header:"generated.h", importcpp:"FlushSummaryWriter/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiflushSummaryWriter(scope: Scope,
                         writer: oresource): FlushSummaryWriter {.header:"generated.h", importcpp:"FlushSummaryWriter(*#, #)", constructor.}

proc flushSummaryWriter*(scope: Scope,
                         writer: oresource): FlushSummaryWriter =
  return iiflushSummaryWriter(scope,
                              writer)




type CreateSummaryDbWriter*{.header:"generated.h", importcpp:"CreateSummaryDbWriter/*'0*/".} = object
  operation: Operation[oinvalid]


proc iicreateSummaryDbWriter(scope: Scope,
                            writer: oresource,
                            db_uri: ostring,
                            experiment_name: ostring,
                            run_name: ostring,
                            user_name: ostring): CreateSummaryDbWriter {.header:"generated.h", importcpp:"CreateSummaryDbWriter(*#, #, #, #, #, #)", constructor.}

proc createSummaryDbWriter*(scope: Scope,
                            writer: oresource,
                            db_uri: ostring,
                            experiment_name: ostring,
                            run_name: ostring,
                            user_name: ostring): CreateSummaryDbWriter =
  return iicreateSummaryDbWriter(scope,
                                 writer,
                                 db_uri,
                                 experiment_name,
                                 run_name,
                                 user_name)




type SummaryWriter*[oT:oresource] {.header:"generated.h", importcpp:"SummaryWriter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisummaryWriter[oT: oresource](scope: Scope,
                    shared_name: cstring,
                    container: cstring): SummaryWriter[oT] {.header:"generated.h", importcpp:"SummaryWriter(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc summaryWriter*[oT: oresource](scope: Scope,
                    shared_name: cstring,
                    container: cstring): SummaryWriter[oT] =
  return iisummaryWriter(scope,
                         shared_name,
                         container)

converter summaryWriterToOut*[oT: oresource](op: SummaryWriter[oT]): oT = return op.output

type SparseFillEmptyRowsGradT = oall

type SparseFillEmptyRowsGrad*[oT:SparseFillEmptyRowsGradT] {.header:"generated.h", importcpp:"SparseFillEmptyRowsGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseFillEmptyRowsGrad[oT: SparseFillEmptyRowsGradT](scope: Scope,
                              reverse_index_map: oint64,
                              grad_values: oT): SparseFillEmptyRowsGrad[oT] {.header:"generated.h", importcpp:"SparseFillEmptyRowsGrad(*#, #, #)", constructor.}

proc sparseFillEmptyRowsGrad*[oT: SparseFillEmptyRowsGradT](scope: Scope,
                              reverse_index_map: oint64,
                              grad_values: oT): SparseFillEmptyRowsGrad[oT] =
  return iisparseFillEmptyRowsGrad(scope,
                                   reverse_index_map,
                                   grad_values)

converter sparseFillEmptyRowsGradToOut*[oT: SparseFillEmptyRowsGradT](op: SparseFillEmptyRowsGrad[oT]): oT = return op.output

type SparseFillEmptyRowsT = oall

type SparseFillEmptyRows*[oT:oint64] {.header:"generated.h", importcpp:"SparseFillEmptyRows/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseFillEmptyRows[oT: oint64](scope: Scope,
                          indices: oT,
                          values: SparseFillEmptyRowsT,
                          dense_shape: oT,
                          default_value: SparseFillEmptyRowsT): SparseFillEmptyRows[oT] {.header:"generated.h", importcpp:"SparseFillEmptyRows(*#, #, #, #, #)", constructor.}

proc sparseFillEmptyRows*[oT: oint64](scope: Scope,
                          indices: oT,
                          values: SparseFillEmptyRowsT,
                          dense_shape: oT,
                          default_value: SparseFillEmptyRowsT): SparseFillEmptyRows[oT] =
  return iisparseFillEmptyRows(scope,
                               indices,
                               values,
                               dense_shape,
                               default_value)

converter sparseFillEmptyRowsToOut*[oT: oint64](op: SparseFillEmptyRows[oT]): oT = return op.output

type SparseSparseMinimumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseSparseMinimum*[oT:oint64] {.header:"generated.h", importcpp:"SparseSparseMinimum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSparseMinimum[oT: oint64](scope: Scope,
                          a_indices: oT,
                          a_values: SparseSparseMinimumT,
                          a_shape: oT,
                          b_indices: oT,
                          b_values: SparseSparseMinimumT,
                          b_shape: oT): SparseSparseMinimum[oT] {.header:"generated.h", importcpp:"SparseSparseMinimum(*#, #, #, #, #, #, #)", constructor.}

proc sparseSparseMinimum*[oT: oint64](scope: Scope,
                          a_indices: oT,
                          a_values: SparseSparseMinimumT,
                          a_shape: oT,
                          b_indices: oT,
                          b_values: SparseSparseMinimumT,
                          b_shape: oT): SparseSparseMinimum[oT] =
  return iisparseSparseMinimum(scope,
                               a_indices,
                               a_values,
                               a_shape,
                               b_indices,
                               b_values,
                               b_shape)

converter sparseSparseMinimumToOut*[oT: oint64](op: SparseSparseMinimum[oT]): oT = return op.output

type SparseSparseMaximumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseSparseMaximum*[oT:oint64] {.header:"generated.h", importcpp:"SparseSparseMaximum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSparseMaximum[oT: oint64](scope: Scope,
                          a_indices: oT,
                          a_values: SparseSparseMaximumT,
                          a_shape: oT,
                          b_indices: oT,
                          b_values: SparseSparseMaximumT,
                          b_shape: oT): SparseSparseMaximum[oT] {.header:"generated.h", importcpp:"SparseSparseMaximum(*#, #, #, #, #, #, #)", constructor.}

proc sparseSparseMaximum*[oT: oint64](scope: Scope,
                          a_indices: oT,
                          a_values: SparseSparseMaximumT,
                          a_shape: oT,
                          b_indices: oT,
                          b_values: SparseSparseMaximumT,
                          b_shape: oT): SparseSparseMaximum[oT] =
  return iisparseSparseMaximum(scope,
                               a_indices,
                               a_values,
                               a_shape,
                               b_indices,
                               b_values,
                               b_shape)

converter sparseSparseMaximumToOut*[oT: oint64](op: SparseSparseMaximum[oT]): oT = return op.output

type SparseSoftmaxT = ofloat | odouble

type SparseSoftmax*[oT:SparseSoftmaxT] {.header:"generated.h", importcpp:"SparseSoftmax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSoftmax[oT: SparseSoftmaxT](scope: Scope,
                    sp_indices: oint64,
                    sp_values: oT,
                    sp_shape: oint64): SparseSoftmax[oT] {.header:"generated.h", importcpp:"SparseSoftmax(*#, #, #, #)", constructor.}

proc sparseSoftmax*[oT: SparseSoftmaxT](scope: Scope,
                    sp_indices: oint64,
                    sp_values: oT,
                    sp_shape: oint64): SparseSoftmax[oT] =
  return iisparseSoftmax(scope,
                         sp_indices,
                         sp_values,
                         sp_shape)

converter sparseSoftmaxToOut*[oT: SparseSoftmaxT](op: SparseSoftmax[oT]): oT = return op.output

type SparseDenseCwiseAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseDenseCwiseAdd*[oT:SparseDenseCwiseAddT] {.header:"generated.h", importcpp:"SparseDenseCwiseAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseDenseCwiseAdd[oT: SparseDenseCwiseAddT](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseAdd[oT] {.header:"generated.h", importcpp:"SparseDenseCwiseAdd(*#, #, #, #, #)", constructor.}

proc sparseDenseCwiseAdd*[oT: SparseDenseCwiseAddT](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseAdd[oT] =
  return iisparseDenseCwiseAdd(scope,
                               sp_indices,
                               sp_values,
                               sp_shape,
                               dense)

converter sparseDenseCwiseAddToOut*[oT: SparseDenseCwiseAddT](op: SparseDenseCwiseAdd[oT]): oT = return op.output

type SparseDenseCwiseDivT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseDenseCwiseDiv*[oT:SparseDenseCwiseDivT] {.header:"generated.h", importcpp:"SparseDenseCwiseDiv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseDenseCwiseDiv[oT: SparseDenseCwiseDivT](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseDiv[oT] {.header:"generated.h", importcpp:"SparseDenseCwiseDiv(*#, #, #, #, #)", constructor.}

proc sparseDenseCwiseDiv*[oT: SparseDenseCwiseDivT](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseDiv[oT] =
  return iisparseDenseCwiseDiv(scope,
                               sp_indices,
                               sp_values,
                               sp_shape,
                               dense)

converter sparseDenseCwiseDivToOut*[oT: SparseDenseCwiseDivT](op: SparseDenseCwiseDiv[oT]): oT = return op.output

type SparseReduceMaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseReduceMax*[oT:SparseReduceMaxT] {.header:"generated.h", importcpp:"SparseReduceMax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseReduceMax[oT: SparseReduceMaxT](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool): SparseReduceMax[oT] {.header:"generated.h", importcpp:"SparseReduceMax(*#, #, #, #, #, #)", constructor.}

proc sparseReduceMax*[oT: SparseReduceMaxT](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool = false): SparseReduceMax[oT] =
  return iisparseReduceMax(scope,
                           input_indices,
                           input_values,
                           input_shape,
                           reduction_axes,
                           keep_dims)

converter sparseReduceMaxToOut*[oT: SparseReduceMaxT](op: SparseReduceMax[oT]): oT = return op.output


type SparseReshape*[oT:oint64] {.header:"generated.h", importcpp:"SparseReshape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseReshape[oT: oint64](scope: Scope,
                    input_indices: oT,
                    input_shape: oT,
                    new_shape: oT): SparseReshape[oT] {.header:"generated.h", importcpp:"SparseReshape(*#, #, #, #)", constructor.}

proc sparseReshape*[oT: oint64](scope: Scope,
                    input_indices: oT,
                    input_shape: oT,
                    new_shape: oT): SparseReshape[oT] =
  return iisparseReshape(scope,
                         input_indices,
                         input_shape,
                         new_shape)

converter sparseReshapeToOut*[oT: oint64](op: SparseReshape[oT]): oT = return op.output

type SparseReorderT = oall

type SparseReorder*[oT:oint64] {.header:"generated.h", importcpp:"SparseReorder/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseReorder[oT: oint64](scope: Scope,
                    input_indices: oT,
                    input_values: SparseReorderT,
                    input_shape: oT): SparseReorder[oT] {.header:"generated.h", importcpp:"SparseReorder(*#, #, #, #)", constructor.}

proc sparseReorder*[oT: oint64](scope: Scope,
                    input_indices: oT,
                    input_values: SparseReorderT,
                    input_shape: oT): SparseReorder[oT] =
  return iisparseReorder(scope,
                         input_indices,
                         input_values,
                         input_shape)

converter sparseReorderToOut*[oT: oint64](op: SparseReorder[oT]): oT = return op.output

type SparseSliceT = oall

type SparseSlice*[oT:oint64] {.header:"generated.h", importcpp:"SparseSlice/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSlice[oT: oint64](scope: Scope,
                  indices: oT,
                  values: SparseSliceT,
                  shape: oT,
                  start: oT,
                  size: oT): SparseSlice[oT] {.header:"generated.h", importcpp:"SparseSlice(*#, #, #, #, #, #)", constructor.}

proc sparseSlice*[oT: oint64](scope: Scope,
                  indices: oT,
                  values: SparseSliceT,
                  shape: oT,
                  start: oT,
                  size: oT): SparseSlice[oT] =
  return iisparseSlice(scope,
                       indices,
                       values,
                       shape,
                       start,
                       size)

converter sparseSliceToOut*[oT: oint64](op: SparseSlice[oT]): oT = return op.output

type SparseSliceGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseSliceGrad*[oT:SparseSliceGradT] {.header:"generated.h", importcpp:"SparseSliceGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSliceGrad[oT: SparseSliceGradT](scope: Scope,
                      backprop_val_grad: oT,
                      input_indices: oint64,
                      input_start: oint64,
                      output_indices: oint64): SparseSliceGrad[oT] {.header:"generated.h", importcpp:"SparseSliceGrad(*#, #, #, #, #)", constructor.}

proc sparseSliceGrad*[oT: SparseSliceGradT](scope: Scope,
                      backprop_val_grad: oT,
                      input_indices: oint64,
                      input_start: oint64,
                      output_indices: oint64): SparseSliceGrad[oT] =
  return iisparseSliceGrad(scope,
                           backprop_val_grad,
                           input_indices,
                           input_start,
                           output_indices)

converter sparseSliceGradToOut*[oT: SparseSliceGradT](op: SparseSliceGrad[oT]): oT = return op.output


type SparseCross*[oT:oint64] {.header:"generated.h", importcpp:"SparseCross/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseCross[oT: oint64](scope: Scope,
                  indices: oT,
                  values: oinvalid,
                  shapes: oT,
                  dense_inputs: oinvalid,
                  sparse_types: ArraySlice[DType],
                  dense_types: ArraySlice[DType],
                  hashed_output: bool,
                  num_buckets: int64,
                  hash_key: int64,
                  out_type: DType,
                  internal_type: DType): SparseCross[oT] {.header:"generated.h", importcpp:"SparseCross(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseCross*[oT: oint64](scope: Scope,
                  indices: oT,
                  values: oinvalid,
                  shapes: oT,
                  dense_inputs: oinvalid,
                  sparse_types: openArray[DType],
                  dense_types: openArray[DType],
                  hashed_output: bool = false,
                  num_buckets: int64 = 0,
                  hash_key: int64 = 0,
                  out_type: DType = DT_INVALID,
                  internal_type: DType = DT_INVALID): SparseCross[oT] =
  return iisparseCross(scope,
                       indices,
                       values,
                       shapes,
                       dense_inputs,
                       newArraySlice(sparse_types),
                       newArraySlice(dense_types),
                       hashed_output,
                       num_buckets,
                       hash_key,
                       out_type,
                       internal_type)

converter sparseCrossToOut*[oT: oint64](op: SparseCross[oT]): oT = return op.output

type SparseConcatT = oall

type SparseConcat*[oT:oint64] {.header:"generated.h", importcpp:"SparseConcat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseConcat[oT: oint64](scope: Scope,
                   indices: oT,
                   values: SparseConcatT,
                   shapes: oT,
                   concat_dim: int64): SparseConcat[oT] {.header:"generated.h", importcpp:"SparseConcat(*#, #, #, #, #)", constructor.}

proc sparseConcat*[oT: oint64](scope: Scope,
                   indices: oT,
                   values: SparseConcatT,
                   shapes: oT,
                   concat_dim: int64 = 0): SparseConcat[oT] =
  return iisparseConcat(scope,
                        indices,
                        values,
                        shapes,
                        concat_dim)

converter sparseConcatToOut*[oT: oint64](op: SparseConcat[oT]): oT = return op.output


type DeserializeManySparse*[oT:oint64] {.header:"generated.h", importcpp:"DeserializeManySparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iideserializeManySparse[oT: oint64](scope: Scope,
                            serialized_sparse: ostring,
                            dtype: DType): DeserializeManySparse[oT] {.header:"generated.h", importcpp:"DeserializeManySparse(*#, #, #)", constructor.}

proc deserializeManySparse*[oT: oint64](scope: Scope,
                            serialized_sparse: ostring,
                            dtype: DType = oT[].oTF): DeserializeManySparse[oT] =
  return iideserializeManySparse(scope,
                                 serialized_sparse,
                                 dtype)

converter deserializeManySparseToOut*[oT: oint64](op: DeserializeManySparse[oT]): oT = return op.output

type SerializeManySparseT = oall
type SerializeManySparseout_type = ostring | ovariant

type SerializeManySparse*[oT:SerializeManySparseout_type] {.header:"generated.h", importcpp:"SerializeManySparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiserializeManySparse[oT: SerializeManySparseout_type](scope: Scope,
                          sparse_indices: oint64,
                          sparse_values: SerializeManySparseT,
                          sparse_shape: oint64): SerializeManySparse[oT] {.header:"generated.h", importcpp:"SerializeManySparse(*#, #, #, #)", constructor.}

proc serializeManySparse*[oT: SerializeManySparseout_type](scope: Scope,
                          sparse_indices: oint64,
                          sparse_values: SerializeManySparseT,
                          sparse_shape: oint64): SerializeManySparse[oT] =
  return iiserializeManySparse(scope,
                               sparse_indices,
                               sparse_values,
                               sparse_shape)

converter serializeManySparseToOut*[oT: SerializeManySparseout_type](op: SerializeManySparse[oT]): oT = return op.output

type SerializeSparseT = oall
type SerializeSparseout_type = ostring | ovariant

type SerializeSparse*[oT:SerializeSparseout_type] {.header:"generated.h", importcpp:"SerializeSparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiserializeSparse[oT: SerializeSparseout_type](scope: Scope,
                      sparse_indices: oint64,
                      sparse_values: SerializeSparseT,
                      sparse_shape: oint64): SerializeSparse[oT] {.header:"generated.h", importcpp:"SerializeSparse(*#, #, #, #)", constructor.}

proc serializeSparse*[oT: SerializeSparseout_type](scope: Scope,
                      sparse_indices: oint64,
                      sparse_values: SerializeSparseT,
                      sparse_shape: oint64): SerializeSparse[oT] =
  return iiserializeSparse(scope,
                           sparse_indices,
                           sparse_values,
                           sparse_shape)

converter serializeSparseToOut*[oT: SerializeSparseout_type](op: SerializeSparse[oT]): oT = return op.output

type SparseAddGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseAddGrad*[oT:SparseAddGradT] {.header:"generated.h", importcpp:"SparseAddGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseAddGrad[oT: SparseAddGradT](scope: Scope,
                    backprop_val_grad: oT,
                    a_indices: oint64,
                    b_indices: oint64,
                    sum_indices: oint64): SparseAddGrad[oT] {.header:"generated.h", importcpp:"SparseAddGrad(*#, #, #, #, #)", constructor.}

proc sparseAddGrad*[oT: SparseAddGradT](scope: Scope,
                    backprop_val_grad: oT,
                    a_indices: oint64,
                    b_indices: oint64,
                    sum_indices: oint64): SparseAddGrad[oT] =
  return iisparseAddGrad(scope,
                         backprop_val_grad,
                         a_indices,
                         b_indices,
                         sum_indices)

converter sparseAddGradToOut*[oT: SparseAddGradT](op: SparseAddGrad[oT]): oT = return op.output

type SparseToSparseSetOperationT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type SparseToSparseSetOperation*[oT:oint64] {.header:"generated.h", importcpp:"SparseToSparseSetOperation/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseToSparseSetOperation[oT: oint64](scope: Scope,
                                 set1_indices: oT,
                                 set1_values: SparseToSparseSetOperationT,
                                 set1_shape: oT,
                                 set2_indices: oT,
                                 set2_values: SparseToSparseSetOperationT,
                                 set2_shape: oT,
                                 set_operation: cstring,
                                 validate_indices: bool): SparseToSparseSetOperation[oT] {.header:"generated.h", importcpp:"SparseToSparseSetOperation(*#, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc sparseToSparseSetOperation*[oT: oint64](scope: Scope,
                                 set1_indices: oT,
                                 set1_values: SparseToSparseSetOperationT,
                                 set1_shape: oT,
                                 set2_indices: oT,
                                 set2_values: SparseToSparseSetOperationT,
                                 set2_shape: oT,
                                 set_operation: cstring,
                                 validate_indices: bool = true): SparseToSparseSetOperation[oT] =
  return iisparseToSparseSetOperation(scope,
                                      set1_indices,
                                      set1_values,
                                      set1_shape,
                                      set2_indices,
                                      set2_values,
                                      set2_shape,
                                      set_operation,
                                      validate_indices)

converter sparseToSparseSetOperationToOut*[oT: oint64](op: SparseToSparseSetOperation[oT]): oT = return op.output

type DenseToDenseSetOperationT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type DenseToDenseSetOperation*[oT:oint64] {.header:"generated.h", importcpp:"DenseToDenseSetOperation/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidenseToDenseSetOperation[oT: oint64](scope: Scope,
                               set1: DenseToDenseSetOperationT,
                               set2: DenseToDenseSetOperationT,
                               set_operation: cstring,
                               validate_indices: bool): DenseToDenseSetOperation[oT] {.header:"generated.h", importcpp:"DenseToDenseSetOperation(*#, #, #, tensorflow::string(#), #)", constructor.}

proc denseToDenseSetOperation*[oT: oint64](scope: Scope,
                               set1: DenseToDenseSetOperationT,
                               set2: DenseToDenseSetOperationT,
                               set_operation: cstring,
                               validate_indices: bool = true): DenseToDenseSetOperation[oT] =
  return iidenseToDenseSetOperation(scope,
                                    set1,
                                    set2,
                                    set_operation,
                                    validate_indices)

converter denseToDenseSetOperationToOut*[oT: oint64](op: DenseToDenseSetOperation[oT]): oT = return op.output

type IRecvtensor_type = oall

type IRecv*[oT:IRecvtensor_type] {.header:"generated.h", importcpp:"_Recv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiRecv[oT: IRecvtensor_type](scope: Scope,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            client_terminated: bool,
            send_device_incarnation: int64): IRecv[oT] {.header:"generated.h", importcpp:"_Recv(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iRecv*[oT: IRecvtensor_type](scope: Scope,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            client_terminated: bool = false,
            send_device_incarnation: int64 = 0): IRecv[oT] =
  return iiiRecv(scope,
                 tensor_name,
                 send_device,
                 recv_device,
                 client_terminated,
                 send_device_incarnation)

converter iRecvToOut*[oT: IRecvtensor_type](op: IRecv[oT]): oT = return op.output

type ISendT = oall

type ISend*{.header:"generated.h", importcpp:"_Send/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiiSend(scope: Scope,
            tensor: ISendT,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            client_terminated: bool,
            send_device_incarnation: int64): ISend {.header:"generated.h", importcpp:"_Send(*#, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iSend*(scope: Scope,
            tensor: ISendT,
            tensor_name: cstring,
            send_device: cstring,
            recv_device: cstring,
            client_terminated: bool = false,
            send_device_incarnation: int64 = 0): ISend =
  return iiiSend(scope,
                 tensor,
                 tensor_name,
                 send_device,
                 recv_device,
                 client_terminated,
                 send_device_incarnation)




type SdcaFprint*[oT:oint64] {.header:"generated.h", importcpp:"SdcaFprint/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisdcaFprint[oT: oint64](scope: Scope,
                 input: ostring): SdcaFprint[oT] {.header:"generated.h", importcpp:"SdcaFprint(*#, #)", constructor.}

proc sdcaFprint*[oT: oint64](scope: Scope,
                 input: ostring): SdcaFprint[oT] =
  return iisdcaFprint(scope,
                      input)

converter sdcaFprintToOut*[oT: oint64](op: SdcaFprint[oT]): oT = return op.output


type SdcaShrinkL1*{.header:"generated.h", importcpp:"SdcaShrinkL1/*'0*/".} = object
  operation: Operation[oinvalid]


proc iisdcaShrinkL1(scope: Scope,
                   weights: ofloat,
                   num_features: int64,
                   l1: float32,
                   l2: float32): SdcaShrinkL1 {.header:"generated.h", importcpp:"SdcaShrinkL1(*#, #, #, #, #)", constructor.}

proc sdcaShrinkL1*(scope: Scope,
                   weights: ofloat,
                   num_features: int64 = 0,
                   l1: float32 = 0.0.float32,
                   l2: float32 = 0.0.float32): SdcaShrinkL1 =
  return iisdcaShrinkL1(scope,
                        weights,
                        num_features,
                        l1,
                        l2)




type SdcaOptimizerV2*[oT:ofloat] {.header:"generated.h", importcpp:"SdcaOptimizerV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisdcaOptimizerV2[oT: ofloat](scope: Scope,
                      sparse_example_indices: oint64,
                      sparse_feature_indices: oint64,
                      sparse_feature_values: oT,
                      dense_features: oT,
                      example_weights: oT,
                      example_labels: oT,
                      sparse_indices: oint64,
                      sparse_weights: oT,
                      dense_weights: oT,
                      example_state_data: oT,
                      loss_type: cstring,
                      adaptive: bool,
                      num_sparse_features: int64,
                      num_sparse_features_with_values: int64,
                      num_dense_features: int64,
                      l1: float32,
                      l2: float32,
                      num_loss_partitions: int64,
                      num_inner_iterations: int64): SdcaOptimizerV2[oT] {.header:"generated.h", importcpp:"SdcaOptimizerV2(*#, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), #, #, #, #, #, #, #, #)", constructor.}

proc sdcaOptimizerV2*[oT: ofloat](scope: Scope,
                      sparse_example_indices: oint64,
                      sparse_feature_indices: oint64,
                      sparse_feature_values: oT,
                      dense_features: oT,
                      example_weights: oT,
                      example_labels: oT,
                      sparse_indices: oint64,
                      sparse_weights: oT,
                      dense_weights: oT,
                      example_state_data: oT,
                      loss_type: cstring,
                      adaptive: bool = false,
                      num_sparse_features: int64 = 0,
                      num_sparse_features_with_values: int64 = 0,
                      num_dense_features: int64 = 0,
                      l1: float32 = 0.0.float32,
                      l2: float32 = 0.0.float32,
                      num_loss_partitions: int64 = 0,
                      num_inner_iterations: int64 = 0): SdcaOptimizerV2[oT] =
  return iisdcaOptimizerV2(scope,
                           sparse_example_indices,
                           sparse_feature_indices,
                           sparse_feature_values,
                           dense_features,
                           example_weights,
                           example_labels,
                           sparse_indices,
                           sparse_weights,
                           dense_weights,
                           example_state_data,
                           loss_type,
                           adaptive,
                           num_sparse_features,
                           num_sparse_features_with_values,
                           num_dense_features,
                           l1,
                           l2,
                           num_loss_partitions,
                           num_inner_iterations)

converter sdcaOptimizerV2ToOut*[oT: ofloat](op: SdcaOptimizerV2[oT]): oT = return op.output


type SdcaOptimizer*[oT:ofloat] {.header:"generated.h", importcpp:"SdcaOptimizer/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisdcaOptimizer[oT: ofloat](scope: Scope,
                    sparse_example_indices: oint64,
                    sparse_feature_indices: oint64,
                    sparse_feature_values: oT,
                    dense_features: oT,
                    example_weights: oT,
                    example_labels: oT,
                    sparse_indices: oint64,
                    sparse_weights: oT,
                    dense_weights: oT,
                    example_state_data: oT,
                    loss_type: cstring,
                    adaptative: bool,
                    num_sparse_features: int64,
                    num_sparse_features_with_values: int64,
                    num_dense_features: int64,
                    l1: float32,
                    l2: float32,
                    num_loss_partitions: int64,
                    num_inner_iterations: int64): SdcaOptimizer[oT] {.header:"generated.h", importcpp:"SdcaOptimizer(*#, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), #, #, #, #, #, #, #, #)", constructor.}

proc sdcaOptimizer*[oT: ofloat](scope: Scope,
                    sparse_example_indices: oint64,
                    sparse_feature_indices: oint64,
                    sparse_feature_values: oT,
                    dense_features: oT,
                    example_weights: oT,
                    example_labels: oT,
                    sparse_indices: oint64,
                    sparse_weights: oT,
                    dense_weights: oT,
                    example_state_data: oT,
                    loss_type: cstring,
                    adaptative: bool = false,
                    num_sparse_features: int64 = 0,
                    num_sparse_features_with_values: int64 = 0,
                    num_dense_features: int64 = 0,
                    l1: float32 = 0.0.float32,
                    l2: float32 = 0.0.float32,
                    num_loss_partitions: int64 = 0,
                    num_inner_iterations: int64 = 0): SdcaOptimizer[oT] =
  return iisdcaOptimizer(scope,
                         sparse_example_indices,
                         sparse_feature_indices,
                         sparse_feature_values,
                         dense_features,
                         example_weights,
                         example_labels,
                         sparse_indices,
                         sparse_weights,
                         dense_weights,
                         example_state_data,
                         loss_type,
                         adaptative,
                         num_sparse_features,
                         num_sparse_features_with_values,
                         num_dense_features,
                         l1,
                         l2,
                         num_loss_partitions,
                         num_inner_iterations)

converter sdcaOptimizerToOut*[oT: ofloat](op: SdcaOptimizer[oT]): oT = return op.output


type EagerPyFunc*[oT:oinvalid] {.header:"generated.h", importcpp:"EagerPyFunc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iieagerPyFunc[oT: oinvalid](scope: Scope,
                  input: oT,
                  token: cstring,
                  Tin: ArraySlice[DType],
                  Tout: ArraySlice[DType]): EagerPyFunc[oT] {.header:"generated.h", importcpp:"EagerPyFunc(*#, #, tensorflow::string(#), #, #)", constructor.}

proc eagerPyFunc*[oT: oinvalid](scope: Scope,
                  input: oT,
                  token: cstring,
                  Tin: openArray[DType],
                  Tout: openArray[DType]): EagerPyFunc[oT] =
  return iieagerPyFunc(scope,
                       input,
                       token,
                       newArraySlice(Tin),
                       newArraySlice(Tout))

converter eagerPyFuncToOut*[oT: oinvalid](op: EagerPyFunc[oT]): oT = return op.output


type PyFuncStateless*[oT:oinvalid] {.header:"generated.h", importcpp:"PyFuncStateless/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipyFuncStateless[oT: oinvalid](scope: Scope,
                      input: oT,
                      token: cstring,
                      Tin: ArraySlice[DType],
                      Tout: ArraySlice[DType]): PyFuncStateless[oT] {.header:"generated.h", importcpp:"PyFuncStateless(*#, #, tensorflow::string(#), #, #)", constructor.}

proc pyFuncStateless*[oT: oinvalid](scope: Scope,
                      input: oT,
                      token: cstring,
                      Tin: openArray[DType],
                      Tout: openArray[DType]): PyFuncStateless[oT] =
  return iipyFuncStateless(scope,
                           input,
                           token,
                           newArraySlice(Tin),
                           newArraySlice(Tout))

converter pyFuncStatelessToOut*[oT: oinvalid](op: PyFuncStateless[oT]): oT = return op.output

type IScopedAllocatorSplitT = oall

type IScopedAllocatorSplit*[oT:IScopedAllocatorSplitT] {.header:"generated.h", importcpp:"_ScopedAllocatorSplit/*'0*/".} = object
  operation: Operation[oT]
  output: olist[oT]

proc iiiScopedAllocatorSplit[oT: IScopedAllocatorSplitT](scope: Scope,
                            concat: oT,
                            split: oT,
                            sa_name: cstring,
                            shapes: ArraySlice[TensorShape],
                            id: int64): IScopedAllocatorSplit[oT] {.header:"generated.h", importcpp:"_ScopedAllocatorSplit(*#, #, #, tensorflow::string(#), #, #)", constructor.}

proc iScopedAllocatorSplit*[oT: IScopedAllocatorSplitT](scope: Scope,
                            concat: oT,
                            split: oT,
                            sa_name: cstring,
                            shapes: openArray[TensorShape],
                            id: int64 = 0): IScopedAllocatorSplit[oT] =
  return iiiScopedAllocatorSplit(scope,
                                 concat,
                                 split,
                                 sa_name,
                                 newArraySlice(shapes),
                                 id)

converter iScopedAllocatorSplitToOutList*[oT: IScopedAllocatorSplitT](op: IScopedAllocatorSplit[oT]): olist[oT] = return op.output

type IScopedAllocatorT = oall

type IScopedAllocator*[oT:IScopedAllocatorT] {.header:"generated.h", importcpp:"_ScopedAllocator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiScopedAllocator[oT: IScopedAllocatorT](scope: Scope,
                       shapes: ArraySlice[TensorShape],
                       sa_name: cstring,
                       shape: TensorShape,
                       expected_call_count: int64,
                       id: int64): IScopedAllocator[oT] {.header:"generated.h", importcpp:"_ScopedAllocator(*#, #, tensorflow::string(#), #, #, #)", constructor.}

proc iScopedAllocator*[oT: IScopedAllocatorT](scope: Scope,
                       shapes: openArray[TensorShape],
                       sa_name: cstring,
                       shape: TensorShape = [].shape,
                       expected_call_count: int64 = 0,
                       id: int64 = 0): IScopedAllocator[oT] =
  return iiiScopedAllocator(scope,
                            newArraySlice(shapes),
                            sa_name,
                            shape,
                            expected_call_count,
                            id)

converter iScopedAllocatorToOut*[oT: IScopedAllocatorT](op: IScopedAllocator[oT]): oT = return op.output


type ConsumeMutexLock*{.header:"generated.h", importcpp:"ConsumeMutexLock/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiconsumeMutexLock(scope: Scope,
                       mutex_lock: ovariant): ConsumeMutexLock {.header:"generated.h", importcpp:"ConsumeMutexLock(*#, #)", constructor.}

proc consumeMutexLock*(scope: Scope,
                       mutex_lock: ovariant): ConsumeMutexLock =
  return iiconsumeMutexLock(scope,
                            mutex_lock)




type MutexLock*[oT:ovariant] {.header:"generated.h", importcpp:"MutexLock/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutexLock[oT: ovariant](scope: Scope,
                mutex: oresource): MutexLock[oT] {.header:"generated.h", importcpp:"MutexLock(*#, #)", constructor.}

proc mutexLock*[oT: ovariant](scope: Scope,
                mutex: oresource): MutexLock[oT] =
  return iimutexLock(scope,
                     mutex)

converter mutexLockToOut*[oT: ovariant](op: MutexLock[oT]): oT = return op.output


type MutexV2*[oT:oresource] {.header:"generated.h", importcpp:"MutexV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutexV2[oT: oresource](scope: Scope,
              container: cstring,
              shared_name: cstring): MutexV2[oT] {.header:"generated.h", importcpp:"MutexV2(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc mutexV2*[oT: oresource](scope: Scope,
              container: cstring,
              shared_name: cstring): MutexV2[oT] =
  return iimutexV2(scope,
                   container,
                   shared_name)

converter mutexV2ToOut*[oT: oresource](op: MutexV2[oT]): oT = return op.output

type ResourceScatterUpdateTindices = oint32 | oint64
type ResourceScatterUpdatedtype = oall

type ResourceScatterUpdate*{.header:"generated.h", importcpp:"ResourceScatterUpdate/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterUpdate(scope: Scope,
                            resource: oresource,
                            indices: ResourceScatterUpdateTindices,
                            updates: ResourceScatterUpdatedtype,
                            dtype: DType): ResourceScatterUpdate {.header:"generated.h", importcpp:"ResourceScatterUpdate(*#, #, #, #, #)", constructor.}

proc resourceScatterUpdate*(scope: Scope,
                            resource: oresource,
                            indices: ResourceScatterUpdateTindices,
                            updates: ResourceScatterUpdatedtype,
                            dtype: DType = DT_INVALID): ResourceScatterUpdate =
  return iiresourceScatterUpdate(scope,
                                 resource,
                                 indices,
                                 updates,
                                 dtype)



type ResourceScatterMinTindices = oint32 | oint64
type ResourceScatterMindtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceScatterMin*{.header:"generated.h", importcpp:"ResourceScatterMin/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterMin(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMinTindices,
                         updates: ResourceScatterMindtype,
                         dtype: DType): ResourceScatterMin {.header:"generated.h", importcpp:"ResourceScatterMin(*#, #, #, #, #)", constructor.}

proc resourceScatterMin*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMinTindices,
                         updates: ResourceScatterMindtype,
                         dtype: DType = DT_INVALID): ResourceScatterMin =
  return iiresourceScatterMin(scope,
                              resource,
                              indices,
                              updates,
                              dtype)



type ResourceScatterAddTindices = oint32 | oint64
type ResourceScatterAdddtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceScatterAdd*{.header:"generated.h", importcpp:"ResourceScatterAdd/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterAdd(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterAddTindices,
                         updates: ResourceScatterAdddtype,
                         dtype: DType): ResourceScatterAdd {.header:"generated.h", importcpp:"ResourceScatterAdd(*#, #, #, #, #)", constructor.}

proc resourceScatterAdd*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterAddTindices,
                         updates: ResourceScatterAdddtype,
                         dtype: DType = DT_INVALID): ResourceScatterAdd =
  return iiresourceScatterAdd(scope,
                              resource,
                              indices,
                              updates,
                              dtype)



type VariableShapeout_type = oint32 | oint64

type VariableShape*[oT:VariableShapeout_type] {.header:"generated.h", importcpp:"VariableShape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iivariableShape[oT: VariableShapeout_type](scope: Scope,
                    input: oresource): VariableShape[oT] {.header:"generated.h", importcpp:"VariableShape(*#, #)", constructor.}

proc variableShape*[oT: VariableShapeout_type](scope: Scope,
                    input: oresource): VariableShape[oT] =
  return iivariableShape(scope,
                         input)

converter variableShapeToOut*[oT: VariableShapeout_type](op: VariableShape[oT]): oT = return op.output


type RemoteFusedGraphExecute*[oT:oinvalid] {.header:"generated.h", importcpp:"RemoteFusedGraphExecute/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiremoteFusedGraphExecute[oT: oinvalid](scope: Scope,
                              inputs: oT,
                              Tinputs: ArraySlice[DType],
                              Toutputs: ArraySlice[DType],
                              serialized_remote_fused_graph_execute_info: cstring): RemoteFusedGraphExecute[oT] {.header:"generated.h", importcpp:"RemoteFusedGraphExecute(*#, #, #, #, tensorflow::string(#))", constructor.}

proc remoteFusedGraphExecute*[oT: oinvalid](scope: Scope,
                              inputs: oT,
                              Tinputs: openArray[DType],
                              Toutputs: openArray[DType],
                              serialized_remote_fused_graph_execute_info: cstring): RemoteFusedGraphExecute[oT] =
  return iiremoteFusedGraphExecute(scope,
                                   inputs,
                                   newArraySlice(Tinputs),
                                   newArraySlice(Toutputs),
                                   serialized_remote_fused_graph_execute_info)

converter remoteFusedGraphExecuteToOut*[oT: oinvalid](op: RemoteFusedGraphExecute[oT]): oT = return op.output

type RandomPoissonV2S = oint32 | oint64
type RandomPoissonV2R = ohalf | ofloat | odouble | oint32 | oint64
type RandomPoissonV2dtype = ohalf | ofloat | odouble | oint32 | oint64

type RandomPoissonV2*[oT:RandomPoissonV2dtype] {.header:"generated.h", importcpp:"RandomPoissonV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomPoissonV2[oT: RandomPoissonV2dtype](scope: Scope,
                      shape: RandomPoissonV2S,
                      rate: RandomPoissonV2R,
                      seed: int64,
                      seed2: int64,
                      dtype: DType): RandomPoissonV2[oT] {.header:"generated.h", importcpp:"RandomPoissonV2(*#, #, #, #, #, #)", constructor.}

proc randomPoissonV2*[oT: RandomPoissonV2dtype](scope: Scope,
                      shape: RandomPoissonV2S,
                      rate: RandomPoissonV2R,
                      seed: int64 = 0,
                      seed2: int64 = 0,
                      dtype: DType = oT[].oTF): RandomPoissonV2[oT] =
  return iirandomPoissonV2(scope,
                           shape,
                           rate,
                           seed,
                           seed2,
                           dtype)

converter randomPoissonV2ToOut*[oT: RandomPoissonV2dtype](op: RandomPoissonV2[oT]): oT = return op.output

type RandomPoissonS = oint32 | oint64
type RandomPoissondtype = ohalf | ofloat | odouble

type RandomPoisson*[oT:RandomPoissondtype] {.header:"generated.h", importcpp:"RandomPoisson/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomPoisson[oT: RandomPoissondtype](scope: Scope,
                    shape: RandomPoissonS,
                    rate: oT,
                    seed: int64,
                    seed2: int64,
                    dtype: DType): RandomPoisson[oT] {.header:"generated.h", importcpp:"RandomPoisson(*#, #, #, #, #, #)", constructor.}

proc randomPoisson*[oT: RandomPoissondtype](scope: Scope,
                    shape: RandomPoissonS,
                    rate: oT,
                    seed: int64 = 0,
                    seed2: int64 = 0,
                    dtype: DType = oT[].oTF): RandomPoisson[oT] =
  return iirandomPoisson(scope,
                         shape,
                         rate,
                         seed,
                         seed2,
                         dtype)

converter randomPoissonToOut*[oT: RandomPoissondtype](op: RandomPoisson[oT]): oT = return op.output

type RandomGammaGradT = ofloat | odouble

type RandomGammaGrad*[oT:RandomGammaGradT] {.header:"generated.h", importcpp:"RandomGammaGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomGammaGrad[oT: RandomGammaGradT](scope: Scope,
                      alpha: oT,
                      sample: oT): RandomGammaGrad[oT] {.header:"generated.h", importcpp:"RandomGammaGrad(*#, #, #)", constructor.}

proc randomGammaGrad*[oT: RandomGammaGradT](scope: Scope,
                      alpha: oT,
                      sample: oT): RandomGammaGrad[oT] =
  return iirandomGammaGrad(scope,
                           alpha,
                           sample)

converter randomGammaGradToOut*[oT: RandomGammaGradT](op: RandomGammaGrad[oT]): oT = return op.output

type MultinomialT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type Multinomialoutput_dtype = oint32 | oint64

type Multinomial*[oT:Multinomialoutput_dtype] {.header:"generated.h", importcpp:"Multinomial/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimultinomial[oT: Multinomialoutput_dtype](scope: Scope,
                  logits: MultinomialT,
                  num_samples: oint32,
                  seed: int64,
                  seed2: int64): Multinomial[oT] {.header:"generated.h", importcpp:"Multinomial(*#, #, #, #, #)", constructor.}

proc multinomial*[oT: Multinomialoutput_dtype](scope: Scope,
                  logits: MultinomialT,
                  num_samples: oint32,
                  seed: int64 = 0,
                  seed2: int64 = 0): Multinomial[oT] =
  return iimultinomial(scope,
                       logits,
                       num_samples,
                       seed,
                       seed2)

converter multinomialToOut*[oT: Multinomialoutput_dtype](op: Multinomial[oT]): oT = return op.output

type RandomShuffleT = oall

type RandomShuffle*[oT:RandomShuffleT] {.header:"generated.h", importcpp:"RandomShuffle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomShuffle[oT: RandomShuffleT](scope: Scope,
                    value: oT,
                    seed: int64,
                    seed2: int64): RandomShuffle[oT] {.header:"generated.h", importcpp:"RandomShuffle(*#, #, #, #)", constructor.}

proc randomShuffle*[oT: RandomShuffleT](scope: Scope,
                    value: oT,
                    seed: int64 = 0,
                    seed2: int64 = 0): RandomShuffle[oT] =
  return iirandomShuffle(scope,
                         value,
                         seed,
                         seed2)

converter randomShuffleToOut*[oT: RandomShuffleT](op: RandomShuffle[oT]): oT = return op.output

type ParameterizedTruncatedNormalT = oint32 | oint64
type ParameterizedTruncatedNormaldtype = ohalf | obfloat16 | ofloat | odouble

type ParameterizedTruncatedNormal*[oT:ParameterizedTruncatedNormaldtype] {.header:"generated.h", importcpp:"ParameterizedTruncatedNormal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparameterizedTruncatedNormal[oT: ParameterizedTruncatedNormaldtype](scope: Scope,
                                   shape: ParameterizedTruncatedNormalT,
                                   means: oT,
                                   stdevs: oT,
                                   minvals: oT,
                                   maxvals: oT,
                                   seed: int64,
                                   seed2: int64,
                                   dtype: DType): ParameterizedTruncatedNormal[oT] {.header:"generated.h", importcpp:"ParameterizedTruncatedNormal(*#, #, #, #, #, #, #, #, #)", constructor.}

proc parameterizedTruncatedNormal*[oT: ParameterizedTruncatedNormaldtype](scope: Scope,
                                   shape: ParameterizedTruncatedNormalT,
                                   means: oT,
                                   stdevs: oT,
                                   minvals: oT,
                                   maxvals: oT,
                                   seed: int64 = 0,
                                   seed2: int64 = 0,
                                   dtype: DType = oT[].oTF): ParameterizedTruncatedNormal[oT] =
  return iiparameterizedTruncatedNormal(scope,
                                        shape,
                                        means,
                                        stdevs,
                                        minvals,
                                        maxvals,
                                        seed,
                                        seed2,
                                        dtype)

converter parameterizedTruncatedNormalToOut*[oT: ParameterizedTruncatedNormaldtype](op: ParameterizedTruncatedNormal[oT]): oT = return op.output

type RandomUniformIntT = oint32 | oint64
type RandomUniformIntTout = oint32 | oint64

type RandomUniformInt*[oT:RandomUniformIntTout] {.header:"generated.h", importcpp:"RandomUniformInt/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomUniformInt[oT: RandomUniformIntTout](scope: Scope,
                       shape: RandomUniformIntT,
                       minval: oT,
                       maxval: oT,
                       seed: int64,
                       seed2: int64): RandomUniformInt[oT] {.header:"generated.h", importcpp:"RandomUniformInt(*#, #, #, #, #, #)", constructor.}

proc randomUniformInt*[oT: RandomUniformIntTout](scope: Scope,
                       shape: RandomUniformIntT,
                       minval: oT,
                       maxval: oT,
                       seed: int64 = 0,
                       seed2: int64 = 0): RandomUniformInt[oT] =
  return iirandomUniformInt(scope,
                            shape,
                            minval,
                            maxval,
                            seed,
                            seed2)

converter randomUniformIntToOut*[oT: RandomUniformIntTout](op: RandomUniformInt[oT]): oT = return op.output

type RandomUniformT = oint32 | oint64
type RandomUniformdtype = ohalf | obfloat16 | ofloat | odouble

type RandomUniform*[oT:RandomUniformdtype] {.header:"generated.h", importcpp:"RandomUniform/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomUniform[oT: RandomUniformdtype](scope: Scope,
                    shape: RandomUniformT,
                    seed: int64,
                    seed2: int64,
                    dtype: DType): RandomUniform[oT] {.header:"generated.h", importcpp:"RandomUniform(*#, #, #, #, #)", constructor.}

proc randomUniform*[oT: RandomUniformdtype](scope: Scope,
                    shape: RandomUniformT,
                    seed: int64 = 0,
                    seed2: int64 = 0,
                    dtype: DType = oT[].oTF): RandomUniform[oT] =
  return iirandomUniform(scope,
                         shape,
                         seed,
                         seed2,
                         dtype)

converter randomUniformToOut*[oT: RandomUniformdtype](op: RandomUniform[oT]): oT = return op.output

type RaggedGatherTvalues = oall
type RaggedGatherTindices = oint32 | oint64

type RaggedGather*[oT:oint64] {.header:"generated.h", importcpp:"RaggedGather/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiraggedGather[oT: oint64](scope: Scope,
                   params_nested_splits: oT,
                   params_dense_values: RaggedGatherTvalues,
                   indices: RaggedGatherTindices,
                   OUTPUT_RAGGED_RANK: int64,
                   PARAMS_RAGGED_RANK: int64): RaggedGather[oT] {.header:"generated.h", importcpp:"RaggedGather(*#, #, #, #, #, #)", constructor.}

proc raggedGather*[oT: oint64](scope: Scope,
                   params_nested_splits: oT,
                   params_dense_values: RaggedGatherTvalues,
                   indices: RaggedGatherTindices,
                   OUTPUT_RAGGED_RANK: int64 = 0,
                   PARAMS_RAGGED_RANK: int64 = 0): RaggedGather[oT] =
  return iiraggedGather(scope,
                        params_nested_splits,
                        params_dense_values,
                        indices,
                        OUTPUT_RAGGED_RANK,
                        PARAMS_RAGGED_RANK)

converter raggedGatherToOut*[oT: oint64](op: RaggedGather[oT]): oT = return op.output


type BatchIFFT2D*[oT:ocomplex64] {.header:"generated.h", importcpp:"BatchIFFT2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchIFFT2D[oT: ocomplex64](scope: Scope,
                  input: oT): BatchIFFT2D[oT] {.header:"generated.h", importcpp:"BatchIFFT2D(*#, #)", constructor.}

proc batchIFFT2D*[oT: ocomplex64](scope: Scope,
                  input: oT): BatchIFFT2D[oT] =
  return iibatchIFFT2D(scope,
                       input)

converter batchIFFT2DToOut*[oT: ocomplex64](op: BatchIFFT2D[oT]): oT = return op.output

type StringToNumberout_type = ofloat | odouble | oint32 | oint64

type StringToNumber*[oT:StringToNumberout_type] {.header:"generated.h", importcpp:"StringToNumber/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringToNumber[oT: StringToNumberout_type](scope: Scope,
                     string_tensor: ostring): StringToNumber[oT] {.header:"generated.h", importcpp:"StringToNumber(*#, #)", constructor.}

proc stringToNumber*[oT: StringToNumberout_type](scope: Scope,
                     string_tensor: ostring): StringToNumber[oT] =
  return iistringToNumber(scope,
                          string_tensor)

converter stringToNumberToOut*[oT: StringToNumberout_type](op: StringToNumber[oT]): oT = return op.output


type DecodeJSONExample*[oT:ostring] {.header:"generated.h", importcpp:"DecodeJSONExample/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeJSONExample[oT: ostring](scope: Scope,
                        json_examples: oT): DecodeJSONExample[oT] {.header:"generated.h", importcpp:"DecodeJSONExample(*#, #)", constructor.}

proc decodeJSONExample*[oT: ostring](scope: Scope,
                        json_examples: oT): DecodeJSONExample[oT] =
  return iidecodeJSONExample(scope,
                             json_examples)

converter decodeJSONExampleToOut*[oT: ostring](op: DecodeJSONExample[oT]): oT = return op.output

type SerializeTensorT = oall

type SerializeTensor*[oT:ostring] {.header:"generated.h", importcpp:"SerializeTensor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiserializeTensor[oT: ostring](scope: Scope,
                      tensor: SerializeTensorT): SerializeTensor[oT] {.header:"generated.h", importcpp:"SerializeTensor(*#, #)", constructor.}

proc serializeTensor*[oT: ostring](scope: Scope,
                      tensor: SerializeTensorT): SerializeTensor[oT] =
  return iiserializeTensor(scope,
                           tensor)

converter serializeTensorToOut*[oT: ostring](op: SerializeTensor[oT]): oT = return op.output

type ParseTensorout_type = oall

type ParseTensor*[oT:ParseTensorout_type] {.header:"generated.h", importcpp:"ParseTensor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparseTensor[oT: ParseTensorout_type](scope: Scope,
                  serialized: ostring): ParseTensor[oT] {.header:"generated.h", importcpp:"ParseTensor(*#, #)", constructor.}

proc parseTensor*[oT: ParseTensorout_type](scope: Scope,
                  serialized: ostring): ParseTensor[oT] =
  return iiparseTensor(scope,
                       serialized)

converter parseTensorToOut*[oT: ParseTensorout_type](op: ParseTensor[oT]): oT = return op.output


type ParseSequenceExample*[oT:oint64] {.header:"generated.h", importcpp:"ParseSequenceExample/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparseSequenceExample[oT: oint64](scope: Scope,
                           serialized: ostring,
                           debug_name: ostring,
                           context_dense_defaults: oinvalid,
                           feature_list_dense_missing_assumed_empty: ArraySlice[cstring],
                           context_sparse_keys: ArraySlice[cstring],
                           context_dense_keys: ArraySlice[cstring],
                           feature_list_sparse_keys: ArraySlice[cstring],
                           feature_list_dense_keys: ArraySlice[cstring],
                           context_sparse_types: ArraySlice[DType],
                           Tcontext_dense: ArraySlice[DType],
                           feature_list_dense_types: ArraySlice[DType],
                           context_dense_shapes: ArraySlice[TensorShape],
                           feature_list_sparse_types: ArraySlice[DType],
                           feature_list_dense_shapes: ArraySlice[TensorShape],
                           Ncontext_sparse: int64,
                           Ncontext_dense: int64,
                           Nfeature_list_sparse: int64,
                           Nfeature_list_dense: int64): ParseSequenceExample[oT] {.header:"generated.h", importcpp:"ParseSequenceExample(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parseSequenceExample*[oT: oint64](scope: Scope,
                           serialized: ostring,
                           debug_name: ostring,
                           context_dense_defaults: oinvalid,
                           feature_list_dense_missing_assumed_empty: openArray[cstring],
                           context_sparse_keys: openArray[cstring],
                           context_dense_keys: openArray[cstring],
                           feature_list_sparse_keys: openArray[cstring],
                           feature_list_dense_keys: openArray[cstring],
                           context_sparse_types: openArray[DType],
                           Tcontext_dense: openArray[DType],
                           feature_list_dense_types: openArray[DType],
                           context_dense_shapes: openArray[TensorShape],
                           feature_list_sparse_types: openArray[DType],
                           feature_list_dense_shapes: openArray[TensorShape],
                           Ncontext_sparse: int64 = 0,
                           Ncontext_dense: int64 = 0,
                           Nfeature_list_sparse: int64 = 0,
                           Nfeature_list_dense: int64 = 0): ParseSequenceExample[oT] =
  return iiparseSequenceExample(scope,
                                serialized,
                                debug_name,
                                context_dense_defaults,
                                newArraySlice(feature_list_dense_missing_assumed_empty),
                                newArraySlice(context_sparse_keys),
                                newArraySlice(context_dense_keys),
                                newArraySlice(feature_list_sparse_keys),
                                newArraySlice(feature_list_dense_keys),
                                newArraySlice(context_sparse_types),
                                newArraySlice(Tcontext_dense),
                                newArraySlice(feature_list_dense_types),
                                newArraySlice(context_dense_shapes),
                                newArraySlice(feature_list_sparse_types),
                                newArraySlice(feature_list_dense_shapes),
                                Ncontext_sparse,
                                Ncontext_dense,
                                Nfeature_list_sparse,
                                Nfeature_list_dense)

converter parseSequenceExampleToOut*[oT: oint64](op: ParseSequenceExample[oT]): oT = return op.output


type ParseExample*[oT:oint64] {.header:"generated.h", importcpp:"ParseExample/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparseExample[oT: oint64](scope: Scope,
                   serialized: ostring,
                   names: ostring,
                   sparse_keys: ostring,
                   dense_keys: ostring,
                   dense_defaults: oinvalid,
                   sparse_types: ArraySlice[DType],
                   Tdense: ArraySlice[DType],
                   dense_shapes: ArraySlice[TensorShape],
                   Nsparse: int64,
                   Ndense: int64): ParseExample[oT] {.header:"generated.h", importcpp:"ParseExample(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parseExample*[oT: oint64](scope: Scope,
                   serialized: ostring,
                   names: ostring,
                   sparse_keys: ostring,
                   dense_keys: ostring,
                   dense_defaults: oinvalid,
                   sparse_types: openArray[DType],
                   Tdense: openArray[DType],
                   dense_shapes: openArray[TensorShape],
                   Nsparse: int64 = 0,
                   Ndense: int64 = 0): ParseExample[oT] =
  return iiparseExample(scope,
                        serialized,
                        names,
                        sparse_keys,
                        dense_keys,
                        dense_defaults,
                        newArraySlice(sparse_types),
                        newArraySlice(Tdense),
                        newArraySlice(dense_shapes),
                        Nsparse,
                        Ndense)

converter parseExampleToOut*[oT: oint64](op: ParseExample[oT]): oT = return op.output


type DecodeCompressed*[oT:ostring] {.header:"generated.h", importcpp:"DecodeCompressed/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeCompressed[oT: ostring](scope: Scope,
                       bytes: oT,
                       compression_type: cstring): DecodeCompressed[oT] {.header:"generated.h", importcpp:"DecodeCompressed(*#, #, tensorflow::string(#))", constructor.}

proc decodeCompressed*[oT: ostring](scope: Scope,
                       bytes: oT,
                       compression_type: cstring): DecodeCompressed[oT] =
  return iidecodeCompressed(scope,
                            bytes,
                            compression_type)

converter decodeCompressedToOut*[oT: ostring](op: DecodeCompressed[oT]): oT = return op.output

type QuantizedBatchNormWithGlobalNormalizationTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedBatchNormWithGlobalNormalizationout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedBatchNormWithGlobalNormalization*[oT:QuantizedBatchNormWithGlobalNormalizationout_type] {.header:"generated.h", importcpp:"QuantizedBatchNormWithGlobalNormalization/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedBatchNormWithGlobalNormalization[oT: QuantizedBatchNormWithGlobalNormalizationout_type](scope: Scope,
                                                t: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                t_min: ofloat,
                                                t_max: ofloat,
                                                m: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                m_min: ofloat,
                                                m_max: ofloat,
                                                v: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                v_min: ofloat,
                                                v_max: ofloat,
                                                beta: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                beta_min: ofloat,
                                                beta_max: ofloat,
                                                gamma: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                gamma_min: ofloat,
                                                gamma_max: ofloat,
                                                scale_after_normalization: bool,
                                                variance_epsilon: float32): QuantizedBatchNormWithGlobalNormalization[oT] {.header:"generated.h", importcpp:"QuantizedBatchNormWithGlobalNormalization(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc quantizedBatchNormWithGlobalNormalization*[oT: QuantizedBatchNormWithGlobalNormalizationout_type](scope: Scope,
                                                t: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                t_min: ofloat,
                                                t_max: ofloat,
                                                m: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                m_min: ofloat,
                                                m_max: ofloat,
                                                v: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                v_min: ofloat,
                                                v_max: ofloat,
                                                beta: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                beta_min: ofloat,
                                                beta_max: ofloat,
                                                gamma: QuantizedBatchNormWithGlobalNormalizationTinput,
                                                gamma_min: ofloat,
                                                gamma_max: ofloat,
                                                scale_after_normalization: bool = false,
                                                variance_epsilon: float32 = 0.0.float32): QuantizedBatchNormWithGlobalNormalization[oT] =
  return iiquantizedBatchNormWithGlobalNormalization(scope,
                                                     t,
                                                     t_min,
                                                     t_max,
                                                     m,
                                                     m_min,
                                                     m_max,
                                                     v,
                                                     v_min,
                                                     v_max,
                                                     beta,
                                                     beta_min,
                                                     beta_max,
                                                     gamma,
                                                     gamma_min,
                                                     gamma_max,
                                                     scale_after_normalization,
                                                     variance_epsilon)

converter quantizedBatchNormWithGlobalNormalizationToOut*[oT: QuantizedBatchNormWithGlobalNormalizationout_type](op: QuantizedBatchNormWithGlobalNormalization[oT]): oT = return op.output

type QuantizedReluXTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedReluXout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedReluX*[oT:QuantizedReluXout_type] {.header:"generated.h", importcpp:"QuantizedReluX/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedReluX[oT: QuantizedReluXout_type](scope: Scope,
                     features: QuantizedReluXTinput,
                     max_value: ofloat,
                     min_features: ofloat,
                     max_features: ofloat): QuantizedReluX[oT] {.header:"generated.h", importcpp:"QuantizedReluX(*#, #, #, #, #)", constructor.}

proc quantizedReluX*[oT: QuantizedReluXout_type](scope: Scope,
                     features: QuantizedReluXTinput,
                     max_value: ofloat,
                     min_features: ofloat,
                     max_features: ofloat): QuantizedReluX[oT] =
  return iiquantizedReluX(scope,
                          features,
                          max_value,
                          min_features,
                          max_features)

converter quantizedReluXToOut*[oT: QuantizedReluXout_type](op: QuantizedReluX[oT]): oT = return op.output

type QuantizedReluTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedReluout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedRelu*[oT:QuantizedReluout_type] {.header:"generated.h", importcpp:"QuantizedRelu/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedRelu[oT: QuantizedReluout_type](scope: Scope,
                    features: QuantizedReluTinput,
                    min_features: ofloat,
                    max_features: ofloat): QuantizedRelu[oT] {.header:"generated.h", importcpp:"QuantizedRelu(*#, #, #, #)", constructor.}

proc quantizedRelu*[oT: QuantizedReluout_type](scope: Scope,
                    features: QuantizedReluTinput,
                    min_features: ofloat,
                    max_features: ofloat): QuantizedRelu[oT] =
  return iiquantizedRelu(scope,
                         features,
                         min_features,
                         max_features)

converter quantizedReluToOut*[oT: QuantizedReluout_type](op: QuantizedRelu[oT]): oT = return op.output

type ScatterNdSubT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ScatterNdSubTindices = oint32 | oint64

type ScatterNdSub*[oT:ScatterNdSubT] {.header:"generated.h", importcpp:"ScatterNdSub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterNdSub[oT: ScatterNdSubT](scope: Scope,
                   nref: oT,
                   indices: ScatterNdSubTindices,
                   updates: oT,
                   use_locking: bool): ScatterNdSub[oT] {.header:"generated.h", importcpp:"ScatterNdSub(*#, #, #, #, #)", constructor.}

proc scatterNdSub*[oT: ScatterNdSubT](scope: Scope,
                   nref: oT,
                   indices: ScatterNdSubTindices,
                   updates: oT,
                   use_locking: bool = false): ScatterNdSub[oT] =
  return iiscatterNdSub(scope,
                        nref,
                        indices,
                        updates,
                        use_locking)

converter scatterNdSubToOut*[oT: ScatterNdSubT](op: ScatterNdSub[oT]): oT = return op.output

type QuantizedConv2DTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedConv2DTfilter = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedConv2Dout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedConv2D*[oT:QuantizedConv2Dout_type] {.header:"generated.h", importcpp:"QuantizedConv2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedConv2D[oT: QuantizedConv2Dout_type](scope: Scope,
                      input: QuantizedConv2DTinput,
                      filter: QuantizedConv2DTfilter,
                      min_input: ofloat,
                      max_input: ofloat,
                      min_filter: ofloat,
                      max_filter: ofloat,
                      strides: ArraySlice[int],
                      padding: cstring,
                      dilations: ArraySlice[int]): QuantizedConv2D[oT] {.header:"generated.h", importcpp:"QuantizedConv2D(*#, #, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc quantizedConv2D*[oT: QuantizedConv2Dout_type](scope: Scope,
                      input: QuantizedConv2DTinput,
                      filter: QuantizedConv2DTfilter,
                      min_input: ofloat,
                      max_input: ofloat,
                      min_filter: ofloat,
                      max_filter: ofloat,
                      strides: openArray[int],
                      padding: cstring,
                      dilations: openArray[int] = [1, 1, 1, 1]): QuantizedConv2D[oT] =
  return iiquantizedConv2D(scope,
                           input,
                           filter,
                           min_input,
                           max_input,
                           min_filter,
                           max_filter,
                           newArraySlice(strides),
                           padding,
                           newArraySlice(dilations))

converter quantizedConv2DToOut*[oT: QuantizedConv2Dout_type](op: QuantizedConv2D[oT]): oT = return op.output

type ReciprocalT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Reciprocal*[oT:ReciprocalT] {.header:"generated.h", importcpp:"Reciprocal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireciprocal[oT: ReciprocalT](scope: Scope,
                 x: oT): Reciprocal[oT] {.header:"generated.h", importcpp:"Reciprocal(*#, #)", constructor.}

proc reciprocal*[oT: ReciprocalT](scope: Scope,
                 x: oT): Reciprocal[oT] =
  return iireciprocal(scope,
                      x)

converter reciprocalToOut*[oT: ReciprocalT](op: Reciprocal[oT]): oT = return op.output

type FractionalMaxPoolT = ofloat | odouble | oint32 | oint64

type FractionalMaxPool*[oT:FractionalMaxPoolT] {.header:"generated.h", importcpp:"FractionalMaxPool/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifractionalMaxPool[oT: FractionalMaxPoolT](scope: Scope,
                        value: oT,
                        pooling_ratio: ArraySlice[float32],
                        pseudo_random: bool,
                        overlapping: bool,
                        deterministic: bool,
                        seed: int64,
                        seed2: int64): FractionalMaxPool[oT] {.header:"generated.h", importcpp:"FractionalMaxPool(*#, #, #, #, #, #, #, #)", constructor.}

proc fractionalMaxPool*[oT: FractionalMaxPoolT](scope: Scope,
                        value: oT,
                        pooling_ratio: openArray[float32],
                        pseudo_random: bool = false,
                        overlapping: bool = false,
                        deterministic: bool = false,
                        seed: int64 = 0,
                        seed2: int64 = 0): FractionalMaxPool[oT] =
  return iifractionalMaxPool(scope,
                             value,
                             newArraySlice(pooling_ratio),
                             pseudo_random,
                             overlapping,
                             deterministic,
                             seed,
                             seed2)

converter fractionalMaxPoolToOut*[oT: FractionalMaxPoolT](op: FractionalMaxPool[oT]): oT = return op.output

type NthElementT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type NthElement*[oT:NthElementT] {.header:"generated.h", importcpp:"NthElement/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinthElement[oT: NthElementT](scope: Scope,
                 input: oT,
                 n: oint32,
                 reverse: bool): NthElement[oT] {.header:"generated.h", importcpp:"NthElement(*#, #, #, #)", constructor.}

proc nthElement*[oT: NthElementT](scope: Scope,
                 input: oT,
                 n: oint32,
                 reverse: bool = false): NthElement[oT] =
  return iinthElement(scope,
                      input,
                      n,
                      reverse)

converter nthElementToOut*[oT: NthElementT](op: NthElement[oT]): oT = return op.output

type InTopKV2T = oint32 | oint64

type InTopKV2*[oT:obool] {.header:"generated.h", importcpp:"InTopKV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinTopKV2[oT: obool](scope: Scope,
               predictions: ofloat,
               targets: InTopKV2T,
               k: InTopKV2T): InTopKV2[oT] {.header:"generated.h", importcpp:"InTopKV2(*#, #, #, #)", constructor.}

proc inTopKV2*[oT: obool](scope: Scope,
               predictions: ofloat,
               targets: InTopKV2T,
               k: InTopKV2T): InTopKV2[oT] =
  return iiinTopKV2(scope,
                    predictions,
                    targets,
                    k)

converter inTopKV2ToOut*[oT: obool](op: InTopKV2[oT]): oT = return op.output

type SubT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type Sub*[oT:SubT] {.header:"generated.h", importcpp:"Sub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisub[oT: SubT](scope: Scope,
          x: oT,
          y: oT): Sub[oT] {.header:"generated.h", importcpp:"Sub(*#, #, #)", constructor.}

proc sub*[oT: SubT](scope: Scope,
          x: oT,
          y: oT): Sub[oT] =
  return iisub(scope,
               x,
               y)

converter subToOut*[oT: SubT](op: Sub[oT]): oT = return op.output

type InTopKT = oint32 | oint64

type InTopK*[oT:obool] {.header:"generated.h", importcpp:"InTopK/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinTopK[oT: obool](scope: Scope,
             predictions: ofloat,
             targets: InTopKT,
             k: int64): InTopK[oT] {.header:"generated.h", importcpp:"InTopK(*#, #, #, #)", constructor.}

proc inTopK*[oT: obool](scope: Scope,
             predictions: ofloat,
             targets: InTopKT,
             k: int64 = 0): InTopK[oT] =
  return iiinTopK(scope,
                  predictions,
                  targets,
                  k)

converter inTopKToOut*[oT: obool](op: InTopK[oT]): oT = return op.output


type DatasetToSingleElement*[oT:oinvalid] {.header:"generated.h", importcpp:"DatasetToSingleElement/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidatasetToSingleElement[oT: oinvalid](scope: Scope,
                             dataset: ovariant,
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape]): DatasetToSingleElement[oT] {.header:"generated.h", importcpp:"DatasetToSingleElement(*#, #, #, #)", constructor.}

proc datasetToSingleElement*[oT: oinvalid](scope: Scope,
                             dataset: ovariant,
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape]): DatasetToSingleElement[oT] =
  return iidatasetToSingleElement(scope,
                                  dataset,
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes))

converter datasetToSingleElementToOut*[oT: oinvalid](op: DatasetToSingleElement[oT]): oT = return op.output

type SoftmaxCrossEntropyWithLogitsT = ohalf | obfloat16 | ofloat | odouble

type SoftmaxCrossEntropyWithLogits*[oT:SoftmaxCrossEntropyWithLogitsT] {.header:"generated.h", importcpp:"SoftmaxCrossEntropyWithLogits/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisoftmaxCrossEntropyWithLogits[oT: SoftmaxCrossEntropyWithLogitsT](scope: Scope,
                                    features: oT,
                                    labels: oT): SoftmaxCrossEntropyWithLogits[oT] {.header:"generated.h", importcpp:"SoftmaxCrossEntropyWithLogits(*#, #, #)", constructor.}

proc softmaxCrossEntropyWithLogits*[oT: SoftmaxCrossEntropyWithLogitsT](scope: Scope,
                                    features: oT,
                                    labels: oT): SoftmaxCrossEntropyWithLogits[oT] =
  return iisoftmaxCrossEntropyWithLogits(scope,
                                         features,
                                         labels)

converter softmaxCrossEntropyWithLogitsToOut*[oT: SoftmaxCrossEntropyWithLogitsT](op: SoftmaxCrossEntropyWithLogits[oT]): oT = return op.output

type LogSoftmaxT = ohalf | obfloat16 | ofloat | odouble

type LogSoftmax*[oT:LogSoftmaxT] {.header:"generated.h", importcpp:"LogSoftmax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilogSoftmax[oT: LogSoftmaxT](scope: Scope,
                 logits: oT): LogSoftmax[oT] {.header:"generated.h", importcpp:"LogSoftmax(*#, #)", constructor.}

proc logSoftmax*[oT: LogSoftmaxT](scope: Scope,
                 logits: oT): LogSoftmax[oT] =
  return iilogSoftmax(scope,
                      logits)

converter logSoftmaxToOut*[oT: LogSoftmaxT](op: LogSoftmax[oT]): oT = return op.output


type MutableHashTableV2*[oT:oresource] {.header:"generated.h", importcpp:"MutableHashTableV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutableHashTableV2[oT: oresource](scope: Scope,
                         container: cstring,
                         shared_name: cstring,
                         use_node_name_sharing: bool,
                         key_dtype: DType,
                         value_dtype: DType): MutableHashTableV2[oT] {.header:"generated.h", importcpp:"MutableHashTableV2(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc mutableHashTableV2*[oT: oresource](scope: Scope,
                         container: cstring,
                         shared_name: cstring,
                         use_node_name_sharing: bool = false,
                         key_dtype: DType = DT_INVALID,
                         value_dtype: DType = DT_INVALID): MutableHashTableV2[oT] =
  return iimutableHashTableV2(scope,
                              container,
                              shared_name,
                              use_node_name_sharing,
                              key_dtype,
                              value_dtype)

converter mutableHashTableV2ToOut*[oT: oresource](op: MutableHashTableV2[oT]): oT = return op.output

type SoftplusT = ohalf | obfloat16 | ofloat | odouble

type Softplus*[oT:SoftplusT] {.header:"generated.h", importcpp:"Softplus/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisoftplus[oT: SoftplusT](scope: Scope,
               features: oT): Softplus[oT] {.header:"generated.h", importcpp:"Softplus(*#, #)", constructor.}

proc softplus*[oT: SoftplusT](scope: Scope,
               features: oT): Softplus[oT] =
  return iisoftplus(scope,
                    features)

converter softplusToOut*[oT: SoftplusT](op: Softplus[oT]): oT = return op.output

type SeluT = ohalf | obfloat16 | ofloat | odouble

type Selu*[oT:SeluT] {.header:"generated.h", importcpp:"Selu/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiselu[oT: SeluT](scope: Scope,
           features: oT): Selu[oT] {.header:"generated.h", importcpp:"Selu(*#, #)", constructor.}

proc selu*[oT: SeluT](scope: Scope,
           features: oT): Selu[oT] =
  return iiselu(scope,
                features)

converter seluToOut*[oT: SeluT](op: Selu[oT]): oT = return op.output

type EluGradT = ohalf | obfloat16 | ofloat | odouble

type EluGrad*[oT:EluGradT] {.header:"generated.h", importcpp:"EluGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iieluGrad[oT: EluGradT](scope: Scope,
              gradients: oT,
              outputs: oT): EluGrad[oT] {.header:"generated.h", importcpp:"EluGrad(*#, #, #)", constructor.}

proc eluGrad*[oT: EluGradT](scope: Scope,
              gradients: oT,
              outputs: oT): EluGrad[oT] =
  return iieluGrad(scope,
                   gradients,
                   outputs)

converter eluGradToOut*[oT: EluGradT](op: EluGrad[oT]): oT = return op.output

type LeakyReluGradT = ohalf | obfloat16 | ofloat | odouble

type LeakyReluGrad*[oT:LeakyReluGradT] {.header:"generated.h", importcpp:"LeakyReluGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iileakyReluGrad[oT: LeakyReluGradT](scope: Scope,
                    gradients: oT,
                    features: oT,
                    alpha: float32): LeakyReluGrad[oT] {.header:"generated.h", importcpp:"LeakyReluGrad(*#, #, #, #)", constructor.}

proc leakyReluGrad*[oT: LeakyReluGradT](scope: Scope,
                    gradients: oT,
                    features: oT,
                    alpha: float32 = 0.2000000029802322.float32): LeakyReluGrad[oT] =
  return iileakyReluGrad(scope,
                         gradients,
                         features,
                         alpha)

converter leakyReluGradToOut*[oT: LeakyReluGradT](op: LeakyReluGrad[oT]): oT = return op.output

type StackPushT = oall

type StackPush*[oT:StackPushT] {.header:"generated.h", importcpp:"StackPush/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistackPush[oT: StackPushT](scope: Scope,
                handle: ostring,
                elem: oT,
                swap_memory: bool): StackPush[oT] {.header:"generated.h", importcpp:"StackPush(*#, #, #, #)", constructor.}

proc stackPush*[oT: StackPushT](scope: Scope,
                handle: ostring,
                elem: oT,
                swap_memory: bool = false): StackPush[oT] =
  return iistackPush(scope,
                     handle,
                     elem,
                     swap_memory)

converter stackPushToOut*[oT: StackPushT](op: StackPush[oT]): oT = return op.output

type LeakyReluT = ohalf | obfloat16 | ofloat | odouble

type LeakyRelu*[oT:LeakyReluT] {.header:"generated.h", importcpp:"LeakyRelu/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iileakyRelu[oT: LeakyReluT](scope: Scope,
                features: oT,
                alpha: float32): LeakyRelu[oT] {.header:"generated.h", importcpp:"LeakyRelu(*#, #, #)", constructor.}

proc leakyRelu*[oT: LeakyReluT](scope: Scope,
                features: oT,
                alpha: float32 = 0.2000000029802322.float32): LeakyRelu[oT] =
  return iileakyRelu(scope,
                     features,
                     alpha)

converter leakyReluToOut*[oT: LeakyReluT](op: LeakyRelu[oT]): oT = return op.output

type SparseSplitT = oall

type SparseSplit*[oT:oint64] {.header:"generated.h", importcpp:"SparseSplit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSplit[oT: oint64](scope: Scope,
                  split_dim: oT,
                  indices: oT,
                  values: SparseSplitT,
                  shape: oT,
                  num_split: int64): SparseSplit[oT] {.header:"generated.h", importcpp:"SparseSplit(*#, #, #, #, #, #)", constructor.}

proc sparseSplit*[oT: oint64](scope: Scope,
                  split_dim: oT,
                  indices: oT,
                  values: SparseSplitT,
                  shape: oT,
                  num_split: int64 = 0): SparseSplit[oT] =
  return iisparseSplit(scope,
                       split_dim,
                       indices,
                       values,
                       shape,
                       num_split)

converter sparseSplitToOut*[oT: oint64](op: SparseSplit[oT]): oT = return op.output

type RaggedRangeT = obfloat16 | ofloat | odouble | oint32 | oint64

type RaggedRange*[oT:oint64] {.header:"generated.h", importcpp:"RaggedRange/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiraggedRange[oT: oint64](scope: Scope,
                  starts: RaggedRangeT,
                  limits: RaggedRangeT,
                  deltas: RaggedRangeT): RaggedRange[oT] {.header:"generated.h", importcpp:"RaggedRange(*#, #, #, #)", constructor.}

proc raggedRange*[oT: oint64](scope: Scope,
                  starts: RaggedRangeT,
                  limits: RaggedRangeT,
                  deltas: RaggedRangeT): RaggedRange[oT] =
  return iiraggedRange(scope,
                       starts,
                       limits,
                       deltas)

converter raggedRangeToOut*[oT: oint64](op: RaggedRange[oT]): oT = return op.output


type ReaderSerializeStateV2*[oT:ostring] {.header:"generated.h", importcpp:"ReaderSerializeStateV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderSerializeStateV2[oT: ostring](scope: Scope,
                             reader_handle: oresource): ReaderSerializeStateV2[oT] {.header:"generated.h", importcpp:"ReaderSerializeStateV2(*#, #)", constructor.}

proc readerSerializeStateV2*[oT: ostring](scope: Scope,
                             reader_handle: oresource): ReaderSerializeStateV2[oT] =
  return iireaderSerializeStateV2(scope,
                                  reader_handle)

converter readerSerializeStateV2ToOut*[oT: ostring](op: ReaderSerializeStateV2[oT]): oT = return op.output

type Relu6T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Relu6*[oT:Relu6T] {.header:"generated.h", importcpp:"Relu6/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirelu6[oT: Relu6T](scope: Scope,
            features: oT): Relu6[oT] {.header:"generated.h", importcpp:"Relu6(*#, #)", constructor.}

proc relu6*[oT: Relu6T](scope: Scope,
            features: oT): Relu6[oT] =
  return iirelu6(scope,
                 features)

converter relu6ToOut*[oT: Relu6T](op: Relu6[oT]): oT = return op.output

type ReluGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type ReluGrad*[oT:ReluGradT] {.header:"generated.h", importcpp:"ReluGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireluGrad[oT: ReluGradT](scope: Scope,
               gradients: oT,
               features: oT): ReluGrad[oT] {.header:"generated.h", importcpp:"ReluGrad(*#, #, #)", constructor.}

proc reluGrad*[oT: ReluGradT](scope: Scope,
               gradients: oT,
               features: oT): ReluGrad[oT] =
  return iireluGrad(scope,
                    gradients,
                    features)

converter reluGradToOut*[oT: ReluGradT](op: ReluGrad[oT]): oT = return op.output

type AllTidx = oint32 | oint64

type All*[oT:obool] {.header:"generated.h", importcpp:"All/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiall[oT: obool](scope: Scope,
          input: oT,
          reduction_indices: AllTidx,
          keep_dims: bool): All[oT] {.header:"generated.h", importcpp:"All(*#, #, #, #)", constructor.}

proc all*[oT: obool](scope: Scope,
          input: oT,
          reduction_indices: AllTidx,
          keep_dims: bool = false): All[oT] =
  return iiall(scope,
               input,
               reduction_indices,
               keep_dims)

converter allToOut*[oT: obool](op: All[oT]): oT = return op.output

type Dilation2DBackpropInputT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Dilation2DBackpropInput*[oT:Dilation2DBackpropInputT] {.header:"generated.h", importcpp:"Dilation2DBackpropInput/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidilation2DBackpropInput[oT: Dilation2DBackpropInputT](scope: Scope,
                              input: oT,
                              filter: oT,
                              out_backprop: oT,
                              strides: ArraySlice[int],
                              rates: ArraySlice[int],
                              padding: cstring): Dilation2DBackpropInput[oT] {.header:"generated.h", importcpp:"Dilation2DBackpropInput(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc dilation2DBackpropInput*[oT: Dilation2DBackpropInputT](scope: Scope,
                              input: oT,
                              filter: oT,
                              out_backprop: oT,
                              strides: openArray[int],
                              rates: openArray[int],
                              padding: cstring): Dilation2DBackpropInput[oT] =
  return iidilation2DBackpropInput(scope,
                                   input,
                                   filter,
                                   out_backprop,
                                   newArraySlice(strides),
                                   newArraySlice(rates),
                                   padding)

converter dilation2DBackpropInputToOut*[oT: Dilation2DBackpropInputT](op: Dilation2DBackpropInput[oT]): oT = return op.output

type MaxPoolGradWithArgmaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type MaxPoolGradWithArgmaxTargmax = oint32 | oint64

type MaxPoolGradWithArgmax*[oT:MaxPoolGradWithArgmaxT] {.header:"generated.h", importcpp:"MaxPoolGradWithArgmax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolGradWithArgmax[oT: MaxPoolGradWithArgmaxT](scope: Scope,
                            input: oT,
                            grad: oT,
                            argmax: MaxPoolGradWithArgmaxTargmax,
                            ksize: ArraySlice[int],
                            strides: ArraySlice[int],
                            padding: cstring): MaxPoolGradWithArgmax[oT] {.header:"generated.h", importcpp:"MaxPoolGradWithArgmax(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc maxPoolGradWithArgmax*[oT: MaxPoolGradWithArgmaxT](scope: Scope,
                            input: oT,
                            grad: oT,
                            argmax: MaxPoolGradWithArgmaxTargmax,
                            ksize: openArray[int],
                            strides: openArray[int],
                            padding: cstring): MaxPoolGradWithArgmax[oT] =
  return iimaxPoolGradWithArgmax(scope,
                                 input,
                                 grad,
                                 argmax,
                                 newArraySlice(ksize),
                                 newArraySlice(strides),
                                 padding)

converter maxPoolGradWithArgmaxToOut*[oT: MaxPoolGradWithArgmaxT](op: MaxPoolGradWithArgmax[oT]): oT = return op.output

type MaxPoolGradGradV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type MaxPoolGradGradV2*[oT:MaxPoolGradGradV2T] {.header:"generated.h", importcpp:"MaxPoolGradGradV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolGradGradV2[oT: MaxPoolGradGradV2T](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: oint32,
                        strides: oint32,
                        padding: cstring,
                        data_format: cstring): MaxPoolGradGradV2[oT] {.header:"generated.h", importcpp:"MaxPoolGradGradV2(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPoolGradGradV2*[oT: MaxPoolGradGradV2T](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: oint32,
                        strides: oint32,
                        padding: cstring,
                        data_format: cstring = "NHWC"): MaxPoolGradGradV2[oT] =
  return iimaxPoolGradGradV2(scope,
                             orig_input,
                             orig_output,
                             grad,
                             ksize,
                             strides,
                             padding,
                             data_format)

converter maxPoolGradGradV2ToOut*[oT: MaxPoolGradGradV2T](op: MaxPoolGradGradV2[oT]): oT = return op.output

type MaxPoolGradV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type MaxPoolGradV2*[oT:MaxPoolGradV2T] {.header:"generated.h", importcpp:"MaxPoolGradV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolGradV2[oT: MaxPoolGradV2T](scope: Scope,
                    orig_input: oT,
                    orig_output: oT,
                    grad: oT,
                    ksize: oint32,
                    strides: oint32,
                    padding: cstring,
                    data_format: cstring): MaxPoolGradV2[oT] {.header:"generated.h", importcpp:"MaxPoolGradV2(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPoolGradV2*[oT: MaxPoolGradV2T](scope: Scope,
                    orig_input: oT,
                    orig_output: oT,
                    grad: oT,
                    ksize: oint32,
                    strides: oint32,
                    padding: cstring,
                    data_format: cstring = "NHWC"): MaxPoolGradV2[oT] =
  return iimaxPoolGradV2(scope,
                         orig_input,
                         orig_output,
                         grad,
                         ksize,
                         strides,
                         padding,
                         data_format)

converter maxPoolGradV2ToOut*[oT: MaxPoolGradV2T](op: MaxPoolGradV2[oT]): oT = return op.output

type RollT = oall
type RollTshift = oint32 | oint64
type RollTaxis = oint32 | oint64

type Roll*[oT:RollT] {.header:"generated.h", importcpp:"Roll/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiroll[oT: RollT](scope: Scope,
           input: oT,
           shift: RollTshift,
           axis: RollTaxis): Roll[oT] {.header:"generated.h", importcpp:"Roll(*#, #, #, #)", constructor.}

proc roll*[oT: RollT](scope: Scope,
           input: oT,
           shift: RollTshift,
           axis: RollTaxis): Roll[oT] =
  return iiroll(scope,
                input,
                shift,
                axis)

converter rollToOut*[oT: RollT](op: Roll[oT]): oT = return op.output

type MaxPoolGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type MaxPoolGrad*[oT:MaxPoolGradT] {.header:"generated.h", importcpp:"MaxPoolGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolGrad[oT: MaxPoolGradT](scope: Scope,
                  orig_input: oT,
                  orig_output: oT,
                  grad: oT,
                  ksize: ArraySlice[int],
                  strides: ArraySlice[int],
                  padding: cstring,
                  data_format: cstring): MaxPoolGrad[oT] {.header:"generated.h", importcpp:"MaxPoolGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPoolGrad*[oT: MaxPoolGradT](scope: Scope,
                  orig_input: oT,
                  orig_output: oT,
                  grad: oT,
                  ksize: openArray[int],
                  strides: openArray[int],
                  padding: cstring,
                  data_format: cstring = "NHWC"): MaxPoolGrad[oT] =
  return iimaxPoolGrad(scope,
                       orig_input,
                       orig_output,
                       grad,
                       newArraySlice(ksize),
                       newArraySlice(strides),
                       padding,
                       data_format)

converter maxPoolGradToOut*[oT: MaxPoolGradT](op: MaxPoolGrad[oT]): oT = return op.output

type LRNGradT = ohalf | obfloat16 | ofloat

type LRNGrad*[oT:LRNGradT] {.header:"generated.h", importcpp:"LRNGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilRNGrad[oT: LRNGradT](scope: Scope,
              input_grads: oT,
              input_image: oT,
              output_image: oT,
              depth_radius: int64,
              bias: float32,
              alpha: float32,
              beta: float32): LRNGrad[oT] {.header:"generated.h", importcpp:"LRNGrad(*#, #, #, #, #, #, #, #)", constructor.}

proc lRNGrad*[oT: LRNGradT](scope: Scope,
              input_grads: oT,
              input_image: oT,
              output_image: oT,
              depth_radius: int64 = 5,
              bias: float32 = 1.0.float32,
              alpha: float32 = 1.0.float32,
              beta: float32 = 0.5.float32): LRNGrad[oT] =
  return iilRNGrad(scope,
                   input_grads,
                   input_image,
                   output_image,
                   depth_radius,
                   bias,
                   alpha,
                   beta)

converter lRNGradToOut*[oT: LRNGradT](op: LRNGrad[oT]): oT = return op.output

type MaxPool3DGradGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type MaxPool3DGradGrad*[oT:MaxPool3DGradGradT] {.header:"generated.h", importcpp:"MaxPool3DGradGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPool3DGradGrad[oT: MaxPool3DGradGradT](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: ArraySlice[int],
                        strides: ArraySlice[int],
                        padding: cstring,
                        data_format: cstring): MaxPool3DGradGrad[oT] {.header:"generated.h", importcpp:"MaxPool3DGradGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPool3DGradGrad*[oT: MaxPool3DGradGradT](scope: Scope,
                        orig_input: oT,
                        orig_output: oT,
                        grad: oT,
                        ksize: openArray[int],
                        strides: openArray[int],
                        padding: cstring,
                        data_format: cstring = "NDHWC"): MaxPool3DGradGrad[oT] =
  return iimaxPool3DGradGrad(scope,
                             orig_input,
                             orig_output,
                             grad,
                             newArraySlice(ksize),
                             newArraySlice(strides),
                             padding,
                             data_format)

converter maxPool3DGradGradToOut*[oT: MaxPool3DGradGradT](op: MaxPool3DGradGrad[oT]): oT = return op.output

type Conv3DBackpropFilterT = ohalf | ofloat | odouble

type Conv3DBackpropFilter*[oT:Conv3DBackpropFilterT] {.header:"generated.h", importcpp:"Conv3DBackpropFilter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv3DBackpropFilter[oT: Conv3DBackpropFilterT](scope: Scope,
                           input: oT,
                           filter: oT,
                           out_backprop: oT,
                           strides: ArraySlice[int],
                           padding: cstring,
                           dilations: ArraySlice[int]): Conv3DBackpropFilter[oT] {.header:"generated.h", importcpp:"Conv3DBackpropFilter(*#, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc conv3DBackpropFilter*[oT: Conv3DBackpropFilterT](scope: Scope,
                           input: oT,
                           filter: oT,
                           out_backprop: oT,
                           strides: openArray[int],
                           padding: cstring,
                           dilations: openArray[int] = [1, 1, 1, 1, 1]): Conv3DBackpropFilter[oT] =
  return iiconv3DBackpropFilter(scope,
                                input,
                                filter,
                                out_backprop,
                                newArraySlice(strides),
                                padding,
                                newArraySlice(dilations))

converter conv3DBackpropFilterToOut*[oT: Conv3DBackpropFilterT](op: Conv3DBackpropFilter[oT]): oT = return op.output

type Conv3DT = ohalf | obfloat16 | ofloat | odouble

type Conv3D*[oT:Conv3DT] {.header:"generated.h", importcpp:"Conv3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv3D[oT: Conv3DT](scope: Scope,
             input: oT,
             filter: oT,
             strides: ArraySlice[int],
             padding: cstring,
             dilations: ArraySlice[int],
             data_format: cstring): Conv3D[oT] {.header:"generated.h", importcpp:"Conv3D(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc conv3D*[oT: Conv3DT](scope: Scope,
             input: oT,
             filter: oT,
             strides: openArray[int],
             padding: cstring,
             dilations: openArray[int] = [1, 1, 1, 1, 1],
             data_format: cstring = "NDHWC"): Conv3D[oT] =
  return iiconv3D(scope,
                  input,
                  filter,
                  newArraySlice(strides),
                  padding,
                  newArraySlice(dilations),
                  data_format)

converter conv3DToOut*[oT: Conv3DT](op: Conv3D[oT]): oT = return op.output

type CropAndResizeT = ouint8 | ouint16 | oint8 | oint16 | oint32 | oint64 | ohalf | ofloat | odouble

type CropAndResize*[oT:ofloat] {.header:"generated.h", importcpp:"CropAndResize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicropAndResize[oT: ofloat](scope: Scope,
                    image: CropAndResizeT,
                    boxes: oT,
                    box_ind: oint32,
                    crop_size: oint32,
                    extrapolation_value: float32,
                    nmethod: cstring): CropAndResize[oT] {.header:"generated.h", importcpp:"CropAndResize(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc cropAndResize*[oT: ofloat](scope: Scope,
                    image: CropAndResizeT,
                    boxes: oT,
                    box_ind: oint32,
                    crop_size: oint32,
                    extrapolation_value: float32 = 0.0.float32,
                    nmethod: cstring = "bilinear"): CropAndResize[oT] =
  return iicropAndResize(scope,
                         image,
                         boxes,
                         box_ind,
                         crop_size,
                         extrapolation_value,
                         nmethod)

converter cropAndResizeToOut*[oT: ofloat](op: CropAndResize[oT]): oT = return op.output

type DepthwiseConv2dNativeBackpropFilterT = ohalf | obfloat16 | ofloat | odouble

type DepthwiseConv2dNativeBackpropFilter*[oT:DepthwiseConv2dNativeBackpropFilterT] {.header:"generated.h", importcpp:"DepthwiseConv2dNativeBackpropFilter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidepthwiseConv2dNativeBackpropFilter[oT: DepthwiseConv2dNativeBackpropFilterT](scope: Scope,
                                          input: oT,
                                          filter_sizes: oint32,
                                          out_backprop: oT,
                                          strides: ArraySlice[int],
                                          padding: cstring,
                                          dilations: ArraySlice[int],
                                          data_format: cstring): DepthwiseConv2dNativeBackpropFilter[oT] {.header:"generated.h", importcpp:"DepthwiseConv2dNativeBackpropFilter(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc depthwiseConv2dNativeBackpropFilter*[oT: DepthwiseConv2dNativeBackpropFilterT](scope: Scope,
                                          input: oT,
                                          filter_sizes: oint32,
                                          out_backprop: oT,
                                          strides: openArray[int],
                                          padding: cstring,
                                          dilations: openArray[int] = [1, 1, 1, 1],
                                          data_format: cstring = "NHWC"): DepthwiseConv2dNativeBackpropFilter[oT] =
  return iidepthwiseConv2dNativeBackpropFilter(scope,
                                               input,
                                               filter_sizes,
                                               out_backprop,
                                               newArraySlice(strides),
                                               padding,
                                               newArraySlice(dilations),
                                               data_format)

converter depthwiseConv2dNativeBackpropFilterToOut*[oT: DepthwiseConv2dNativeBackpropFilterT](op: DepthwiseConv2dNativeBackpropFilter[oT]): oT = return op.output

type Expm1T = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Expm1*[oT:Expm1T] {.header:"generated.h", importcpp:"Expm1/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexpm1[oT: Expm1T](scope: Scope,
            x: oT): Expm1[oT] {.header:"generated.h", importcpp:"Expm1(*#, #)", constructor.}

proc expm1*[oT: Expm1T](scope: Scope,
            x: oT): Expm1[oT] =
  return iiexpm1(scope,
                 x)

converter expm1ToOut*[oT: Expm1T](op: Expm1[oT]): oT = return op.output

type Conv2DBackpropInputT = ohalf | obfloat16 | ofloat | odouble

type Conv2DBackpropInput*[oT:Conv2DBackpropInputT] {.header:"generated.h", importcpp:"Conv2DBackpropInput/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv2DBackpropInput[oT: Conv2DBackpropInputT](scope: Scope,
                          input_sizes: oint32,
                          filter: oT,
                          out_backprop: oT,
                          strides: ArraySlice[int],
                          padding: cstring,
                          dilations: ArraySlice[int],
                          use_cudnn_on_gpu: bool,
                          data_format: cstring): Conv2DBackpropInput[oT] {.header:"generated.h", importcpp:"Conv2DBackpropInput(*#, #, #, #, #, tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc conv2DBackpropInput*[oT: Conv2DBackpropInputT](scope: Scope,
                          input_sizes: oint32,
                          filter: oT,
                          out_backprop: oT,
                          strides: openArray[int],
                          padding: cstring,
                          dilations: openArray[int] = [1, 1, 1, 1],
                          use_cudnn_on_gpu: bool = true,
                          data_format: cstring = "NHWC"): Conv2DBackpropInput[oT] =
  return iiconv2DBackpropInput(scope,
                               input_sizes,
                               filter,
                               out_backprop,
                               newArraySlice(strides),
                               padding,
                               newArraySlice(dilations),
                               use_cudnn_on_gpu,
                               data_format)

converter conv2DBackpropInputToOut*[oT: Conv2DBackpropInputT](op: Conv2DBackpropInput[oT]): oT = return op.output

type INcclReduceRecvT = ohalf | ofloat | odouble | oint32 | oint64

type INcclReduceRecv*[oT:INcclReduceRecvT] {.header:"generated.h", importcpp:"_NcclReduceRecv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiNcclReduceRecv[oT: INcclReduceRecvT](scope: Scope,
                      input: oT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64): INcclReduceRecv[oT] {.header:"generated.h", importcpp:"_NcclReduceRecv(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc iNcclReduceRecv*[oT: INcclReduceRecvT](scope: Scope,
                      input: oT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64 = 0): INcclReduceRecv[oT] =
  return iiiNcclReduceRecv(scope,
                           input,
                           reduction,
                           shared_name,
                           num_devices)

converter iNcclReduceRecvToOut*[oT: INcclReduceRecvT](op: INcclReduceRecv[oT]): oT = return op.output

type Conv2DT = ohalf | obfloat16 | ofloat | odouble

type Conv2D*[oT:Conv2DT] {.header:"generated.h", importcpp:"Conv2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv2D[oT: Conv2DT](scope: Scope,
             input: oT,
             filter: oT,
             strides: ArraySlice[int],
             padding: cstring,
             dilations: ArraySlice[int],
             use_cudnn_on_gpu: bool,
             data_format: cstring): Conv2D[oT] {.header:"generated.h", importcpp:"Conv2D(*#, #, #, #, tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc conv2D*[oT: Conv2DT](scope: Scope,
             input: oT,
             filter: oT,
             strides: openArray[int],
             padding: cstring,
             dilations: openArray[int] = [1, 1, 1, 1],
             use_cudnn_on_gpu: bool = true,
             data_format: cstring = "NHWC"): Conv2D[oT] =
  return iiconv2D(scope,
                  input,
                  filter,
                  newArraySlice(strides),
                  padding,
                  newArraySlice(dilations),
                  use_cudnn_on_gpu,
                  data_format)

converter conv2DToOut*[oT: Conv2DT](op: Conv2D[oT]): oT = return op.output

type SinT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Sin*[oT:SinT] {.header:"generated.h", importcpp:"Sin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisin[oT: SinT](scope: Scope,
          x: oT): Sin[oT] {.header:"generated.h", importcpp:"Sin(*#, #)", constructor.}

proc sin*[oT: SinT](scope: Scope,
          x: oT): Sin[oT] =
  return iisin(scope,
               x)

converter sinToOut*[oT: SinT](op: Sin[oT]): oT = return op.output

type FusedBatchNormV2T = ohalf | obfloat16 | ofloat
type FusedBatchNormV2U = ofloat

type FusedBatchNormV2*[oT:FusedBatchNormV2T] {.header:"generated.h", importcpp:"FusedBatchNormV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifusedBatchNormV2[oT: FusedBatchNormV2T](scope: Scope,
                       x: oT,
                       scale: FusedBatchNormV2U,
                       offset: FusedBatchNormV2U,
                       mean: FusedBatchNormV2U,
                       variance: FusedBatchNormV2U,
                       is_training: bool,
                       data_format: cstring,
                       epsilon: float32): FusedBatchNormV2[oT] {.header:"generated.h", importcpp:"FusedBatchNormV2(*#, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc fusedBatchNormV2*[oT: FusedBatchNormV2T](scope: Scope,
                       x: oT,
                       scale: FusedBatchNormV2U,
                       offset: FusedBatchNormV2U,
                       mean: FusedBatchNormV2U,
                       variance: FusedBatchNormV2U,
                       is_training: bool = true,
                       data_format: cstring = "NHWC",
                       epsilon: float32 = 9.999999747378752e-05.float32): FusedBatchNormV2[oT] =
  return iifusedBatchNormV2(scope,
                            x,
                            scale,
                            offset,
                            mean,
                            variance,
                            is_training,
                            data_format,
                            epsilon)

converter fusedBatchNormV2ToOut*[oT: FusedBatchNormV2T](op: FusedBatchNormV2[oT]): oT = return op.output

type SparseMatMulTa = ofloat | obfloat16
type SparseMatMulTb = ofloat | obfloat16

type SparseMatMul*[oT:ofloat] {.header:"generated.h", importcpp:"SparseMatMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseMatMul[oT: ofloat](scope: Scope,
                   a: SparseMatMulTa,
                   b: SparseMatMulTb,
                   transpose_a: bool,
                   transpose_b: bool,
                   a_is_sparse: bool,
                   b_is_sparse: bool): SparseMatMul[oT] {.header:"generated.h", importcpp:"SparseMatMul(*#, #, #, #, #, #, #)", constructor.}

proc sparseMatMul*[oT: ofloat](scope: Scope,
                   a: SparseMatMulTa,
                   b: SparseMatMulTb,
                   transpose_a: bool = false,
                   transpose_b: bool = false,
                   a_is_sparse: bool = false,
                   b_is_sparse: bool = false): SparseMatMul[oT] =
  return iisparseMatMul(scope,
                        a,
                        b,
                        transpose_a,
                        transpose_b,
                        a_is_sparse,
                        b_is_sparse)

converter sparseMatMulToOut*[oT: ofloat](op: SparseMatMul[oT]): oT = return op.output

type FusedBatchNormT = ofloat

type FusedBatchNorm*[oT:FusedBatchNormT] {.header:"generated.h", importcpp:"FusedBatchNorm/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifusedBatchNorm[oT: FusedBatchNormT](scope: Scope,
                     x: oT,
                     scale: oT,
                     offset: oT,
                     mean: oT,
                     variance: oT,
                     is_training: bool,
                     epsilon: float32,
                     data_format: cstring): FusedBatchNorm[oT] {.header:"generated.h", importcpp:"FusedBatchNorm(*#, #, #, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc fusedBatchNorm*[oT: FusedBatchNormT](scope: Scope,
                     x: oT,
                     scale: oT,
                     offset: oT,
                     mean: oT,
                     variance: oT,
                     is_training: bool = true,
                     epsilon: float32 = 9.999999747378752e-05.float32,
                     data_format: cstring = "NHWC"): FusedBatchNorm[oT] =
  return iifusedBatchNorm(scope,
                          x,
                          scale,
                          offset,
                          mean,
                          variance,
                          is_training,
                          epsilon,
                          data_format)

converter fusedBatchNormToOut*[oT: FusedBatchNormT](op: FusedBatchNorm[oT]): oT = return op.output


type ReduceDataset*[oT:oinvalid] {.header:"generated.h", importcpp:"ReduceDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireduceDataset[oT: oinvalid](scope: Scope,
                    input_dataset: ovariant,
                    initial_state: oT,
                    other_arguments: oT,
                    f: NameAttrList,
                    Tstate: ArraySlice[DType],
                    Targuments: ArraySlice[DType],
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape],
                    use_inter_op_parallelism: bool): ReduceDataset[oT] {.header:"generated.h", importcpp:"ReduceDataset(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc reduceDataset*[oT: oinvalid](scope: Scope,
                    input_dataset: ovariant,
                    initial_state: oT,
                    other_arguments: oT,
                    f: NameAttrList,
                    Tstate: openArray[DType],
                    Targuments: openArray[DType],
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape],
                    use_inter_op_parallelism: bool = true): ReduceDataset[oT] =
  return iireduceDataset(scope,
                         input_dataset,
                         initial_state,
                         other_arguments,
                         f,
                         newArraySlice(Tstate),
                         newArraySlice(Targuments),
                         newArraySlice(output_types),
                         newArraySlice(output_shapes),
                         use_inter_op_parallelism)

converter reduceDatasetToOut*[oT: oinvalid](op: ReduceDataset[oT]): oT = return op.output


type FakeQuantWithMinMaxArgs*[oT:ofloat] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxArgs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQuantWithMinMaxArgs[oT: ofloat](scope: Scope,
                              inputs: oT,
                              min: float32,
                              max: float32,
                              num_bits: int64,
                              narrow_range: bool): FakeQuantWithMinMaxArgs[oT] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxArgs(*#, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxArgs*[oT: ofloat](scope: Scope,
                              inputs: oT,
                              min: float32 = -6.0.float32,
                              max: float32 = 6.0.float32,
                              num_bits: int64 = 8,
                              narrow_range: bool = false): FakeQuantWithMinMaxArgs[oT] =
  return iifakeQuantWithMinMaxArgs(scope,
                                   inputs,
                                   min,
                                   max,
                                   num_bits,
                                   narrow_range)

converter fakeQuantWithMinMaxArgsToOut*[oT: ofloat](op: FakeQuantWithMinMaxArgs[oT]): oT = return op.output

type BatchNormWithGlobalNormalizationT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type BatchNormWithGlobalNormalization*[oT:BatchNormWithGlobalNormalizationT] {.header:"generated.h", importcpp:"BatchNormWithGlobalNormalization/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchNormWithGlobalNormalization[oT: BatchNormWithGlobalNormalizationT](scope: Scope,
                                       t: oT,
                                       m: oT,
                                       v: oT,
                                       beta: oT,
                                       gamma: oT,
                                       scale_after_normalization: bool,
                                       variance_epsilon: float32): BatchNormWithGlobalNormalization[oT] {.header:"generated.h", importcpp:"BatchNormWithGlobalNormalization(*#, #, #, #, #, #, #, #)", constructor.}

proc batchNormWithGlobalNormalization*[oT: BatchNormWithGlobalNormalizationT](scope: Scope,
                                       t: oT,
                                       m: oT,
                                       v: oT,
                                       beta: oT,
                                       gamma: oT,
                                       scale_after_normalization: bool = false,
                                       variance_epsilon: float32 = 0.0.float32): BatchNormWithGlobalNormalization[oT] =
  return iibatchNormWithGlobalNormalization(scope,
                                            t,
                                            m,
                                            v,
                                            beta,
                                            gamma,
                                            scale_after_normalization,
                                            variance_epsilon)

converter batchNormWithGlobalNormalizationToOut*[oT: BatchNormWithGlobalNormalizationT](op: BatchNormWithGlobalNormalization[oT]): oT = return op.output

type ApplyFtrlV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyFtrlV2*[oT:ApplyFtrlV2T] {.header:"generated.h", importcpp:"ApplyFtrlV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyFtrlV2[oT: ApplyFtrlV2T](scope: Scope,
                  nvar: oT,
                  accum: oT,
                  linear: oT,
                  grad: oT,
                  lr: oT,
                  l1: oT,
                  l2: oT,
                  l2_shrinkage: oT,
                  lr_power: oT,
                  use_locking: bool): ApplyFtrlV2[oT] {.header:"generated.h", importcpp:"ApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyFtrlV2*[oT: ApplyFtrlV2T](scope: Scope,
                  nvar: oT,
                  accum: oT,
                  linear: oT,
                  grad: oT,
                  lr: oT,
                  l1: oT,
                  l2: oT,
                  l2_shrinkage: oT,
                  lr_power: oT,
                  use_locking: bool = false): ApplyFtrlV2[oT] =
  return iiapplyFtrlV2(scope,
                       nvar,
                       accum,
                       linear,
                       grad,
                       lr,
                       l1,
                       l2,
                       l2_shrinkage,
                       lr_power,
                       use_locking)

converter applyFtrlV2ToOut*[oT: ApplyFtrlV2T](op: ApplyFtrlV2[oT]): oT = return op.output

type WhereT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64 | obool

type Where*[oT:oint64] {.header:"generated.h", importcpp:"Where/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiwhere[oT: oint64](scope: Scope,
            input: WhereT): Where[oT] {.header:"generated.h", importcpp:"Where(*#, #)", constructor.}

proc where*[oT: oint64](scope: Scope,
            input: WhereT): Where[oT] =
  return iiwhere(scope,
                 input)

converter whereToOut*[oT: oint64](op: Where[oT]): oT = return op.output

type INcclReduceSendT = ohalf | ofloat | odouble | oint32 | oint64

type INcclReduceSend*{.header:"generated.h", importcpp:"_NcclReduceSend/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiiNcclReduceSend(scope: Scope,
                      input: INcclReduceSendT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64): INcclReduceSend {.header:"generated.h", importcpp:"_NcclReduceSend(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc iNcclReduceSend*(scope: Scope,
                      input: INcclReduceSendT,
                      reduction: cstring,
                      shared_name: cstring,
                      num_devices: int64 = 0): INcclReduceSend =
  return iiiNcclReduceSend(scope,
                           input,
                           reduction,
                           shared_name,
                           num_devices)



type GetSessionTensordtype = oall

type GetSessionTensor*[oT:GetSessionTensordtype] {.header:"generated.h", importcpp:"GetSessionTensor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigetSessionTensor[oT: GetSessionTensordtype](scope: Scope,
                       handle: ostring,
                       dtype: DType): GetSessionTensor[oT] {.header:"generated.h", importcpp:"GetSessionTensor(*#, #, #)", constructor.}

proc getSessionTensor*[oT: GetSessionTensordtype](scope: Scope,
                       handle: ostring,
                       dtype: DType = oT[].oTF): GetSessionTensor[oT] =
  return iigetSessionTensor(scope,
                            handle,
                            dtype)

converter getSessionTensorToOut*[oT: GetSessionTensordtype](op: GetSessionTensor[oT]): oT = return op.output

type MinT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type MinTidx = oint32 | oint64

type Min*[oT:MinT] {.header:"generated.h", importcpp:"Min/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimin[oT: MinT](scope: Scope,
          input: oT,
          reduction_indices: MinTidx,
          keep_dims: bool): Min[oT] {.header:"generated.h", importcpp:"Min(*#, #, #, #)", constructor.}

proc min*[oT: MinT](scope: Scope,
          input: oT,
          reduction_indices: MinTidx,
          keep_dims: bool = false): Min[oT] =
  return iimin(scope,
               input,
               reduction_indices,
               keep_dims)

converter minToOut*[oT: MinT](op: Min[oT]): oT = return op.output

type NcclAllReduceT = ohalf | ofloat | odouble | oint32 | oint64

type NcclAllReduce*[oT:NcclAllReduceT] {.header:"generated.h", importcpp:"NcclAllReduce/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iincclAllReduce[oT: NcclAllReduceT](scope: Scope,
                    input: oT,
                    reduction: cstring,
                    shared_name: cstring,
                    num_devices: int64): NcclAllReduce[oT] {.header:"generated.h", importcpp:"NcclAllReduce(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc ncclAllReduce*[oT: NcclAllReduceT](scope: Scope,
                    input: oT,
                    reduction: cstring,
                    shared_name: cstring,
                    num_devices: int64 = 0): NcclAllReduce[oT] =
  return iincclAllReduce(scope,
                         input,
                         reduction,
                         shared_name,
                         num_devices)

converter ncclAllReduceToOut*[oT: NcclAllReduceT](op: NcclAllReduce[oT]): oT = return op.output

type ReadVariableOpdtype = oall

type ReadVariableOp*[oT:ReadVariableOpdtype] {.header:"generated.h", importcpp:"ReadVariableOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireadVariableOp[oT: ReadVariableOpdtype](scope: Scope,
                     resource: oresource,
                     dtype: DType): ReadVariableOp[oT] {.header:"generated.h", importcpp:"ReadVariableOp(*#, #, #)", constructor.}

proc readVariableOp*[oT: ReadVariableOpdtype](scope: Scope,
                     resource: oresource,
                     dtype: DType = oT[].oTF): ReadVariableOp[oT] =
  return iireadVariableOp(scope,
                          resource,
                          dtype)

converter readVariableOpToOut*[oT: ReadVariableOpdtype](op: ReadVariableOp[oT]): oT = return op.output

type LgammaT = obfloat16 | ohalf | ofloat | odouble

type Lgamma*[oT:LgammaT] {.header:"generated.h", importcpp:"Lgamma/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilgamma[oT: LgammaT](scope: Scope,
             x: oT): Lgamma[oT] {.header:"generated.h", importcpp:"Lgamma(*#, #)", constructor.}

proc lgamma*[oT: LgammaT](scope: Scope,
             x: oT): Lgamma[oT] =
  return iilgamma(scope,
                  x)

converter lgammaToOut*[oT: LgammaT](op: Lgamma[oT]): oT = return op.output

type RequantizationRangeTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type RequantizationRange*[oT:ofloat] {.header:"generated.h", importcpp:"RequantizationRange/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirequantizationRange[oT: ofloat](scope: Scope,
                          input: RequantizationRangeTinput,
                          input_min: oT,
                          input_max: oT): RequantizationRange[oT] {.header:"generated.h", importcpp:"RequantizationRange(*#, #, #, #)", constructor.}

proc requantizationRange*[oT: ofloat](scope: Scope,
                          input: RequantizationRangeTinput,
                          input_min: oT,
                          input_max: oT): RequantizationRange[oT] =
  return iirequantizationRange(scope,
                               input,
                               input_min,
                               input_max)

converter requantizationRangeToOut*[oT: ofloat](op: RequantizationRange[oT]): oT = return op.output

type CompareAndBitpackT = obool | ohalf | ofloat | odouble | oint8 | oint16 | oint32 | oint64

type CompareAndBitpack*[oT:ouint8] {.header:"generated.h", importcpp:"CompareAndBitpack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicompareAndBitpack[oT: ouint8](scope: Scope,
                        input: CompareAndBitpackT,
                        threshold: CompareAndBitpackT): CompareAndBitpack[oT] {.header:"generated.h", importcpp:"CompareAndBitpack(*#, #, #)", constructor.}

proc compareAndBitpack*[oT: ouint8](scope: Scope,
                        input: CompareAndBitpackT,
                        threshold: CompareAndBitpackT): CompareAndBitpack[oT] =
  return iicompareAndBitpack(scope,
                             input,
                             threshold)

converter compareAndBitpackToOut*[oT: ouint8](op: CompareAndBitpack[oT]): oT = return op.output

type QuantizeDownAndShrinkRangeTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizeDownAndShrinkRangeout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizeDownAndShrinkRange*[oT:QuantizeDownAndShrinkRangeout_type] {.header:"generated.h", importcpp:"QuantizeDownAndShrinkRange/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizeDownAndShrinkRange[oT: QuantizeDownAndShrinkRangeout_type](scope: Scope,
                                 input: QuantizeDownAndShrinkRangeTinput,
                                 input_min: ofloat,
                                 input_max: ofloat): QuantizeDownAndShrinkRange[oT] {.header:"generated.h", importcpp:"QuantizeDownAndShrinkRange(*#, #, #, #)", constructor.}

proc quantizeDownAndShrinkRange*[oT: QuantizeDownAndShrinkRangeout_type](scope: Scope,
                                 input: QuantizeDownAndShrinkRangeTinput,
                                 input_min: ofloat,
                                 input_max: ofloat): QuantizeDownAndShrinkRange[oT] =
  return iiquantizeDownAndShrinkRange(scope,
                                      input,
                                      input_min,
                                      input_max)

converter quantizeDownAndShrinkRangeToOut*[oT: QuantizeDownAndShrinkRangeout_type](op: QuantizeDownAndShrinkRange[oT]): oT = return op.output

type QuantizedMatMulT1 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedMatMulT2 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedMatMulToutput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedMatMul*[oT:QuantizedMatMulToutput] {.header:"generated.h", importcpp:"QuantizedMatMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedMatMul[oT: QuantizedMatMulToutput](scope: Scope,
                      a: QuantizedMatMulT1,
                      b: QuantizedMatMulT2,
                      min_a: ofloat,
                      max_a: ofloat,
                      min_b: ofloat,
                      max_b: ofloat,
                      Tactivation: DType,
                      transpose_b: bool,
                      transpose_a: bool): QuantizedMatMul[oT] {.header:"generated.h", importcpp:"QuantizedMatMul(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc quantizedMatMul*[oT: QuantizedMatMulToutput](scope: Scope,
                      a: QuantizedMatMulT1,
                      b: QuantizedMatMulT2,
                      min_a: ofloat,
                      max_a: ofloat,
                      min_b: ofloat,
                      max_b: ofloat,
                      Tactivation: DType = DT_QUINT8,
                      transpose_b: bool = false,
                      transpose_a: bool = false): QuantizedMatMul[oT] =
  return iiquantizedMatMul(scope,
                           a,
                           b,
                           min_a,
                           max_a,
                           min_b,
                           max_b,
                           Tactivation,
                           transpose_b,
                           transpose_a)

converter quantizedMatMulToOut*[oT: QuantizedMatMulToutput](op: QuantizedMatMul[oT]): oT = return op.output

type BatchNormWithGlobalNormalizationGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type BatchNormWithGlobalNormalizationGrad*[oT:BatchNormWithGlobalNormalizationGradT] {.header:"generated.h", importcpp:"BatchNormWithGlobalNormalizationGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchNormWithGlobalNormalizationGrad[oT: BatchNormWithGlobalNormalizationGradT](scope: Scope,
                                           t: oT,
                                           m: oT,
                                           v: oT,
                                           gamma: oT,
                                           backprop: oT,
                                           scale_after_normalization: bool,
                                           variance_epsilon: float32): BatchNormWithGlobalNormalizationGrad[oT] {.header:"generated.h", importcpp:"BatchNormWithGlobalNormalizationGrad(*#, #, #, #, #, #, #, #)", constructor.}

proc batchNormWithGlobalNormalizationGrad*[oT: BatchNormWithGlobalNormalizationGradT](scope: Scope,
                                           t: oT,
                                           m: oT,
                                           v: oT,
                                           gamma: oT,
                                           backprop: oT,
                                           scale_after_normalization: bool = false,
                                           variance_epsilon: float32 = 0.0.float32): BatchNormWithGlobalNormalizationGrad[oT] =
  return iibatchNormWithGlobalNormalizationGrad(scope,
                                                t,
                                                m,
                                                v,
                                                gamma,
                                                backprop,
                                                scale_after_normalization,
                                                variance_epsilon)

converter batchNormWithGlobalNormalizationGradToOut*[oT: BatchNormWithGlobalNormalizationGradT](op: BatchNormWithGlobalNormalizationGrad[oT]): oT = return op.output

type BincountT = oint32 | oint64 | ofloat | odouble

type Bincount*[oT:BincountT] {.header:"generated.h", importcpp:"Bincount/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibincount[oT: BincountT](scope: Scope,
               arr: oint32,
               size: oint32,
               weights: oT): Bincount[oT] {.header:"generated.h", importcpp:"Bincount(*#, #, #, #)", constructor.}

proc bincount*[oT: BincountT](scope: Scope,
               arr: oint32,
               size: oint32,
               weights: oT): Bincount[oT] =
  return iibincount(scope,
                    arr,
                    size,
                    weights)

converter bincountToOut*[oT: BincountT](op: Bincount[oT]): oT = return op.output


type DestroyResourceOp*{.header:"generated.h", importcpp:"DestroyResourceOp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iidestroyResourceOp(scope: Scope,
                        resource: oresource,
                        ignore_lookup_error: bool): DestroyResourceOp {.header:"generated.h", importcpp:"DestroyResourceOp(*#, #, #)", constructor.}

proc destroyResourceOp*(scope: Scope,
                        resource: oresource,
                        ignore_lookup_error: bool = true): DestroyResourceOp =
  return iidestroyResourceOp(scope,
                             resource,
                             ignore_lookup_error)



type HistogramFixedWidthT = oint32 | oint64 | ofloat | odouble
type HistogramFixedWidthdtype = oint32 | oint64

type HistogramFixedWidth*[oT:HistogramFixedWidthdtype] {.header:"generated.h", importcpp:"HistogramFixedWidth/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iihistogramFixedWidth[oT: HistogramFixedWidthdtype](scope: Scope,
                          values: HistogramFixedWidthT,
                          value_range: HistogramFixedWidthT,
                          nbins: oint32,
                          dtype: DType): HistogramFixedWidth[oT] {.header:"generated.h", importcpp:"HistogramFixedWidth(*#, #, #, #, #)", constructor.}

proc histogramFixedWidth*[oT: HistogramFixedWidthdtype](scope: Scope,
                          values: HistogramFixedWidthT,
                          value_range: HistogramFixedWidthT,
                          nbins: oint32,
                          dtype: DType = oT[].oTF): HistogramFixedWidth[oT] =
  return iihistogramFixedWidth(scope,
                               values,
                               value_range,
                               nbins,
                               dtype)

converter histogramFixedWidthToOut*[oT: HistogramFixedWidthdtype](op: HistogramFixedWidth[oT]): oT = return op.output

type BatchSelfAdjointEigV2T = odouble | ofloat

type BatchSelfAdjointEigV2*[oT:BatchSelfAdjointEigV2T] {.header:"generated.h", importcpp:"BatchSelfAdjointEigV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchSelfAdjointEigV2[oT: BatchSelfAdjointEigV2T](scope: Scope,
                            input: oT,
                            compute_v: bool): BatchSelfAdjointEigV2[oT] {.header:"generated.h", importcpp:"BatchSelfAdjointEigV2(*#, #, #)", constructor.}

proc batchSelfAdjointEigV2*[oT: BatchSelfAdjointEigV2T](scope: Scope,
                            input: oT,
                            compute_v: bool = true): BatchSelfAdjointEigV2[oT] =
  return iibatchSelfAdjointEigV2(scope,
                                 input,
                                 compute_v)

converter batchSelfAdjointEigV2ToOut*[oT: BatchSelfAdjointEigV2T](op: BatchSelfAdjointEigV2[oT]): oT = return op.output

type NcclBroadcastT = ohalf | ofloat | odouble | oint32 | oint64

type NcclBroadcast*[oT:NcclBroadcastT] {.header:"generated.h", importcpp:"NcclBroadcast/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iincclBroadcast[oT: NcclBroadcastT](scope: Scope,
                    input: oT,
                    shape: TensorShape): NcclBroadcast[oT] {.header:"generated.h", importcpp:"NcclBroadcast(*#, #, #)", constructor.}

proc ncclBroadcast*[oT: NcclBroadcastT](scope: Scope,
                    input: oT,
                    shape: TensorShape = [].shape): NcclBroadcast[oT] =
  return iincclBroadcast(scope,
                         input,
                         shape)

converter ncclBroadcastToOut*[oT: NcclBroadcastT](op: NcclBroadcast[oT]): oT = return op.output

type CrossT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Cross*[oT:CrossT] {.header:"generated.h", importcpp:"Cross/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicross[oT: CrossT](scope: Scope,
            a: oT,
            b: oT): Cross[oT] {.header:"generated.h", importcpp:"Cross(*#, #, #)", constructor.}

proc cross*[oT: CrossT](scope: Scope,
            a: oT,
            b: oT): Cross[oT] =
  return iicross(scope,
                 a,
                 b)

converter crossToOut*[oT: CrossT](op: Cross[oT]): oT = return op.output

type ConjT = ocomplex64 | ocomplex128 | ovariant

type Conj*[oT:ConjT] {.header:"generated.h", importcpp:"Conj/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconj[oT: ConjT](scope: Scope,
           input: oT): Conj[oT] {.header:"generated.h", importcpp:"Conj(*#, #)", constructor.}

proc conj*[oT: ConjT](scope: Scope,
           input: oT): Conj[oT] =
  return iiconj(scope,
                input)

converter conjToOut*[oT: ConjT](op: Conj[oT]): oT = return op.output


type ExperimentalSleepDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalSleepDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalSleepDataset[oT: ovariant](scope: Scope,
                               input_dataset: oT,
                               sleep_microseconds: oint64,
                               output_types: ArraySlice[DType],
                               output_shapes: ArraySlice[TensorShape]): ExperimentalSleepDataset[oT] {.header:"generated.h", importcpp:"ExperimentalSleepDataset(*#, #, #, #, #)", constructor.}

proc experimentalSleepDataset*[oT: ovariant](scope: Scope,
                               input_dataset: oT,
                               sleep_microseconds: oint64,
                               output_types: openArray[DType],
                               output_shapes: openArray[TensorShape]): ExperimentalSleepDataset[oT] =
  return iiexperimentalSleepDataset(scope,
                                    input_dataset,
                                    sleep_microseconds,
                                    newArraySlice(output_types),
                                    newArraySlice(output_shapes))

converter experimentalSleepDatasetToOut*[oT: ovariant](op: ExperimentalSleepDataset[oT]): oT = return op.output

type IMklAddT = ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128 | ostring

type IMklAdd*[oT:IMklAddT] {.header:"generated.h", importcpp:"_MklAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiMklAdd[oT: IMklAddT](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklAdd[oT] {.header:"generated.h", importcpp:"_MklAdd(*#, #, #, #, #)", constructor.}

proc iMklAdd*[oT: IMklAddT](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklAdd[oT] =
  return iiiMklAdd(scope,
                   x,
                   y,
                   mkl_x,
                   mkl_y)

converter iMklAddToOut*[oT: IMklAddT](op: IMklAdd[oT]): oT = return op.output

type RealT = ocomplex64 | ocomplex128
type RealTout = ofloat | odouble

type Real*[oT:RealTout] {.header:"generated.h", importcpp:"Real/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireal[oT: RealTout](scope: Scope,
           input: RealT): Real[oT] {.header:"generated.h", importcpp:"Real(*#, #)", constructor.}

proc real*[oT: RealTout](scope: Scope,
           input: RealT): Real[oT] =
  return iireal(scope,
                input)

converter realToOut*[oT: RealTout](op: Real[oT]): oT = return op.output

type DequantizeT = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type Dequantize*[oT:ofloat] {.header:"generated.h", importcpp:"Dequantize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidequantize[oT: ofloat](scope: Scope,
                 input: DequantizeT,
                 min_range: oT,
                 max_range: oT,
                 mode: cstring): Dequantize[oT] {.header:"generated.h", importcpp:"Dequantize(*#, #, #, #, tensorflow::string(#))", constructor.}

proc dequantize*[oT: ofloat](scope: Scope,
                 input: DequantizeT,
                 min_range: oT,
                 max_range: oT,
                 mode: cstring = "MIN_COMBINED"): Dequantize[oT] =
  return iidequantize(scope,
                      input,
                      min_range,
                      max_range,
                      mode)

converter dequantizeToOut*[oT: ofloat](op: Dequantize[oT]): oT = return op.output

type ComplexT = ofloat | odouble
type ComplexTout = ocomplex64 | ocomplex128

type Complex*[oT:ComplexTout] {.header:"generated.h", importcpp:"Complex/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicomplex[oT: ComplexTout](scope: Scope,
              real: ComplexT,
              imag: ComplexT): Complex[oT] {.header:"generated.h", importcpp:"Complex(*#, #, #)", constructor.}

proc complex*[oT: ComplexTout](scope: Scope,
              real: ComplexT,
              imag: ComplexT): Complex[oT] =
  return iicomplex(scope,
                   real,
                   imag)

converter complexToOut*[oT: ComplexTout](op: Complex[oT]): oT = return op.output

type SparseSoftmaxCrossEntropyWithLogitsT = ohalf | obfloat16 | ofloat | odouble
type SparseSoftmaxCrossEntropyWithLogitsTlabels = oint32 | oint64

type SparseSoftmaxCrossEntropyWithLogits*[oT:SparseSoftmaxCrossEntropyWithLogitsT] {.header:"generated.h", importcpp:"SparseSoftmaxCrossEntropyWithLogits/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSoftmaxCrossEntropyWithLogits[oT: SparseSoftmaxCrossEntropyWithLogitsT](scope: Scope,
                                          features: oT,
                                          labels: SparseSoftmaxCrossEntropyWithLogitsTlabels): SparseSoftmaxCrossEntropyWithLogits[oT] {.header:"generated.h", importcpp:"SparseSoftmaxCrossEntropyWithLogits(*#, #, #)", constructor.}

proc sparseSoftmaxCrossEntropyWithLogits*[oT: SparseSoftmaxCrossEntropyWithLogitsT](scope: Scope,
                                          features: oT,
                                          labels: SparseSoftmaxCrossEntropyWithLogitsTlabels): SparseSoftmaxCrossEntropyWithLogits[oT] =
  return iisparseSoftmaxCrossEntropyWithLogits(scope,
                                               features,
                                               labels)

converter sparseSoftmaxCrossEntropyWithLogitsToOut*[oT: SparseSoftmaxCrossEntropyWithLogitsT](op: SparseSoftmaxCrossEntropyWithLogits[oT]): oT = return op.output

type CholeskyT = odouble | ofloat | ocomplex64 | ocomplex128

type Cholesky*[oT:CholeskyT] {.header:"generated.h", importcpp:"Cholesky/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicholesky[oT: CholeskyT](scope: Scope,
               input: oT): Cholesky[oT] {.header:"generated.h", importcpp:"Cholesky(*#, #)", constructor.}

proc cholesky*[oT: CholeskyT](scope: Scope,
               input: oT): Cholesky[oT] =
  return iicholesky(scope,
                    input)

converter choleskyToOut*[oT: CholeskyT](op: Cholesky[oT]): oT = return op.output

type SparseSegmentSqrtNWithNumSegmentsT = ofloat | odouble
type SparseSegmentSqrtNWithNumSegmentsTidx = oint32 | oint64
type SparseSegmentSqrtNWithNumSegmentsTnumsegments = oint32 | oint64

type SparseSegmentSqrtNWithNumSegments*[oT:SparseSegmentSqrtNWithNumSegmentsT] {.header:"generated.h", importcpp:"SparseSegmentSqrtNWithNumSegments/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentSqrtNWithNumSegments[oT: SparseSegmentSqrtNWithNumSegmentsT](scope: Scope,
                                        data: oT,
                                        indices: SparseSegmentSqrtNWithNumSegmentsTidx,
                                        segment_ids: oint32,
                                        num_segments: SparseSegmentSqrtNWithNumSegmentsTnumsegments): SparseSegmentSqrtNWithNumSegments[oT] {.header:"generated.h", importcpp:"SparseSegmentSqrtNWithNumSegments(*#, #, #, #, #)", constructor.}

proc sparseSegmentSqrtNWithNumSegments*[oT: SparseSegmentSqrtNWithNumSegmentsT](scope: Scope,
                                        data: oT,
                                        indices: SparseSegmentSqrtNWithNumSegmentsTidx,
                                        segment_ids: oint32,
                                        num_segments: SparseSegmentSqrtNWithNumSegmentsTnumsegments): SparseSegmentSqrtNWithNumSegments[oT] =
  return iisparseSegmentSqrtNWithNumSegments(scope,
                                             data,
                                             indices,
                                             segment_ids,
                                             num_segments)

converter sparseSegmentSqrtNWithNumSegmentsToOut*[oT: SparseSegmentSqrtNWithNumSegmentsT](op: SparseSegmentSqrtNWithNumSegments[oT]): oT = return op.output

type SparseSegmentMeanT = ofloat | odouble
type SparseSegmentMeanTidx = oint32 | oint64

type SparseSegmentMean*[oT:SparseSegmentMeanT] {.header:"generated.h", importcpp:"SparseSegmentMean/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentMean[oT: SparseSegmentMeanT](scope: Scope,
                        data: oT,
                        indices: SparseSegmentMeanTidx,
                        segment_ids: oint32): SparseSegmentMean[oT] {.header:"generated.h", importcpp:"SparseSegmentMean(*#, #, #, #)", constructor.}

proc sparseSegmentMean*[oT: SparseSegmentMeanT](scope: Scope,
                        data: oT,
                        indices: SparseSegmentMeanTidx,
                        segment_ids: oint32): SparseSegmentMean[oT] =
  return iisparseSegmentMean(scope,
                             data,
                             indices,
                             segment_ids)

converter sparseSegmentMeanToOut*[oT: SparseSegmentMeanT](op: SparseSegmentMean[oT]): oT = return op.output

type SparseSegmentSumWithNumSegmentsT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type SparseSegmentSumWithNumSegmentsTidx = oint32 | oint64
type SparseSegmentSumWithNumSegmentsTnumsegments = oint32 | oint64

type SparseSegmentSumWithNumSegments*[oT:SparseSegmentSumWithNumSegmentsT] {.header:"generated.h", importcpp:"SparseSegmentSumWithNumSegments/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentSumWithNumSegments[oT: SparseSegmentSumWithNumSegmentsT](scope: Scope,
                                      data: oT,
                                      indices: SparseSegmentSumWithNumSegmentsTidx,
                                      segment_ids: oint32,
                                      num_segments: SparseSegmentSumWithNumSegmentsTnumsegments): SparseSegmentSumWithNumSegments[oT] {.header:"generated.h", importcpp:"SparseSegmentSumWithNumSegments(*#, #, #, #, #)", constructor.}

proc sparseSegmentSumWithNumSegments*[oT: SparseSegmentSumWithNumSegmentsT](scope: Scope,
                                      data: oT,
                                      indices: SparseSegmentSumWithNumSegmentsTidx,
                                      segment_ids: oint32,
                                      num_segments: SparseSegmentSumWithNumSegmentsTnumsegments): SparseSegmentSumWithNumSegments[oT] =
  return iisparseSegmentSumWithNumSegments(scope,
                                           data,
                                           indices,
                                           segment_ids,
                                           num_segments)

converter sparseSegmentSumWithNumSegmentsToOut*[oT: SparseSegmentSumWithNumSegmentsT](op: SparseSegmentSumWithNumSegments[oT]): oT = return op.output

type UnsortedSegmentProdT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type UnsortedSegmentProdTindices = oint32 | oint64
type UnsortedSegmentProdTnumsegments = oint32 | oint64

type UnsortedSegmentProd*[oT:UnsortedSegmentProdT] {.header:"generated.h", importcpp:"UnsortedSegmentProd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunsortedSegmentProd[oT: UnsortedSegmentProdT](scope: Scope,
                          data: oT,
                          segment_ids: UnsortedSegmentProdTindices,
                          num_segments: UnsortedSegmentProdTnumsegments): UnsortedSegmentProd[oT] {.header:"generated.h", importcpp:"UnsortedSegmentProd(*#, #, #, #)", constructor.}

proc unsortedSegmentProd*[oT: UnsortedSegmentProdT](scope: Scope,
                          data: oT,
                          segment_ids: UnsortedSegmentProdTindices,
                          num_segments: UnsortedSegmentProdTnumsegments): UnsortedSegmentProd[oT] =
  return iiunsortedSegmentProd(scope,
                               data,
                               segment_ids,
                               num_segments)

converter unsortedSegmentProdToOut*[oT: UnsortedSegmentProdT](op: UnsortedSegmentProd[oT]): oT = return op.output

type UnsortedSegmentSumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type UnsortedSegmentSumTindices = oint32 | oint64
type UnsortedSegmentSumTnumsegments = oint32 | oint64

type UnsortedSegmentSum*[oT:UnsortedSegmentSumT] {.header:"generated.h", importcpp:"UnsortedSegmentSum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunsortedSegmentSum[oT: UnsortedSegmentSumT](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentSumTindices,
                         num_segments: UnsortedSegmentSumTnumsegments): UnsortedSegmentSum[oT] {.header:"generated.h", importcpp:"UnsortedSegmentSum(*#, #, #, #)", constructor.}

proc unsortedSegmentSum*[oT: UnsortedSegmentSumT](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentSumTindices,
                         num_segments: UnsortedSegmentSumTnumsegments): UnsortedSegmentSum[oT] =
  return iiunsortedSegmentSum(scope,
                              data,
                              segment_ids,
                              num_segments)

converter unsortedSegmentSumToOut*[oT: UnsortedSegmentSumT](op: UnsortedSegmentSum[oT]): oT = return op.output


type IReadVariablesOp*[oT:oinvalid] {.header:"generated.h", importcpp:"_ReadVariablesOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiReadVariablesOp[oT: oinvalid](scope: Scope,
                       resources: oresource,
                       dtypes: ArraySlice[DType]): IReadVariablesOp[oT] {.header:"generated.h", importcpp:"_ReadVariablesOp(*#, #, #)", constructor.}

proc iReadVariablesOp*[oT: oinvalid](scope: Scope,
                       resources: oresource,
                       dtypes: openArray[DType]): IReadVariablesOp[oT] =
  return iiiReadVariablesOp(scope,
                            resources,
                            newArraySlice(dtypes))

converter iReadVariablesOpToOut*[oT: oinvalid](op: IReadVariablesOp[oT]): oT = return op.output

type L2LossT = ohalf | obfloat16 | ofloat | odouble

type L2Loss*[oT:L2LossT] {.header:"generated.h", importcpp:"L2Loss/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iil2Loss[oT: L2LossT](scope: Scope,
             t: oT): L2Loss[oT] {.header:"generated.h", importcpp:"L2Loss(*#, #)", constructor.}

proc l2Loss*[oT: L2LossT](scope: Scope,
             t: oT): L2Loss[oT] =
  return iil2Loss(scope,
                  t)

converter l2LossToOut*[oT: L2LossT](op: L2Loss[oT]): oT = return op.output

type CastSrcT = oall
type CastDstT = oall

type Cast*[oT:CastDstT] {.header:"generated.h", importcpp:"Cast/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iincast[oT: CastDstT](scope: Scope,
            x: CastSrcT,
            Truncate: bool): Cast[oT] {.header:"generated.h", importcpp:"Cast(*#, #, #)", constructor.}

proc ncast*[oT: CastDstT](scope: Scope,
            x: CastSrcT,
            Truncate: bool = false): Cast[oT] =
  return iincast(scope,
                 x,
                 Truncate)

converter ncastToOut*[oT: CastDstT](op: Cast[oT]): oT = return op.output

type SegmentMaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type SegmentMaxTindices = oint32 | oint64

type SegmentMax*[oT:SegmentMaxT] {.header:"generated.h", importcpp:"SegmentMax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisegmentMax[oT: SegmentMaxT](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMaxTindices): SegmentMax[oT] {.header:"generated.h", importcpp:"SegmentMax(*#, #, #)", constructor.}

proc segmentMax*[oT: SegmentMaxT](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMaxTindices): SegmentMax[oT] =
  return iisegmentMax(scope,
                      data,
                      segment_ids)

converter segmentMaxToOut*[oT: SegmentMaxT](op: SegmentMax[oT]): oT = return op.output

type Atan2T = obfloat16 | ohalf | ofloat | odouble

type Atan2*[oT:Atan2T] {.header:"generated.h", importcpp:"Atan2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiatan2[oT: Atan2T](scope: Scope,
            y: oT,
            x: oT): Atan2[oT] {.header:"generated.h", importcpp:"Atan2(*#, #, #)", constructor.}

proc atan2*[oT: Atan2T](scope: Scope,
            y: oT,
            x: oT): Atan2[oT] =
  return iiatan2(scope,
                 y,
                 x)

converter atan2ToOut*[oT: Atan2T](op: Atan2[oT]): oT = return op.output

type SegmentProdT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SegmentProdTindices = oint32 | oint64

type SegmentProd*[oT:SegmentProdT] {.header:"generated.h", importcpp:"SegmentProd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisegmentProd[oT: SegmentProdT](scope: Scope,
                  data: oT,
                  segment_ids: SegmentProdTindices): SegmentProd[oT] {.header:"generated.h", importcpp:"SegmentProd(*#, #, #)", constructor.}

proc segmentProd*[oT: SegmentProdT](scope: Scope,
                  data: oT,
                  segment_ids: SegmentProdTindices): SegmentProd[oT] =
  return iisegmentProd(scope,
                       data,
                       segment_ids)

converter segmentProdToOut*[oT: SegmentProdT](op: SegmentProd[oT]): oT = return op.output

type ArgMinT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ArgMinTidx = oint32 | oint64
type ArgMinoutput_type = oint32 | oint64

type ArgMin*[oT:ArgMinoutput_type] {.header:"generated.h", importcpp:"ArgMin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiargMin[oT: ArgMinoutput_type](scope: Scope,
             input: ArgMinT,
             dimension: ArgMinTidx): ArgMin[oT] {.header:"generated.h", importcpp:"ArgMin(*#, #, #)", constructor.}

proc argMin*[oT: ArgMinoutput_type](scope: Scope,
             input: ArgMinT,
             dimension: ArgMinTidx): ArgMin[oT] =
  return iiargMin(scope,
                  input,
                  dimension)

converter argMinToOut*[oT: ArgMinoutput_type](op: ArgMin[oT]): oT = return op.output

type ResizeBilinearGradT = ofloat | obfloat16 | ohalf | odouble

type ResizeBilinearGrad*[oT:ResizeBilinearGradT] {.header:"generated.h", importcpp:"ResizeBilinearGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeBilinearGrad[oT: ResizeBilinearGradT](scope: Scope,
                         grads: ofloat,
                         original_image: oT,
                         align_corners: bool): ResizeBilinearGrad[oT] {.header:"generated.h", importcpp:"ResizeBilinearGrad(*#, #, #, #)", constructor.}

proc resizeBilinearGrad*[oT: ResizeBilinearGradT](scope: Scope,
                         grads: ofloat,
                         original_image: oT,
                         align_corners: bool = false): ResizeBilinearGrad[oT] =
  return iiresizeBilinearGrad(scope,
                              grads,
                              original_image,
                              align_corners)

converter resizeBilinearGradToOut*[oT: ResizeBilinearGradT](op: ResizeBilinearGrad[oT]): oT = return op.output

type MaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type MaxTidx = oint32 | oint64

type Max*[oT:MaxT] {.header:"generated.h", importcpp:"Max/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimax[oT: MaxT](scope: Scope,
          input: oT,
          reduction_indices: MaxTidx,
          keep_dims: bool): Max[oT] {.header:"generated.h", importcpp:"Max(*#, #, #, #)", constructor.}

proc max*[oT: MaxT](scope: Scope,
          input: oT,
          reduction_indices: MaxTidx,
          keep_dims: bool = false): Max[oT] =
  return iimax(scope,
               input,
               reduction_indices,
               keep_dims)

converter maxToOut*[oT: MaxT](op: Max[oT]): oT = return op.output

type AccumulatorApplyGradientdtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type AccumulatorApplyGradient*{.header:"generated.h", importcpp:"AccumulatorApplyGradient/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiaccumulatorApplyGradient(scope: Scope,
                               handle: ostring,
                               local_step: oint64,
                               gradient: AccumulatorApplyGradientdtype,
                               dtype: DType): AccumulatorApplyGradient {.header:"generated.h", importcpp:"AccumulatorApplyGradient(*#, #, #, #, #)", constructor.}

proc accumulatorApplyGradient*(scope: Scope,
                               handle: ostring,
                               local_step: oint64,
                               gradient: AccumulatorApplyGradientdtype,
                               dtype: DType = DT_INVALID): AccumulatorApplyGradient =
  return iiaccumulatorApplyGradient(scope,
                                    handle,
                                    local_step,
                                    gradient,
                                    dtype)



type SampleDistortedBoundingBoxV2T = ouint8 | oint8 | oint16 | oint32 | oint64

type SampleDistortedBoundingBoxV2*[oT:SampleDistortedBoundingBoxV2T] {.header:"generated.h", importcpp:"SampleDistortedBoundingBoxV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisampleDistortedBoundingBoxV2[oT: SampleDistortedBoundingBoxV2T](scope: Scope,
                                   image_size: oT,
                                   bounding_boxes: ofloat,
                                   min_object_covered: ofloat,
                                   use_image_if_no_bounding_boxes: bool,
                                   seed: int64,
                                   seed2: int64,
                                   aspect_ratio_range: ArraySlice[float32],
                                   area_range: ArraySlice[float32],
                                   max_attempts: int64): SampleDistortedBoundingBoxV2[oT] {.header:"generated.h", importcpp:"SampleDistortedBoundingBoxV2(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc sampleDistortedBoundingBoxV2*[oT: SampleDistortedBoundingBoxV2T](scope: Scope,
                                   image_size: oT,
                                   bounding_boxes: ofloat,
                                   min_object_covered: ofloat,
                                   use_image_if_no_bounding_boxes: bool = false,
                                   seed: int64 = 0,
                                   seed2: int64 = 0,
                                   aspect_ratio_range: openArray[float32] = [0.75.float32, 1.330000042915344.float32],
                                   area_range: openArray[float32] = [0.05000000074505806.float32, 1.0.float32],
                                   max_attempts: int64 = 100): SampleDistortedBoundingBoxV2[oT] =
  return iisampleDistortedBoundingBoxV2(scope,
                                        image_size,
                                        bounding_boxes,
                                        min_object_covered,
                                        use_image_if_no_bounding_boxes,
                                        seed,
                                        seed2,
                                        newArraySlice(aspect_ratio_range),
                                        newArraySlice(area_range),
                                        max_attempts)

converter sampleDistortedBoundingBoxV2ToOut*[oT: SampleDistortedBoundingBoxV2T](op: SampleDistortedBoundingBoxV2[oT]): oT = return op.output

type ProdT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ProdTidx = oint32 | oint64

type Prod*[oT:ProdT] {.header:"generated.h", importcpp:"Prod/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiprod[oT: ProdT](scope: Scope,
           input: oT,
           reduction_indices: ProdTidx,
           keep_dims: bool): Prod[oT] {.header:"generated.h", importcpp:"Prod(*#, #, #, #)", constructor.}

proc prod*[oT: ProdT](scope: Scope,
           input: oT,
           reduction_indices: ProdTidx,
           keep_dims: bool = false): Prod[oT] =
  return iiprod(scope,
                input,
                reduction_indices,
                keep_dims)

converter prodToOut*[oT: ProdT](op: Prod[oT]): oT = return op.output

type SumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SumTidx = oint32 | oint64

type Sum*[oT:SumT] {.header:"generated.h", importcpp:"Sum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisum[oT: SumT](scope: Scope,
          input: oT,
          reduction_indices: SumTidx,
          keep_dims: bool): Sum[oT] {.header:"generated.h", importcpp:"Sum(*#, #, #, #)", constructor.}

proc sum*[oT: SumT](scope: Scope,
          input: oT,
          reduction_indices: SumTidx,
          keep_dims: bool = false): Sum[oT] =
  return iisum(scope,
               input,
               reduction_indices,
               keep_dims)

converter sumToOut*[oT: SumT](op: Sum[oT]): oT = return op.output

type SeluGradT = ohalf | obfloat16 | ofloat | odouble

type SeluGrad*[oT:SeluGradT] {.header:"generated.h", importcpp:"SeluGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiseluGrad[oT: SeluGradT](scope: Scope,
               gradients: oT,
               outputs: oT): SeluGrad[oT] {.header:"generated.h", importcpp:"SeluGrad(*#, #, #)", constructor.}

proc seluGrad*[oT: SeluGradT](scope: Scope,
               gradients: oT,
               outputs: oT): SeluGrad[oT] =
  return iiseluGrad(scope,
                    gradients,
                    outputs)

converter seluGradToOut*[oT: SeluGradT](op: SeluGrad[oT]): oT = return op.output

type SelectT = oall

type Select*[oT:SelectT] {.header:"generated.h", importcpp:"Select/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiselect[oT: SelectT](scope: Scope,
             condition: obool,
             t: oT,
             e: oT): Select[oT] {.header:"generated.h", importcpp:"Select(*#, #, #, #)", constructor.}

proc select*[oT: SelectT](scope: Scope,
             condition: obool,
             t: oT,
             e: oT): Select[oT] =
  return iiselect(scope,
                  condition,
                  t,
                  e)

converter selectToOut*[oT: SelectT](op: Select[oT]): oT = return op.output

type CollectiveBcastSendT = ofloat | ohalf | odouble | oint32 | oint64

type CollectiveBcastSend*[oT:CollectiveBcastSendT] {.header:"generated.h", importcpp:"CollectiveBcastSend/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicollectiveBcastSend[oT: CollectiveBcastSendT](scope: Scope,
                          input: oT,
                          shape: TensorShape,
                          group_size: int64,
                          group_key: int64,
                          instance_key: int64): CollectiveBcastSend[oT] {.header:"generated.h", importcpp:"CollectiveBcastSend(*#, #, #, #, #, #)", constructor.}

proc collectiveBcastSend*[oT: CollectiveBcastSendT](scope: Scope,
                          input: oT,
                          shape: TensorShape = [].shape,
                          group_size: int64 = 0,
                          group_key: int64 = 0,
                          instance_key: int64 = 0): CollectiveBcastSend[oT] =
  return iicollectiveBcastSend(scope,
                               input,
                               shape,
                               group_size,
                               group_key,
                               instance_key)

converter collectiveBcastSendToOut*[oT: CollectiveBcastSendT](op: CollectiveBcastSend[oT]): oT = return op.output


type LogicalAnd*[oT:obool] {.header:"generated.h", importcpp:"LogicalAnd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilogicalAnd[oT: obool](scope: Scope,
                 x: oT,
                 y: oT): LogicalAnd[oT] {.header:"generated.h", importcpp:"LogicalAnd(*#, #, #)", constructor.}

proc logicalAnd*[oT: obool](scope: Scope,
                 x: oT,
                 y: oT): LogicalAnd[oT] =
  return iilogicalAnd(scope,
                      x,
                      y)

converter logicalAndToOut*[oT: obool](op: LogicalAnd[oT]): oT = return op.output


type WriteGraphSummary*{.header:"generated.h", importcpp:"WriteGraphSummary/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteGraphSummary(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tensor: ostring): WriteGraphSummary {.header:"generated.h", importcpp:"WriteGraphSummary(*#, #, #, #)", constructor.}

proc writeGraphSummary*(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tensor: ostring): WriteGraphSummary =
  return iiwriteGraphSummary(scope,
                             writer,
                             step,
                             tensor)



type ApproximateEqualT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApproximateEqual*[oT:obool] {.header:"generated.h", importcpp:"ApproximateEqual/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapproximateEqual[oT: obool](scope: Scope,
                       x: ApproximateEqualT,
                       y: ApproximateEqualT,
                       tolerance: float32): ApproximateEqual[oT] {.header:"generated.h", importcpp:"ApproximateEqual(*#, #, #, #)", constructor.}

proc approximateEqual*[oT: obool](scope: Scope,
                       x: ApproximateEqualT,
                       y: ApproximateEqualT,
                       tolerance: float32 = 9.999999747378752e-06.float32): ApproximateEqual[oT] =
  return iiapproximateEqual(scope,
                            x,
                            y,
                            tolerance)

converter approximateEqualToOut*[oT: obool](op: ApproximateEqual[oT]): oT = return op.output

type EqualT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | oquint8 | oqint8 | oqint32 | ostring | obool | ocomplex128

type Equal*[oT:obool] {.header:"generated.h", importcpp:"Equal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiequal[oT: obool](scope: Scope,
            x: EqualT,
            y: EqualT): Equal[oT] {.header:"generated.h", importcpp:"Equal(*#, #, #)", constructor.}

proc equal*[oT: obool](scope: Scope,
            x: EqualT,
            y: EqualT): Equal[oT] =
  return iiequal(scope,
                 x,
                 y)

converter equalToOut*[oT: obool](op: Equal[oT]): oT = return op.output

type QuantizeV2T = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizeV2*[oT:QuantizeV2T] {.header:"generated.h", importcpp:"QuantizeV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizeV2[oT: QuantizeV2T](scope: Scope,
                 input: ofloat,
                 min_range: ofloat,
                 max_range: ofloat,
                 round_mode: cstring,
                 mode: cstring): QuantizeV2[oT] {.header:"generated.h", importcpp:"QuantizeV2(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc quantizeV2*[oT: QuantizeV2T](scope: Scope,
                 input: ofloat,
                 min_range: ofloat,
                 max_range: ofloat,
                 round_mode: cstring = "HALF_AWAY_FROM_ZERO",
                 mode: cstring = "MIN_COMBINED"): QuantizeV2[oT] =
  return iiquantizeV2(scope,
                      input,
                      min_range,
                      max_range,
                      round_mode,
                      mode)

converter quantizeV2ToOut*[oT: QuantizeV2T](op: QuantizeV2[oT]): oT = return op.output

type GreaterEqualT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type GreaterEqual*[oT:obool] {.header:"generated.h", importcpp:"GreaterEqual/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigreaterEqual[oT: obool](scope: Scope,
                   x: GreaterEqualT,
                   y: GreaterEqualT): GreaterEqual[oT] {.header:"generated.h", importcpp:"GreaterEqual(*#, #, #)", constructor.}

proc greaterEqual*[oT: obool](scope: Scope,
                   x: GreaterEqualT,
                   y: GreaterEqualT): GreaterEqual[oT] =
  return iigreaterEqual(scope,
                        x,
                        y)

converter greaterEqualToOut*[oT: obool](op: GreaterEqual[oT]): oT = return op.output

type ResourceScatterMaxTindices = oint32 | oint64
type ResourceScatterMaxdtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceScatterMax*{.header:"generated.h", importcpp:"ResourceScatterMax/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterMax(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMaxTindices,
                         updates: ResourceScatterMaxdtype,
                         dtype: DType): ResourceScatterMax {.header:"generated.h", importcpp:"ResourceScatterMax(*#, #, #, #, #)", constructor.}

proc resourceScatterMax*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMaxTindices,
                         updates: ResourceScatterMaxdtype,
                         dtype: DType = DT_INVALID): ResourceScatterMax =
  return iiresourceScatterMax(scope,
                              resource,
                              indices,
                              updates,
                              dtype)



type BetaincT = ofloat | odouble

type Betainc*[oT:BetaincT] {.header:"generated.h", importcpp:"Betainc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibetainc[oT: BetaincT](scope: Scope,
              a: oT,
              b: oT,
              x: oT): Betainc[oT] {.header:"generated.h", importcpp:"Betainc(*#, #, #, #)", constructor.}

proc betainc*[oT: BetaincT](scope: Scope,
              a: oT,
              b: oT,
              x: oT): Betainc[oT] =
  return iibetainc(scope,
                   a,
                   b,
                   x)

converter betaincToOut*[oT: BetaincT](op: Betainc[oT]): oT = return op.output

type PolygammaT = ofloat | odouble

type Polygamma*[oT:PolygammaT] {.header:"generated.h", importcpp:"Polygamma/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipolygamma[oT: PolygammaT](scope: Scope,
                a: oT,
                x: oT): Polygamma[oT] {.header:"generated.h", importcpp:"Polygamma(*#, #, #)", constructor.}

proc polygamma*[oT: PolygammaT](scope: Scope,
                a: oT,
                x: oT): Polygamma[oT] =
  return iipolygamma(scope,
                     a,
                     x)

converter polygammaToOut*[oT: PolygammaT](op: Polygamma[oT]): oT = return op.output


type Assert*{.header:"generated.h", importcpp:"Assert/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiassert(scope: Scope,
             condition: obool,
             data: oinvalid,
             T: ArraySlice[DType],
             summarize: int64): Assert {.header:"generated.h", importcpp:"Assert(*#, #, #, #, #)", constructor.}

proc assert*(scope: Scope,
             condition: obool,
             data: oinvalid,
             T: openArray[DType],
             summarize: int64 = 3): Assert =
  return iiassert(scope,
                  condition,
                  data,
                  newArraySlice(T),
                  summarize)



type TransposeT = oall
type TransposeTperm = oint32 | oint64

type Transpose*[oT:TransposeT] {.header:"generated.h", importcpp:"Transpose/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitranspose[oT: TransposeT](scope: Scope,
                x: oT,
                perm: TransposeTperm): Transpose[oT] {.header:"generated.h", importcpp:"Transpose(*#, #, #)", constructor.}

proc transpose*[oT: TransposeT](scope: Scope,
                x: oT,
                perm: TransposeTperm): Transpose[oT] =
  return iitranspose(scope,
                     x,
                     perm)

converter transposeToOut*[oT: TransposeT](op: Transpose[oT]): oT = return op.output

type IgammaGradAT = ofloat | odouble

type IgammaGradA*[oT:IgammaGradAT] {.header:"generated.h", importcpp:"IgammaGradA/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiigammaGradA[oT: IgammaGradAT](scope: Scope,
                  a: oT,
                  x: oT): IgammaGradA[oT] {.header:"generated.h", importcpp:"IgammaGradA(*#, #, #)", constructor.}

proc igammaGradA*[oT: IgammaGradAT](scope: Scope,
                  a: oT,
                  x: oT): IgammaGradA[oT] =
  return iiigammaGradA(scope,
                       a,
                       x)

converter igammaGradAToOut*[oT: IgammaGradAT](op: IgammaGradA[oT]): oT = return op.output


type StringSplitV2*[oT:oint64] {.header:"generated.h", importcpp:"StringSplitV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringSplitV2[oT: oint64](scope: Scope,
                    input: ostring,
                    sep: ostring,
                    maxsplit: int64): StringSplitV2[oT] {.header:"generated.h", importcpp:"StringSplitV2(*#, #, #, #)", constructor.}

proc stringSplitV2*[oT: oint64](scope: Scope,
                    input: ostring,
                    sep: ostring,
                    maxsplit: int64 = -1): StringSplitV2[oT] =
  return iistringSplitV2(scope,
                         input,
                         sep,
                         maxsplit)

converter stringSplitV2ToOut*[oT: oint64](op: StringSplitV2[oT]): oT = return op.output


type ImportEvent*{.header:"generated.h", importcpp:"ImportEvent/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiimportEvent(scope: Scope,
                  writer: oresource,
                  event: ostring): ImportEvent {.header:"generated.h", importcpp:"ImportEvent(*#, #, #)", constructor.}

proc importEvent*(scope: Scope,
                  writer: oresource,
                  event: ostring): ImportEvent =
  return iiimportEvent(scope,
                       writer,
                       event)



type IgammaT = ofloat | odouble

type Igamma*[oT:IgammaT] {.header:"generated.h", importcpp:"Igamma/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiigamma[oT: IgammaT](scope: Scope,
             a: oT,
             x: oT): Igamma[oT] {.header:"generated.h", importcpp:"Igamma(*#, #, #)", constructor.}

proc igamma*[oT: IgammaT](scope: Scope,
             a: oT,
             x: oT): Igamma[oT] =
  return iiigamma(scope,
                  a,
                  x)

converter igammaToOut*[oT: IgammaT](op: Igamma[oT]): oT = return op.output

type IgammacT = ofloat | odouble

type Igammac*[oT:IgammacT] {.header:"generated.h", importcpp:"Igammac/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiigammac[oT: IgammacT](scope: Scope,
              a: oT,
              x: oT): Igammac[oT] {.header:"generated.h", importcpp:"Igammac(*#, #, #)", constructor.}

proc igammac*[oT: IgammacT](scope: Scope,
              a: oT,
              x: oT): Igammac[oT] =
  return iiigammac(scope,
                   a,
                   x)

converter igammacToOut*[oT: IgammacT](op: Igammac[oT]): oT = return op.output

type ModT = oint32 | oint64 | ohalf | ohalf | obfloat16 | ofloat | odouble

type Mod*[oT:ModT] {.header:"generated.h", importcpp:"Mod/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinmod[oT: ModT](scope: Scope,
           x: oT,
           y: oT): Mod[oT] {.header:"generated.h", importcpp:"Mod(*#, #, #)", constructor.}

proc nmod*[oT: ModT](scope: Scope,
           x: oT,
           y: oT): Mod[oT] =
  return iinmod(scope,
                x,
                y)

converter nmodToOut*[oT: ModT](op: Mod[oT]): oT = return op.output

type MaximumT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64

type Maximum*[oT:MaximumT] {.header:"generated.h", importcpp:"Maximum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaximum[oT: MaximumT](scope: Scope,
              x: oT,
              y: oT): Maximum[oT] {.header:"generated.h", importcpp:"Maximum(*#, #, #)", constructor.}

proc maximum*[oT: MaximumT](scope: Scope,
              x: oT,
              y: oT): Maximum[oT] =
  return iimaximum(scope,
                   x,
                   y)

converter maximumToOut*[oT: MaximumT](op: Maximum[oT]): oT = return op.output

type XlogyT = ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Xlogy*[oT:XlogyT] {.header:"generated.h", importcpp:"Xlogy/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iixlogy[oT: XlogyT](scope: Scope,
            x: oT,
            y: oT): Xlogy[oT] {.header:"generated.h", importcpp:"Xlogy(*#, #, #)", constructor.}

proc xlogy*[oT: XlogyT](scope: Scope,
            x: oT,
            y: oT): Xlogy[oT] =
  return iixlogy(scope,
                 x,
                 y)

converter xlogyToOut*[oT: XlogyT](op: Xlogy[oT]): oT = return op.output

type SquaredDifferenceT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type SquaredDifference*[oT:SquaredDifferenceT] {.header:"generated.h", importcpp:"SquaredDifference/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisquaredDifference[oT: SquaredDifferenceT](scope: Scope,
                        x: oT,
                        y: oT): SquaredDifference[oT] {.header:"generated.h", importcpp:"SquaredDifference(*#, #, #)", constructor.}

proc squaredDifference*[oT: SquaredDifferenceT](scope: Scope,
                        x: oT,
                        y: oT): SquaredDifference[oT] =
  return iisquaredDifference(scope,
                             x,
                             y)

converter squaredDifferenceToOut*[oT: SquaredDifferenceT](op: SquaredDifference[oT]): oT = return op.output

type ResourceCountUpToT = oint32 | oint64

type ResourceCountUpTo*[oT:ResourceCountUpToT] {.header:"generated.h", importcpp:"ResourceCountUpTo/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresourceCountUpTo[oT: ResourceCountUpToT](scope: Scope,
                        resource: oresource,
                        limit: int64): ResourceCountUpTo[oT] {.header:"generated.h", importcpp:"ResourceCountUpTo(*#, #, #)", constructor.}

proc resourceCountUpTo*[oT: ResourceCountUpToT](scope: Scope,
                        resource: oresource,
                        limit: int64 = 0): ResourceCountUpTo[oT] =
  return iiresourceCountUpTo(scope,
                             resource,
                             limit)

converter resourceCountUpToToOut*[oT: ResourceCountUpToT](op: ResourceCountUpTo[oT]): oT = return op.output

type RealDivT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type RealDiv*[oT:RealDivT] {.header:"generated.h", importcpp:"RealDiv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirealDiv[oT: RealDivT](scope: Scope,
              x: oT,
              y: oT): RealDiv[oT] {.header:"generated.h", importcpp:"RealDiv(*#, #, #)", constructor.}

proc realDiv*[oT: RealDivT](scope: Scope,
              x: oT,
              y: oT): RealDiv[oT] =
  return iirealDiv(scope,
                   x,
                   y)

converter realDivToOut*[oT: RealDivT](op: RealDiv[oT]): oT = return op.output

type TruncateDivT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type TruncateDiv*[oT:TruncateDivT] {.header:"generated.h", importcpp:"TruncateDiv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitruncateDiv[oT: TruncateDivT](scope: Scope,
                  x: oT,
                  y: oT): TruncateDiv[oT] {.header:"generated.h", importcpp:"TruncateDiv(*#, #, #)", constructor.}

proc truncateDiv*[oT: TruncateDivT](scope: Scope,
                  x: oT,
                  y: oT): TruncateDiv[oT] =
  return iitruncateDiv(scope,
                       x,
                       y)

converter truncateDivToOut*[oT: TruncateDivT](op: TruncateDiv[oT]): oT = return op.output


type StringToHashBucketStrong*[oT:oint64] {.header:"generated.h", importcpp:"StringToHashBucketStrong/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringToHashBucketStrong[oT: oint64](scope: Scope,
                               input: ostring,
                               key: ArraySlice[int],
                               num_buckets: int64): StringToHashBucketStrong[oT] {.header:"generated.h", importcpp:"StringToHashBucketStrong(*#, #, #, #)", constructor.}

proc stringToHashBucketStrong*[oT: oint64](scope: Scope,
                               input: ostring,
                               key: openArray[int],
                               num_buckets: int64 = 0): StringToHashBucketStrong[oT] =
  return iistringToHashBucketStrong(scope,
                                    input,
                                    newArraySlice(key),
                                    num_buckets)

converter stringToHashBucketStrongToOut*[oT: oint64](op: StringToHashBucketStrong[oT]): oT = return op.output


type QueueEnqueue*{.header:"generated.h", importcpp:"QueueEnqueue/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiqueueEnqueue(scope: Scope,
                   handle: ostring,
                   components: oinvalid,
                   Tcomponents: ArraySlice[DType],
                   timeout_ms: int64): QueueEnqueue {.header:"generated.h", importcpp:"QueueEnqueue(*#, #, #, #, #)", constructor.}

proc queueEnqueue*(scope: Scope,
                   handle: ostring,
                   components: oinvalid,
                   Tcomponents: openArray[DType],
                   timeout_ms: int64 = -1): QueueEnqueue =
  return iiqueueEnqueue(scope,
                        handle,
                        components,
                        newArraySlice(Tcomponents),
                        timeout_ms)



type IMklSubT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type IMklSub*[oT:IMklSubT] {.header:"generated.h", importcpp:"_MklSub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiMklSub[oT: IMklSubT](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklSub[oT] {.header:"generated.h", importcpp:"_MklSub(*#, #, #, #, #)", constructor.}

proc iMklSub*[oT: IMklSubT](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklSub[oT] =
  return iiiMklSub(scope,
                   x,
                   y,
                   mkl_x,
                   mkl_y)

converter iMklSubToOut*[oT: IMklSubT](op: IMklSub[oT]): oT = return op.output

type AsStringT = oint8 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128 | ofloat | odouble | obool

type AsString*[oT:ostring] {.header:"generated.h", importcpp:"AsString/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiasString[oT: ostring](scope: Scope,
               input: AsStringT,
               fill: cstring,
               width: int64,
               precision: int64,
               scientific: bool,
               shortest: bool): AsString[oT] {.header:"generated.h", importcpp:"AsString(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc asString*[oT: ostring](scope: Scope,
               input: AsStringT,
               fill: cstring,
               width: int64 = -1,
               precision: int64 = -1,
               scientific: bool = false,
               shortest: bool = false): AsString[oT] =
  return iiasString(scope,
                    input,
                    fill,
                    width,
                    precision,
                    scientific,
                    shortest)

converter asStringToOut*[oT: ostring](op: AsString[oT]): oT = return op.output

type Conv3DBackpropFilterV2T = ohalf | obfloat16 | ofloat | odouble

type Conv3DBackpropFilterV2*[oT:Conv3DBackpropFilterV2T] {.header:"generated.h", importcpp:"Conv3DBackpropFilterV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv3DBackpropFilterV2[oT: Conv3DBackpropFilterV2T](scope: Scope,
                             input: oT,
                             filter_sizes: oint32,
                             out_backprop: oT,
                             strides: ArraySlice[int],
                             padding: cstring,
                             dilations: ArraySlice[int],
                             data_format: cstring): Conv3DBackpropFilterV2[oT] {.header:"generated.h", importcpp:"Conv3DBackpropFilterV2(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc conv3DBackpropFilterV2*[oT: Conv3DBackpropFilterV2T](scope: Scope,
                             input: oT,
                             filter_sizes: oint32,
                             out_backprop: oT,
                             strides: openArray[int],
                             padding: cstring,
                             dilations: openArray[int] = [1, 1, 1, 1, 1],
                             data_format: cstring = "NDHWC"): Conv3DBackpropFilterV2[oT] =
  return iiconv3DBackpropFilterV2(scope,
                                  input,
                                  filter_sizes,
                                  out_backprop,
                                  newArraySlice(strides),
                                  padding,
                                  newArraySlice(dilations),
                                  data_format)

converter conv3DBackpropFilterV2ToOut*[oT: Conv3DBackpropFilterV2T](op: Conv3DBackpropFilterV2[oT]): oT = return op.output

type AddV2T = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type AddV2*[oT:AddV2T] {.header:"generated.h", importcpp:"AddV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaddV2[oT: AddV2T](scope: Scope,
            x: oT,
            y: oT): AddV2[oT] {.header:"generated.h", importcpp:"AddV2(*#, #, #)", constructor.}

proc addV2*[oT: AddV2T](scope: Scope,
            x: oT,
            y: oT): AddV2[oT] =
  return iiaddV2(scope,
                 x,
                 y)

converter addV2ToOut*[oT: AddV2T](op: AddV2[oT]): oT = return op.output


type TryRpc*[oT:ostring] {.header:"generated.h", importcpp:"TryRpc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitryRpc[oT: ostring](scope: Scope,
             address: oT,
             nmethod: oT,
             request: oT,
             protocol: cstring,
             fail_fast: bool,
             timeout_in_ms: int64): TryRpc[oT] {.header:"generated.h", importcpp:"TryRpc(*#, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc tryRpc*[oT: ostring](scope: Scope,
             address: oT,
             nmethod: oT,
             request: oT,
             protocol: cstring,
             fail_fast: bool = true,
             timeout_in_ms: int64 = 0): TryRpc[oT] =
  return iitryRpc(scope,
                  address,
                  nmethod,
                  request,
                  protocol,
                  fail_fast,
                  timeout_in_ms)

converter tryRpcToOut*[oT: ostring](op: TryRpc[oT]): oT = return op.output

type ResourceGatherTindices = oint32 | oint64
type ResourceGatherdtype = oall

type ResourceGather*[oT:ResourceGatherdtype] {.header:"generated.h", importcpp:"ResourceGather/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresourceGather[oT: ResourceGatherdtype](scope: Scope,
                     resource: oresource,
                     indices: ResourceGatherTindices,
                     validate_indices: bool,
                     dtype: DType): ResourceGather[oT] {.header:"generated.h", importcpp:"ResourceGather(*#, #, #, #, #)", constructor.}

proc resourceGather*[oT: ResourceGatherdtype](scope: Scope,
                     resource: oresource,
                     indices: ResourceGatherTindices,
                     validate_indices: bool = true,
                     dtype: DType = oT[].oTF): ResourceGather[oT] =
  return iiresourceGather(scope,
                          resource,
                          indices,
                          validate_indices,
                          dtype)

converter resourceGatherToOut*[oT: ResourceGatherdtype](op: ResourceGather[oT]): oT = return op.output


type UniformCandidateSampler*[oT:oint64] {.header:"generated.h", importcpp:"UniformCandidateSampler/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiuniformCandidateSampler[oT: oint64](scope: Scope,
                              true_classes: oT,
                              num_true: int64,
                              num_sampled: int64,
                              unique: bool,
                              range_max: int64,
                              seed: int64,
                              seed2: int64): UniformCandidateSampler[oT] {.header:"generated.h", importcpp:"UniformCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc uniformCandidateSampler*[oT: oint64](scope: Scope,
                              true_classes: oT,
                              num_true: int64 = 0,
                              num_sampled: int64 = 0,
                              unique: bool = false,
                              range_max: int64 = 0,
                              seed: int64 = 0,
                              seed2: int64 = 0): UniformCandidateSampler[oT] =
  return iiuniformCandidateSampler(scope,
                                   true_classes,
                                   num_true,
                                   num_sampled,
                                   unique,
                                   range_max,
                                   seed,
                                   seed2)

converter uniformCandidateSamplerToOut*[oT: oint64](op: UniformCandidateSampler[oT]): oT = return op.output

type AddT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128 | ostring

type Add*[oT:AddT] {.header:"generated.h", importcpp:"Add/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiadd[oT: AddT](scope: Scope,
          x: oT,
          y: oT): Add[oT] {.header:"generated.h", importcpp:"Add(*#, #, #)", constructor.}

proc add*[oT: AddT](scope: Scope,
          x: oT,
          y: oT): Add[oT] =
  return iiadd(scope,
               x,
               y)

converter addToOut*[oT: AddT](op: Add[oT]): oT = return op.output

type FloorT = obfloat16 | ohalf | ofloat | odouble

type Floor*[oT:FloorT] {.header:"generated.h", importcpp:"Floor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifloor[oT: FloorT](scope: Scope,
            x: oT): Floor[oT] {.header:"generated.h", importcpp:"Floor(*#, #)", constructor.}

proc floor*[oT: FloorT](scope: Scope,
            x: oT): Floor[oT] =
  return iifloor(scope,
                 x)

converter floorToOut*[oT: FloorT](op: Floor[oT]): oT = return op.output

type CeilT = obfloat16 | ohalf | ofloat | odouble

type Ceil*[oT:CeilT] {.header:"generated.h", importcpp:"Ceil/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiceil[oT: CeilT](scope: Scope,
           x: oT): Ceil[oT] {.header:"generated.h", importcpp:"Ceil(*#, #)", constructor.}

proc ceil*[oT: CeilT](scope: Scope,
           x: oT): Ceil[oT] =
  return iiceil(scope,
                x)

converter ceilToOut*[oT: CeilT](op: Ceil[oT]): oT = return op.output

type IsFiniteT = obfloat16 | ohalf | ofloat | odouble

type IsFinite*[oT:obool] {.header:"generated.h", importcpp:"IsFinite/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiisFinite[oT: obool](scope: Scope,
               x: IsFiniteT): IsFinite[oT] {.header:"generated.h", importcpp:"IsFinite(*#, #)", constructor.}

proc isFinite*[oT: obool](scope: Scope,
               x: IsFiniteT): IsFinite[oT] =
  return iiisFinite(scope,
                    x)

converter isFiniteToOut*[oT: obool](op: IsFinite[oT]): oT = return op.output

type MaxPool3DT = ohalf | obfloat16 | ofloat

type MaxPool3D*[oT:MaxPool3DT] {.header:"generated.h", importcpp:"MaxPool3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPool3D[oT: MaxPool3DT](scope: Scope,
                input: oT,
                ksize: ArraySlice[int],
                strides: ArraySlice[int],
                padding: cstring,
                data_format: cstring): MaxPool3D[oT] {.header:"generated.h", importcpp:"MaxPool3D(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPool3D*[oT: MaxPool3DT](scope: Scope,
                input: oT,
                ksize: openArray[int],
                strides: openArray[int],
                padding: cstring,
                data_format: cstring = "NDHWC"): MaxPool3D[oT] =
  return iimaxPool3D(scope,
                     input,
                     newArraySlice(ksize),
                     newArraySlice(strides),
                     padding,
                     data_format)

converter maxPool3DToOut*[oT: MaxPool3DT](op: MaxPool3D[oT]): oT = return op.output

type IsInfT = obfloat16 | ohalf | ofloat | odouble

type IsInf*[oT:obool] {.header:"generated.h", importcpp:"IsInf/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiisInf[oT: obool](scope: Scope,
            x: IsInfT): IsInf[oT] {.header:"generated.h", importcpp:"IsInf(*#, #)", constructor.}

proc isInf*[oT: obool](scope: Scope,
            x: IsInfT): IsInf[oT] =
  return iiisInf(scope,
                 x)

converter isInfToOut*[oT: obool](op: IsInf[oT]): oT = return op.output

type CumsumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type CumsumTidx = oint32 | oint64

type Cumsum*[oT:CumsumT] {.header:"generated.h", importcpp:"Cumsum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicumsum[oT: CumsumT](scope: Scope,
             x: oT,
             axis: CumsumTidx,
             exclusive: bool,
             reverse: bool): Cumsum[oT] {.header:"generated.h", importcpp:"Cumsum(*#, #, #, #, #)", constructor.}

proc cumsum*[oT: CumsumT](scope: Scope,
             x: oT,
             axis: CumsumTidx,
             exclusive: bool = false,
             reverse: bool = false): Cumsum[oT] =
  return iicumsum(scope,
                  x,
                  axis,
                  exclusive,
                  reverse)

converter cumsumToOut*[oT: CumsumT](op: Cumsum[oT]): oT = return op.output

type BesselI1eT = obfloat16 | ohalf | ofloat | odouble

type BesselI1e*[oT:BesselI1eT] {.header:"generated.h", importcpp:"BesselI1e/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibesselI1e[oT: BesselI1eT](scope: Scope,
                x: oT): BesselI1e[oT] {.header:"generated.h", importcpp:"BesselI1e(*#, #)", constructor.}

proc besselI1e*[oT: BesselI1eT](scope: Scope,
                x: oT): BesselI1e[oT] =
  return iibesselI1e(scope,
                     x)

converter besselI1eToOut*[oT: BesselI1eT](op: BesselI1e[oT]): oT = return op.output

type BesselI0eT = obfloat16 | ohalf | ofloat | odouble

type BesselI0e*[oT:BesselI0eT] {.header:"generated.h", importcpp:"BesselI0e/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibesselI0e[oT: BesselI0eT](scope: Scope,
                x: oT): BesselI0e[oT] {.header:"generated.h", importcpp:"BesselI0e(*#, #)", constructor.}

proc besselI0e*[oT: BesselI0eT](scope: Scope,
                x: oT): BesselI0e[oT] =
  return iibesselI0e(scope,
                     x)

converter besselI0eToOut*[oT: BesselI0eT](op: BesselI0e[oT]): oT = return op.output

type BiasAddGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type BiasAddGrad*[oT:BiasAddGradT] {.header:"generated.h", importcpp:"BiasAddGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibiasAddGrad[oT: BiasAddGradT](scope: Scope,
                  out_backprop: oT,
                  data_format: cstring): BiasAddGrad[oT] {.header:"generated.h", importcpp:"BiasAddGrad(*#, #, tensorflow::string(#))", constructor.}

proc biasAddGrad*[oT: BiasAddGradT](scope: Scope,
                  out_backprop: oT,
                  data_format: cstring = "NHWC"): BiasAddGrad[oT] =
  return iibiasAddGrad(scope,
                       out_backprop,
                       data_format)

converter biasAddGradToOut*[oT: BiasAddGradT](op: BiasAddGrad[oT]): oT = return op.output

type WriteHistogramSummaryT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type WriteHistogramSummary*{.header:"generated.h", importcpp:"WriteHistogramSummary/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteHistogramSummary(scope: Scope,
                            writer: oresource,
                            step: oint64,
                            tag: ostring,
                            values: WriteHistogramSummaryT): WriteHistogramSummary {.header:"generated.h", importcpp:"WriteHistogramSummary(*#, #, #, #, #)", constructor.}

proc writeHistogramSummary*(scope: Scope,
                            writer: oresource,
                            step: oint64,
                            tag: ostring,
                            values: WriteHistogramSummaryT): WriteHistogramSummary =
  return iiwriteHistogramSummary(scope,
                                 writer,
                                 step,
                                 tag,
                                 values)



type TanT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Tan*[oT:TanT] {.header:"generated.h", importcpp:"Tan/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitan[oT: TanT](scope: Scope,
          x: oT): Tan[oT] {.header:"generated.h", importcpp:"Tan(*#, #)", constructor.}

proc tan*[oT: TanT](scope: Scope,
          x: oT): Tan[oT] =
  return iitan(scope,
               x)

converter tanToOut*[oT: TanT](op: Tan[oT]): oT = return op.output

type TopKV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type TopKV2*[oT:TopKV2T] {.header:"generated.h", importcpp:"TopKV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitopKV2[oT: TopKV2T](scope: Scope,
             input: oT,
             k: oint32,
             sorted: bool): TopKV2[oT] {.header:"generated.h", importcpp:"TopKV2(*#, #, #, #)", constructor.}

proc topKV2*[oT: TopKV2T](scope: Scope,
             input: oT,
             k: oint32,
             sorted: bool = true): TopKV2[oT] =
  return iitopKV2(scope,
                  input,
                  k,
                  sorted)

converter topKV2ToOut*[oT: TopKV2T](op: TopKV2[oT]): oT = return op.output

type PadV2T = oall
type PadV2Tpaddings = oint32 | oint64

type PadV2*[oT:PadV2T] {.header:"generated.h", importcpp:"PadV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipadV2[oT: PadV2T](scope: Scope,
            input: oT,
            paddings: PadV2Tpaddings,
            constant_values: oT): PadV2[oT] {.header:"generated.h", importcpp:"PadV2(*#, #, #, #)", constructor.}

proc padV2*[oT: PadV2T](scope: Scope,
            input: oT,
            paddings: PadV2Tpaddings,
            constant_values: oT): PadV2[oT] =
  return iipadV2(scope,
                 input,
                 paddings,
                 constant_values)

converter padV2ToOut*[oT: PadV2T](op: PadV2[oT]): oT = return op.output

type CosT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Cos*[oT:CosT] {.header:"generated.h", importcpp:"Cos/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicos[oT: CosT](scope: Scope,
          x: oT): Cos[oT] {.header:"generated.h", importcpp:"Cos(*#, #)", constructor.}

proc cos*[oT: CosT](scope: Scope,
          x: oT): Cos[oT] =
  return iicos(scope,
               x)

converter cosToOut*[oT: CosT](op: Cos[oT]): oT = return op.output

type ErfcT = obfloat16 | ohalf | ofloat | odouble

type Erfc*[oT:ErfcT] {.header:"generated.h", importcpp:"Erfc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iierfc[oT: ErfcT](scope: Scope,
           x: oT): Erfc[oT] {.header:"generated.h", importcpp:"Erfc(*#, #)", constructor.}

proc erfc*[oT: ErfcT](scope: Scope,
           x: oT): Erfc[oT] =
  return iierfc(scope,
                x)

converter erfcToOut*[oT: ErfcT](op: Erfc[oT]): oT = return op.output

type DigammaT = obfloat16 | ohalf | ofloat | odouble

type Digamma*[oT:DigammaT] {.header:"generated.h", importcpp:"Digamma/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidigamma[oT: DigammaT](scope: Scope,
              x: oT): Digamma[oT] {.header:"generated.h", importcpp:"Digamma(*#, #)", constructor.}

proc digamma*[oT: DigammaT](scope: Scope,
              x: oT): Digamma[oT] =
  return iidigamma(scope,
                   x)

converter digammaToOut*[oT: DigammaT](op: Digamma[oT]): oT = return op.output


type BoostedTreesSerializeEnsemble*[oT:oint64] {.header:"generated.h", importcpp:"BoostedTreesSerializeEnsemble/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesSerializeEnsemble[oT: oint64](scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesSerializeEnsemble[oT] {.header:"generated.h", importcpp:"BoostedTreesSerializeEnsemble(*#, #)", constructor.}

proc boostedTreesSerializeEnsemble*[oT: oint64](scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesSerializeEnsemble[oT] =
  return iiboostedTreesSerializeEnsemble(scope,
                                         tree_ensemble_handle)

converter boostedTreesSerializeEnsembleToOut*[oT: oint64](op: BoostedTreesSerializeEnsemble[oT]): oT = return op.output

type AcoshT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Acosh*[oT:AcoshT] {.header:"generated.h", importcpp:"Acosh/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiacosh[oT: AcoshT](scope: Scope,
            x: oT): Acosh[oT] {.header:"generated.h", importcpp:"Acosh(*#, #)", constructor.}

proc acosh*[oT: AcoshT](scope: Scope,
            x: oT): Acosh[oT] =
  return iiacosh(scope,
                 x)

converter acoshToOut*[oT: AcoshT](op: Acosh[oT]): oT = return op.output

type CoshT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Cosh*[oT:CoshT] {.header:"generated.h", importcpp:"Cosh/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicosh[oT: CoshT](scope: Scope,
           x: oT): Cosh[oT] {.header:"generated.h", importcpp:"Cosh(*#, #)", constructor.}

proc cosh*[oT: CoshT](scope: Scope,
           x: oT): Cosh[oT] =
  return iicosh(scope,
                x)

converter coshToOut*[oT: CoshT](op: Cosh[oT]): oT = return op.output

type ResourceApplyProximalAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyProximalAdagrad*{.header:"generated.h", importcpp:"ResourceApplyProximalAdagrad/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyProximalAdagrad(scope: Scope,
                                   nvar: oresource,
                                   accum: oresource,
                                   lr: ResourceApplyProximalAdagradT,
                                   l1: ResourceApplyProximalAdagradT,
                                   l2: ResourceApplyProximalAdagradT,
                                   grad: ResourceApplyProximalAdagradT,
                                   use_locking: bool): ResourceApplyProximalAdagrad {.header:"generated.h", importcpp:"ResourceApplyProximalAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyProximalAdagrad*(scope: Scope,
                                   nvar: oresource,
                                   accum: oresource,
                                   lr: ResourceApplyProximalAdagradT,
                                   l1: ResourceApplyProximalAdagradT,
                                   l2: ResourceApplyProximalAdagradT,
                                   grad: ResourceApplyProximalAdagradT,
                                   use_locking: bool = false): ResourceApplyProximalAdagrad =
  return iiresourceApplyProximalAdagrad(scope,
                                        nvar,
                                        accum,
                                        lr,
                                        l1,
                                        l2,
                                        grad,
                                        use_locking)



type ResourceScatterDivTindices = oint32 | oint64
type ResourceScatterDivdtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceScatterDiv*{.header:"generated.h", importcpp:"ResourceScatterDiv/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterDiv(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterDivTindices,
                         updates: ResourceScatterDivdtype,
                         dtype: DType): ResourceScatterDiv {.header:"generated.h", importcpp:"ResourceScatterDiv(*#, #, #, #, #)", constructor.}

proc resourceScatterDiv*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterDivTindices,
                         updates: ResourceScatterDivdtype,
                         dtype: DType = DT_INVALID): ResourceScatterDiv =
  return iiresourceScatterDiv(scope,
                              resource,
                              indices,
                              updates,
                              dtype)



type AsinT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Asin*[oT:AsinT] {.header:"generated.h", importcpp:"Asin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiasin[oT: AsinT](scope: Scope,
           x: oT): Asin[oT] {.header:"generated.h", importcpp:"Asin(*#, #)", constructor.}

proc asin*[oT: AsinT](scope: Scope,
           x: oT): Asin[oT] =
  return iiasin(scope,
                x)

converter asinToOut*[oT: AsinT](op: Asin[oT]): oT = return op.output

type IHostRecvtensor_type = oall

type IHostRecv*[oT:IHostRecvtensor_type] {.header:"generated.h", importcpp:"_HostRecv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiHostRecv[oT: IHostRecvtensor_type](scope: Scope,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                client_terminated: bool,
                send_device_incarnation: int64): IHostRecv[oT] {.header:"generated.h", importcpp:"_HostRecv(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iHostRecv*[oT: IHostRecvtensor_type](scope: Scope,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                client_terminated: bool = false,
                send_device_incarnation: int64 = 0): IHostRecv[oT] =
  return iiiHostRecv(scope,
                     tensor_name,
                     send_device,
                     recv_device,
                     client_terminated,
                     send_device_incarnation)

converter iHostRecvToOut*[oT: IHostRecvtensor_type](op: IHostRecv[oT]): oT = return op.output


type ExperimentalScanDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalScanDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalScanDataset[oT: ovariant](scope: Scope,
                              input_dataset: oT,
                              initial_state: oinvalid,
                              other_arguments: oinvalid,
                              f: NameAttrList,
                              Tstate: ArraySlice[DType],
                              Targuments: ArraySlice[DType],
                              output_types: ArraySlice[DType],
                              output_shapes: ArraySlice[TensorShape],
                              preserve_cardinality: bool): ExperimentalScanDataset[oT] {.header:"generated.h", importcpp:"ExperimentalScanDataset(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalScanDataset*[oT: ovariant](scope: Scope,
                              input_dataset: oT,
                              initial_state: oinvalid,
                              other_arguments: oinvalid,
                              f: NameAttrList,
                              Tstate: openArray[DType],
                              Targuments: openArray[DType],
                              output_types: openArray[DType],
                              output_shapes: openArray[TensorShape],
                              preserve_cardinality: bool = false): ExperimentalScanDataset[oT] =
  return iiexperimentalScanDataset(scope,
                                   input_dataset,
                                   initial_state,
                                   other_arguments,
                                   f,
                                   newArraySlice(Tstate),
                                   newArraySlice(Targuments),
                                   newArraySlice(output_types),
                                   newArraySlice(output_shapes),
                                   preserve_cardinality)

converter experimentalScanDatasetToOut*[oT: ovariant](op: ExperimentalScanDataset[oT]): oT = return op.output

type Log1pT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Log1p*[oT:Log1pT] {.header:"generated.h", importcpp:"Log1p/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilog1p[oT: Log1pT](scope: Scope,
            x: oT): Log1p[oT] {.header:"generated.h", importcpp:"Log1p(*#, #)", constructor.}

proc log1p*[oT: Log1pT](scope: Scope,
            x: oT): Log1p[oT] =
  return iilog1p(scope,
                 x)

converter log1pToOut*[oT: Log1pT](op: Log1p[oT]): oT = return op.output


type TensorArraySize*[oT:oint32] {.header:"generated.h", importcpp:"TensorArraySize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArraySize[oT: oint32](scope: Scope,
                      handle: ostring,
                      flow_in: ofloat): TensorArraySize[oT] {.header:"generated.h", importcpp:"TensorArraySize(*#, #, #)", constructor.}

proc tensorArraySize*[oT: oint32](scope: Scope,
                      handle: ostring,
                      flow_in: ofloat): TensorArraySize[oT] =
  return iitensorArraySize(scope,
                           handle,
                           flow_in)

converter tensorArraySizeToOut*[oT: oint32](op: TensorArraySize[oT]): oT = return op.output

type RequantizeTinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type Requantizeout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type Requantize*[oT:Requantizeout_type] {.header:"generated.h", importcpp:"Requantize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirequantize[oT: Requantizeout_type](scope: Scope,
                 input: RequantizeTinput,
                 input_min: ofloat,
                 input_max: ofloat,
                 requested_output_min: ofloat,
                 requested_output_max: ofloat): Requantize[oT] {.header:"generated.h", importcpp:"Requantize(*#, #, #, #, #, #)", constructor.}

proc requantize*[oT: Requantizeout_type](scope: Scope,
                 input: RequantizeTinput,
                 input_min: ofloat,
                 input_max: ofloat,
                 requested_output_min: ofloat,
                 requested_output_max: ofloat): Requantize[oT] =
  return iirequantize(scope,
                      input,
                      input_min,
                      input_max,
                      requested_output_min,
                      requested_output_max)

converter requantizeToOut*[oT: Requantizeout_type](op: Requantize[oT]): oT = return op.output

type ExpT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Exp*[oT:ExpT] {.header:"generated.h", importcpp:"Exp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexp[oT: ExpT](scope: Scope,
          x: oT): Exp[oT] {.header:"generated.h", importcpp:"Exp(*#, #)", constructor.}

proc exp*[oT: ExpT](scope: Scope,
          x: oT): Exp[oT] =
  return iiexp(scope,
               x)

converter expToOut*[oT: ExpT](op: Exp[oT]): oT = return op.output

type ScatterNdAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ScatterNdAddTindices = oint32 | oint64

type ScatterNdAdd*[oT:ScatterNdAddT] {.header:"generated.h", importcpp:"ScatterNdAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterNdAdd[oT: ScatterNdAddT](scope: Scope,
                   nref: oT,
                   indices: ScatterNdAddTindices,
                   updates: oT,
                   use_locking: bool): ScatterNdAdd[oT] {.header:"generated.h", importcpp:"ScatterNdAdd(*#, #, #, #, #)", constructor.}

proc scatterNdAdd*[oT: ScatterNdAddT](scope: Scope,
                   nref: oT,
                   indices: ScatterNdAddTindices,
                   updates: oT,
                   use_locking: bool = false): ScatterNdAdd[oT] =
  return iiscatterNdAdd(scope,
                        nref,
                        indices,
                        updates,
                        use_locking)

converter scatterNdAddToOut*[oT: ScatterNdAddT](op: ScatterNdAdd[oT]): oT = return op.output


type MutableHashTableOfTensors*[oT:ostring] {.header:"generated.h", importcpp:"MutableHashTableOfTensors/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutableHashTableOfTensors[oT: ostring](scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                use_node_name_sharing: bool,
                                key_dtype: DType,
                                value_dtype: DType,
                                value_shape: TensorShape): MutableHashTableOfTensors[oT] {.header:"generated.h", importcpp:"MutableHashTableOfTensors(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc mutableHashTableOfTensors*[oT: ostring](scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                use_node_name_sharing: bool = false,
                                key_dtype: DType = DT_INVALID,
                                value_dtype: DType = DT_INVALID,
                                value_shape: TensorShape = [].shape): MutableHashTableOfTensors[oT] =
  return iimutableHashTableOfTensors(scope,
                                     container,
                                     shared_name,
                                     use_node_name_sharing,
                                     key_dtype,
                                     value_dtype,
                                     value_shape)

converter mutableHashTableOfTensorsToOut*[oT: ostring](op: MutableHashTableOfTensors[oT]): oT = return op.output

type Dilation2DT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Dilation2D*[oT:Dilation2DT] {.header:"generated.h", importcpp:"Dilation2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidilation2D[oT: Dilation2DT](scope: Scope,
                 input: oT,
                 filter: oT,
                 strides: ArraySlice[int],
                 rates: ArraySlice[int],
                 padding: cstring): Dilation2D[oT] {.header:"generated.h", importcpp:"Dilation2D(*#, #, #, #, #, tensorflow::string(#))", constructor.}

proc dilation2D*[oT: Dilation2DT](scope: Scope,
                 input: oT,
                 filter: oT,
                 strides: openArray[int],
                 rates: openArray[int],
                 padding: cstring): Dilation2D[oT] =
  return iidilation2D(scope,
                      input,
                      filter,
                      newArraySlice(strides),
                      newArraySlice(rates),
                      padding)

converter dilation2DToOut*[oT: Dilation2DT](op: Dilation2D[oT]): oT = return op.output


type DeserializeIterator*{.header:"generated.h", importcpp:"DeserializeIterator/*'0*/".} = object
  operation: Operation[oinvalid]


proc iideserializeIterator(scope: Scope,
                          resource_handle: oresource,
                          serialized: ovariant): DeserializeIterator {.header:"generated.h", importcpp:"DeserializeIterator(*#, #, #)", constructor.}

proc deserializeIterator*(scope: Scope,
                          resource_handle: oresource,
                          serialized: ovariant): DeserializeIterator =
  return iideserializeIterator(scope,
                               resource_handle,
                               serialized)



type RsqrtGradT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type RsqrtGrad*[oT:RsqrtGradT] {.header:"generated.h", importcpp:"RsqrtGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirsqrtGrad[oT: RsqrtGradT](scope: Scope,
                y: oT,
                dy: oT): RsqrtGrad[oT] {.header:"generated.h", importcpp:"RsqrtGrad(*#, #, #)", constructor.}

proc rsqrtGrad*[oT: RsqrtGradT](scope: Scope,
                y: oT,
                dy: oT): RsqrtGrad[oT] =
  return iirsqrtGrad(scope,
                     y,
                     dy)

converter rsqrtGradToOut*[oT: RsqrtGradT](op: RsqrtGrad[oT]): oT = return op.output

type QuantizedInstanceNormT = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedInstanceNorm*[oT:QuantizedInstanceNormT] {.header:"generated.h", importcpp:"QuantizedInstanceNorm/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedInstanceNorm[oT: QuantizedInstanceNormT](scope: Scope,
                            x: oT,
                            x_min: ofloat,
                            x_max: ofloat,
                            min_separation: float32,
                            output_range_given: bool,
                            given_y_min: float32,
                            given_y_max: float32,
                            variance_epsilon: float32): QuantizedInstanceNorm[oT] {.header:"generated.h", importcpp:"QuantizedInstanceNorm(*#, #, #, #, #, #, #, #, #)", constructor.}

proc quantizedInstanceNorm*[oT: QuantizedInstanceNormT](scope: Scope,
                            x: oT,
                            x_min: ofloat,
                            x_max: ofloat,
                            min_separation: float32 = 0.001000000047497451.float32,
                            output_range_given: bool = false,
                            given_y_min: float32 = 0.0.float32,
                            given_y_max: float32 = 0.0.float32,
                            variance_epsilon: float32 = 9.999999747378752e-06.float32): QuantizedInstanceNorm[oT] =
  return iiquantizedInstanceNorm(scope,
                                 x,
                                 x_min,
                                 x_max,
                                 min_separation,
                                 output_range_given,
                                 given_y_min,
                                 given_y_max,
                                 variance_epsilon)

converter quantizedInstanceNormToOut*[oT: QuantizedInstanceNormT](op: QuantizedInstanceNorm[oT]): oT = return op.output

type RsqrtT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Rsqrt*[oT:RsqrtT] {.header:"generated.h", importcpp:"Rsqrt/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirsqrt[oT: RsqrtT](scope: Scope,
            x: oT): Rsqrt[oT] {.header:"generated.h", importcpp:"Rsqrt(*#, #)", constructor.}

proc rsqrt*[oT: RsqrtT](scope: Scope,
            x: oT): Rsqrt[oT] =
  return iirsqrt(scope,
                 x)

converter rsqrtToOut*[oT: RsqrtT](op: Rsqrt[oT]): oT = return op.output


type InitializeTableFromTextFile*{.header:"generated.h", importcpp:"InitializeTableFromTextFile/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiinitializeTableFromTextFile(scope: Scope,
                                  table_handle: ostring,
                                  filename: ostring,
                                  key_index: int64,
                                  value_index: int64,
                                  vocab_size: int64,
                                  delimiter: cstring): InitializeTableFromTextFile {.header:"generated.h", importcpp:"InitializeTableFromTextFile(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc initializeTableFromTextFile*(scope: Scope,
                                  table_handle: ostring,
                                  filename: ostring,
                                  key_index: int64 = 0,
                                  value_index: int64 = 0,
                                  vocab_size: int64 = -1,
                                  delimiter: cstring = "	"): InitializeTableFromTextFile =
  return iiinitializeTableFromTextFile(scope,
                                       table_handle,
                                       filename,
                                       key_index,
                                       value_index,
                                       vocab_size,
                                       delimiter)



type SqrtGradT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type SqrtGrad*[oT:SqrtGradT] {.header:"generated.h", importcpp:"SqrtGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisqrtGrad[oT: SqrtGradT](scope: Scope,
               y: oT,
               dy: oT): SqrtGrad[oT] {.header:"generated.h", importcpp:"SqrtGrad(*#, #, #)", constructor.}

proc sqrtGrad*[oT: SqrtGradT](scope: Scope,
               y: oT,
               dy: oT): SqrtGrad[oT] =
  return iisqrtGrad(scope,
                    y,
                    dy)

converter sqrtGradToOut*[oT: SqrtGradT](op: SqrtGrad[oT]): oT = return op.output

type SparseSegmentSqrtNT = ofloat | odouble
type SparseSegmentSqrtNTidx = oint32 | oint64

type SparseSegmentSqrtN*[oT:SparseSegmentSqrtNT] {.header:"generated.h", importcpp:"SparseSegmentSqrtN/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentSqrtN[oT: SparseSegmentSqrtNT](scope: Scope,
                         data: oT,
                         indices: SparseSegmentSqrtNTidx,
                         segment_ids: oint32): SparseSegmentSqrtN[oT] {.header:"generated.h", importcpp:"SparseSegmentSqrtN(*#, #, #, #)", constructor.}

proc sparseSegmentSqrtN*[oT: SparseSegmentSqrtNT](scope: Scope,
                         data: oT,
                         indices: SparseSegmentSqrtNTidx,
                         segment_ids: oint32): SparseSegmentSqrtN[oT] =
  return iisparseSegmentSqrtN(scope,
                              data,
                              indices,
                              segment_ids)

converter sparseSegmentSqrtNToOut*[oT: SparseSegmentSqrtNT](op: SparseSegmentSqrtN[oT]): oT = return op.output

type IMklMaximumT = ohalf | ofloat | odouble | oint32 | oint64

type IMklMaximum*[oT:IMklMaximumT] {.header:"generated.h", importcpp:"_MklMaximum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiMklMaximum[oT: IMklMaximumT](scope: Scope,
                  x: oT,
                  y: oT,
                  mkl_x: ouint8,
                  mkl_y: ouint8): IMklMaximum[oT] {.header:"generated.h", importcpp:"_MklMaximum(*#, #, #, #, #)", constructor.}

proc iMklMaximum*[oT: IMklMaximumT](scope: Scope,
                  x: oT,
                  y: oT,
                  mkl_x: ouint8,
                  mkl_y: ouint8): IMklMaximum[oT] =
  return iiiMklMaximum(scope,
                       x,
                       y,
                       mkl_x,
                       mkl_y)

converter iMklMaximumToOut*[oT: IMklMaximumT](op: IMklMaximum[oT]): oT = return op.output

type SqrtT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Sqrt*[oT:SqrtT] {.header:"generated.h", importcpp:"Sqrt/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisqrt[oT: SqrtT](scope: Scope,
           x: oT): Sqrt[oT] {.header:"generated.h", importcpp:"Sqrt(*#, #)", constructor.}

proc sqrt*[oT: SqrtT](scope: Scope,
           x: oT): Sqrt[oT] =
  return iisqrt(scope,
                x)

converter sqrtToOut*[oT: SqrtT](op: Sqrt[oT]): oT = return op.output

type InvGradT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type InvGrad*[oT:InvGradT] {.header:"generated.h", importcpp:"InvGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinvGrad[oT: InvGradT](scope: Scope,
              y: oT,
              dy: oT): InvGrad[oT] {.header:"generated.h", importcpp:"InvGrad(*#, #, #)", constructor.}

proc invGrad*[oT: InvGradT](scope: Scope,
              y: oT,
              dy: oT): InvGrad[oT] =
  return iiinvGrad(scope,
                   y,
                   dy)

converter invGradToOut*[oT: InvGradT](op: InvGrad[oT]): oT = return op.output

type InvT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Inv*[oT:InvT] {.header:"generated.h", importcpp:"Inv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinv[oT: InvT](scope: Scope,
          x: oT): Inv[oT] {.header:"generated.h", importcpp:"Inv(*#, #)", constructor.}

proc inv*[oT: InvT](scope: Scope,
          x: oT): Inv[oT] =
  return iiinv(scope,
               x)

converter invToOut*[oT: InvT](op: Inv[oT]): oT = return op.output


type ExperimentalStatsAggregatorSummary*[oT:ostring] {.header:"generated.h", importcpp:"ExperimentalStatsAggregatorSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalStatsAggregatorSummary[oT: ostring](scope: Scope,
                                         niterator: oresource): ExperimentalStatsAggregatorSummary[oT] {.header:"generated.h", importcpp:"ExperimentalStatsAggregatorSummary(*#, #)", constructor.}

proc experimentalStatsAggregatorSummary*[oT: ostring](scope: Scope,
                                         niterator: oresource): ExperimentalStatsAggregatorSummary[oT] =
  return iiexperimentalStatsAggregatorSummary(scope,
                                              niterator)

converter experimentalStatsAggregatorSummaryToOut*[oT: ostring](op: ExperimentalStatsAggregatorSummary[oT]): oT = return op.output

type IHostCastSrcT = oall
type IHostCastDstT = oall

type IHostCast*[oT:IHostCastDstT] {.header:"generated.h", importcpp:"_HostCast/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiHostCast[oT: IHostCastDstT](scope: Scope,
                x: IHostCastSrcT,
                Truncate: bool): IHostCast[oT] {.header:"generated.h", importcpp:"_HostCast(*#, #, #)", constructor.}

proc iHostCast*[oT: IHostCastDstT](scope: Scope,
                x: IHostCastSrcT,
                Truncate: bool = false): IHostCast[oT] =
  return iiiHostCast(scope,
                     x,
                     Truncate)

converter iHostCastToOut*[oT: IHostCastDstT](op: IHostCast[oT]): oT = return op.output

type BatchMatMulT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type BatchMatMul*[oT:BatchMatMulT] {.header:"generated.h", importcpp:"BatchMatMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatMul[oT: BatchMatMulT](scope: Scope,
                  x: oT,
                  y: oT,
                  adj_y: bool,
                  adj_x: bool): BatchMatMul[oT] {.header:"generated.h", importcpp:"BatchMatMul(*#, #, #, #, #)", constructor.}

proc batchMatMul*[oT: BatchMatMulT](scope: Scope,
                  x: oT,
                  y: oT,
                  adj_y: bool = false,
                  adj_x: bool = false): BatchMatMul[oT] =
  return iibatchMatMul(scope,
                       x,
                       y,
                       adj_y,
                       adj_x)

converter batchMatMulToOut*[oT: BatchMatMulT](op: BatchMatMul[oT]): oT = return op.output

type AccumulateNV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type AccumulateNV2*[oT:AccumulateNV2T] {.header:"generated.h", importcpp:"AccumulateNV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaccumulateNV2[oT: AccumulateNV2T](scope: Scope,
                    inputs: oT,
                    shape: TensorShape): AccumulateNV2[oT] {.header:"generated.h", importcpp:"AccumulateNV2(*#, #, #)", constructor.}

proc accumulateNV2*[oT: AccumulateNV2T](scope: Scope,
                    inputs: oT,
                    shape: TensorShape = [].shape): AccumulateNV2[oT] =
  return iiaccumulateNV2(scope,
                         inputs,
                         shape)

converter accumulateNV2ToOut*[oT: AccumulateNV2T](op: AccumulateNV2[oT]): oT = return op.output


type InitializeTableFromTextFileV2*{.header:"generated.h", importcpp:"InitializeTableFromTextFileV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiinitializeTableFromTextFileV2(scope: Scope,
                                    table_handle: oresource,
                                    filename: ostring,
                                    key_index: int64,
                                    value_index: int64,
                                    vocab_size: int64,
                                    delimiter: cstring): InitializeTableFromTextFileV2 {.header:"generated.h", importcpp:"InitializeTableFromTextFileV2(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc initializeTableFromTextFileV2*(scope: Scope,
                                    table_handle: oresource,
                                    filename: ostring,
                                    key_index: int64 = 0,
                                    value_index: int64 = 0,
                                    vocab_size: int64 = -1,
                                    delimiter: cstring = "	"): InitializeTableFromTextFileV2 =
  return iiinitializeTableFromTextFileV2(scope,
                                         table_handle,
                                         filename,
                                         key_index,
                                         value_index,
                                         vocab_size,
                                         delimiter)



type InitializeTableTkey = oall
type InitializeTableTval = oall

type InitializeTable*{.header:"generated.h", importcpp:"InitializeTable/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiinitializeTable(scope: Scope,
                      table_handle: ostring,
                      keys: InitializeTableTkey,
                      values: InitializeTableTval): InitializeTable {.header:"generated.h", importcpp:"InitializeTable(*#, #, #, #)", constructor.}

proc initializeTable*(scope: Scope,
                      table_handle: ostring,
                      keys: InitializeTableTkey,
                      values: InitializeTableTval): InitializeTable =
  return iiinitializeTable(scope,
                           table_handle,
                           keys,
                           values)



type FractionalAvgPoolGradT = ofloat | odouble | oint32 | oint64

type FractionalAvgPoolGrad*[oT:FractionalAvgPoolGradT] {.header:"generated.h", importcpp:"FractionalAvgPoolGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifractionalAvgPoolGrad[oT: FractionalAvgPoolGradT](scope: Scope,
                            orig_input_tensor_shape: oint64,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool): FractionalAvgPoolGrad[oT] {.header:"generated.h", importcpp:"FractionalAvgPoolGrad(*#, #, #, #, #, #)", constructor.}

proc fractionalAvgPoolGrad*[oT: FractionalAvgPoolGradT](scope: Scope,
                            orig_input_tensor_shape: oint64,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool = false): FractionalAvgPoolGrad[oT] =
  return iifractionalAvgPoolGrad(scope,
                                 orig_input_tensor_shape,
                                 out_backprop,
                                 row_pooling_sequence,
                                 col_pooling_sequence,
                                 overlapping)

converter fractionalAvgPoolGradToOut*[oT: FractionalAvgPoolGradT](op: FractionalAvgPoolGrad[oT]): oT = return op.output

type MutableDenseHashTableV2key_dtype = oall

type MutableDenseHashTableV2*[oT:oresource] {.header:"generated.h", importcpp:"MutableDenseHashTableV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutableDenseHashTableV2[oT: oresource](scope: Scope,
                              empty_key: MutableDenseHashTableV2key_dtype,
                              deleted_key: MutableDenseHashTableV2key_dtype,
                              container: cstring,
                              shared_name: cstring,
                              use_node_name_sharing: bool,
                              max_load_factor: float32,
                              value_dtype: DType,
                              value_shape: TensorShape,
                              initial_num_buckets: int64): MutableDenseHashTableV2[oT] {.header:"generated.h", importcpp:"MutableDenseHashTableV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc mutableDenseHashTableV2*[oT: oresource](scope: Scope,
                              empty_key: MutableDenseHashTableV2key_dtype,
                              deleted_key: MutableDenseHashTableV2key_dtype,
                              container: cstring,
                              shared_name: cstring,
                              use_node_name_sharing: bool = false,
                              max_load_factor: float32 = 0.800000011920929.float32,
                              value_dtype: DType = DT_INVALID,
                              value_shape: TensorShape = [].shape,
                              initial_num_buckets: int64 = 131072): MutableDenseHashTableV2[oT] =
  return iimutableDenseHashTableV2(scope,
                                   empty_key,
                                   deleted_key,
                                   container,
                                   shared_name,
                                   use_node_name_sharing,
                                   max_load_factor,
                                   value_dtype,
                                   value_shape,
                                   initial_num_buckets)

converter mutableDenseHashTableV2ToOut*[oT: oresource](op: MutableDenseHashTableV2[oT]): oT = return op.output


type MutableHashTable*[oT:ostring] {.header:"generated.h", importcpp:"MutableHashTable/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutableHashTable[oT: ostring](scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       use_node_name_sharing: bool,
                       key_dtype: DType,
                       value_dtype: DType): MutableHashTable[oT] {.header:"generated.h", importcpp:"MutableHashTable(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc mutableHashTable*[oT: ostring](scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       use_node_name_sharing: bool = false,
                       key_dtype: DType = DT_INVALID,
                       value_dtype: DType = DT_INVALID): MutableHashTable[oT] =
  return iimutableHashTable(scope,
                            container,
                            shared_name,
                            use_node_name_sharing,
                            key_dtype,
                            value_dtype)

converter mutableHashTableToOut*[oT: ostring](op: MutableHashTable[oT]): oT = return op.output


type BoostedTreesCenterBias*[oT:obool] {.header:"generated.h", importcpp:"BoostedTreesCenterBias/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesCenterBias[oT: obool](scope: Scope,
                             tree_ensemble_handle: oresource,
                             mean_gradients: ofloat,
                             mean_hessians: ofloat,
                             l1: ofloat,
                             l2: ofloat): BoostedTreesCenterBias[oT] {.header:"generated.h", importcpp:"BoostedTreesCenterBias(*#, #, #, #, #, #)", constructor.}

proc boostedTreesCenterBias*[oT: obool](scope: Scope,
                             tree_ensemble_handle: oresource,
                             mean_gradients: ofloat,
                             mean_hessians: ofloat,
                             l1: ofloat,
                             l2: ofloat): BoostedTreesCenterBias[oT] =
  return iiboostedTreesCenterBias(scope,
                                  tree_ensemble_handle,
                                  mean_gradients,
                                  mean_hessians,
                                  l1,
                                  l2)

converter boostedTreesCenterBiasToOut*[oT: obool](op: BoostedTreesCenterBias[oT]): oT = return op.output


type HashTableV2*[oT:oresource] {.header:"generated.h", importcpp:"HashTableV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iihashTableV2[oT: oresource](scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  use_node_name_sharing: bool,
                  key_dtype: DType,
                  value_dtype: DType): HashTableV2[oT] {.header:"generated.h", importcpp:"HashTableV2(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc hashTableV2*[oT: oresource](scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  use_node_name_sharing: bool = false,
                  key_dtype: DType = DT_INVALID,
                  value_dtype: DType = DT_INVALID): HashTableV2[oT] =
  return iihashTableV2(scope,
                       container,
                       shared_name,
                       use_node_name_sharing,
                       key_dtype,
                       value_dtype)

converter hashTableV2ToOut*[oT: oresource](op: HashTableV2[oT]): oT = return op.output


type HashTable*[oT:ostring] {.header:"generated.h", importcpp:"HashTable/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iihashTable[oT: ostring](scope: Scope,
                container: cstring,
                shared_name: cstring,
                use_node_name_sharing: bool,
                key_dtype: DType,
                value_dtype: DType): HashTable[oT] {.header:"generated.h", importcpp:"HashTable(*#, tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc hashTable*[oT: ostring](scope: Scope,
                container: cstring,
                shared_name: cstring,
                use_node_name_sharing: bool = false,
                key_dtype: DType = DT_INVALID,
                value_dtype: DType = DT_INVALID): HashTable[oT] =
  return iihashTable(scope,
                     container,
                     shared_name,
                     use_node_name_sharing,
                     key_dtype,
                     value_dtype)

converter hashTableToOut*[oT: ostring](op: HashTable[oT]): oT = return op.output

type LookupTableImportV2Tin = oall
type LookupTableImportV2Tout = oall

type LookupTableImportV2*{.header:"generated.h", importcpp:"LookupTableImportV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iilookupTableImportV2(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableImportV2Tin,
                          values: LookupTableImportV2Tout): LookupTableImportV2 {.header:"generated.h", importcpp:"LookupTableImportV2(*#, #, #, #)", constructor.}

proc lookupTableImportV2*(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableImportV2Tin,
                          values: LookupTableImportV2Tout): LookupTableImportV2 =
  return iilookupTableImportV2(scope,
                               table_handle,
                               keys,
                               values)




type RegexFullMatch*[oT:obool] {.header:"generated.h", importcpp:"RegexFullMatch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiregexFullMatch[oT: obool](scope: Scope,
                     input: ostring,
                     pattern: ostring): RegexFullMatch[oT] {.header:"generated.h", importcpp:"RegexFullMatch(*#, #, #)", constructor.}

proc regexFullMatch*[oT: obool](scope: Scope,
                     input: ostring,
                     pattern: ostring): RegexFullMatch[oT] =
  return iiregexFullMatch(scope,
                          input,
                          pattern)

converter regexFullMatchToOut*[oT: obool](op: RegexFullMatch[oT]): oT = return op.output

type LookupTableImportTin = oall
type LookupTableImportTout = oall

type LookupTableImport*{.header:"generated.h", importcpp:"LookupTableImport/*'0*/".} = object
  operation: Operation[oinvalid]


proc iilookupTableImport(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableImportTin,
                        values: LookupTableImportTout): LookupTableImport {.header:"generated.h", importcpp:"LookupTableImport(*#, #, #, #)", constructor.}

proc lookupTableImport*(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableImportTin,
                        values: LookupTableImportTout): LookupTableImport =
  return iilookupTableImport(scope,
                             table_handle,
                             keys,
                             values)




type NonMaxSuppressionWithOverlaps*[oT:oint32] {.header:"generated.h", importcpp:"NonMaxSuppressionWithOverlaps/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinonMaxSuppressionWithOverlaps[oT: oint32](scope: Scope,
                                    overlaps: ofloat,
                                    scores: ofloat,
                                    max_output_size: oT,
                                    overlap_threshold: ofloat,
                                    score_threshold: ofloat): NonMaxSuppressionWithOverlaps[oT] {.header:"generated.h", importcpp:"NonMaxSuppressionWithOverlaps(*#, #, #, #, #, #)", constructor.}

proc nonMaxSuppressionWithOverlaps*[oT: oint32](scope: Scope,
                                    overlaps: ofloat,
                                    scores: ofloat,
                                    max_output_size: oT,
                                    overlap_threshold: ofloat,
                                    score_threshold: ofloat): NonMaxSuppressionWithOverlaps[oT] =
  return iinonMaxSuppressionWithOverlaps(scope,
                                         overlaps,
                                         scores,
                                         max_output_size,
                                         overlap_threshold,
                                         score_threshold)

converter nonMaxSuppressionWithOverlapsToOut*[oT: oint32](op: NonMaxSuppressionWithOverlaps[oT]): oT = return op.output

type LookupTableExportV2Tkeys = oall

type LookupTableExportV2*[oT:LookupTableExportV2Tkeys] {.header:"generated.h", importcpp:"LookupTableExportV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilookupTableExportV2[oT: LookupTableExportV2Tkeys](scope: Scope,
                          table_handle: oresource,
                          Tvalues: DType): LookupTableExportV2[oT] {.header:"generated.h", importcpp:"LookupTableExportV2(*#, #, #)", constructor.}

proc lookupTableExportV2*[oT: LookupTableExportV2Tkeys](scope: Scope,
                          table_handle: oresource,
                          Tvalues: DType = DT_INVALID): LookupTableExportV2[oT] =
  return iilookupTableExportV2(scope,
                               table_handle,
                               Tvalues)

converter lookupTableExportV2ToOut*[oT: LookupTableExportV2Tkeys](op: LookupTableExportV2[oT]): oT = return op.output

type AssignVariableOpdtype = oall

type AssignVariableOp*{.header:"generated.h", importcpp:"AssignVariableOp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiassignVariableOp(scope: Scope,
                       resource: oresource,
                       value: AssignVariableOpdtype,
                       dtype: DType): AssignVariableOp {.header:"generated.h", importcpp:"AssignVariableOp(*#, #, #, #)", constructor.}

proc assignVariableOp*(scope: Scope,
                       resource: oresource,
                       value: AssignVariableOpdtype,
                       dtype: DType = DT_INVALID): AssignVariableOp =
  return iiassignVariableOp(scope,
                            resource,
                            value,
                            dtype)




type LookupTableSize*[oT:oint64] {.header:"generated.h", importcpp:"LookupTableSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilookupTableSize[oT: oint64](scope: Scope,
                      table_handle: ostring): LookupTableSize[oT] {.header:"generated.h", importcpp:"LookupTableSize(*#, #)", constructor.}

proc lookupTableSize*[oT: oint64](scope: Scope,
                      table_handle: ostring): LookupTableSize[oT] =
  return iilookupTableSize(scope,
                           table_handle)

converter lookupTableSizeToOut*[oT: oint64](op: LookupTableSize[oT]): oT = return op.output


type PaddingFIFOQueueV2*[oT:oresource] {.header:"generated.h", importcpp:"PaddingFIFOQueueV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipaddingFIFOQueueV2[oT: oresource](scope: Scope,
                         component_types: ArraySlice[DType],
                         shapes: ArraySlice[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64): PaddingFIFOQueueV2[oT] {.header:"generated.h", importcpp:"PaddingFIFOQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc paddingFIFOQueueV2*[oT: oresource](scope: Scope,
                         component_types: openArray[DType],
                         shapes: openArray[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64 = -1): PaddingFIFOQueueV2[oT] =
  return iipaddingFIFOQueueV2(scope,
                              newArraySlice(component_types),
                              newArraySlice(shapes),
                              container,
                              shared_name,
                              capacity)

converter paddingFIFOQueueV2ToOut*[oT: oresource](op: PaddingFIFOQueueV2[oT]): oT = return op.output

type LookupTableFindTin = oall
type LookupTableFindTout = oall

type LookupTableFind*[oT:LookupTableFindTout] {.header:"generated.h", importcpp:"LookupTableFind/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilookupTableFind[oT: LookupTableFindTout](scope: Scope,
                      table_handle: ostring,
                      keys: LookupTableFindTin,
                      default_value: oT): LookupTableFind[oT] {.header:"generated.h", importcpp:"LookupTableFind(*#, #, #, #)", constructor.}

proc lookupTableFind*[oT: LookupTableFindTout](scope: Scope,
                      table_handle: ostring,
                      keys: LookupTableFindTin,
                      default_value: oT): LookupTableFind[oT] =
  return iilookupTableFind(scope,
                           table_handle,
                           keys,
                           default_value)

converter lookupTableFindToOut*[oT: LookupTableFindTout](op: LookupTableFind[oT]): oT = return op.output

type LessEqualT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type LessEqual*[oT:obool] {.header:"generated.h", importcpp:"LessEqual/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilessEqual[oT: obool](scope: Scope,
                x: LessEqualT,
                y: LessEqualT): LessEqual[oT] {.header:"generated.h", importcpp:"LessEqual(*#, #, #)", constructor.}

proc lessEqual*[oT: obool](scope: Scope,
                x: LessEqualT,
                y: LessEqualT): LessEqual[oT] =
  return iilessEqual(scope,
                     x,
                     y)

converter lessEqualToOut*[oT: obool](op: LessEqual[oT]): oT = return op.output


type Timestamp*[oT:odouble] {.header:"generated.h", importcpp:"Timestamp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitimestamp[oT: odouble](scope: Scope): Timestamp[oT] {.header:"generated.h", importcpp:"Timestamp(*#)", constructor.}

proc timestamp*[oT: odouble](scope: Scope): Timestamp[oT] =
  return iitimestamp(scope)

converter timestampToOut*[oT: odouble](op: Timestamp[oT]): oT = return op.output


type MergeSummary*[oT:ostring] {.header:"generated.h", importcpp:"MergeSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimergeSummary[oT: ostring](scope: Scope,
                   inputs: oT): MergeSummary[oT] {.header:"generated.h", importcpp:"MergeSummary(*#, #)", constructor.}

proc mergeSummary*[oT: ostring](scope: Scope,
                   inputs: oT): MergeSummary[oT] =
  return iimergeSummary(scope,
                        inputs)

converter mergeSummaryToOut*[oT: ostring](op: MergeSummary[oT]): oT = return op.output

type AvgPoolT = ohalf | obfloat16 | ofloat | odouble

type AvgPool*[oT:AvgPoolT] {.header:"generated.h", importcpp:"AvgPool/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiavgPool[oT: AvgPoolT](scope: Scope,
              value: oT,
              ksize: ArraySlice[int],
              strides: ArraySlice[int],
              padding: cstring,
              data_format: cstring): AvgPool[oT] {.header:"generated.h", importcpp:"AvgPool(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc avgPool*[oT: AvgPoolT](scope: Scope,
              value: oT,
              ksize: openArray[int],
              strides: openArray[int],
              padding: cstring,
              data_format: cstring = "NHWC"): AvgPool[oT] =
  return iiavgPool(scope,
                   value,
                   newArraySlice(ksize),
                   newArraySlice(strides),
                   padding,
                   data_format)

converter avgPoolToOut*[oT: AvgPoolT](op: AvgPool[oT]): oT = return op.output


type AudioSummaryV2*[oT:ostring] {.header:"generated.h", importcpp:"AudioSummaryV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaudioSummaryV2[oT: ostring](scope: Scope,
                     tag: oT,
                     tensor: ofloat,
                     sample_rate: ofloat,
                     max_outputs: int64): AudioSummaryV2[oT] {.header:"generated.h", importcpp:"AudioSummaryV2(*#, #, #, #, #)", constructor.}

proc audioSummaryV2*[oT: ostring](scope: Scope,
                     tag: oT,
                     tensor: ofloat,
                     sample_rate: ofloat,
                     max_outputs: int64 = 3): AudioSummaryV2[oT] =
  return iiaudioSummaryV2(scope,
                          tag,
                          tensor,
                          sample_rate,
                          max_outputs)

converter audioSummaryV2ToOut*[oT: ostring](op: AudioSummaryV2[oT]): oT = return op.output

type HistogramSummaryT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type HistogramSummary*[oT:ostring] {.header:"generated.h", importcpp:"HistogramSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iihistogramSummary[oT: ostring](scope: Scope,
                       tag: oT,
                       values: HistogramSummaryT): HistogramSummary[oT] {.header:"generated.h", importcpp:"HistogramSummary(*#, #, #)", constructor.}

proc histogramSummary*[oT: ostring](scope: Scope,
                       tag: oT,
                       values: HistogramSummaryT): HistogramSummary[oT] =
  return iihistogramSummary(scope,
                            tag,
                            values)

converter histogramSummaryToOut*[oT: ostring](op: HistogramSummary[oT]): oT = return op.output

type TensorListScatterelement_dtype = oall
type TensorListScattershape_type = oint32 | oint64

type TensorListScatter*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListScatter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListScatter[oT: ovariant](scope: Scope,
                        tensor: TensorListScatterelement_dtype,
                        indices: oint32,
                        element_shape: TensorListScattershape_type): TensorListScatter[oT] {.header:"generated.h", importcpp:"TensorListScatter(*#, #, #, #)", constructor.}

proc tensorListScatter*[oT: ovariant](scope: Scope,
                        tensor: TensorListScatterelement_dtype,
                        indices: oint32,
                        element_shape: TensorListScattershape_type): TensorListScatter[oT] =
  return iitensorListScatter(scope,
                             tensor,
                             indices,
                             element_shape)

converter tensorListScatterToOut*[oT: ovariant](op: TensorListScatter[oT]): oT = return op.output

type TensorListSetItemelement_dtype = oall

type TensorListSetItem*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListSetItem/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListSetItem[oT: ovariant](scope: Scope,
                        input_handle: oT,
                        index: oint32,
                        item: TensorListSetItemelement_dtype): TensorListSetItem[oT] {.header:"generated.h", importcpp:"TensorListSetItem(*#, #, #, #)", constructor.}

proc tensorListSetItem*[oT: ovariant](scope: Scope,
                        input_handle: oT,
                        index: oint32,
                        item: TensorListSetItemelement_dtype): TensorListSetItem[oT] =
  return iitensorListSetItem(scope,
                             input_handle,
                             index,
                             item)

converter tensorListSetItemToOut*[oT: ovariant](op: TensorListSetItem[oT]): oT = return op.output

type ClipByValueT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ClipByValue*[oT:ClipByValueT] {.header:"generated.h", importcpp:"ClipByValue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiclipByValue[oT: ClipByValueT](scope: Scope,
                  t: oT,
                  clip_value_min: oT,
                  clip_value_max: oT): ClipByValue[oT] {.header:"generated.h", importcpp:"ClipByValue(*#, #, #, #)", constructor.}

proc clipByValue*[oT: ClipByValueT](scope: Scope,
                  t: oT,
                  clip_value_min: oT,
                  clip_value_max: oT): ClipByValue[oT] =
  return iiclipByValue(scope,
                       t,
                       clip_value_min,
                       clip_value_max)

converter clipByValueToOut*[oT: ClipByValueT](op: ClipByValue[oT]): oT = return op.output

type TensorListReserveshape_type = oint32 | oint64

type TensorListReserve*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListReserve/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListReserve[oT: ovariant](scope: Scope,
                        element_shape: TensorListReserveshape_type,
                        num_elements: oint32,
                        element_dtype: DType): TensorListReserve[oT] {.header:"generated.h", importcpp:"TensorListReserve(*#, #, #, #)", constructor.}

proc tensorListReserve*[oT: ovariant](scope: Scope,
                        element_shape: TensorListReserveshape_type,
                        num_elements: oint32,
                        element_dtype: DType = DT_INVALID): TensorListReserve[oT] =
  return iitensorListReserve(scope,
                             element_shape,
                             num_elements,
                             element_dtype)

converter tensorListReserveToOut*[oT: ovariant](op: TensorListReserve[oT]): oT = return op.output


type ExperimentalThreadPoolHandle*[oT:oresource] {.header:"generated.h", importcpp:"ExperimentalThreadPoolHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalThreadPoolHandle[oT: oresource](scope: Scope,
                                   display_name: cstring,
                                   container: cstring,
                                   shared_name: cstring,
                                   num_threads: int64,
                                   max_intra_op_parallelism: int64): ExperimentalThreadPoolHandle[oT] {.header:"generated.h", importcpp:"ExperimentalThreadPoolHandle(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc experimentalThreadPoolHandle*[oT: oresource](scope: Scope,
                                   display_name: cstring,
                                   container: cstring,
                                   shared_name: cstring,
                                   num_threads: int64 = 0,
                                   max_intra_op_parallelism: int64 = 1): ExperimentalThreadPoolHandle[oT] =
  return iiexperimentalThreadPoolHandle(scope,
                                        display_name,
                                        container,
                                        shared_name,
                                        num_threads,
                                        max_intra_op_parallelism)

converter experimentalThreadPoolHandleToOut*[oT: oresource](op: ExperimentalThreadPoolHandle[oT]): oT = return op.output

type TensorListFromTensorelement_dtype = oall
type TensorListFromTensorshape_type = oint32 | oint64

type TensorListFromTensor*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListFromTensor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListFromTensor[oT: ovariant](scope: Scope,
                           tensor: TensorListFromTensorelement_dtype,
                           element_shape: TensorListFromTensorshape_type): TensorListFromTensor[oT] {.header:"generated.h", importcpp:"TensorListFromTensor(*#, #, #)", constructor.}

proc tensorListFromTensor*[oT: ovariant](scope: Scope,
                           tensor: TensorListFromTensorelement_dtype,
                           element_shape: TensorListFromTensorshape_type): TensorListFromTensor[oT] =
  return iitensorListFromTensor(scope,
                                tensor,
                                element_shape)

converter tensorListFromTensorToOut*[oT: ovariant](op: TensorListFromTensor[oT]): oT = return op.output

type TensorListStackelement_dtype = oall

type TensorListStack*[oT:TensorListStackelement_dtype] {.header:"generated.h", importcpp:"TensorListStack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListStack[oT: TensorListStackelement_dtype](scope: Scope,
                      input_handle: ovariant,
                      num_elements: int64): TensorListStack[oT] {.header:"generated.h", importcpp:"TensorListStack(*#, #, #)", constructor.}

proc tensorListStack*[oT: TensorListStackelement_dtype](scope: Scope,
                      input_handle: ovariant,
                      num_elements: int64 = -1): TensorListStack[oT] =
  return iitensorListStack(scope,
                           input_handle,
                           num_elements)

converter tensorListStackToOut*[oT: TensorListStackelement_dtype](op: TensorListStack[oT]): oT = return op.output

type IMklMulT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type IMklMul*[oT:IMklMulT] {.header:"generated.h", importcpp:"_MklMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiMklMul[oT: IMklMulT](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklMul[oT] {.header:"generated.h", importcpp:"_MklMul(*#, #, #, #, #)", constructor.}

proc iMklMul*[oT: IMklMulT](scope: Scope,
              x: oT,
              y: oT,
              mkl_x: ouint8,
              mkl_y: ouint8): IMklMul[oT] =
  return iiiMklMul(scope,
                   x,
                   y,
                   mkl_x,
                   mkl_y)

converter iMklMulToOut*[oT: IMklMulT](op: IMklMul[oT]): oT = return op.output

type TensorScatterUpdateT = oall
type TensorScatterUpdateTindices = oint32 | oint64

type TensorScatterUpdate*[oT:TensorScatterUpdateT] {.header:"generated.h", importcpp:"TensorScatterUpdate/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorScatterUpdate[oT: TensorScatterUpdateT](scope: Scope,
                          tensor: oT,
                          indices: TensorScatterUpdateTindices,
                          updates: oT): TensorScatterUpdate[oT] {.header:"generated.h", importcpp:"TensorScatterUpdate(*#, #, #, #)", constructor.}

proc tensorScatterUpdate*[oT: TensorScatterUpdateT](scope: Scope,
                          tensor: oT,
                          indices: TensorScatterUpdateTindices,
                          updates: oT): TensorScatterUpdate[oT] =
  return iitensorScatterUpdate(scope,
                               tensor,
                               indices,
                               updates)

converter tensorScatterUpdateToOut*[oT: TensorScatterUpdateT](op: TensorScatterUpdate[oT]): oT = return op.output


type TakeDataset*[oT:ovariant] {.header:"generated.h", importcpp:"TakeDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitakeDataset[oT: ovariant](scope: Scope,
                  input_dataset: oT,
                  count: oint64,
                  output_types: ArraySlice[DType],
                  output_shapes: ArraySlice[TensorShape]): TakeDataset[oT] {.header:"generated.h", importcpp:"TakeDataset(*#, #, #, #, #)", constructor.}

proc takeDataset*[oT: ovariant](scope: Scope,
                  input_dataset: oT,
                  count: oint64,
                  output_types: openArray[DType],
                  output_shapes: openArray[TensorShape]): TakeDataset[oT] =
  return iitakeDataset(scope,
                       input_dataset,
                       count,
                       newArraySlice(output_types),
                       newArraySlice(output_shapes))

converter takeDatasetToOut*[oT: ovariant](op: TakeDataset[oT]): oT = return op.output


type TensorListPopBack*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListPopBack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListPopBack[oT: ovariant](scope: Scope,
                        input_handle: oT,
                        element_dtype: DType): TensorListPopBack[oT] {.header:"generated.h", importcpp:"TensorListPopBack(*#, #, #)", constructor.}

proc tensorListPopBack*[oT: ovariant](scope: Scope,
                        input_handle: oT,
                        element_dtype: DType = DT_INVALID): TensorListPopBack[oT] =
  return iitensorListPopBack(scope,
                             input_handle,
                             element_dtype)

converter tensorListPopBackToOut*[oT: ovariant](op: TensorListPopBack[oT]): oT = return op.output


type TensorListLength*[oT:oint32] {.header:"generated.h", importcpp:"TensorListLength/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListLength[oT: oint32](scope: Scope,
                       input_handle: ovariant): TensorListLength[oT] {.header:"generated.h", importcpp:"TensorListLength(*#, #)", constructor.}

proc tensorListLength*[oT: oint32](scope: Scope,
                       input_handle: ovariant): TensorListLength[oT] =
  return iitensorListLength(scope,
                            input_handle)

converter tensorListLengthToOut*[oT: oint32](op: TensorListLength[oT]): oT = return op.output


type ExperimentalIndexedDatasetGet*[oT:oinvalid] {.header:"generated.h", importcpp:"ExperimentalIndexedDatasetGet/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalIndexedDatasetGet[oT: oinvalid](scope: Scope,
                                    materialized: oresource,
                                    index: ouint64,
                                    output_types: ArraySlice[DType],
                                    output_shapes: ArraySlice[TensorShape]): ExperimentalIndexedDatasetGet[oT] {.header:"generated.h", importcpp:"ExperimentalIndexedDatasetGet(*#, #, #, #, #)", constructor.}

proc experimentalIndexedDatasetGet*[oT: oinvalid](scope: Scope,
                                    materialized: oresource,
                                    index: ouint64,
                                    output_types: openArray[DType],
                                    output_shapes: openArray[TensorShape]): ExperimentalIndexedDatasetGet[oT] =
  return iiexperimentalIndexedDatasetGet(scope,
                                         materialized,
                                         index,
                                         newArraySlice(output_types),
                                         newArraySlice(output_shapes))

converter experimentalIndexedDatasetGetToOut*[oT: oinvalid](op: ExperimentalIndexedDatasetGet[oT]): oT = return op.output

type TensorListPushBackBatchelement_dtype = oall

type TensorListPushBackBatch*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListPushBackBatch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListPushBackBatch[oT: ovariant](scope: Scope,
                              input_handles: oT,
                              tensor: TensorListPushBackBatchelement_dtype): TensorListPushBackBatch[oT] {.header:"generated.h", importcpp:"TensorListPushBackBatch(*#, #, #)", constructor.}

proc tensorListPushBackBatch*[oT: ovariant](scope: Scope,
                              input_handles: oT,
                              tensor: TensorListPushBackBatchelement_dtype): TensorListPushBackBatch[oT] =
  return iitensorListPushBackBatch(scope,
                                   input_handles,
                                   tensor)

converter tensorListPushBackBatchToOut*[oT: ovariant](op: TensorListPushBackBatch[oT]): oT = return op.output

type EmptyTensorListshape_type = oint32 | oint64

type EmptyTensorList*[oT:ovariant] {.header:"generated.h", importcpp:"EmptyTensorList/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiemptyTensorList[oT: ovariant](scope: Scope,
                      element_shape: EmptyTensorListshape_type,
                      max_num_elements: oint32,
                      element_dtype: DType): EmptyTensorList[oT] {.header:"generated.h", importcpp:"EmptyTensorList(*#, #, #, #)", constructor.}

proc emptyTensorList*[oT: ovariant](scope: Scope,
                      element_shape: EmptyTensorListshape_type,
                      max_num_elements: oint32,
                      element_dtype: DType = DT_INVALID): EmptyTensorList[oT] =
  return iiemptyTensorList(scope,
                           element_shape,
                           max_num_elements,
                           element_dtype)

converter emptyTensorListToOut*[oT: ovariant](op: EmptyTensorList[oT]): oT = return op.output

type RandomStandardNormalT = oint32 | oint64
type RandomStandardNormaldtype = ohalf | obfloat16 | ofloat | odouble

type RandomStandardNormal*[oT:RandomStandardNormaldtype] {.header:"generated.h", importcpp:"RandomStandardNormal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomStandardNormal[oT: RandomStandardNormaldtype](scope: Scope,
                           shape: RandomStandardNormalT,
                           seed: int64,
                           seed2: int64,
                           dtype: DType): RandomStandardNormal[oT] {.header:"generated.h", importcpp:"RandomStandardNormal(*#, #, #, #, #)", constructor.}

proc randomStandardNormal*[oT: RandomStandardNormaldtype](scope: Scope,
                           shape: RandomStandardNormalT,
                           seed: int64 = 0,
                           seed2: int64 = 0,
                           dtype: DType = oT[].oTF): RandomStandardNormal[oT] =
  return iirandomStandardNormal(scope,
                                shape,
                                seed,
                                seed2,
                                dtype)

converter randomStandardNormalToOut*[oT: RandomStandardNormaldtype](op: RandomStandardNormal[oT]): oT = return op.output

type ErfT = obfloat16 | ohalf | ofloat | odouble

type Erf*[oT:ErfT] {.header:"generated.h", importcpp:"Erf/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iierf[oT: ErfT](scope: Scope,
          x: oT): Erf[oT] {.header:"generated.h", importcpp:"Erf(*#, #)", constructor.}

proc erf*[oT: ErfT](scope: Scope,
          x: oT): Erf[oT] =
  return iierf(scope,
               x)

converter erfToOut*[oT: ErfT](op: Erf[oT]): oT = return op.output

type MeanT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type MeanTidx = oint32 | oint64

type Mean*[oT:MeanT] {.header:"generated.h", importcpp:"Mean/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimean[oT: MeanT](scope: Scope,
           input: oT,
           reduction_indices: MeanTidx,
           keep_dims: bool): Mean[oT] {.header:"generated.h", importcpp:"Mean(*#, #, #, #)", constructor.}

proc mean*[oT: MeanT](scope: Scope,
           input: oT,
           reduction_indices: MeanTidx,
           keep_dims: bool = false): Mean[oT] =
  return iimean(scope,
                input,
                reduction_indices,
                keep_dims)

converter meanToOut*[oT: MeanT](op: Mean[oT]): oT = return op.output

type BatchMatrixTriangularSolveT = odouble | ofloat

type BatchMatrixTriangularSolve*[oT:BatchMatrixTriangularSolveT] {.header:"generated.h", importcpp:"BatchMatrixTriangularSolve/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixTriangularSolve[oT: BatchMatrixTriangularSolveT](scope: Scope,
                                 matrix: oT,
                                 rhs: oT,
                                 lower: bool,
                                 adjoint: bool): BatchMatrixTriangularSolve[oT] {.header:"generated.h", importcpp:"BatchMatrixTriangularSolve(*#, #, #, #, #)", constructor.}

proc batchMatrixTriangularSolve*[oT: BatchMatrixTriangularSolveT](scope: Scope,
                                 matrix: oT,
                                 rhs: oT,
                                 lower: bool = true,
                                 adjoint: bool = false): BatchMatrixTriangularSolve[oT] =
  return iibatchMatrixTriangularSolve(scope,
                                      matrix,
                                      rhs,
                                      lower,
                                      adjoint)

converter batchMatrixTriangularSolveToOut*[oT: BatchMatrixTriangularSolveT](op: BatchMatrixTriangularSolve[oT]): oT = return op.output

type BatchMatrixSolveT = odouble | ofloat

type BatchMatrixSolve*[oT:BatchMatrixSolveT] {.header:"generated.h", importcpp:"BatchMatrixSolve/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixSolve[oT: BatchMatrixSolveT](scope: Scope,
                       matrix: oT,
                       rhs: oT,
                       adjoint: bool): BatchMatrixSolve[oT] {.header:"generated.h", importcpp:"BatchMatrixSolve(*#, #, #, #)", constructor.}

proc batchMatrixSolve*[oT: BatchMatrixSolveT](scope: Scope,
                       matrix: oT,
                       rhs: oT,
                       adjoint: bool = false): BatchMatrixSolve[oT] =
  return iibatchMatrixSolve(scope,
                            matrix,
                            rhs,
                            adjoint)

converter batchMatrixSolveToOut*[oT: BatchMatrixSolveT](op: BatchMatrixSolve[oT]): oT = return op.output

type QuantizedBiasAddT1 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedBiasAddT2 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedBiasAddout_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedBiasAdd*[oT:QuantizedBiasAddout_type] {.header:"generated.h", importcpp:"QuantizedBiasAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedBiasAdd[oT: QuantizedBiasAddout_type](scope: Scope,
                       input: QuantizedBiasAddT1,
                       bias: QuantizedBiasAddT2,
                       min_input: ofloat,
                       max_input: ofloat,
                       min_bias: ofloat,
                       max_bias: ofloat): QuantizedBiasAdd[oT] {.header:"generated.h", importcpp:"QuantizedBiasAdd(*#, #, #, #, #, #, #)", constructor.}

proc quantizedBiasAdd*[oT: QuantizedBiasAddout_type](scope: Scope,
                       input: QuantizedBiasAddT1,
                       bias: QuantizedBiasAddT2,
                       min_input: ofloat,
                       max_input: ofloat,
                       min_bias: ofloat,
                       max_bias: ofloat): QuantizedBiasAdd[oT] =
  return iiquantizedBiasAdd(scope,
                            input,
                            bias,
                            min_input,
                            max_input,
                            min_bias,
                            max_bias)

converter quantizedBiasAddToOut*[oT: QuantizedBiasAddout_type](op: QuantizedBiasAdd[oT]): oT = return op.output

type DataFormatVecPermuteT = oint32 | oint64

type DataFormatVecPermute*[oT:DataFormatVecPermuteT] {.header:"generated.h", importcpp:"DataFormatVecPermute/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidataFormatVecPermute[oT: DataFormatVecPermuteT](scope: Scope,
                           x: oT,
                           dst_format: cstring,
                           src_format: cstring): DataFormatVecPermute[oT] {.header:"generated.h", importcpp:"DataFormatVecPermute(*#, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc dataFormatVecPermute*[oT: DataFormatVecPermuteT](scope: Scope,
                           x: oT,
                           dst_format: cstring = "NCHW",
                           src_format: cstring = "NHWC"): DataFormatVecPermute[oT] =
  return iidataFormatVecPermute(scope,
                                x,
                                dst_format,
                                src_format)

converter dataFormatVecPermuteToOut*[oT: DataFormatVecPermuteT](op: DataFormatVecPermute[oT]): oT = return op.output

type BatchCholeskyGradT = ofloat | odouble

type BatchCholeskyGrad*[oT:BatchCholeskyGradT] {.header:"generated.h", importcpp:"BatchCholeskyGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchCholeskyGrad[oT: BatchCholeskyGradT](scope: Scope,
                        l: oT,
                        grad: oT): BatchCholeskyGrad[oT] {.header:"generated.h", importcpp:"BatchCholeskyGrad(*#, #, #)", constructor.}

proc batchCholeskyGrad*[oT: BatchCholeskyGradT](scope: Scope,
                        l: oT,
                        grad: oT): BatchCholeskyGrad[oT] =
  return iibatchCholeskyGrad(scope,
                             l,
                             grad)

converter batchCholeskyGradToOut*[oT: BatchCholeskyGradT](op: BatchCholeskyGrad[oT]): oT = return op.output

type BatchMatrixInverseT = odouble | ofloat

type BatchMatrixInverse*[oT:BatchMatrixInverseT] {.header:"generated.h", importcpp:"BatchMatrixInverse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixInverse[oT: BatchMatrixInverseT](scope: Scope,
                         input: oT,
                         adjoint: bool): BatchMatrixInverse[oT] {.header:"generated.h", importcpp:"BatchMatrixInverse(*#, #, #)", constructor.}

proc batchMatrixInverse*[oT: BatchMatrixInverseT](scope: Scope,
                         input: oT,
                         adjoint: bool = false): BatchMatrixInverse[oT] =
  return iibatchMatrixInverse(scope,
                              input,
                              adjoint)

converter batchMatrixInverseToOut*[oT: BatchMatrixInverseT](op: BatchMatrixInverse[oT]): oT = return op.output

type DebugNumericSummaryT = oall

type DebugNumericSummary*[oT:odouble] {.header:"generated.h", importcpp:"DebugNumericSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidebugNumericSummary[oT: odouble](scope: Scope,
                          input: DebugNumericSummaryT,
                          device_name: cstring,
                          tensor_name: cstring,
                          debug_urls: ArraySlice[cstring],
                          gated_grpc: bool,
                          lower_bound: float32,
                          upper_bound: float32,
                          mute_if_healthy: bool): DebugNumericSummary[oT] {.header:"generated.h", importcpp:"DebugNumericSummary(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc debugNumericSummary*[oT: odouble](scope: Scope,
                          input: DebugNumericSummaryT,
                          device_name: cstring,
                          tensor_name: cstring,
                          debug_urls: openArray[cstring],
                          gated_grpc: bool = false,
                          lower_bound: float32 = NegInf.float32,
                          upper_bound: float32 = Inf.float32,
                          mute_if_healthy: bool = false): DebugNumericSummary[oT] =
  return iidebugNumericSummary(scope,
                               input,
                               device_name,
                               tensor_name,
                               newArraySlice(debug_urls),
                               gated_grpc,
                               lower_bound,
                               upper_bound,
                               mute_if_healthy)

converter debugNumericSummaryToOut*[oT: odouble](op: DebugNumericSummary[oT]): oT = return op.output

type BatchSelfAdjointEigT = odouble | ofloat

type BatchSelfAdjointEig*[oT:BatchSelfAdjointEigT] {.header:"generated.h", importcpp:"BatchSelfAdjointEig/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchSelfAdjointEig[oT: BatchSelfAdjointEigT](scope: Scope,
                          input: oT): BatchSelfAdjointEig[oT] {.header:"generated.h", importcpp:"BatchSelfAdjointEig(*#, #)", constructor.}

proc batchSelfAdjointEig*[oT: BatchSelfAdjointEigT](scope: Scope,
                          input: oT): BatchSelfAdjointEig[oT] =
  return iibatchSelfAdjointEig(scope,
                               input)

converter batchSelfAdjointEigToOut*[oT: BatchSelfAdjointEigT](op: BatchSelfAdjointEig[oT]): oT = return op.output

type LookupTableFindV2Tin = oall
type LookupTableFindV2Tout = oall

type LookupTableFindV2*[oT:LookupTableFindV2Tout] {.header:"generated.h", importcpp:"LookupTableFindV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilookupTableFindV2[oT: LookupTableFindV2Tout](scope: Scope,
                        table_handle: oresource,
                        keys: LookupTableFindV2Tin,
                        default_value: oT): LookupTableFindV2[oT] {.header:"generated.h", importcpp:"LookupTableFindV2(*#, #, #, #)", constructor.}

proc lookupTableFindV2*[oT: LookupTableFindV2Tout](scope: Scope,
                        table_handle: oresource,
                        keys: LookupTableFindV2Tin,
                        default_value: oT): LookupTableFindV2[oT] =
  return iilookupTableFindV2(scope,
                             table_handle,
                             keys,
                             default_value)

converter lookupTableFindV2ToOut*[oT: LookupTableFindV2Tout](op: LookupTableFindV2[oT]): oT = return op.output

type AsinhT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Asinh*[oT:AsinhT] {.header:"generated.h", importcpp:"Asinh/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiasinh[oT: AsinhT](scope: Scope,
            x: oT): Asinh[oT] {.header:"generated.h", importcpp:"Asinh(*#, #)", constructor.}

proc asinh*[oT: AsinhT](scope: Scope,
            x: oT): Asinh[oT] =
  return iiasinh(scope,
                 x)

converter asinhToOut*[oT: AsinhT](op: Asinh[oT]): oT = return op.output

type CollectiveBcastRecvT = ofloat | ohalf | odouble | oint32 | oint64

type CollectiveBcastRecv*[oT:CollectiveBcastRecvT] {.header:"generated.h", importcpp:"CollectiveBcastRecv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicollectiveBcastRecv[oT: CollectiveBcastRecvT](scope: Scope,
                          shape: TensorShape,
                          group_size: int64,
                          group_key: int64,
                          instance_key: int64): CollectiveBcastRecv[oT] {.header:"generated.h", importcpp:"CollectiveBcastRecv(*#, #, #, #, #)", constructor.}

proc collectiveBcastRecv*[oT: CollectiveBcastRecvT](scope: Scope,
                          shape: TensorShape = [].shape,
                          group_size: int64 = 0,
                          group_key: int64 = 0,
                          instance_key: int64 = 0): CollectiveBcastRecv[oT] =
  return iicollectiveBcastRecv(scope,
                               shape,
                               group_size,
                               group_key,
                               instance_key)

converter collectiveBcastRecvToOut*[oT: CollectiveBcastRecvT](op: CollectiveBcastRecv[oT]): oT = return op.output

type TensorArrayScatterV3T = oall

type TensorArrayScatterV3*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayScatterV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayScatterV3[oT: ofloat](scope: Scope,
                           handle: oresource,
                           indices: oint32,
                           value: TensorArrayScatterV3T,
                           flow_in: oT): TensorArrayScatterV3[oT] {.header:"generated.h", importcpp:"TensorArrayScatterV3(*#, #, #, #, #)", constructor.}

proc tensorArrayScatterV3*[oT: ofloat](scope: Scope,
                           handle: oresource,
                           indices: oint32,
                           value: TensorArrayScatterV3T,
                           flow_in: oT): TensorArrayScatterV3[oT] =
  return iitensorArrayScatterV3(scope,
                                handle,
                                indices,
                                value,
                                flow_in)

converter tensorArrayScatterV3ToOut*[oT: ofloat](op: TensorArrayScatterV3[oT]): oT = return op.output

type MatrixSquareRootT = odouble | ofloat | ocomplex64 | ocomplex128

type MatrixSquareRoot*[oT:MatrixSquareRootT] {.header:"generated.h", importcpp:"MatrixSquareRoot/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixSquareRoot[oT: MatrixSquareRootT](scope: Scope,
                       input: oT): MatrixSquareRoot[oT] {.header:"generated.h", importcpp:"MatrixSquareRoot(*#, #)", constructor.}

proc matrixSquareRoot*[oT: MatrixSquareRootT](scope: Scope,
                       input: oT): MatrixSquareRoot[oT] =
  return iimatrixSquareRoot(scope,
                            input)

converter matrixSquareRootToOut*[oT: MatrixSquareRootT](op: MatrixSquareRoot[oT]): oT = return op.output

type MatrixTriangularSolveT = odouble | ofloat | ocomplex64 | ocomplex128

type MatrixTriangularSolve*[oT:MatrixTriangularSolveT] {.header:"generated.h", importcpp:"MatrixTriangularSolve/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixTriangularSolve[oT: MatrixTriangularSolveT](scope: Scope,
                            matrix: oT,
                            rhs: oT,
                            lower: bool,
                            adjoint: bool): MatrixTriangularSolve[oT] {.header:"generated.h", importcpp:"MatrixTriangularSolve(*#, #, #, #, #)", constructor.}

proc matrixTriangularSolve*[oT: MatrixTriangularSolveT](scope: Scope,
                            matrix: oT,
                            rhs: oT,
                            lower: bool = true,
                            adjoint: bool = false): MatrixTriangularSolve[oT] =
  return iimatrixTriangularSolve(scope,
                                 matrix,
                                 rhs,
                                 lower,
                                 adjoint)

converter matrixTriangularSolveToOut*[oT: MatrixTriangularSolveT](op: MatrixTriangularSolve[oT]): oT = return op.output

type SelfAdjointEigT = odouble | ofloat

type SelfAdjointEig*[oT:SelfAdjointEigT] {.header:"generated.h", importcpp:"SelfAdjointEig/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiselfAdjointEig[oT: SelfAdjointEigT](scope: Scope,
                     input: oT): SelfAdjointEig[oT] {.header:"generated.h", importcpp:"SelfAdjointEig(*#, #)", constructor.}

proc selfAdjointEig*[oT: SelfAdjointEigT](scope: Scope,
                     input: oT): SelfAdjointEig[oT] =
  return iiselfAdjointEig(scope,
                          input)

converter selfAdjointEigToOut*[oT: SelfAdjointEigT](op: SelfAdjointEig[oT]): oT = return op.output

type ReshapeT = oall
type ReshapeTshape = oint32 | oint64

type Reshape*[oT:ReshapeT] {.header:"generated.h", importcpp:"Reshape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireshape[oT: ReshapeT](scope: Scope,
              tensor: oT,
              shape: ReshapeTshape): Reshape[oT] {.header:"generated.h", importcpp:"Reshape(*#, #, #)", constructor.}

proc reshape*[oT: ReshapeT](scope: Scope,
              tensor: oT,
              shape: ReshapeTshape): Reshape[oT] =
  return iireshape(scope,
                   tensor,
                   shape)

converter reshapeToOut*[oT: ReshapeT](op: Reshape[oT]): oT = return op.output

type ArgMaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ArgMaxTidx = oint32 | oint64
type ArgMaxoutput_type = oint32 | oint64

type ArgMax*[oT:ArgMaxoutput_type] {.header:"generated.h", importcpp:"ArgMax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiargMax[oT: ArgMaxoutput_type](scope: Scope,
             input: ArgMaxT,
             dimension: ArgMaxTidx): ArgMax[oT] {.header:"generated.h", importcpp:"ArgMax(*#, #, #)", constructor.}

proc argMax*[oT: ArgMaxoutput_type](scope: Scope,
             input: ArgMaxT,
             dimension: ArgMaxTidx): ArgMax[oT] =
  return iiargMax(scope,
                  input,
                  dimension)

converter argMaxToOut*[oT: ArgMaxoutput_type](op: ArgMax[oT]): oT = return op.output

type CholeskyGradT = ofloat | odouble

type CholeskyGrad*[oT:CholeskyGradT] {.header:"generated.h", importcpp:"CholeskyGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicholeskyGrad[oT: CholeskyGradT](scope: Scope,
                   l: oT,
                   grad: oT): CholeskyGrad[oT] {.header:"generated.h", importcpp:"CholeskyGrad(*#, #, #)", constructor.}

proc choleskyGrad*[oT: CholeskyGradT](scope: Scope,
                   l: oT,
                   grad: oT): CholeskyGrad[oT] =
  return iicholeskyGrad(scope,
                        l,
                        grad)

converter choleskyGradToOut*[oT: CholeskyGradT](op: CholeskyGrad[oT]): oT = return op.output


type StaticRegexFullMatch*[oT:obool] {.header:"generated.h", importcpp:"StaticRegexFullMatch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistaticRegexFullMatch[oT: obool](scope: Scope,
                           input: ostring,
                           pattern: cstring): StaticRegexFullMatch[oT] {.header:"generated.h", importcpp:"StaticRegexFullMatch(*#, #, tensorflow::string(#))", constructor.}

proc staticRegexFullMatch*[oT: obool](scope: Scope,
                           input: ostring,
                           pattern: cstring): StaticRegexFullMatch[oT] =
  return iistaticRegexFullMatch(scope,
                                input,
                                pattern)

converter staticRegexFullMatchToOut*[oT: obool](op: StaticRegexFullMatch[oT]): oT = return op.output


type ParseSingleSequenceExample*[oT:oint64] {.header:"generated.h", importcpp:"ParseSingleSequenceExample/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparseSingleSequenceExample[oT: oint64](scope: Scope,
                                 serialized: ostring,
                                 feature_list_dense_missing_assumed_empty: ostring,
                                 context_sparse_keys: ostring,
                                 context_dense_keys: ostring,
                                 feature_list_sparse_keys: ostring,
                                 feature_list_dense_keys: ostring,
                                 context_dense_defaults: oinvalid,
                                 debug_name: ostring,
                                 context_sparse_types: ArraySlice[DType],
                                 Tcontext_dense: ArraySlice[DType],
                                 feature_list_dense_types: ArraySlice[DType],
                                 context_dense_shapes: ArraySlice[TensorShape],
                                 feature_list_sparse_types: ArraySlice[DType],
                                 feature_list_dense_shapes: ArraySlice[TensorShape],
                                 Ncontext_sparse: int64,
                                 Ncontext_dense: int64,
                                 Nfeature_list_sparse: int64,
                                 Nfeature_list_dense: int64): ParseSingleSequenceExample[oT] {.header:"generated.h", importcpp:"ParseSingleSequenceExample(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parseSingleSequenceExample*[oT: oint64](scope: Scope,
                                 serialized: ostring,
                                 feature_list_dense_missing_assumed_empty: ostring,
                                 context_sparse_keys: ostring,
                                 context_dense_keys: ostring,
                                 feature_list_sparse_keys: ostring,
                                 feature_list_dense_keys: ostring,
                                 context_dense_defaults: oinvalid,
                                 debug_name: ostring,
                                 context_sparse_types: openArray[DType],
                                 Tcontext_dense: openArray[DType],
                                 feature_list_dense_types: openArray[DType],
                                 context_dense_shapes: openArray[TensorShape],
                                 feature_list_sparse_types: openArray[DType],
                                 feature_list_dense_shapes: openArray[TensorShape],
                                 Ncontext_sparse: int64 = 0,
                                 Ncontext_dense: int64 = 0,
                                 Nfeature_list_sparse: int64 = 0,
                                 Nfeature_list_dense: int64 = 0): ParseSingleSequenceExample[oT] =
  return iiparseSingleSequenceExample(scope,
                                      serialized,
                                      feature_list_dense_missing_assumed_empty,
                                      context_sparse_keys,
                                      context_dense_keys,
                                      feature_list_sparse_keys,
                                      feature_list_dense_keys,
                                      context_dense_defaults,
                                      debug_name,
                                      newArraySlice(context_sparse_types),
                                      newArraySlice(Tcontext_dense),
                                      newArraySlice(feature_list_dense_types),
                                      newArraySlice(context_dense_shapes),
                                      newArraySlice(feature_list_sparse_types),
                                      newArraySlice(feature_list_dense_shapes),
                                      Ncontext_sparse,
                                      Ncontext_dense,
                                      Nfeature_list_sparse,
                                      Nfeature_list_dense)

converter parseSingleSequenceExampleToOut*[oT: oint64](op: ParseSingleSequenceExample[oT]): oT = return op.output

type LookupTableExportTkeys = oall

type LookupTableExport*[oT:LookupTableExportTkeys] {.header:"generated.h", importcpp:"LookupTableExport/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilookupTableExport[oT: LookupTableExportTkeys](scope: Scope,
                        table_handle: ostring,
                        Tvalues: DType): LookupTableExport[oT] {.header:"generated.h", importcpp:"LookupTableExport(*#, #, #)", constructor.}

proc lookupTableExport*[oT: LookupTableExportTkeys](scope: Scope,
                        table_handle: ostring,
                        Tvalues: DType = DT_INVALID): LookupTableExport[oT] =
  return iilookupTableExport(scope,
                             table_handle,
                             Tvalues)

converter lookupTableExportToOut*[oT: LookupTableExportTkeys](op: LookupTableExport[oT]): oT = return op.output


type QueueDequeue*[oT:oinvalid] {.header:"generated.h", importcpp:"QueueDequeue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueDequeue[oT: oinvalid](scope: Scope,
                   handle: ostring,
                   component_types: ArraySlice[DType],
                   timeout_ms: int64): QueueDequeue[oT] {.header:"generated.h", importcpp:"QueueDequeue(*#, #, #, #)", constructor.}

proc queueDequeue*[oT: oinvalid](scope: Scope,
                   handle: ostring,
                   component_types: openArray[DType],
                   timeout_ms: int64 = -1): QueueDequeue[oT] =
  return iiqueueDequeue(scope,
                        handle,
                        newArraySlice(component_types),
                        timeout_ms)

converter queueDequeueToOut*[oT: oinvalid](op: QueueDequeue[oT]): oT = return op.output

type TensorListSplitelement_dtype = oall
type TensorListSplitshape_type = oint32 | oint64

type TensorListSplit*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListSplit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListSplit[oT: ovariant](scope: Scope,
                      tensor: TensorListSplitelement_dtype,
                      element_shape: TensorListSplitshape_type,
                      lengths: oint64): TensorListSplit[oT] {.header:"generated.h", importcpp:"TensorListSplit(*#, #, #, #)", constructor.}

proc tensorListSplit*[oT: ovariant](scope: Scope,
                      tensor: TensorListSplitelement_dtype,
                      element_shape: TensorListSplitshape_type,
                      lengths: oint64): TensorListSplit[oT] =
  return iitensorListSplit(scope,
                           tensor,
                           element_shape,
                           lengths)

converter tensorListSplitToOut*[oT: ovariant](op: TensorListSplit[oT]): oT = return op.output

type BatchMatrixSolveLsT = odouble | ofloat

type BatchMatrixSolveLs*[oT:BatchMatrixSolveLsT] {.header:"generated.h", importcpp:"BatchMatrixSolveLs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixSolveLs[oT: BatchMatrixSolveLsT](scope: Scope,
                         matrix: oT,
                         rhs: oT,
                         l2_regularizer: odouble,
                         fast: bool): BatchMatrixSolveLs[oT] {.header:"generated.h", importcpp:"BatchMatrixSolveLs(*#, #, #, #, #)", constructor.}

proc batchMatrixSolveLs*[oT: BatchMatrixSolveLsT](scope: Scope,
                         matrix: oT,
                         rhs: oT,
                         l2_regularizer: odouble,
                         fast: bool = true): BatchMatrixSolveLs[oT] =
  return iibatchMatrixSolveLs(scope,
                              matrix,
                              rhs,
                              l2_regularizer,
                              fast)

converter batchMatrixSolveLsToOut*[oT: BatchMatrixSolveLsT](op: BatchMatrixSolveLs[oT]): oT = return op.output

type MatrixDeterminantT = ofloat | odouble | ocomplex64 | ocomplex128

type MatrixDeterminant*[oT:MatrixDeterminantT] {.header:"generated.h", importcpp:"MatrixDeterminant/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixDeterminant[oT: MatrixDeterminantT](scope: Scope,
                        input: oT): MatrixDeterminant[oT] {.header:"generated.h", importcpp:"MatrixDeterminant(*#, #)", constructor.}

proc matrixDeterminant*[oT: MatrixDeterminantT](scope: Scope,
                        input: oT): MatrixDeterminant[oT] =
  return iimatrixDeterminant(scope,
                             input)

converter matrixDeterminantToOut*[oT: MatrixDeterminantT](op: MatrixDeterminant[oT]): oT = return op.output

type FloorModT = oint32 | oint64 | obfloat16 | ohalf | ofloat | odouble

type FloorMod*[oT:FloorModT] {.header:"generated.h", importcpp:"FloorMod/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifloorMod[oT: FloorModT](scope: Scope,
               x: oT,
               y: oT): FloorMod[oT] {.header:"generated.h", importcpp:"FloorMod(*#, #, #)", constructor.}

proc floorMod*[oT: FloorModT](scope: Scope,
               x: oT,
               y: oT): FloorMod[oT] =
  return iifloorMod(scope,
                    x,
                    y)

converter floorModToOut*[oT: FloorModT](op: FloorMod[oT]): oT = return op.output


type MatchingFiles*[oT:ostring] {.header:"generated.h", importcpp:"MatchingFiles/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatchingFiles[oT: ostring](scope: Scope,
                    pattern: oT): MatchingFiles[oT] {.header:"generated.h", importcpp:"MatchingFiles(*#, #)", constructor.}

proc matchingFiles*[oT: ostring](scope: Scope,
                    pattern: oT): MatchingFiles[oT] =
  return iimatchingFiles(scope,
                         pattern)

converter matchingFilesToOut*[oT: ostring](op: MatchingFiles[oT]): oT = return op.output

type WriteImageSummaryT = ouint8 | ofloat | ohalf

type WriteImageSummary*{.header:"generated.h", importcpp:"WriteImageSummary/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteImageSummary(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: WriteImageSummaryT,
                        bad_color: ouint8,
                        max_images: int64): WriteImageSummary {.header:"generated.h", importcpp:"WriteImageSummary(*#, #, #, #, #, #, #)", constructor.}

proc writeImageSummary*(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: WriteImageSummaryT,
                        bad_color: ouint8,
                        max_images: int64 = 3): WriteImageSummary =
  return iiwriteImageSummary(scope,
                             writer,
                             step,
                             tag,
                             tensor,
                             bad_color,
                             max_images)



type MatrixSolveT = odouble | ofloat | ocomplex64 | ocomplex128

type MatrixSolve*[oT:MatrixSolveT] {.header:"generated.h", importcpp:"MatrixSolve/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixSolve[oT: MatrixSolveT](scope: Scope,
                  matrix: oT,
                  rhs: oT,
                  adjoint: bool): MatrixSolve[oT] {.header:"generated.h", importcpp:"MatrixSolve(*#, #, #, #)", constructor.}

proc matrixSolve*[oT: MatrixSolveT](scope: Scope,
                  matrix: oT,
                  rhs: oT,
                  adjoint: bool = false): MatrixSolve[oT] =
  return iimatrixSolve(scope,
                       matrix,
                       rhs,
                       adjoint)

converter matrixSolveToOut*[oT: MatrixSolveT](op: MatrixSolve[oT]): oT = return op.output

type TensorArrayConcatV2dtype = oall

type TensorArrayConcatV2*[oT:TensorArrayConcatV2dtype] {.header:"generated.h", importcpp:"TensorArrayConcatV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayConcatV2[oT: TensorArrayConcatV2dtype](scope: Scope,
                          handle: ostring,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape_except0: TensorShape): TensorArrayConcatV2[oT] {.header:"generated.h", importcpp:"TensorArrayConcatV2(*#, #, #, #, #)", constructor.}

proc tensorArrayConcatV2*[oT: TensorArrayConcatV2dtype](scope: Scope,
                          handle: ostring,
                          flow_in: ofloat,
                          dtype: DType = oT[].oTF,
                          element_shape_except0: TensorShape = [].shape): TensorArrayConcatV2[oT] =
  return iitensorArrayConcatV2(scope,
                               handle,
                               flow_in,
                               dtype,
                               element_shape_except0)

converter tensorArrayConcatV2ToOut*[oT: TensorArrayConcatV2dtype](op: TensorArrayConcatV2[oT]): oT = return op.output


type WriteFile*{.header:"generated.h", importcpp:"WriteFile/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteFile(scope: Scope,
                filename: ostring,
                contents: ostring): WriteFile {.header:"generated.h", importcpp:"WriteFile(*#, #, #)", constructor.}

proc writeFile*(scope: Scope,
                filename: ostring,
                contents: ostring): WriteFile =
  return iiwriteFile(scope,
                     filename,
                     contents)



type TruncatedNormalT = oint32 | oint64
type TruncatedNormaldtype = ohalf | obfloat16 | ofloat | odouble

type TruncatedNormal*[oT:TruncatedNormaldtype] {.header:"generated.h", importcpp:"TruncatedNormal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitruncatedNormal[oT: TruncatedNormaldtype](scope: Scope,
                      shape: TruncatedNormalT,
                      seed: int64,
                      seed2: int64,
                      dtype: DType): TruncatedNormal[oT] {.header:"generated.h", importcpp:"TruncatedNormal(*#, #, #, #, #)", constructor.}

proc truncatedNormal*[oT: TruncatedNormaldtype](scope: Scope,
                      shape: TruncatedNormalT,
                      seed: int64 = 0,
                      seed2: int64 = 0,
                      dtype: DType = oT[].oTF): TruncatedNormal[oT] =
  return iitruncatedNormal(scope,
                           shape,
                           seed,
                           seed2,
                           dtype)

converter truncatedNormalToOut*[oT: TruncatedNormaldtype](op: TruncatedNormal[oT]): oT = return op.output


type ReadFile*[oT:ostring] {.header:"generated.h", importcpp:"ReadFile/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireadFile[oT: ostring](scope: Scope,
               filename: oT): ReadFile[oT] {.header:"generated.h", importcpp:"ReadFile(*#, #)", constructor.}

proc readFile*[oT: ostring](scope: Scope,
               filename: oT): ReadFile[oT] =
  return iireadFile(scope,
                    filename)

converter readFileToOut*[oT: ostring](op: ReadFile[oT]): oT = return op.output


type FakeQuantWithMinMaxVarsPerChannelGradient*[oT:ofloat] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannelGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQuantWithMinMaxVarsPerChannelGradient[oT: ofloat](scope: Scope,
                                                gradients: oT,
                                                inputs: oT,
                                                min: oT,
                                                max: oT,
                                                num_bits: int64,
                                                narrow_range: bool): FakeQuantWithMinMaxVarsPerChannelGradient[oT] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannelGradient(*#, #, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVarsPerChannelGradient*[oT: ofloat](scope: Scope,
                                                gradients: oT,
                                                inputs: oT,
                                                min: oT,
                                                max: oT,
                                                num_bits: int64 = 8,
                                                narrow_range: bool = false): FakeQuantWithMinMaxVarsPerChannelGradient[oT] =
  return iifakeQuantWithMinMaxVarsPerChannelGradient(scope,
                                                     gradients,
                                                     inputs,
                                                     min,
                                                     max,
                                                     num_bits,
                                                     narrow_range)

converter fakeQuantWithMinMaxVarsPerChannelGradientToOut*[oT: ofloat](op: FakeQuantWithMinMaxVarsPerChannelGradient[oT]): oT = return op.output


type PrintV2*{.header:"generated.h", importcpp:"PrintV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiprintV2(scope: Scope,
              input: ostring,
              output_stream: cstring): PrintV2 {.header:"generated.h", importcpp:"PrintV2(*#, #, tensorflow::string(#))", constructor.}

proc printV2*(scope: Scope,
              input: ostring,
              output_stream: cstring = "stderr"): PrintV2 =
  return iiprintV2(scope,
                   input,
                   output_stream)




type ReaderResetV2*{.header:"generated.h", importcpp:"ReaderResetV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iireaderResetV2(scope: Scope,
                    reader_handle: oresource): ReaderResetV2 {.header:"generated.h", importcpp:"ReaderResetV2(*#, #)", constructor.}

proc readerResetV2*(scope: Scope,
                    reader_handle: oresource): ReaderResetV2 =
  return iireaderResetV2(scope,
                         reader_handle)




type ReaderSerializeState*[oT:ostring] {.header:"generated.h", importcpp:"ReaderSerializeState/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderSerializeState[oT: ostring](scope: Scope,
                           reader_handle: oT): ReaderSerializeState[oT] {.header:"generated.h", importcpp:"ReaderSerializeState(*#, #)", constructor.}

proc readerSerializeState*[oT: ostring](scope: Scope,
                           reader_handle: oT): ReaderSerializeState[oT] =
  return iireaderSerializeState(scope,
                                reader_handle)

converter readerSerializeStateToOut*[oT: ostring](op: ReaderSerializeState[oT]): oT = return op.output


type ReaderNumWorkUnitsCompletedV2*[oT:oint64] {.header:"generated.h", importcpp:"ReaderNumWorkUnitsCompletedV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderNumWorkUnitsCompletedV2[oT: oint64](scope: Scope,
                                    reader_handle: oresource): ReaderNumWorkUnitsCompletedV2[oT] {.header:"generated.h", importcpp:"ReaderNumWorkUnitsCompletedV2(*#, #)", constructor.}

proc readerNumWorkUnitsCompletedV2*[oT: oint64](scope: Scope,
                                    reader_handle: oresource): ReaderNumWorkUnitsCompletedV2[oT] =
  return iireaderNumWorkUnitsCompletedV2(scope,
                                         reader_handle)

converter readerNumWorkUnitsCompletedV2ToOut*[oT: oint64](op: ReaderNumWorkUnitsCompletedV2[oT]): oT = return op.output

type LowerBoundT = oall
type LowerBoundout_type = oint32 | oint64

type LowerBound*[oT:LowerBoundout_type] {.header:"generated.h", importcpp:"LowerBound/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilowerBound[oT: LowerBoundout_type](scope: Scope,
                 sorted_inputs: LowerBoundT,
                 values: LowerBoundT): LowerBound[oT] {.header:"generated.h", importcpp:"LowerBound(*#, #, #)", constructor.}

proc lowerBound*[oT: LowerBoundout_type](scope: Scope,
                 sorted_inputs: LowerBoundT,
                 values: LowerBoundT): LowerBound[oT] =
  return iilowerBound(scope,
                      sorted_inputs,
                      values)

converter lowerBoundToOut*[oT: LowerBoundout_type](op: LowerBound[oT]): oT = return op.output

type GreaterT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Greater*[oT:obool] {.header:"generated.h", importcpp:"Greater/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigreater[oT: obool](scope: Scope,
              x: GreaterT,
              y: GreaterT): Greater[oT] {.header:"generated.h", importcpp:"Greater(*#, #, #)", constructor.}

proc greater*[oT: obool](scope: Scope,
              x: GreaterT,
              y: GreaterT): Greater[oT] =
  return iigreater(scope,
                   x,
                   y)

converter greaterToOut*[oT: obool](op: Greater[oT]): oT = return op.output


type ReaderNumWorkUnitsCompleted*[oT:oint64] {.header:"generated.h", importcpp:"ReaderNumWorkUnitsCompleted/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderNumWorkUnitsCompleted[oT: oint64](scope: Scope,
                                  reader_handle: ostring): ReaderNumWorkUnitsCompleted[oT] {.header:"generated.h", importcpp:"ReaderNumWorkUnitsCompleted(*#, #)", constructor.}

proc readerNumWorkUnitsCompleted*[oT: oint64](scope: Scope,
                                  reader_handle: ostring): ReaderNumWorkUnitsCompleted[oT] =
  return iireaderNumWorkUnitsCompleted(scope,
                                       reader_handle)

converter readerNumWorkUnitsCompletedToOut*[oT: oint64](op: ReaderNumWorkUnitsCompleted[oT]): oT = return op.output

type DecodeRawout_type = ohalf | ofloat | odouble | oint32 | ouint16 | ouint8 | oint16 | oint8 | oint64

type DecodeRaw*[oT:DecodeRawout_type] {.header:"generated.h", importcpp:"DecodeRaw/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeRaw[oT: DecodeRawout_type](scope: Scope,
                bytes: ostring,
                little_endian: bool): DecodeRaw[oT] {.header:"generated.h", importcpp:"DecodeRaw(*#, #, #)", constructor.}

proc decodeRaw*[oT: DecodeRawout_type](scope: Scope,
                bytes: ostring,
                little_endian: bool = true): DecodeRaw[oT] =
  return iidecodeRaw(scope,
                     bytes,
                     little_endian)

converter decodeRawToOut*[oT: DecodeRawout_type](op: DecodeRaw[oT]): oT = return op.output


type ReaderNumRecordsProducedV2*[oT:oint64] {.header:"generated.h", importcpp:"ReaderNumRecordsProducedV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderNumRecordsProducedV2[oT: oint64](scope: Scope,
                                 reader_handle: oresource): ReaderNumRecordsProducedV2[oT] {.header:"generated.h", importcpp:"ReaderNumRecordsProducedV2(*#, #)", constructor.}

proc readerNumRecordsProducedV2*[oT: oint64](scope: Scope,
                                 reader_handle: oresource): ReaderNumRecordsProducedV2[oT] =
  return iireaderNumRecordsProducedV2(scope,
                                      reader_handle)

converter readerNumRecordsProducedV2ToOut*[oT: oint64](op: ReaderNumRecordsProducedV2[oT]): oT = return op.output

type CumprodT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type CumprodTidx = oint32 | oint64

type Cumprod*[oT:CumprodT] {.header:"generated.h", importcpp:"Cumprod/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicumprod[oT: CumprodT](scope: Scope,
              x: oT,
              axis: CumprodTidx,
              exclusive: bool,
              reverse: bool): Cumprod[oT] {.header:"generated.h", importcpp:"Cumprod(*#, #, #, #, #)", constructor.}

proc cumprod*[oT: CumprodT](scope: Scope,
              x: oT,
              axis: CumprodTidx,
              exclusive: bool = false,
              reverse: bool = false): Cumprod[oT] =
  return iicumprod(scope,
                   x,
                   axis,
                   exclusive,
                   reverse)

converter cumprodToOut*[oT: CumprodT](op: Cumprod[oT]): oT = return op.output


type ReaderReadV2*[oT:ostring] {.header:"generated.h", importcpp:"ReaderReadV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderReadV2[oT: ostring](scope: Scope,
                   reader_handle: oresource,
                   queue_handle: oresource): ReaderReadV2[oT] {.header:"generated.h", importcpp:"ReaderReadV2(*#, #, #)", constructor.}

proc readerReadV2*[oT: ostring](scope: Scope,
                   reader_handle: oresource,
                   queue_handle: oresource): ReaderReadV2[oT] =
  return iireaderReadV2(scope,
                        reader_handle,
                        queue_handle)

converter readerReadV2ToOut*[oT: ostring](op: ReaderReadV2[oT]): oT = return op.output

type SquareT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Square*[oT:SquareT] {.header:"generated.h", importcpp:"Square/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisquare[oT: SquareT](scope: Scope,
             x: oT): Square[oT] {.header:"generated.h", importcpp:"Square(*#, #)", constructor.}

proc square*[oT: SquareT](scope: Scope,
             x: oT): Square[oT] =
  return iisquare(scope,
                  x)

converter squareToOut*[oT: SquareT](op: Square[oT]): oT = return op.output


type IdentityReader*[oT:ostring] {.header:"generated.h", importcpp:"IdentityReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiidentityReader[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring): IdentityReader[oT] {.header:"generated.h", importcpp:"IdentityReader(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc identityReader*[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring): IdentityReader[oT] =
  return iiidentityReader(scope,
                          container,
                          shared_name)

converter identityReaderToOut*[oT: ostring](op: IdentityReader[oT]): oT = return op.output

type SliceT = oall
type SliceIndex = oint32 | oint64

type Slice*[oT:SliceT] {.header:"generated.h", importcpp:"Slice/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iislice[oT: SliceT](scope: Scope,
            input: oT,
            begin: SliceIndex,
            size: SliceIndex): Slice[oT] {.header:"generated.h", importcpp:"Slice(*#, #, #, #)", constructor.}

proc slice*[oT: SliceT](scope: Scope,
            input: oT,
            begin: SliceIndex,
            size: SliceIndex): Slice[oT] =
  return iislice(scope,
                 input,
                 begin,
                 size)

converter sliceToOut*[oT: SliceT](op: Slice[oT]): oT = return op.output


type LMDBReader*[oT:ostring] {.header:"generated.h", importcpp:"LMDBReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilMDBReader[oT: ostring](scope: Scope,
                 container: cstring,
                 shared_name: cstring): LMDBReader[oT] {.header:"generated.h", importcpp:"LMDBReader(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc lMDBReader*[oT: ostring](scope: Scope,
                 container: cstring,
                 shared_name: cstring): LMDBReader[oT] =
  return iilMDBReader(scope,
                      container,
                      shared_name)

converter lMDBReaderToOut*[oT: ostring](op: LMDBReader[oT]): oT = return op.output


type TFRecordReaderV2*[oT:oresource] {.header:"generated.h", importcpp:"TFRecordReaderV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitFRecordReaderV2[oT: oresource](scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       compression_type: cstring): TFRecordReaderV2[oT] {.header:"generated.h", importcpp:"TFRecordReaderV2(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc tFRecordReaderV2*[oT: oresource](scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       compression_type: cstring): TFRecordReaderV2[oT] =
  return iitFRecordReaderV2(scope,
                            container,
                            shared_name,
                            compression_type)

converter tFRecordReaderV2ToOut*[oT: oresource](op: TFRecordReaderV2[oT]): oT = return op.output


type TFRecordReader*[oT:ostring] {.header:"generated.h", importcpp:"TFRecordReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitFRecordReader[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     compression_type: cstring): TFRecordReader[oT] {.header:"generated.h", importcpp:"TFRecordReader(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc tFRecordReader*[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     compression_type: cstring): TFRecordReader[oT] =
  return iitFRecordReader(scope,
                          container,
                          shared_name,
                          compression_type)

converter tFRecordReaderToOut*[oT: ostring](op: TFRecordReader[oT]): oT = return op.output


type FixedLengthRecordReaderV2*[oT:oresource] {.header:"generated.h", importcpp:"FixedLengthRecordReaderV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifixedLengthRecordReaderV2[oT: oresource](scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                encoding: cstring,
                                header_bytes: int64,
                                record_bytes: int64,
                                footer_bytes: int64,
                                hop_bytes: int64): FixedLengthRecordReaderV2[oT] {.header:"generated.h", importcpp:"FixedLengthRecordReaderV2(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc fixedLengthRecordReaderV2*[oT: oresource](scope: Scope,
                                container: cstring,
                                shared_name: cstring,
                                encoding: cstring,
                                header_bytes: int64 = 0,
                                record_bytes: int64 = 0,
                                footer_bytes: int64 = 0,
                                hop_bytes: int64 = 0): FixedLengthRecordReaderV2[oT] =
  return iifixedLengthRecordReaderV2(scope,
                                     container,
                                     shared_name,
                                     encoding,
                                     header_bytes,
                                     record_bytes,
                                     footer_bytes,
                                     hop_bytes)

converter fixedLengthRecordReaderV2ToOut*[oT: oresource](op: FixedLengthRecordReaderV2[oT]): oT = return op.output


type IdentityReaderV2*[oT:oresource] {.header:"generated.h", importcpp:"IdentityReaderV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiidentityReaderV2[oT: oresource](scope: Scope,
                       container: cstring,
                       shared_name: cstring): IdentityReaderV2[oT] {.header:"generated.h", importcpp:"IdentityReaderV2(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc identityReaderV2*[oT: oresource](scope: Scope,
                       container: cstring,
                       shared_name: cstring): IdentityReaderV2[oT] =
  return iiidentityReaderV2(scope,
                            container,
                            shared_name)

converter identityReaderV2ToOut*[oT: oresource](op: IdentityReaderV2[oT]): oT = return op.output


type TextLineReaderV2*[oT:oresource] {.header:"generated.h", importcpp:"TextLineReaderV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitextLineReaderV2[oT: oresource](scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       skip_header_lines: int64): TextLineReaderV2[oT] {.header:"generated.h", importcpp:"TextLineReaderV2(*#, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc textLineReaderV2*[oT: oresource](scope: Scope,
                       container: cstring,
                       shared_name: cstring,
                       skip_header_lines: int64 = 0): TextLineReaderV2[oT] =
  return iitextLineReaderV2(scope,
                            container,
                            shared_name,
                            skip_header_lines)

converter textLineReaderV2ToOut*[oT: oresource](op: TextLineReaderV2[oT]): oT = return op.output


type ShardedFilename*[oT:ostring] {.header:"generated.h", importcpp:"ShardedFilename/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iishardedFilename[oT: ostring](scope: Scope,
                      basename: oT,
                      shard: oint32,
                      num_shards: oint32): ShardedFilename[oT] {.header:"generated.h", importcpp:"ShardedFilename(*#, #, #, #)", constructor.}

proc shardedFilename*[oT: ostring](scope: Scope,
                      basename: oT,
                      shard: oint32,
                      num_shards: oint32): ShardedFilename[oT] =
  return iishardedFilename(scope,
                           basename,
                           shard,
                           num_shards)

converter shardedFilenameToOut*[oT: ostring](op: ShardedFilename[oT]): oT = return op.output

type RestoreSlicedt = oall

type RestoreSlice*[oT:RestoreSlicedt] {.header:"generated.h", importcpp:"RestoreSlice/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirestoreSlice[oT: RestoreSlicedt](scope: Scope,
                   file_pattern: ostring,
                   tensor_name: ostring,
                   shape_and_slice: ostring,
                   preferred_shard: int64): RestoreSlice[oT] {.header:"generated.h", importcpp:"RestoreSlice(*#, #, #, #, #)", constructor.}

proc restoreSlice*[oT: RestoreSlicedt](scope: Scope,
                   file_pattern: ostring,
                   tensor_name: ostring,
                   shape_and_slice: ostring,
                   preferred_shard: int64 = -1): RestoreSlice[oT] =
  return iirestoreSlice(scope,
                        file_pattern,
                        tensor_name,
                        shape_and_slice,
                        preferred_shard)

converter restoreSliceToOut*[oT: RestoreSlicedt](op: RestoreSlice[oT]): oT = return op.output

type Restoredt = oall

type Restore*[oT:Restoredt] {.header:"generated.h", importcpp:"Restore/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirestore[oT: Restoredt](scope: Scope,
              file_pattern: ostring,
              tensor_name: ostring,
              preferred_shard: int64): Restore[oT] {.header:"generated.h", importcpp:"Restore(*#, #, #, #)", constructor.}

proc restore*[oT: Restoredt](scope: Scope,
              file_pattern: ostring,
              tensor_name: ostring,
              preferred_shard: int64 = -1): Restore[oT] =
  return iirestore(scope,
                   file_pattern,
                   tensor_name,
                   preferred_shard)

converter restoreToOut*[oT: Restoredt](op: Restore[oT]): oT = return op.output


type SaveSlices*{.header:"generated.h", importcpp:"SaveSlices/*'0*/".} = object
  operation: Operation[oinvalid]


proc iisaveSlices(scope: Scope,
                 filename: ostring,
                 tensor_names: ostring,
                 shapes_and_slices: ostring,
                 data: oinvalid,
                 T: ArraySlice[DType]): SaveSlices {.header:"generated.h", importcpp:"SaveSlices(*#, #, #, #, #, #)", constructor.}

proc saveSlices*(scope: Scope,
                 filename: ostring,
                 tensor_names: ostring,
                 shapes_and_slices: ostring,
                 data: oinvalid,
                 T: openArray[DType]): SaveSlices =
  return iisaveSlices(scope,
                      filename,
                      tensor_names,
                      shapes_and_slices,
                      data,
                      newArraySlice(T))




type Save*{.header:"generated.h", importcpp:"Save/*'0*/".} = object
  operation: Operation[oinvalid]


proc iisave(scope: Scope,
           filename: ostring,
           tensor_names: ostring,
           data: oinvalid,
           T: ArraySlice[DType]): Save {.header:"generated.h", importcpp:"Save(*#, #, #, #, #)", constructor.}

proc save*(scope: Scope,
           filename: ostring,
           tensor_names: ostring,
           data: oinvalid,
           T: openArray[DType]): Save =
  return iisave(scope,
                filename,
                tensor_names,
                data,
                newArraySlice(T))




type MergeV2Checkpoints*{.header:"generated.h", importcpp:"MergeV2Checkpoints/*'0*/".} = object
  operation: Operation[oinvalid]


proc iimergeV2Checkpoints(scope: Scope,
                         checkpoint_prefixes: ostring,
                         destination_prefix: ostring,
                         delete_old_dirs: bool): MergeV2Checkpoints {.header:"generated.h", importcpp:"MergeV2Checkpoints(*#, #, #, #)", constructor.}

proc mergeV2Checkpoints*(scope: Scope,
                         checkpoint_prefixes: ostring,
                         destination_prefix: ostring,
                         delete_old_dirs: bool = true): MergeV2Checkpoints =
  return iimergeV2Checkpoints(scope,
                              checkpoint_prefixes,
                              destination_prefix,
                              delete_old_dirs)



type NonMaxSuppressionV2T = ohalf | ofloat

type NonMaxSuppressionV2*[oT:oint32] {.header:"generated.h", importcpp:"NonMaxSuppressionV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinonMaxSuppressionV2[oT: oint32](scope: Scope,
                          boxes: NonMaxSuppressionV2T,
                          scores: NonMaxSuppressionV2T,
                          max_output_size: oT,
                          iou_threshold: ofloat): NonMaxSuppressionV2[oT] {.header:"generated.h", importcpp:"NonMaxSuppressionV2(*#, #, #, #, #)", constructor.}

proc nonMaxSuppressionV2*[oT: oint32](scope: Scope,
                          boxes: NonMaxSuppressionV2T,
                          scores: NonMaxSuppressionV2T,
                          max_output_size: oT,
                          iou_threshold: ofloat): NonMaxSuppressionV2[oT] =
  return iinonMaxSuppressionV2(scope,
                               boxes,
                               scores,
                               max_output_size,
                               iou_threshold)

converter nonMaxSuppressionV2ToOut*[oT: oint32](op: NonMaxSuppressionV2[oT]): oT = return op.output

type RefExitT = oall

type RefExit*[oT:RefExitT] {.header:"generated.h", importcpp:"RefExit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefExit[oT: RefExitT](scope: Scope,
              data: oT): RefExit[oT] {.header:"generated.h", importcpp:"RefExit(*#, #)", constructor.}

proc refExit*[oT: RefExitT](scope: Scope,
              data: oT): RefExit[oT] =
  return iirefExit(scope,
                   data)

converter refExitToOut*[oT: RefExitT](op: RefExit[oT]): oT = return op.output

type NotEqualT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | oint16 | oint32 | oint64 | ocomplex64 | oquint8 | oqint8 | oqint32 | ostring | obool | ocomplex128

type NotEqual*[oT:obool] {.header:"generated.h", importcpp:"NotEqual/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinotEqual[oT: obool](scope: Scope,
               x: NotEqualT,
               y: NotEqualT): NotEqual[oT] {.header:"generated.h", importcpp:"NotEqual(*#, #, #)", constructor.}

proc notEqual*[oT: obool](scope: Scope,
               x: NotEqualT,
               y: NotEqualT): NotEqual[oT] =
  return iinotEqual(scope,
                    x,
                    y)

converter notEqualToOut*[oT: obool](op: NotEqual[oT]): oT = return op.output

type LookupTableRemoveV2Tin = oall

type LookupTableRemoveV2*{.header:"generated.h", importcpp:"LookupTableRemoveV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iilookupTableRemoveV2(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableRemoveV2Tin): LookupTableRemoveV2 {.header:"generated.h", importcpp:"LookupTableRemoveV2(*#, #, #)", constructor.}

proc lookupTableRemoveV2*(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableRemoveV2Tin): LookupTableRemoveV2 =
  return iilookupTableRemoveV2(scope,
                               table_handle,
                               keys)




type NonMaxSuppression*[oT:oint32] {.header:"generated.h", importcpp:"NonMaxSuppression/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinonMaxSuppression[oT: oint32](scope: Scope,
                        boxes: ofloat,
                        scores: ofloat,
                        max_output_size: oT,
                        iou_threshold: float32): NonMaxSuppression[oT] {.header:"generated.h", importcpp:"NonMaxSuppression(*#, #, #, #, #)", constructor.}

proc nonMaxSuppression*[oT: oint32](scope: Scope,
                        boxes: ofloat,
                        scores: ofloat,
                        max_output_size: oT,
                        iou_threshold: float32 = 0.5.float32): NonMaxSuppression[oT] =
  return iinonMaxSuppression(scope,
                             boxes,
                             scores,
                             max_output_size,
                             iou_threshold)

converter nonMaxSuppressionToOut*[oT: oint32](op: NonMaxSuppression[oT]): oT = return op.output

type TanhT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Tanh*[oT:TanhT] {.header:"generated.h", importcpp:"Tanh/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitanh[oT: TanhT](scope: Scope,
           x: oT): Tanh[oT] {.header:"generated.h", importcpp:"Tanh(*#, #)", constructor.}

proc tanh*[oT: TanhT](scope: Scope,
           x: oT): Tanh[oT] =
  return iitanh(scope,
                x)

converter tanhToOut*[oT: TanhT](op: Tanh[oT]): oT = return op.output

type CropAndResizeGradImageT = ofloat | ohalf | odouble

type CropAndResizeGradImage*[oT:CropAndResizeGradImageT] {.header:"generated.h", importcpp:"CropAndResizeGradImage/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicropAndResizeGradImage[oT: CropAndResizeGradImageT](scope: Scope,
                             grads: ofloat,
                             boxes: ofloat,
                             box_ind: oint32,
                             image_size: oint32,
                             nmethod: cstring): CropAndResizeGradImage[oT] {.header:"generated.h", importcpp:"CropAndResizeGradImage(*#, #, #, #, #, tensorflow::string(#))", constructor.}

proc cropAndResizeGradImage*[oT: CropAndResizeGradImageT](scope: Scope,
                             grads: ofloat,
                             boxes: ofloat,
                             box_ind: oint32,
                             image_size: oint32,
                             nmethod: cstring = "bilinear"): CropAndResizeGradImage[oT] =
  return iicropAndResizeGradImage(scope,
                                  grads,
                                  boxes,
                                  box_ind,
                                  image_size,
                                  nmethod)

converter cropAndResizeGradImageToOut*[oT: CropAndResizeGradImageT](op: CropAndResizeGradImage[oT]): oT = return op.output


type AdjustSaturation*[oT:ofloat] {.header:"generated.h", importcpp:"AdjustSaturation/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiadjustSaturation[oT: ofloat](scope: Scope,
                       images: oT,
                       scale: oT): AdjustSaturation[oT] {.header:"generated.h", importcpp:"AdjustSaturation(*#, #, #)", constructor.}

proc adjustSaturation*[oT: ofloat](scope: Scope,
                       images: oT,
                       scale: oT): AdjustSaturation[oT] =
  return iiadjustSaturation(scope,
                            images,
                            scale)

converter adjustSaturationToOut*[oT: ofloat](op: AdjustSaturation[oT]): oT = return op.output

type ApplyPowerSignT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyPowerSign*[oT:ApplyPowerSignT] {.header:"generated.h", importcpp:"ApplyPowerSign/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyPowerSign[oT: ApplyPowerSignT](scope: Scope,
                     nvar: oT,
                     m: oT,
                     lr: oT,
                     logbase: oT,
                     sign_decay: oT,
                     beta: oT,
                     grad: oT,
                     use_locking: bool): ApplyPowerSign[oT] {.header:"generated.h", importcpp:"ApplyPowerSign(*#, #, #, #, #, #, #, #, #)", constructor.}

proc applyPowerSign*[oT: ApplyPowerSignT](scope: Scope,
                     nvar: oT,
                     m: oT,
                     lr: oT,
                     logbase: oT,
                     sign_decay: oT,
                     beta: oT,
                     grad: oT,
                     use_locking: bool = false): ApplyPowerSign[oT] =
  return iiapplyPowerSign(scope,
                          nvar,
                          m,
                          lr,
                          logbase,
                          sign_decay,
                          beta,
                          grad,
                          use_locking)

converter applyPowerSignToOut*[oT: ApplyPowerSignT](op: ApplyPowerSign[oT]): oT = return op.output

type QuantizedAvgPoolT = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedAvgPool*[oT:QuantizedAvgPoolT] {.header:"generated.h", importcpp:"QuantizedAvgPool/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedAvgPool[oT: QuantizedAvgPoolT](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: ArraySlice[int],
                       strides: ArraySlice[int],
                       padding: cstring): QuantizedAvgPool[oT] {.header:"generated.h", importcpp:"QuantizedAvgPool(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc quantizedAvgPool*[oT: QuantizedAvgPoolT](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: openArray[int],
                       strides: openArray[int],
                       padding: cstring): QuantizedAvgPool[oT] =
  return iiquantizedAvgPool(scope,
                            input,
                            min_input,
                            max_input,
                            newArraySlice(ksize),
                            newArraySlice(strides),
                            padding)

converter quantizedAvgPoolToOut*[oT: QuantizedAvgPoolT](op: QuantizedAvgPool[oT]): oT = return op.output


type AdjustContrastv2*[oT:ofloat] {.header:"generated.h", importcpp:"AdjustContrastv2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiadjustContrastv2[oT: ofloat](scope: Scope,
                       images: oT,
                       contrast_factor: oT): AdjustContrastv2[oT] {.header:"generated.h", importcpp:"AdjustContrastv2(*#, #, #)", constructor.}

proc adjustContrastv2*[oT: ofloat](scope: Scope,
                       images: oT,
                       contrast_factor: oT): AdjustContrastv2[oT] =
  return iiadjustContrastv2(scope,
                            images,
                            contrast_factor)

converter adjustContrastv2ToOut*[oT: ofloat](op: AdjustContrastv2[oT]): oT = return op.output

type RankT = oall

type Rank*[oT:oint32] {.header:"generated.h", importcpp:"Rank/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirank[oT: oint32](scope: Scope,
           input: RankT): Rank[oT] {.header:"generated.h", importcpp:"Rank(*#, #)", constructor.}

proc rank*[oT: oint32](scope: Scope,
           input: RankT): Rank[oT] =
  return iirank(scope,
                input)

converter rankToOut*[oT: oint32](op: Rank[oT]): oT = return op.output


type EncodeJpeg*[oT:ostring] {.header:"generated.h", importcpp:"EncodeJpeg/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiencodeJpeg[oT: ostring](scope: Scope,
                 image: ouint8,
                 format: cstring,
                 xmp_metadata: cstring,
                 quality: int64,
                 progressive: bool,
                 optimize_size: bool,
                 chroma_downsampling: bool,
                 density_unit: cstring,
                 x_density: int64,
                 y_density: int64): EncodeJpeg[oT] {.header:"generated.h", importcpp:"EncodeJpeg(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc encodeJpeg*[oT: ostring](scope: Scope,
                 image: ouint8,
                 format: cstring,
                 xmp_metadata: cstring,
                 quality: int64 = 95,
                 progressive: bool = false,
                 optimize_size: bool = false,
                 chroma_downsampling: bool = true,
                 density_unit: cstring = "in",
                 x_density: int64 = 300,
                 y_density: int64 = 300): EncodeJpeg[oT] =
  return iiencodeJpeg(scope,
                      image,
                      format,
                      xmp_metadata,
                      quality,
                      progressive,
                      optimize_size,
                      chroma_downsampling,
                      density_unit,
                      x_density,
                      y_density)

converter encodeJpegToOut*[oT: ostring](op: EncodeJpeg[oT]): oT = return op.output

type TensorArrayConcatdtype = oall

type TensorArrayConcat*[oT:TensorArrayConcatdtype] {.header:"generated.h", importcpp:"TensorArrayConcat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayConcat[oT: TensorArrayConcatdtype](scope: Scope,
                        handle: ostring,
                        flow_in: ofloat,
                        dtype: DType,
                        element_shape_except0: TensorShape): TensorArrayConcat[oT] {.header:"generated.h", importcpp:"TensorArrayConcat(*#, #, #, #, #)", constructor.}

proc tensorArrayConcat*[oT: TensorArrayConcatdtype](scope: Scope,
                        handle: ostring,
                        flow_in: ofloat,
                        dtype: DType = oT[].oTF,
                        element_shape_except0: TensorShape = [].shape): TensorArrayConcat[oT] =
  return iitensorArrayConcat(scope,
                             handle,
                             flow_in,
                             dtype,
                             element_shape_except0)

converter tensorArrayConcatToOut*[oT: TensorArrayConcatdtype](op: TensorArrayConcat[oT]): oT = return op.output


type DecodeAndCropJpeg*[oT:ouint8] {.header:"generated.h", importcpp:"DecodeAndCropJpeg/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeAndCropJpeg[oT: ouint8](scope: Scope,
                        contents: ostring,
                        crop_window: oint32,
                        dct_method: cstring,
                        channels: int64,
                        ratio: int64,
                        fancy_upscaling: bool,
                        try_recover_truncated: bool,
                        acceptable_fraction: float32): DecodeAndCropJpeg[oT] {.header:"generated.h", importcpp:"DecodeAndCropJpeg(*#, #, #, tensorflow::string(#), #, #, #, #, #)", constructor.}

proc decodeAndCropJpeg*[oT: ouint8](scope: Scope,
                        contents: ostring,
                        crop_window: oint32,
                        dct_method: cstring,
                        channels: int64 = 0,
                        ratio: int64 = 1,
                        fancy_upscaling: bool = true,
                        try_recover_truncated: bool = false,
                        acceptable_fraction: float32 = 1.0.float32): DecodeAndCropJpeg[oT] =
  return iidecodeAndCropJpeg(scope,
                             contents,
                             crop_window,
                             dct_method,
                             channels,
                             ratio,
                             fancy_upscaling,
                             try_recover_truncated,
                             acceptable_fraction)

converter decodeAndCropJpegToOut*[oT: ouint8](op: DecodeAndCropJpeg[oT]): oT = return op.output


type DecodeJpeg*[oT:ouint8] {.header:"generated.h", importcpp:"DecodeJpeg/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeJpeg[oT: ouint8](scope: Scope,
                 contents: ostring,
                 dct_method: cstring,
                 channels: int64,
                 ratio: int64,
                 fancy_upscaling: bool,
                 try_recover_truncated: bool,
                 acceptable_fraction: float32): DecodeJpeg[oT] {.header:"generated.h", importcpp:"DecodeJpeg(*#, #, tensorflow::string(#), #, #, #, #, #)", constructor.}

proc decodeJpeg*[oT: ouint8](scope: Scope,
                 contents: ostring,
                 dct_method: cstring,
                 channels: int64 = 0,
                 ratio: int64 = 1,
                 fancy_upscaling: bool = true,
                 try_recover_truncated: bool = false,
                 acceptable_fraction: float32 = 1.0.float32): DecodeJpeg[oT] =
  return iidecodeJpeg(scope,
                      contents,
                      dct_method,
                      channels,
                      ratio,
                      fancy_upscaling,
                      try_recover_truncated,
                      acceptable_fraction)

converter decodeJpegToOut*[oT: ouint8](op: DecodeJpeg[oT]): oT = return op.output

type RandomCropT = ouint8 | oint8 | oint16 | oint32 | oint64 | ofloat | odouble

type RandomCrop*[oT:RandomCropT] {.header:"generated.h", importcpp:"RandomCrop/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomCrop[oT: RandomCropT](scope: Scope,
                 image: oT,
                 size: oint64,
                 seed2: int64,
                 seed: int64): RandomCrop[oT] {.header:"generated.h", importcpp:"RandomCrop(*#, #, #, #, #)", constructor.}

proc randomCrop*[oT: RandomCropT](scope: Scope,
                 image: oT,
                 size: oint64,
                 seed2: int64 = 0,
                 seed: int64 = 0): RandomCrop[oT] =
  return iirandomCrop(scope,
                      image,
                      size,
                      seed2,
                      seed)

converter randomCropToOut*[oT: RandomCropT](op: RandomCrop[oT]): oT = return op.output


type BigQueryReader*[oT:ostring] {.header:"generated.h", importcpp:"BigQueryReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibigQueryReader[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     project_id: cstring,
                     dataset_id: cstring,
                     table_id: cstring,
                     columns: ArraySlice[cstring],
                     test_end_point: cstring,
                     timestamp_millis: int64): BigQueryReader[oT] {.header:"generated.h", importcpp:"BigQueryReader(*#, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc bigQueryReader*[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     project_id: cstring,
                     dataset_id: cstring,
                     table_id: cstring,
                     columns: openArray[cstring],
                     test_end_point: cstring,
                     timestamp_millis: int64 = 0): BigQueryReader[oT] =
  return iibigQueryReader(scope,
                          container,
                          shared_name,
                          project_id,
                          dataset_id,
                          table_id,
                          newArraySlice(columns),
                          test_end_point,
                          timestamp_millis)

converter bigQueryReaderToOut*[oT: ostring](op: BigQueryReader[oT]): oT = return op.output

type ResizeNearestNeighborGradT = ouint8 | oint8 | oint32 | ohalf | ofloat | odouble

type ResizeNearestNeighborGrad*[oT:ResizeNearestNeighborGradT] {.header:"generated.h", importcpp:"ResizeNearestNeighborGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeNearestNeighborGrad[oT: ResizeNearestNeighborGradT](scope: Scope,
                                grads: oT,
                                size: oint32,
                                align_corners: bool): ResizeNearestNeighborGrad[oT] {.header:"generated.h", importcpp:"ResizeNearestNeighborGrad(*#, #, #, #)", constructor.}

proc resizeNearestNeighborGrad*[oT: ResizeNearestNeighborGradT](scope: Scope,
                                grads: oT,
                                size: oint32,
                                align_corners: bool = false): ResizeNearestNeighborGrad[oT] =
  return iiresizeNearestNeighborGrad(scope,
                                     grads,
                                     size,
                                     align_corners)

converter resizeNearestNeighborGradToOut*[oT: ResizeNearestNeighborGradT](op: ResizeNearestNeighborGrad[oT]): oT = return op.output

type LRNT = ohalf | obfloat16 | ofloat

type LRN*[oT:LRNT] {.header:"generated.h", importcpp:"LRN/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilRN[oT: LRNT](scope: Scope,
          input: oT,
          depth_radius: int64,
          bias: float32,
          alpha: float32,
          beta: float32): LRN[oT] {.header:"generated.h", importcpp:"LRN(*#, #, #, #, #, #)", constructor.}

proc lRN*[oT: LRNT](scope: Scope,
          input: oT,
          depth_radius: int64 = 5,
          bias: float32 = 1.0.float32,
          alpha: float32 = 1.0.float32,
          beta: float32 = 0.5.float32): LRN[oT] =
  return iilRN(scope,
               input,
               depth_radius,
               bias,
               alpha,
               beta)

converter lRNToOut*[oT: LRNT](op: LRN[oT]): oT = return op.output

type Conv3DBackpropInputV2Tshape = oint32 | oint64
type Conv3DBackpropInputV2T = ohalf | obfloat16 | ofloat | odouble

type Conv3DBackpropInputV2*[oT:Conv3DBackpropInputV2T] {.header:"generated.h", importcpp:"Conv3DBackpropInputV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv3DBackpropInputV2[oT: Conv3DBackpropInputV2T](scope: Scope,
                            input_sizes: Conv3DBackpropInputV2Tshape,
                            filter: oT,
                            out_backprop: oT,
                            strides: ArraySlice[int],
                            padding: cstring,
                            dilations: ArraySlice[int],
                            data_format: cstring): Conv3DBackpropInputV2[oT] {.header:"generated.h", importcpp:"Conv3DBackpropInputV2(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc conv3DBackpropInputV2*[oT: Conv3DBackpropInputV2T](scope: Scope,
                            input_sizes: Conv3DBackpropInputV2Tshape,
                            filter: oT,
                            out_backprop: oT,
                            strides: openArray[int],
                            padding: cstring,
                            dilations: openArray[int] = [1, 1, 1, 1, 1],
                            data_format: cstring = "NDHWC"): Conv3DBackpropInputV2[oT] =
  return iiconv3DBackpropInputV2(scope,
                                 input_sizes,
                                 filter,
                                 out_backprop,
                                 newArraySlice(strides),
                                 padding,
                                 newArraySlice(dilations),
                                 data_format)

converter conv3DBackpropInputV2ToOut*[oT: Conv3DBackpropInputV2T](op: Conv3DBackpropInputV2[oT]): oT = return op.output

type ResizeBilinearT = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | obfloat16 | ohalf | ofloat | odouble

type ResizeBilinear*[oT:ofloat] {.header:"generated.h", importcpp:"ResizeBilinear/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeBilinear[oT: ofloat](scope: Scope,
                     images: ResizeBilinearT,
                     size: oint32,
                     align_corners: bool): ResizeBilinear[oT] {.header:"generated.h", importcpp:"ResizeBilinear(*#, #, #, #)", constructor.}

proc resizeBilinear*[oT: ofloat](scope: Scope,
                     images: ResizeBilinearT,
                     size: oint32,
                     align_corners: bool = false): ResizeBilinear[oT] =
  return iiresizeBilinear(scope,
                          images,
                          size,
                          align_corners)

converter resizeBilinearToOut*[oT: ofloat](op: ResizeBilinear[oT]): oT = return op.output

type AssignAddVariableOpdtype = oall

type AssignAddVariableOp*{.header:"generated.h", importcpp:"AssignAddVariableOp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiassignAddVariableOp(scope: Scope,
                          resource: oresource,
                          value: AssignAddVariableOpdtype,
                          dtype: DType): AssignAddVariableOp {.header:"generated.h", importcpp:"AssignAddVariableOp(*#, #, #, #)", constructor.}

proc assignAddVariableOp*(scope: Scope,
                          resource: oresource,
                          value: AssignAddVariableOpdtype,
                          dtype: DType = DT_INVALID): AssignAddVariableOp =
  return iiassignAddVariableOp(scope,
                               resource,
                               value,
                               dtype)



type DepthwiseConv2dNativeBackpropInputT = ohalf | obfloat16 | ofloat | odouble

type DepthwiseConv2dNativeBackpropInput*[oT:DepthwiseConv2dNativeBackpropInputT] {.header:"generated.h", importcpp:"DepthwiseConv2dNativeBackpropInput/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidepthwiseConv2dNativeBackpropInput[oT: DepthwiseConv2dNativeBackpropInputT](scope: Scope,
                                         input_sizes: oint32,
                                         filter: oT,
                                         out_backprop: oT,
                                         strides: ArraySlice[int],
                                         padding: cstring,
                                         dilations: ArraySlice[int],
                                         data_format: cstring): DepthwiseConv2dNativeBackpropInput[oT] {.header:"generated.h", importcpp:"DepthwiseConv2dNativeBackpropInput(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc depthwiseConv2dNativeBackpropInput*[oT: DepthwiseConv2dNativeBackpropInputT](scope: Scope,
                                         input_sizes: oint32,
                                         filter: oT,
                                         out_backprop: oT,
                                         strides: openArray[int],
                                         padding: cstring,
                                         dilations: openArray[int] = [1, 1, 1, 1],
                                         data_format: cstring = "NHWC"): DepthwiseConv2dNativeBackpropInput[oT] =
  return iidepthwiseConv2dNativeBackpropInput(scope,
                                              input_sizes,
                                              filter,
                                              out_backprop,
                                              newArraySlice(strides),
                                              padding,
                                              newArraySlice(dilations),
                                              data_format)

converter depthwiseConv2dNativeBackpropInputToOut*[oT: DepthwiseConv2dNativeBackpropInputT](op: DepthwiseConv2dNativeBackpropInput[oT]): oT = return op.output

type IsNanT = obfloat16 | ohalf | ofloat | odouble

type IsNan*[oT:obool] {.header:"generated.h", importcpp:"IsNan/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiisNan[oT: obool](scope: Scope,
            x: IsNanT): IsNan[oT] {.header:"generated.h", importcpp:"IsNan(*#, #)", constructor.}

proc isNan*[oT: obool](scope: Scope,
            x: IsNanT): IsNan[oT] =
  return iiisNan(scope,
                 x)

converter isNanToOut*[oT: obool](op: IsNan[oT]): oT = return op.output

type TensorListPushBackelement_dtype = oall

type TensorListPushBack*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListPushBack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListPushBack[oT: ovariant](scope: Scope,
                         input_handle: oT,
                         tensor: TensorListPushBackelement_dtype): TensorListPushBack[oT] {.header:"generated.h", importcpp:"TensorListPushBack(*#, #, #)", constructor.}

proc tensorListPushBack*[oT: ovariant](scope: Scope,
                         input_handle: oT,
                         tensor: TensorListPushBackelement_dtype): TensorListPushBack[oT] =
  return iitensorListPushBack(scope,
                              input_handle,
                              tensor)

converter tensorListPushBackToOut*[oT: ovariant](op: TensorListPushBack[oT]): oT = return op.output

type SparseApplyMomentumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyMomentumTindices = oint32 | oint64

type SparseApplyMomentum*[oT:SparseApplyMomentumT] {.header:"generated.h", importcpp:"SparseApplyMomentum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyMomentum[oT: SparseApplyMomentumT](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          lr: oT,
                          grad: oT,
                          indices: SparseApplyMomentumTindices,
                          momentum: oT,
                          use_nesterov: bool,
                          use_locking: bool): SparseApplyMomentum[oT] {.header:"generated.h", importcpp:"SparseApplyMomentum(*#, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyMomentum*[oT: SparseApplyMomentumT](scope: Scope,
                          nvar: oT,
                          accum: oT,
                          lr: oT,
                          grad: oT,
                          indices: SparseApplyMomentumTindices,
                          momentum: oT,
                          use_nesterov: bool = false,
                          use_locking: bool = false): SparseApplyMomentum[oT] =
  return iisparseApplyMomentum(scope,
                               nvar,
                               accum,
                               lr,
                               grad,
                               indices,
                               momentum,
                               use_nesterov,
                               use_locking)

converter sparseApplyMomentumToOut*[oT: SparseApplyMomentumT](op: SparseApplyMomentum[oT]): oT = return op.output

type UniqueWithCountsT = oall

type UniqueWithCounts*[oT:UniqueWithCountsT] {.header:"generated.h", importcpp:"UniqueWithCounts/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiuniqueWithCounts[oT: UniqueWithCountsT](scope: Scope,
                       x: oT,
                       out_idx: DType): UniqueWithCounts[oT] {.header:"generated.h", importcpp:"UniqueWithCounts(*#, #, #)", constructor.}

proc uniqueWithCounts*[oT: UniqueWithCountsT](scope: Scope,
                       x: oT,
                       out_idx: DType = DT_INT32): UniqueWithCounts[oT] =
  return iiuniqueWithCounts(scope,
                            x,
                            out_idx)

converter uniqueWithCountsToOut*[oT: UniqueWithCountsT](op: UniqueWithCounts[oT]): oT = return op.output

type ResizeBicubicGradT = ofloat | odouble

type ResizeBicubicGrad*[oT:ResizeBicubicGradT] {.header:"generated.h", importcpp:"ResizeBicubicGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeBicubicGrad[oT: ResizeBicubicGradT](scope: Scope,
                        grads: ofloat,
                        original_image: oT,
                        align_corners: bool): ResizeBicubicGrad[oT] {.header:"generated.h", importcpp:"ResizeBicubicGrad(*#, #, #, #)", constructor.}

proc resizeBicubicGrad*[oT: ResizeBicubicGradT](scope: Scope,
                        grads: ofloat,
                        original_image: oT,
                        align_corners: bool = false): ResizeBicubicGrad[oT] =
  return iiresizeBicubicGrad(scope,
                             grads,
                             original_image,
                             align_corners)

converter resizeBicubicGradToOut*[oT: ResizeBicubicGradT](op: ResizeBicubicGrad[oT]): oT = return op.output

type HSVToRGBT = ohalf | obfloat16 | ofloat | odouble

type HSVToRGB*[oT:HSVToRGBT] {.header:"generated.h", importcpp:"HSVToRGB/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iihSVToRGB[oT: HSVToRGBT](scope: Scope,
               images: oT): HSVToRGB[oT] {.header:"generated.h", importcpp:"HSVToRGB(*#, #)", constructor.}

proc hSVToRGB*[oT: HSVToRGBT](scope: Scope,
               images: oT): HSVToRGB[oT] =
  return iihSVToRGB(scope,
                    images)

converter hSVToRGBToOut*[oT: HSVToRGBT](op: HSVToRGB[oT]): oT = return op.output

type SparseSegmentMeanWithNumSegmentsT = ofloat | odouble
type SparseSegmentMeanWithNumSegmentsTidx = oint32 | oint64
type SparseSegmentMeanWithNumSegmentsTnumsegments = oint32 | oint64

type SparseSegmentMeanWithNumSegments*[oT:SparseSegmentMeanWithNumSegmentsT] {.header:"generated.h", importcpp:"SparseSegmentMeanWithNumSegments/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentMeanWithNumSegments[oT: SparseSegmentMeanWithNumSegmentsT](scope: Scope,
                                       data: oT,
                                       indices: SparseSegmentMeanWithNumSegmentsTidx,
                                       segment_ids: oint32,
                                       num_segments: SparseSegmentMeanWithNumSegmentsTnumsegments): SparseSegmentMeanWithNumSegments[oT] {.header:"generated.h", importcpp:"SparseSegmentMeanWithNumSegments(*#, #, #, #, #)", constructor.}

proc sparseSegmentMeanWithNumSegments*[oT: SparseSegmentMeanWithNumSegmentsT](scope: Scope,
                                       data: oT,
                                       indices: SparseSegmentMeanWithNumSegmentsTidx,
                                       segment_ids: oint32,
                                       num_segments: SparseSegmentMeanWithNumSegmentsTnumsegments): SparseSegmentMeanWithNumSegments[oT] =
  return iisparseSegmentMeanWithNumSegments(scope,
                                            data,
                                            indices,
                                            segment_ids,
                                            num_segments)

converter sparseSegmentMeanWithNumSegmentsToOut*[oT: SparseSegmentMeanWithNumSegmentsT](op: SparseSegmentMeanWithNumSegments[oT]): oT = return op.output

type ResizeBicubicT = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | ohalf | ofloat | odouble

type ResizeBicubic*[oT:ofloat] {.header:"generated.h", importcpp:"ResizeBicubic/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeBicubic[oT: ofloat](scope: Scope,
                    images: ResizeBicubicT,
                    size: oint32,
                    align_corners: bool): ResizeBicubic[oT] {.header:"generated.h", importcpp:"ResizeBicubic(*#, #, #, #)", constructor.}

proc resizeBicubic*[oT: ofloat](scope: Scope,
                    images: ResizeBicubicT,
                    size: oint32,
                    align_corners: bool = false): ResizeBicubic[oT] =
  return iiresizeBicubic(scope,
                         images,
                         size,
                         align_corners)

converter resizeBicubicToOut*[oT: ofloat](op: ResizeBicubic[oT]): oT = return op.output


type ReaderRestoreState*{.header:"generated.h", importcpp:"ReaderRestoreState/*'0*/".} = object
  operation: Operation[oinvalid]


proc iireaderRestoreState(scope: Scope,
                         reader_handle: ostring,
                         state: ostring): ReaderRestoreState {.header:"generated.h", importcpp:"ReaderRestoreState(*#, #, #)", constructor.}

proc readerRestoreState*(scope: Scope,
                         reader_handle: ostring,
                         state: ostring): ReaderRestoreState =
  return iireaderRestoreState(scope,
                              reader_handle,
                              state)



type ResizeAreaT = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | ohalf | ofloat | odouble

type ResizeArea*[oT:ofloat] {.header:"generated.h", importcpp:"ResizeArea/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeArea[oT: ofloat](scope: Scope,
                 images: ResizeAreaT,
                 size: oint32,
                 align_corners: bool): ResizeArea[oT] {.header:"generated.h", importcpp:"ResizeArea(*#, #, #, #)", constructor.}

proc resizeArea*[oT: ofloat](scope: Scope,
                 images: ResizeAreaT,
                 size: oint32,
                 align_corners: bool = false): ResizeArea[oT] =
  return iiresizeArea(scope,
                      images,
                      size,
                      align_corners)

converter resizeAreaToOut*[oT: ofloat](op: ResizeArea[oT]): oT = return op.output

type ScatterMinT = ohalf | obfloat16 | ofloat | odouble | oint32 | oint64
type ScatterMinTindices = oint32 | oint64

type ScatterMin*[oT:ScatterMinT] {.header:"generated.h", importcpp:"ScatterMin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterMin[oT: ScatterMinT](scope: Scope,
                 nref: oT,
                 indices: ScatterMinTindices,
                 updates: oT,
                 use_locking: bool): ScatterMin[oT] {.header:"generated.h", importcpp:"ScatterMin(*#, #, #, #, #)", constructor.}

proc scatterMin*[oT: ScatterMinT](scope: Scope,
                 nref: oT,
                 indices: ScatterMinTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterMin[oT] =
  return iiscatterMin(scope,
                      nref,
                      indices,
                      updates,
                      use_locking)

converter scatterMinToOut*[oT: ScatterMinT](op: ScatterMin[oT]): oT = return op.output

type FakeParamdtype = oall

type FakeParam*[oT:FakeParamdtype] {.header:"generated.h", importcpp:"FakeParam/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeParam[oT: FakeParamdtype](scope: Scope,
                dtype: DType,
                shape: TensorShape): FakeParam[oT] {.header:"generated.h", importcpp:"FakeParam(*#, #, #)", constructor.}

proc fakeParam*[oT: FakeParamdtype](scope: Scope,
                dtype: DType = oT[].oTF,
                shape: TensorShape = [].shape): FakeParam[oT] =
  return iifakeParam(scope,
                     dtype,
                     shape)

converter fakeParamToOut*[oT: FakeParamdtype](op: FakeParam[oT]): oT = return op.output

type PowT = obfloat16 | ofloat | ohalf | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Pow*[oT:PowT] {.header:"generated.h", importcpp:"Pow/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipow[oT: PowT](scope: Scope,
          x: oT,
          y: oT): Pow[oT] {.header:"generated.h", importcpp:"Pow(*#, #, #)", constructor.}

proc pow*[oT: PowT](scope: Scope,
          x: oT,
          y: oT): Pow[oT] =
  return iipow(scope,
               x,
               y)

converter powToOut*[oT: PowT](op: Pow[oT]): oT = return op.output


type PartitionedCall*[oT:oinvalid] {.header:"generated.h", importcpp:"PartitionedCall/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipartitionedCall[oT: oinvalid](scope: Scope,
                      args: oT,
                      Tin: ArraySlice[DType],
                      Tout: ArraySlice[DType],
                      f: NameAttrList,
                      config: cstring,
                      config_proto: cstring,
                      executor_type: cstring): PartitionedCall[oT] {.header:"generated.h", importcpp:"PartitionedCall(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc partitionedCall*[oT: oinvalid](scope: Scope,
                      args: oT,
                      Tin: openArray[DType],
                      Tout: openArray[DType],
                      f: NameAttrList,
                      config: cstring,
                      config_proto: cstring,
                      executor_type: cstring): PartitionedCall[oT] =
  return iipartitionedCall(scope,
                           args,
                           newArraySlice(Tin),
                           newArraySlice(Tout),
                           f,
                           config,
                           config_proto,
                           executor_type)

converter partitionedCallToOut*[oT: oinvalid](op: PartitionedCall[oT]): oT = return op.output

type SignT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Sign*[oT:SignT] {.header:"generated.h", importcpp:"Sign/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisign[oT: SignT](scope: Scope,
           x: oT): Sign[oT] {.header:"generated.h", importcpp:"Sign(*#, #)", constructor.}

proc sign*[oT: SignT](scope: Scope,
           x: oT): Sign[oT] =
  return iisign(scope,
                x)

converter signToOut*[oT: SignT](op: Sign[oT]): oT = return op.output


type While*[oT:oinvalid] {.header:"generated.h", importcpp:"While/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinwhile[oT: oinvalid](scope: Scope,
             input: oT,
             T: ArraySlice[DType],
             cond: NameAttrList,
             body: NameAttrList,
             output_shapes: ArraySlice[TensorShape]): While[oT] {.header:"generated.h", importcpp:"While(*#, #, #, #, #, #)", constructor.}

proc nwhile*[oT: oinvalid](scope: Scope,
             input: oT,
             T: openArray[DType],
             cond: NameAttrList,
             body: NameAttrList,
             output_shapes: openArray[TensorShape]): While[oT] =
  return iinwhile(scope,
                  input,
                  newArraySlice(T),
                  cond,
                  body,
                  newArraySlice(output_shapes))

converter nwhileToOut*[oT: oinvalid](op: While[oT]): oT = return op.output

type LogT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Log*[oT:LogT] {.header:"generated.h", importcpp:"Log/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilog[oT: LogT](scope: Scope,
          x: oT): Log[oT] {.header:"generated.h", importcpp:"Log(*#, #)", constructor.}

proc log*[oT: LogT](scope: Scope,
          x: oT): Log[oT] =
  return iilog(scope,
               x)

converter logToOut*[oT: LogT](op: Log[oT]): oT = return op.output


type IWhile*[oT:oinvalid] {.header:"generated.h", importcpp:"_While/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiWhile[oT: oinvalid](scope: Scope,
             input: oT,
             T: ArraySlice[DType],
             cond: NameAttrList,
             body: NameAttrList): IWhile[oT] {.header:"generated.h", importcpp:"_While(*#, #, #, #, #)", constructor.}

proc iWhile*[oT: oinvalid](scope: Scope,
             input: oT,
             T: openArray[DType],
             cond: NameAttrList,
             body: NameAttrList): IWhile[oT] =
  return iiiWhile(scope,
                  input,
                  newArraySlice(T),
                  cond,
                  body)

converter iWhileToOut*[oT: oinvalid](op: IWhile[oT]): oT = return op.output

type AddManySparseToTensorsMapT = oall

type AddManySparseToTensorsMap*[oT:oint64] {.header:"generated.h", importcpp:"AddManySparseToTensorsMap/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaddManySparseToTensorsMap[oT: oint64](scope: Scope,
                                sparse_indices: oT,
                                sparse_values: AddManySparseToTensorsMapT,
                                sparse_shape: oT,
                                container: cstring,
                                shared_name: cstring): AddManySparseToTensorsMap[oT] {.header:"generated.h", importcpp:"AddManySparseToTensorsMap(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc addManySparseToTensorsMap*[oT: oint64](scope: Scope,
                                sparse_indices: oT,
                                sparse_values: AddManySparseToTensorsMapT,
                                sparse_shape: oT,
                                container: cstring,
                                shared_name: cstring): AddManySparseToTensorsMap[oT] =
  return iiaddManySparseToTensorsMap(scope,
                                     sparse_indices,
                                     sparse_values,
                                     sparse_shape,
                                     container,
                                     shared_name)

converter addManySparseToTensorsMapToOut*[oT: oint64](op: AddManySparseToTensorsMap[oT]): oT = return op.output


type FlatMapDataset*[oT:ovariant] {.header:"generated.h", importcpp:"FlatMapDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiflatMapDataset[oT: ovariant](scope: Scope,
                     input_dataset: oT,
                     other_arguments: oinvalid,
                     f: NameAttrList,
                     Targuments: ArraySlice[DType],
                     output_types: ArraySlice[DType],
                     output_shapes: ArraySlice[TensorShape]): FlatMapDataset[oT] {.header:"generated.h", importcpp:"FlatMapDataset(*#, #, #, #, #, #, #)", constructor.}

proc flatMapDataset*[oT: ovariant](scope: Scope,
                     input_dataset: oT,
                     other_arguments: oinvalid,
                     f: NameAttrList,
                     Targuments: openArray[DType],
                     output_types: openArray[DType],
                     output_shapes: openArray[TensorShape]): FlatMapDataset[oT] =
  return iiflatMapDataset(scope,
                          input_dataset,
                          other_arguments,
                          f,
                          newArraySlice(Targuments),
                          newArraySlice(output_types),
                          newArraySlice(output_shapes))

converter flatMapDatasetToOut*[oT: ovariant](op: FlatMapDataset[oT]): oT = return op.output

type StatelessIfTcond = oall

type StatelessIf*[oT:oinvalid] {.header:"generated.h", importcpp:"StatelessIf/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessIf[oT: oinvalid](scope: Scope,
                  cond: StatelessIfTcond,
                  input: oT,
                  Tin: ArraySlice[DType],
                  Tout: ArraySlice[DType],
                  then_branch: NameAttrList,
                  else_branch: NameAttrList): StatelessIf[oT] {.header:"generated.h", importcpp:"StatelessIf(*#, #, #, #, #, #, #)", constructor.}

proc statelessIf*[oT: oinvalid](scope: Scope,
                  cond: StatelessIfTcond,
                  input: oT,
                  Tin: openArray[DType],
                  Tout: openArray[DType],
                  then_branch: NameAttrList,
                  else_branch: NameAttrList): StatelessIf[oT] =
  return iistatelessIf(scope,
                       cond,
                       input,
                       newArraySlice(Tin),
                       newArraySlice(Tout),
                       then_branch,
                       else_branch)

converter statelessIfToOut*[oT: oinvalid](op: StatelessIf[oT]): oT = return op.output

type AngleT = ocomplex64 | ocomplex128
type AngleTout = ofloat | odouble

type Angle*[oT:AngleTout] {.header:"generated.h", importcpp:"Angle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiangle[oT: AngleTout](scope: Scope,
            input: AngleT): Angle[oT] {.header:"generated.h", importcpp:"Angle(*#, #)", constructor.}

proc angle*[oT: AngleTout](scope: Scope,
            input: AngleT): Angle[oT] =
  return iiangle(scope,
                 input)

converter angleToOut*[oT: AngleTout](op: Angle[oT]): oT = return op.output


type RemoteCall*[oT:oinvalid] {.header:"generated.h", importcpp:"RemoteCall/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiremoteCall[oT: oinvalid](scope: Scope,
                 target: ostring,
                 args: oT,
                 Tin: ArraySlice[DType],
                 Tout: ArraySlice[DType],
                 f: NameAttrList): RemoteCall[oT] {.header:"generated.h", importcpp:"RemoteCall(*#, #, #, #, #, #)", constructor.}

proc remoteCall*[oT: oinvalid](scope: Scope,
                 target: ostring,
                 args: oT,
                 Tin: openArray[DType],
                 Tout: openArray[DType],
                 f: NameAttrList): RemoteCall[oT] =
  return iiremoteCall(scope,
                      target,
                      args,
                      newArraySlice(Tin),
                      newArraySlice(Tout),
                      f)

converter remoteCallToOut*[oT: oinvalid](op: RemoteCall[oT]): oT = return op.output


type ExperimentalMapAndBatchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalMapAndBatchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalMapAndBatchDataset[oT: ovariant](scope: Scope,
                                     input_dataset: oT,
                                     other_arguments: oinvalid,
                                     batch_size: oint64,
                                     num_parallel_calls: oint64,
                                     drop_remainder: obool,
                                     f: NameAttrList,
                                     Targuments: ArraySlice[DType],
                                     output_types: ArraySlice[DType],
                                     output_shapes: ArraySlice[TensorShape],
                                     preserve_cardinality: bool): ExperimentalMapAndBatchDataset[oT] {.header:"generated.h", importcpp:"ExperimentalMapAndBatchDataset(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalMapAndBatchDataset*[oT: ovariant](scope: Scope,
                                     input_dataset: oT,
                                     other_arguments: oinvalid,
                                     batch_size: oint64,
                                     num_parallel_calls: oint64,
                                     drop_remainder: obool,
                                     f: NameAttrList,
                                     Targuments: openArray[DType],
                                     output_types: openArray[DType],
                                     output_shapes: openArray[TensorShape],
                                     preserve_cardinality: bool = false): ExperimentalMapAndBatchDataset[oT] =
  return iiexperimentalMapAndBatchDataset(scope,
                                          input_dataset,
                                          other_arguments,
                                          batch_size,
                                          num_parallel_calls,
                                          drop_remainder,
                                          f,
                                          newArraySlice(Targuments),
                                          newArraySlice(output_types),
                                          newArraySlice(output_shapes),
                                          preserve_cardinality)

converter experimentalMapAndBatchDatasetToOut*[oT: ovariant](op: ExperimentalMapAndBatchDataset[oT]): oT = return op.output


type SymbolicGradient*[oT:oinvalid] {.header:"generated.h", importcpp:"SymbolicGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisymbolicGradient[oT: oinvalid](scope: Scope,
                       input: oT,
                       Tin: ArraySlice[DType],
                       Tout: ArraySlice[DType],
                       f: NameAttrList): SymbolicGradient[oT] {.header:"generated.h", importcpp:"SymbolicGradient(*#, #, #, #, #)", constructor.}

proc symbolicGradient*[oT: oinvalid](scope: Scope,
                       input: oT,
                       Tin: openArray[DType],
                       Tout: openArray[DType],
                       f: NameAttrList): SymbolicGradient[oT] =
  return iisymbolicGradient(scope,
                            input,
                            newArraySlice(Tin),
                            newArraySlice(Tout),
                            f)

converter symbolicGradientToOut*[oT: oinvalid](op: SymbolicGradient[oT]): oT = return op.output

type IArrayToListT = oall

type IArrayToList*[oT:oinvalid] {.header:"generated.h", importcpp:"_ArrayToList/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiArrayToList[oT: oinvalid](scope: Scope,
                   input: IArrayToListT,
                   out_types: ArraySlice[DType]): IArrayToList[oT] {.header:"generated.h", importcpp:"_ArrayToList(*#, #, #)", constructor.}

proc iArrayToList*[oT: oinvalid](scope: Scope,
                   input: IArrayToListT,
                   out_types: openArray[DType]): IArrayToList[oT] =
  return iiiArrayToList(scope,
                        input,
                        newArraySlice(out_types))

converter iArrayToListToOut*[oT: oinvalid](op: IArrayToList[oT]): oT = return op.output

type IListToArrayT = oall

type IListToArray*[oT:IListToArrayT] {.header:"generated.h", importcpp:"_ListToArray/*'0*/".} = object
  operation: Operation[oT]
  output: olist[oT]

proc iiiListToArray[oT: IListToArrayT](scope: Scope,
                   input: oinvalid,
                   Tin: ArraySlice[DType]): IListToArray[oT] {.header:"generated.h", importcpp:"_ListToArray(*#, #, #)", constructor.}

proc iListToArray*[oT: IListToArrayT](scope: Scope,
                   input: oinvalid,
                   Tin: openArray[DType]): IListToArray[oT] =
  return iiiListToArray(scope,
                        input,
                        newArraySlice(Tin))

converter iListToArrayToOutList*[oT: IListToArrayT](op: IListToArray[oT]): olist[oT] = return op.output

type IArgT = oall

type IArg*[oT:IArgT] {.header:"generated.h", importcpp:"_Arg/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiArg[oT: IArgT](scope: Scope,
           index: int64): IArg[oT] {.header:"generated.h", importcpp:"_Arg(*#, #)", constructor.}

proc iArg*[oT: IArgT](scope: Scope,
           index: int64 = 0): IArg[oT] =
  return iiiArg(scope,
                index)

converter iArgToOut*[oT: IArgT](op: IArg[oT]): oT = return op.output


type ReaderRead*[oT:ostring] {.header:"generated.h", importcpp:"ReaderRead/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderRead[oT: ostring](scope: Scope,
                 reader_handle: oT,
                 queue_handle: oT): ReaderRead[oT] {.header:"generated.h", importcpp:"ReaderRead(*#, #, #)", constructor.}

proc readerRead*[oT: ostring](scope: Scope,
                 reader_handle: oT,
                 queue_handle: oT): ReaderRead[oT] =
  return iireaderRead(scope,
                      reader_handle,
                      queue_handle)

converter readerReadToOut*[oT: ostring](op: ReaderRead[oT]): oT = return op.output

type MirrorPadT = oall
type MirrorPadTpaddings = oint32 | oint64

type MirrorPad*[oT:MirrorPadT] {.header:"generated.h", importcpp:"MirrorPad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimirrorPad[oT: MirrorPadT](scope: Scope,
                input: oT,
                paddings: MirrorPadTpaddings,
                mode: cstring): MirrorPad[oT] {.header:"generated.h", importcpp:"MirrorPad(*#, #, #, tensorflow::string(#))", constructor.}

proc mirrorPad*[oT: MirrorPadT](scope: Scope,
                input: oT,
                paddings: MirrorPadTpaddings,
                mode: cstring): MirrorPad[oT] =
  return iimirrorPad(scope,
                     input,
                     paddings,
                     mode)

converter mirrorPadToOut*[oT: MirrorPadT](op: MirrorPad[oT]): oT = return op.output


type TensorArrayV3*[oT:oresource] {.header:"generated.h", importcpp:"TensorArrayV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayV3[oT: oresource](scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: DType,
                    element_shape: TensorShape,
                    dynamic_size: bool,
                    clear_after_read: bool,
                    identical_element_shapes: bool): TensorArrayV3[oT] {.header:"generated.h", importcpp:"TensorArrayV3(*#, #, tensorflow::string(#), #, #, #, #, #)", constructor.}

proc tensorArrayV3*[oT: oresource](scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: DType = oT[].oTF,
                    element_shape: TensorShape = [].shape,
                    dynamic_size: bool = false,
                    clear_after_read: bool = true,
                    identical_element_shapes: bool = false): TensorArrayV3[oT] =
  return iitensorArrayV3(scope,
                         size,
                         tensor_array_name,
                         dtype,
                         element_shape,
                         dynamic_size,
                         clear_after_read,
                         identical_element_shapes)

converter tensorArrayV3ToOut*[oT: oresource](op: TensorArrayV3[oT]): oT = return op.output

type MatrixSolveLsT = odouble | ofloat | ocomplex64 | ocomplex128

type MatrixSolveLs*[oT:MatrixSolveLsT] {.header:"generated.h", importcpp:"MatrixSolveLs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixSolveLs[oT: MatrixSolveLsT](scope: Scope,
                    matrix: oT,
                    rhs: oT,
                    l2_regularizer: odouble,
                    fast: bool): MatrixSolveLs[oT] {.header:"generated.h", importcpp:"MatrixSolveLs(*#, #, #, #, #)", constructor.}

proc matrixSolveLs*[oT: MatrixSolveLsT](scope: Scope,
                    matrix: oT,
                    rhs: oT,
                    l2_regularizer: odouble,
                    fast: bool = true): MatrixSolveLs[oT] =
  return iimatrixSolveLs(scope,
                         matrix,
                         rhs,
                         l2_regularizer,
                         fast)

converter matrixSolveLsToOut*[oT: MatrixSolveLsT](op: MatrixSolveLs[oT]): oT = return op.output


type ExperimentalIdentityIndexedDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalIdentityIndexedDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalIdentityIndexedDataset[oT: ovariant](scope: Scope,
                                         size: ouint64): ExperimentalIdentityIndexedDataset[oT] {.header:"generated.h", importcpp:"ExperimentalIdentityIndexedDataset(*#, #)", constructor.}

proc experimentalIdentityIndexedDataset*[oT: ovariant](scope: Scope,
                                         size: ouint64): ExperimentalIdentityIndexedDataset[oT] =
  return iiexperimentalIdentityIndexedDataset(scope,
                                              size)

converter experimentalIdentityIndexedDatasetToOut*[oT: ovariant](op: ExperimentalIdentityIndexedDataset[oT]): oT = return op.output

type SinhT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Sinh*[oT:SinhT] {.header:"generated.h", importcpp:"Sinh/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisinh[oT: SinhT](scope: Scope,
           x: oT): Sinh[oT] {.header:"generated.h", importcpp:"Sinh(*#, #)", constructor.}

proc sinh*[oT: SinhT](scope: Scope,
           x: oT): Sinh[oT] =
  return iisinh(scope,
                x)

converter sinhToOut*[oT: SinhT](op: Sinh[oT]): oT = return op.output


type ExperimentalAssertNextDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalAssertNextDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalAssertNextDataset[oT: ovariant](scope: Scope,
                                    input_dataset: oT,
                                    transformations: ostring,
                                    output_types: ArraySlice[DType],
                                    output_shapes: ArraySlice[TensorShape]): ExperimentalAssertNextDataset[oT] {.header:"generated.h", importcpp:"ExperimentalAssertNextDataset(*#, #, #, #, #)", constructor.}

proc experimentalAssertNextDataset*[oT: ovariant](scope: Scope,
                                    input_dataset: oT,
                                    transformations: ostring,
                                    output_types: openArray[DType],
                                    output_shapes: openArray[TensorShape]): ExperimentalAssertNextDataset[oT] =
  return iiexperimentalAssertNextDataset(scope,
                                         input_dataset,
                                         transformations,
                                         newArraySlice(output_types),
                                         newArraySlice(output_shapes))

converter experimentalAssertNextDatasetToOut*[oT: ovariant](op: ExperimentalAssertNextDataset[oT]): oT = return op.output

type SparseReduceSumSparseT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseReduceSumSparse*[oT:oint64] {.header:"generated.h", importcpp:"SparseReduceSumSparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseReduceSumSparse[oT: oint64](scope: Scope,
                            input_indices: oT,
                            input_values: SparseReduceSumSparseT,
                            input_shape: oT,
                            reduction_axes: oint32,
                            keep_dims: bool): SparseReduceSumSparse[oT] {.header:"generated.h", importcpp:"SparseReduceSumSparse(*#, #, #, #, #, #)", constructor.}

proc sparseReduceSumSparse*[oT: oint64](scope: Scope,
                            input_indices: oT,
                            input_values: SparseReduceSumSparseT,
                            input_shape: oT,
                            reduction_axes: oint32,
                            keep_dims: bool = false): SparseReduceSumSparse[oT] =
  return iisparseReduceSumSparse(scope,
                                 input_indices,
                                 input_values,
                                 input_shape,
                                 reduction_axes,
                                 keep_dims)

converter sparseReduceSumSparseToOut*[oT: oint64](op: SparseReduceSumSparse[oT]): oT = return op.output

type ReluT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64 | oqint8

type Relu*[oT:ReluT] {.header:"generated.h", importcpp:"Relu/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirelu[oT: ReluT](scope: Scope,
           features: oT): Relu[oT] {.header:"generated.h", importcpp:"Relu(*#, #)", constructor.}

proc relu*[oT: ReluT](scope: Scope,
           features: oT): Relu[oT] =
  return iirelu(scope,
                features)

converter reluToOut*[oT: ReluT](op: Relu[oT]): oT = return op.output

type MatMulT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type MatMul*[oT:MatMulT] {.header:"generated.h", importcpp:"MatMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatMul[oT: MatMulT](scope: Scope,
             a: oT,
             b: oT,
             transpose_a: bool,
             transpose_b: bool): MatMul[oT] {.header:"generated.h", importcpp:"MatMul(*#, #, #, #, #)", constructor.}

proc matMul*[oT: MatMulT](scope: Scope,
             a: oT,
             b: oT,
             transpose_a: bool = false,
             transpose_b: bool = false): MatMul[oT] =
  return iimatMul(scope,
                  a,
                  b,
                  transpose_a,
                  transpose_b)

converter matMulToOut*[oT: MatMulT](op: MatMul[oT]): oT = return op.output


type ExperimentalThreadPoolDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalThreadPoolDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalThreadPoolDataset[oT: ovariant](scope: Scope,
                                    input_dataset: oT,
                                    thread_pool: oresource,
                                    output_types: ArraySlice[DType],
                                    output_shapes: ArraySlice[TensorShape]): ExperimentalThreadPoolDataset[oT] {.header:"generated.h", importcpp:"ExperimentalThreadPoolDataset(*#, #, #, #, #)", constructor.}

proc experimentalThreadPoolDataset*[oT: ovariant](scope: Scope,
                                    input_dataset: oT,
                                    thread_pool: oresource,
                                    output_types: openArray[DType],
                                    output_shapes: openArray[TensorShape]): ExperimentalThreadPoolDataset[oT] =
  return iiexperimentalThreadPoolDataset(scope,
                                         input_dataset,
                                         thread_pool,
                                         newArraySlice(output_types),
                                         newArraySlice(output_shapes))

converter experimentalThreadPoolDatasetToOut*[oT: ovariant](op: ExperimentalThreadPoolDataset[oT]): oT = return op.output

type SoftplusGradT = ohalf | obfloat16 | ofloat | odouble

type SoftplusGrad*[oT:SoftplusGradT] {.header:"generated.h", importcpp:"SoftplusGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisoftplusGrad[oT: SoftplusGradT](scope: Scope,
                   gradients: oT,
                   features: oT): SoftplusGrad[oT] {.header:"generated.h", importcpp:"SoftplusGrad(*#, #, #)", constructor.}

proc softplusGrad*[oT: SoftplusGradT](scope: Scope,
                   gradients: oT,
                   features: oT): SoftplusGrad[oT] =
  return iisoftplusGrad(scope,
                        gradients,
                        features)

converter softplusGradToOut*[oT: SoftplusGradT](op: SoftplusGrad[oT]): oT = return op.output


type ExperimentalIndexedDatasetMaterialize*{.header:"generated.h", importcpp:"ExperimentalIndexedDatasetMaterialize/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiexperimentalIndexedDatasetMaterialize(scope: Scope,
                                            dataset: ovariant,
                                            materialized: oresource): ExperimentalIndexedDatasetMaterialize {.header:"generated.h", importcpp:"ExperimentalIndexedDatasetMaterialize(*#, #, #)", constructor.}

proc experimentalIndexedDatasetMaterialize*(scope: Scope,
                                            dataset: ovariant,
                                            materialized: oresource): ExperimentalIndexedDatasetMaterialize =
  return iiexperimentalIndexedDatasetMaterialize(scope,
                                                 dataset,
                                                 materialized)



type QuantizeAndDequantizeV3T = obfloat16 | ohalf | ofloat | odouble

type QuantizeAndDequantizeV3*[oT:QuantizeAndDequantizeV3T] {.header:"generated.h", importcpp:"QuantizeAndDequantizeV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizeAndDequantizeV3[oT: QuantizeAndDequantizeV3T](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              num_bits: oint32,
                              signed_input: bool,
                              range_given: bool): QuantizeAndDequantizeV3[oT] {.header:"generated.h", importcpp:"QuantizeAndDequantizeV3(*#, #, #, #, #, #, #)", constructor.}

proc quantizeAndDequantizeV3*[oT: QuantizeAndDequantizeV3T](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              num_bits: oint32,
                              signed_input: bool = true,
                              range_given: bool = true): QuantizeAndDequantizeV3[oT] =
  return iiquantizeAndDequantizeV3(scope,
                                   input,
                                   input_min,
                                   input_max,
                                   num_bits,
                                   signed_input,
                                   range_given)

converter quantizeAndDequantizeV3ToOut*[oT: QuantizeAndDequantizeV3T](op: QuantizeAndDequantizeV3[oT]): oT = return op.output

type MulT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type Mul*[oT:MulT] {.header:"generated.h", importcpp:"Mul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimul[oT: MulT](scope: Scope,
          x: oT,
          y: oT): Mul[oT] {.header:"generated.h", importcpp:"Mul(*#, #, #)", constructor.}

proc mul*[oT: MulT](scope: Scope,
          x: oT,
          y: oT): Mul[oT] =
  return iimul(scope,
               x,
               y)

converter mulToOut*[oT: MulT](op: Mul[oT]): oT = return op.output

type BatchToSpaceT = oall
type BatchToSpaceTidx = oint32 | oint64

type BatchToSpace*[oT:BatchToSpaceT] {.header:"generated.h", importcpp:"BatchToSpace/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchToSpace[oT: BatchToSpaceT](scope: Scope,
                   input: oT,
                   crops: BatchToSpaceTidx,
                   block_size: int64): BatchToSpace[oT] {.header:"generated.h", importcpp:"BatchToSpace(*#, #, #, #)", constructor.}

proc batchToSpace*[oT: BatchToSpaceT](scope: Scope,
                   input: oT,
                   crops: BatchToSpaceTidx,
                   block_size: int64 = 0): BatchToSpace[oT] =
  return iibatchToSpace(scope,
                        input,
                        crops,
                        block_size)

converter batchToSpaceToOut*[oT: BatchToSpaceT](op: BatchToSpace[oT]): oT = return op.output


type ExperimentalPrivateThreadPoolDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalPrivateThreadPoolDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalPrivateThreadPoolDataset[oT: ovariant](scope: Scope,
                                           input_dataset: oT,
                                           num_threads: oint64,
                                           output_types: ArraySlice[DType],
                                           output_shapes: ArraySlice[TensorShape]): ExperimentalPrivateThreadPoolDataset[oT] {.header:"generated.h", importcpp:"ExperimentalPrivateThreadPoolDataset(*#, #, #, #, #)", constructor.}

proc experimentalPrivateThreadPoolDataset*[oT: ovariant](scope: Scope,
                                           input_dataset: oT,
                                           num_threads: oint64,
                                           output_types: openArray[DType],
                                           output_shapes: openArray[TensorShape]): ExperimentalPrivateThreadPoolDataset[oT] =
  return iiexperimentalPrivateThreadPoolDataset(scope,
                                                input_dataset,
                                                num_threads,
                                                newArraySlice(output_types),
                                                newArraySlice(output_shapes))

converter experimentalPrivateThreadPoolDatasetToOut*[oT: ovariant](op: ExperimentalPrivateThreadPoolDataset[oT]): oT = return op.output

type AddSparseToTensorsMapT = oall

type AddSparseToTensorsMap*[oT:oint64] {.header:"generated.h", importcpp:"AddSparseToTensorsMap/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaddSparseToTensorsMap[oT: oint64](scope: Scope,
                            sparse_indices: oT,
                            sparse_values: AddSparseToTensorsMapT,
                            sparse_shape: oT,
                            container: cstring,
                            shared_name: cstring): AddSparseToTensorsMap[oT] {.header:"generated.h", importcpp:"AddSparseToTensorsMap(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc addSparseToTensorsMap*[oT: oint64](scope: Scope,
                            sparse_indices: oT,
                            sparse_values: AddSparseToTensorsMapT,
                            sparse_shape: oT,
                            container: cstring,
                            shared_name: cstring): AddSparseToTensorsMap[oT] =
  return iiaddSparseToTensorsMap(scope,
                                 sparse_indices,
                                 sparse_values,
                                 sparse_shape,
                                 container,
                                 shared_name)

converter addSparseToTensorsMapToOut*[oT: oint64](op: AddSparseToTensorsMap[oT]): oT = return op.output

type EluT = ohalf | obfloat16 | ofloat | odouble

type Elu*[oT:EluT] {.header:"generated.h", importcpp:"Elu/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iielu[oT: EluT](scope: Scope,
          features: oT): Elu[oT] {.header:"generated.h", importcpp:"Elu(*#, #)", constructor.}

proc elu*[oT: EluT](scope: Scope,
          features: oT): Elu[oT] =
  return iielu(scope,
               features)

converter eluToOut*[oT: EluT](op: Elu[oT]): oT = return op.output


type ExperimentalBytesProducedStatsDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalBytesProducedStatsDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalBytesProducedStatsDataset[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            tag: ostring,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalBytesProducedStatsDataset[oT] {.header:"generated.h", importcpp:"ExperimentalBytesProducedStatsDataset(*#, #, #, #, #)", constructor.}

proc experimentalBytesProducedStatsDataset*[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            tag: ostring,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalBytesProducedStatsDataset[oT] =
  return iiexperimentalBytesProducedStatsDataset(scope,
                                                 input_dataset,
                                                 tag,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalBytesProducedStatsDatasetToOut*[oT: ovariant](op: ExperimentalBytesProducedStatsDataset[oT]): oT = return op.output


type ExperimentalIteratorGetDevice*[oT:ostring] {.header:"generated.h", importcpp:"ExperimentalIteratorGetDevice/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalIteratorGetDevice[oT: ostring](scope: Scope,
                                    resource: oresource): ExperimentalIteratorGetDevice[oT] {.header:"generated.h", importcpp:"ExperimentalIteratorGetDevice(*#, #)", constructor.}

proc experimentalIteratorGetDevice*[oT: ostring](scope: Scope,
                                    resource: oresource): ExperimentalIteratorGetDevice[oT] =
  return iiexperimentalIteratorGetDevice(scope,
                                         resource)

converter experimentalIteratorGetDeviceToOut*[oT: ostring](op: ExperimentalIteratorGetDevice[oT]): oT = return op.output


type StringFormat*[oT:ostring] {.header:"generated.h", importcpp:"StringFormat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringFormat[oT: ostring](scope: Scope,
                   inputs: oinvalid,
                   T: ArraySlice[DType],
                   ntemplate: cstring,
                   placeholder: cstring,
                   summarize: int64): StringFormat[oT] {.header:"generated.h", importcpp:"StringFormat(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc stringFormat*[oT: ostring](scope: Scope,
                   inputs: oinvalid,
                   T: openArray[DType],
                   ntemplate: cstring = "%s",
                   placeholder: cstring = "%s",
                   summarize: int64 = 3): StringFormat[oT] =
  return iistringFormat(scope,
                        inputs,
                        newArraySlice(T),
                        ntemplate,
                        placeholder,
                        summarize)

converter stringFormatToOut*[oT: ostring](op: StringFormat[oT]): oT = return op.output


type ExperimentalUniqueDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalUniqueDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalUniqueDataset[oT: ovariant](scope: Scope,
                                input_dataset: oT,
                                output_types: ArraySlice[DType],
                                output_shapes: ArraySlice[TensorShape]): ExperimentalUniqueDataset[oT] {.header:"generated.h", importcpp:"ExperimentalUniqueDataset(*#, #, #, #)", constructor.}

proc experimentalUniqueDataset*[oT: ovariant](scope: Scope,
                                input_dataset: oT,
                                output_types: openArray[DType],
                                output_shapes: openArray[TensorShape]): ExperimentalUniqueDataset[oT] =
  return iiexperimentalUniqueDataset(scope,
                                     input_dataset,
                                     newArraySlice(output_types),
                                     newArraySlice(output_shapes))

converter experimentalUniqueDatasetToOut*[oT: ovariant](op: ExperimentalUniqueDataset[oT]): oT = return op.output


type ExperimentalUnbatchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalUnbatchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalUnbatchDataset[oT: ovariant](scope: Scope,
                                 input_dataset: oT,
                                 output_types: ArraySlice[DType],
                                 output_shapes: ArraySlice[TensorShape]): ExperimentalUnbatchDataset[oT] {.header:"generated.h", importcpp:"ExperimentalUnbatchDataset(*#, #, #, #)", constructor.}

proc experimentalUnbatchDataset*[oT: ovariant](scope: Scope,
                                 input_dataset: oT,
                                 output_types: openArray[DType],
                                 output_shapes: openArray[TensorShape]): ExperimentalUnbatchDataset[oT] =
  return iiexperimentalUnbatchDataset(scope,
                                      input_dataset,
                                      newArraySlice(output_types),
                                      newArraySlice(output_shapes))

converter experimentalUnbatchDatasetToOut*[oT: ovariant](op: ExperimentalUnbatchDataset[oT]): oT = return op.output

type TensorArrayPackdtype = oall

type TensorArrayPack*[oT:TensorArrayPackdtype] {.header:"generated.h", importcpp:"TensorArrayPack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayPack[oT: TensorArrayPackdtype](scope: Scope,
                      handle: ostring,
                      flow_in: ofloat,
                      dtype: DType,
                      element_shape: TensorShape): TensorArrayPack[oT] {.header:"generated.h", importcpp:"TensorArrayPack(*#, #, #, #, #)", constructor.}

proc tensorArrayPack*[oT: TensorArrayPackdtype](scope: Scope,
                      handle: ostring,
                      flow_in: ofloat,
                      dtype: DType = oT[].oTF,
                      element_shape: TensorShape = [].shape): TensorArrayPack[oT] =
  return iitensorArrayPack(scope,
                           handle,
                           flow_in,
                           dtype,
                           element_shape)

converter tensorArrayPackToOut*[oT: TensorArrayPackdtype](op: TensorArrayPack[oT]): oT = return op.output


type ExperimentalStatsAggregatorHandle*[oT:oresource] {.header:"generated.h", importcpp:"ExperimentalStatsAggregatorHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalStatsAggregatorHandle[oT: oresource](scope: Scope,
                                        container: cstring,
                                        shared_name: cstring): ExperimentalStatsAggregatorHandle[oT] {.header:"generated.h", importcpp:"ExperimentalStatsAggregatorHandle(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc experimentalStatsAggregatorHandle*[oT: oresource](scope: Scope,
                                        container: cstring,
                                        shared_name: cstring): ExperimentalStatsAggregatorHandle[oT] =
  return iiexperimentalStatsAggregatorHandle(scope,
                                             container,
                                             shared_name)

converter experimentalStatsAggregatorHandleToOut*[oT: oresource](op: ExperimentalStatsAggregatorHandle[oT]): oT = return op.output


type LookupTableSizeV2*[oT:oint64] {.header:"generated.h", importcpp:"LookupTableSizeV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilookupTableSizeV2[oT: oint64](scope: Scope,
                        table_handle: oresource): LookupTableSizeV2[oT] {.header:"generated.h", importcpp:"LookupTableSizeV2(*#, #)", constructor.}

proc lookupTableSizeV2*[oT: oint64](scope: Scope,
                        table_handle: oresource): LookupTableSizeV2[oT] =
  return iilookupTableSizeV2(scope,
                             table_handle)

converter lookupTableSizeV2ToOut*[oT: oint64](op: LookupTableSizeV2[oT]): oT = return op.output


type ExperimentalSqlDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalSqlDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalSqlDataset[oT: ovariant](scope: Scope,
                             driver_name: ostring,
                             data_source_name: ostring,
                             query: ostring,
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape]): ExperimentalSqlDataset[oT] {.header:"generated.h", importcpp:"ExperimentalSqlDataset(*#, #, #, #, #, #)", constructor.}

proc experimentalSqlDataset*[oT: ovariant](scope: Scope,
                             driver_name: ostring,
                             data_source_name: ostring,
                             query: ostring,
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape]): ExperimentalSqlDataset[oT] =
  return iiexperimentalSqlDataset(scope,
                                  driver_name,
                                  data_source_name,
                                  query,
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes))

converter experimentalSqlDatasetToOut*[oT: ovariant](op: ExperimentalSqlDataset[oT]): oT = return op.output

type TensorArrayUnpackT = oall

type TensorArrayUnpack*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayUnpack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayUnpack[oT: ofloat](scope: Scope,
                        handle: ostring,
                        value: TensorArrayUnpackT,
                        flow_in: oT): TensorArrayUnpack[oT] {.header:"generated.h", importcpp:"TensorArrayUnpack(*#, #, #, #)", constructor.}

proc tensorArrayUnpack*[oT: ofloat](scope: Scope,
                        handle: ostring,
                        value: TensorArrayUnpackT,
                        flow_in: oT): TensorArrayUnpack[oT] =
  return iitensorArrayUnpack(scope,
                             handle,
                             value,
                             flow_in)

converter tensorArrayUnpackToOut*[oT: ofloat](op: TensorArrayUnpack[oT]): oT = return op.output


type ExperimentalSetStatsAggregatorDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalSetStatsAggregatorDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalSetStatsAggregatorDataset[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            stats_aggregator: oresource,
                                            tag: ostring,
                                            counter_prefix: ostring,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalSetStatsAggregatorDataset[oT] {.header:"generated.h", importcpp:"ExperimentalSetStatsAggregatorDataset(*#, #, #, #, #, #, #)", constructor.}

proc experimentalSetStatsAggregatorDataset*[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            stats_aggregator: oresource,
                                            tag: ostring,
                                            counter_prefix: ostring,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalSetStatsAggregatorDataset[oT] =
  return iiexperimentalSetStatsAggregatorDataset(scope,
                                                 input_dataset,
                                                 stats_aggregator,
                                                 tag,
                                                 counter_prefix,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalSetStatsAggregatorDatasetToOut*[oT: ovariant](op: ExperimentalSetStatsAggregatorDataset[oT]): oT = return op.output

type IFFT3DTcomplex = ocomplex64 | ocomplex128

type IFFT3D*[oT:IFFT3DTcomplex] {.header:"generated.h", importcpp:"IFFT3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiFFT3D[oT: IFFT3DTcomplex](scope: Scope,
             input: oT): IFFT3D[oT] {.header:"generated.h", importcpp:"IFFT3D(*#, #)", constructor.}

proc iFFT3D*[oT: IFFT3DTcomplex](scope: Scope,
             input: oT): IFFT3D[oT] =
  return iiiFFT3D(scope,
                  input)

converter iFFT3DToOut*[oT: IFFT3DTcomplex](op: IFFT3D[oT]): oT = return op.output

type IUnaryOpsCompositionT = ofloat | ohalf | odouble

type IUnaryOpsComposition*[oT:IUnaryOpsCompositionT] {.header:"generated.h", importcpp:"_UnaryOpsComposition/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiUnaryOpsComposition[oT: IUnaryOpsCompositionT](scope: Scope,
                           x: oT,
                           op_names: ArraySlice[cstring]): IUnaryOpsComposition[oT] {.header:"generated.h", importcpp:"_UnaryOpsComposition(*#, #, #)", constructor.}

proc iUnaryOpsComposition*[oT: IUnaryOpsCompositionT](scope: Scope,
                           x: oT,
                           op_names: openArray[cstring]): IUnaryOpsComposition[oT] =
  return iiiUnaryOpsComposition(scope,
                                x,
                                newArraySlice(op_names))

converter iUnaryOpsCompositionToOut*[oT: IUnaryOpsCompositionT](op: IUnaryOpsComposition[oT]): oT = return op.output

type BatchMatrixDeterminantT = ofloat | odouble | ocomplex64 | ocomplex128

type BatchMatrixDeterminant*[oT:BatchMatrixDeterminantT] {.header:"generated.h", importcpp:"BatchMatrixDeterminant/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixDeterminant[oT: BatchMatrixDeterminantT](scope: Scope,
                             input: oT): BatchMatrixDeterminant[oT] {.header:"generated.h", importcpp:"BatchMatrixDeterminant(*#, #)", constructor.}

proc batchMatrixDeterminant*[oT: BatchMatrixDeterminantT](scope: Scope,
                             input: oT): BatchMatrixDeterminant[oT] =
  return iibatchMatrixDeterminant(scope,
                                  input)

converter batchMatrixDeterminantToOut*[oT: BatchMatrixDeterminantT](op: BatchMatrixDeterminant[oT]): oT = return op.output


type ExperimentalIgnoreErrorsDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalIgnoreErrorsDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalIgnoreErrorsDataset[oT: ovariant](scope: Scope,
                                      input_dataset: oT,
                                      output_types: ArraySlice[DType],
                                      output_shapes: ArraySlice[TensorShape]): ExperimentalIgnoreErrorsDataset[oT] {.header:"generated.h", importcpp:"ExperimentalIgnoreErrorsDataset(*#, #, #, #)", constructor.}

proc experimentalIgnoreErrorsDataset*[oT: ovariant](scope: Scope,
                                      input_dataset: oT,
                                      output_types: openArray[DType],
                                      output_shapes: openArray[TensorShape]): ExperimentalIgnoreErrorsDataset[oT] =
  return iiexperimentalIgnoreErrorsDataset(scope,
                                           input_dataset,
                                           newArraySlice(output_types),
                                           newArraySlice(output_shapes))

converter experimentalIgnoreErrorsDatasetToOut*[oT: ovariant](op: ExperimentalIgnoreErrorsDataset[oT]): oT = return op.output


type ExperimentalRandomDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalRandomDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalRandomDataset[oT: ovariant](scope: Scope,
                                seed: oint64,
                                seed2: oint64,
                                output_types: ArraySlice[DType],
                                output_shapes: ArraySlice[TensorShape]): ExperimentalRandomDataset[oT] {.header:"generated.h", importcpp:"ExperimentalRandomDataset(*#, #, #, #, #)", constructor.}

proc experimentalRandomDataset*[oT: ovariant](scope: Scope,
                                seed: oint64,
                                seed2: oint64,
                                output_types: openArray[DType],
                                output_shapes: openArray[TensorShape]): ExperimentalRandomDataset[oT] =
  return iiexperimentalRandomDataset(scope,
                                     seed,
                                     seed2,
                                     newArraySlice(output_types),
                                     newArraySlice(output_shapes))

converter experimentalRandomDatasetToOut*[oT: ovariant](op: ExperimentalRandomDataset[oT]): oT = return op.output


type PriorityQueue*[oT:ostring] {.header:"generated.h", importcpp:"PriorityQueue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipriorityQueue[oT: ostring](scope: Scope,
                    component_types: ArraySlice[DType],
                    shapes: ArraySlice[TensorShape],
                    container: cstring,
                    shared_name: cstring,
                    capacity: int64): PriorityQueue[oT] {.header:"generated.h", importcpp:"PriorityQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc priorityQueue*[oT: ostring](scope: Scope,
                    component_types: openArray[DType],
                    shapes: openArray[TensorShape],
                    container: cstring,
                    shared_name: cstring,
                    capacity: int64 = -1): PriorityQueue[oT] =
  return iipriorityQueue(scope,
                         newArraySlice(component_types),
                         newArraySlice(shapes),
                         container,
                         shared_name,
                         capacity)

converter priorityQueueToOut*[oT: ostring](op: PriorityQueue[oT]): oT = return op.output


type For*[oT:oinvalid] {.header:"generated.h", importcpp:"For/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinfor[oT: oinvalid](scope: Scope,
           start: oint32,
           limit: oint32,
           delta: oint32,
           input: oT,
           T: ArraySlice[DType],
           body: NameAttrList): For[oT] {.header:"generated.h", importcpp:"For(*#, #, #, #, #, #, #)", constructor.}

proc nfor*[oT: oinvalid](scope: Scope,
           start: oint32,
           limit: oint32,
           delta: oint32,
           input: oT,
           T: openArray[DType],
           body: NameAttrList): For[oT] =
  return iinfor(scope,
                start,
                limit,
                delta,
                input,
                newArraySlice(T),
                body)

converter nforToOut*[oT: oinvalid](op: For[oT]): oT = return op.output


type ExperimentalParallelInterleaveDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalParallelInterleaveDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalParallelInterleaveDataset[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            other_arguments: oinvalid,
                                            cycle_length: oint64,
                                            block_length: oint64,
                                            sloppy: obool,
                                            buffer_output_elements: oint64,
                                            prefetch_input_elements: oint64,
                                            f: NameAttrList,
                                            Targuments: ArraySlice[DType],
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalParallelInterleaveDataset[oT] {.header:"generated.h", importcpp:"ExperimentalParallelInterleaveDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalParallelInterleaveDataset*[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            other_arguments: oinvalid,
                                            cycle_length: oint64,
                                            block_length: oint64,
                                            sloppy: obool,
                                            buffer_output_elements: oint64,
                                            prefetch_input_elements: oint64,
                                            f: NameAttrList,
                                            Targuments: openArray[DType],
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalParallelInterleaveDataset[oT] =
  return iiexperimentalParallelInterleaveDataset(scope,
                                                 input_dataset,
                                                 other_arguments,
                                                 cycle_length,
                                                 block_length,
                                                 sloppy,
                                                 buffer_output_elements,
                                                 prefetch_input_elements,
                                                 f,
                                                 newArraySlice(Targuments),
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalParallelInterleaveDatasetToOut*[oT: ovariant](op: ExperimentalParallelInterleaveDataset[oT]): oT = return op.output


type Skipgram*[oT:ostring] {.header:"generated.h", importcpp:"Skipgram/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiskipgram[oT: ostring](scope: Scope,
               filename: cstring,
               batch_size: int64,
               window_size: int64,
               min_count: int64,
               subsample: float32): Skipgram[oT] {.header:"generated.h", importcpp:"Skipgram(*#, tensorflow::string(#), #, #, #, #)", constructor.}

proc skipgram*[oT: ostring](scope: Scope,
               filename: cstring,
               batch_size: int64 = 0,
               window_size: int64 = 5,
               min_count: int64 = 5,
               subsample: float32 = 0.001000000047497451.float32): Skipgram[oT] =
  return iiskipgram(scope,
                    filename,
                    batch_size,
                    window_size,
                    min_count,
                    subsample)

converter skipgramToOut*[oT: ostring](op: Skipgram[oT]): oT = return op.output


type ExperimentalMatchingFilesDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalMatchingFilesDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalMatchingFilesDataset[oT: ovariant](scope: Scope,
                                       patterns: ostring): ExperimentalMatchingFilesDataset[oT] {.header:"generated.h", importcpp:"ExperimentalMatchingFilesDataset(*#, #)", constructor.}

proc experimentalMatchingFilesDataset*[oT: ovariant](scope: Scope,
                                       patterns: ostring): ExperimentalMatchingFilesDataset[oT] =
  return iiexperimentalMatchingFilesDataset(scope,
                                            patterns)

converter experimentalMatchingFilesDatasetToOut*[oT: ovariant](op: ExperimentalMatchingFilesDataset[oT]): oT = return op.output


type StageClear*{.header:"generated.h", importcpp:"StageClear/*'0*/".} = object
  operation: Operation[oinvalid]


proc iistageClear(scope: Scope,
                 dtypes: ArraySlice[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64,
                 memory_limit: int64): StageClear {.header:"generated.h", importcpp:"StageClear(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stageClear*(scope: Scope,
                 dtypes: openArray[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64 = 0,
                 memory_limit: int64 = 0): StageClear =
  return iistageClear(scope,
                      newArraySlice(dtypes),
                      container,
                      shared_name,
                      capacity,
                      memory_limit)




type ExperimentalMapDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalMapDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalMapDataset[oT: ovariant](scope: Scope,
                             input_dataset: oT,
                             other_arguments: oinvalid,
                             f: NameAttrList,
                             Targuments: ArraySlice[DType],
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape],
                             use_inter_op_parallelism: bool,
                             preserve_cardinality: bool): ExperimentalMapDataset[oT] {.header:"generated.h", importcpp:"ExperimentalMapDataset(*#, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalMapDataset*[oT: ovariant](scope: Scope,
                             input_dataset: oT,
                             other_arguments: oinvalid,
                             f: NameAttrList,
                             Targuments: openArray[DType],
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape],
                             use_inter_op_parallelism: bool = true,
                             preserve_cardinality: bool = false): ExperimentalMapDataset[oT] =
  return iiexperimentalMapDataset(scope,
                                  input_dataset,
                                  other_arguments,
                                  f,
                                  newArraySlice(Targuments),
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes),
                                  use_inter_op_parallelism,
                                  preserve_cardinality)

converter experimentalMapDatasetToOut*[oT: ovariant](op: ExperimentalMapDataset[oT]): oT = return op.output

type BiasAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type BiasAdd*[oT:BiasAddT] {.header:"generated.h", importcpp:"BiasAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibiasAdd[oT: BiasAddT](scope: Scope,
              value: oT,
              bias: oT,
              data_format: cstring): BiasAdd[oT] {.header:"generated.h", importcpp:"BiasAdd(*#, #, #, tensorflow::string(#))", constructor.}

proc biasAdd*[oT: BiasAddT](scope: Scope,
              value: oT,
              bias: oT,
              data_format: cstring = "NHWC"): BiasAdd[oT] =
  return iibiasAdd(scope,
                   value,
                   bias,
                   data_format)

converter biasAddToOut*[oT: BiasAddT](op: BiasAdd[oT]): oT = return op.output


type ExperimentalGroupByReducerDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalGroupByReducerDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalGroupByReducerDataset[oT: ovariant](scope: Scope,
                                        input_dataset: oT,
                                        key_func_other_arguments: oinvalid,
                                        init_func_other_arguments: oinvalid,
                                        reduce_func_other_arguments: oinvalid,
                                        finalize_func_other_arguments: oinvalid,
                                        key_func: NameAttrList,
                                        init_func: NameAttrList,
                                        reduce_func: NameAttrList,
                                        finalize_func: NameAttrList,
                                        Tkey_func_other_arguments: ArraySlice[DType],
                                        Tinit_func_other_arguments: ArraySlice[DType],
                                        Treduce_func_other_arguments: ArraySlice[DType],
                                        Tfinalize_func_other_arguments: ArraySlice[DType],
                                        output_types: ArraySlice[DType],
                                        output_shapes: ArraySlice[TensorShape]): ExperimentalGroupByReducerDataset[oT] {.header:"generated.h", importcpp:"ExperimentalGroupByReducerDataset(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalGroupByReducerDataset*[oT: ovariant](scope: Scope,
                                        input_dataset: oT,
                                        key_func_other_arguments: oinvalid,
                                        init_func_other_arguments: oinvalid,
                                        reduce_func_other_arguments: oinvalid,
                                        finalize_func_other_arguments: oinvalid,
                                        key_func: NameAttrList,
                                        init_func: NameAttrList,
                                        reduce_func: NameAttrList,
                                        finalize_func: NameAttrList,
                                        Tkey_func_other_arguments: openArray[DType],
                                        Tinit_func_other_arguments: openArray[DType],
                                        Treduce_func_other_arguments: openArray[DType],
                                        Tfinalize_func_other_arguments: openArray[DType],
                                        output_types: openArray[DType],
                                        output_shapes: openArray[TensorShape]): ExperimentalGroupByReducerDataset[oT] =
  return iiexperimentalGroupByReducerDataset(scope,
                                             input_dataset,
                                             key_func_other_arguments,
                                             init_func_other_arguments,
                                             reduce_func_other_arguments,
                                             finalize_func_other_arguments,
                                             key_func,
                                             init_func,
                                             reduce_func,
                                             finalize_func,
                                             newArraySlice(Tkey_func_other_arguments),
                                             newArraySlice(Tinit_func_other_arguments),
                                             newArraySlice(Treduce_func_other_arguments),
                                             newArraySlice(Tfinalize_func_other_arguments),
                                             newArraySlice(output_types),
                                             newArraySlice(output_shapes))

converter experimentalGroupByReducerDatasetToOut*[oT: ovariant](op: ExperimentalGroupByReducerDataset[oT]): oT = return op.output

type CropAndResizeGradBoxesT = ouint8 | ouint16 | oint8 | oint16 | oint32 | oint64 | ohalf | ofloat | odouble

type CropAndResizeGradBoxes*[oT:ofloat] {.header:"generated.h", importcpp:"CropAndResizeGradBoxes/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicropAndResizeGradBoxes[oT: ofloat](scope: Scope,
                             grads: oT,
                             image: CropAndResizeGradBoxesT,
                             boxes: oT,
                             box_ind: oint32,
                             nmethod: cstring): CropAndResizeGradBoxes[oT] {.header:"generated.h", importcpp:"CropAndResizeGradBoxes(*#, #, #, #, #, tensorflow::string(#))", constructor.}

proc cropAndResizeGradBoxes*[oT: ofloat](scope: Scope,
                             grads: oT,
                             image: CropAndResizeGradBoxesT,
                             boxes: oT,
                             box_ind: oint32,
                             nmethod: cstring = "bilinear"): CropAndResizeGradBoxes[oT] =
  return iicropAndResizeGradBoxes(scope,
                                  grads,
                                  image,
                                  boxes,
                                  box_ind,
                                  nmethod)

converter cropAndResizeGradBoxesToOut*[oT: ofloat](op: CropAndResizeGradBoxes[oT]): oT = return op.output


type FIFOQueueV2*[oT:oresource] {.header:"generated.h", importcpp:"FIFOQueueV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifIFOQueueV2[oT: oresource](scope: Scope,
                  component_types: ArraySlice[DType],
                  shapes: ArraySlice[TensorShape],
                  container: cstring,
                  shared_name: cstring,
                  capacity: int64): FIFOQueueV2[oT] {.header:"generated.h", importcpp:"FIFOQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc fIFOQueueV2*[oT: oresource](scope: Scope,
                  component_types: openArray[DType],
                  shapes: openArray[TensorShape],
                  container: cstring,
                  shared_name: cstring,
                  capacity: int64 = -1): FIFOQueueV2[oT] =
  return iifIFOQueueV2(scope,
                       newArraySlice(component_types),
                       newArraySlice(shapes),
                       container,
                       shared_name,
                       capacity)

converter fIFOQueueV2ToOut*[oT: oresource](op: FIFOQueueV2[oT]): oT = return op.output

type BatchToSpaceNDT = oall
type BatchToSpaceNDTblock_shape = oint32 | oint64
type BatchToSpaceNDTcrops = oint32 | oint64

type BatchToSpaceND*[oT:BatchToSpaceNDT] {.header:"generated.h", importcpp:"BatchToSpaceND/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchToSpaceND[oT: BatchToSpaceNDT](scope: Scope,
                     input: oT,
                     block_shape: BatchToSpaceNDTblock_shape,
                     crops: BatchToSpaceNDTcrops): BatchToSpaceND[oT] {.header:"generated.h", importcpp:"BatchToSpaceND(*#, #, #, #)", constructor.}

proc batchToSpaceND*[oT: BatchToSpaceNDT](scope: Scope,
                     input: oT,
                     block_shape: BatchToSpaceNDTblock_shape,
                     crops: BatchToSpaceNDTcrops): BatchToSpaceND[oT] =
  return iibatchToSpaceND(scope,
                          input,
                          block_shape,
                          crops)

converter batchToSpaceNDToOut*[oT: BatchToSpaceNDT](op: BatchToSpaceND[oT]): oT = return op.output


type AccumulatorSetGlobalStep*{.header:"generated.h", importcpp:"AccumulatorSetGlobalStep/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiaccumulatorSetGlobalStep(scope: Scope,
                               handle: ostring,
                               new_global_step: oint64): AccumulatorSetGlobalStep {.header:"generated.h", importcpp:"AccumulatorSetGlobalStep(*#, #, #)", constructor.}

proc accumulatorSetGlobalStep*(scope: Scope,
                               handle: ostring,
                               new_global_step: oint64): AccumulatorSetGlobalStep =
  return iiaccumulatorSetGlobalStep(scope,
                                    handle,
                                    new_global_step)




type ExperimentalDatasetCardinality*[oT:oint64] {.header:"generated.h", importcpp:"ExperimentalDatasetCardinality/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalDatasetCardinality[oT: oint64](scope: Scope,
                                     input_dataset: ovariant): ExperimentalDatasetCardinality[oT] {.header:"generated.h", importcpp:"ExperimentalDatasetCardinality(*#, #)", constructor.}

proc experimentalDatasetCardinality*[oT: oint64](scope: Scope,
                                     input_dataset: ovariant): ExperimentalDatasetCardinality[oT] =
  return iiexperimentalDatasetCardinality(scope,
                                          input_dataset)

converter experimentalDatasetCardinalityToOut*[oT: oint64](op: ExperimentalDatasetCardinality[oT]): oT = return op.output

type IDeviceRetvalT = oall

type IDeviceRetval*{.header:"generated.h", importcpp:"_DeviceRetval/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiiDeviceRetval(scope: Scope,
                    input: IDeviceRetvalT,
                    index: int64): IDeviceRetval {.header:"generated.h", importcpp:"_DeviceRetval(*#, #, #)", constructor.}

proc iDeviceRetval*(scope: Scope,
                    input: IDeviceRetvalT,
                    index: int64 = 0): IDeviceRetval =
  return iiiDeviceRetval(scope,
                         input,
                         index)




type LogUniformCandidateSampler*[oT:oint64] {.header:"generated.h", importcpp:"LogUniformCandidateSampler/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilogUniformCandidateSampler[oT: oint64](scope: Scope,
                                 true_classes: oT,
                                 num_true: int64,
                                 num_sampled: int64,
                                 unique: bool,
                                 range_max: int64,
                                 seed: int64,
                                 seed2: int64): LogUniformCandidateSampler[oT] {.header:"generated.h", importcpp:"LogUniformCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc logUniformCandidateSampler*[oT: oint64](scope: Scope,
                                 true_classes: oT,
                                 num_true: int64 = 0,
                                 num_sampled: int64 = 0,
                                 unique: bool = false,
                                 range_max: int64 = 0,
                                 seed: int64 = 0,
                                 seed2: int64 = 0): LogUniformCandidateSampler[oT] =
  return iilogUniformCandidateSampler(scope,
                                      true_classes,
                                      num_true,
                                      num_sampled,
                                      unique,
                                      range_max,
                                      seed,
                                      seed2)

converter logUniformCandidateSamplerToOut*[oT: oint64](op: LogUniformCandidateSampler[oT]): oT = return op.output


type MapDefun*[oT:oinvalid] {.header:"generated.h", importcpp:"MapDefun/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapDefun[oT: oinvalid](scope: Scope,
               arguments: oT,
               captured_inputs: oT,
               Targuments: ArraySlice[DType],
               Tcaptured: ArraySlice[DType],
               output_types: ArraySlice[DType],
               output_shapes: ArraySlice[TensorShape],
               f: NameAttrList): MapDefun[oT] {.header:"generated.h", importcpp:"MapDefun(*#, #, #, #, #, #, #, #)", constructor.}

proc mapDefun*[oT: oinvalid](scope: Scope,
               arguments: oT,
               captured_inputs: oT,
               Targuments: openArray[DType],
               Tcaptured: openArray[DType],
               output_types: openArray[DType],
               output_shapes: openArray[TensorShape],
               f: NameAttrList): MapDefun[oT] =
  return iimapDefun(scope,
                    arguments,
                    captured_inputs,
                    newArraySlice(Targuments),
                    newArraySlice(Tcaptured),
                    newArraySlice(output_types),
                    newArraySlice(output_shapes),
                    f)

converter mapDefunToOut*[oT: oinvalid](op: MapDefun[oT]): oT = return op.output


type ExperimentalCSVDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalCSVDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalCSVDataset[oT: ovariant](scope: Scope,
                             filenames: ostring,
                             compression_type: ostring,
                             buffer_size: oint64,
                             header: obool,
                             field_delim: ostring,
                             use_quote_delim: obool,
                             na_value: ostring,
                             select_cols: oint64,
                             record_defaults: oinvalid,
                             output_types: ArraySlice[DType],
                             output_shapes: ArraySlice[TensorShape]): ExperimentalCSVDataset[oT] {.header:"generated.h", importcpp:"ExperimentalCSVDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalCSVDataset*[oT: ovariant](scope: Scope,
                             filenames: ostring,
                             compression_type: ostring,
                             buffer_size: oint64,
                             header: obool,
                             field_delim: ostring,
                             use_quote_delim: obool,
                             na_value: ostring,
                             select_cols: oint64,
                             record_defaults: oinvalid,
                             output_types: openArray[DType],
                             output_shapes: openArray[TensorShape]): ExperimentalCSVDataset[oT] =
  return iiexperimentalCSVDataset(scope,
                                  filenames,
                                  compression_type,
                                  buffer_size,
                                  header,
                                  field_delim,
                                  use_quote_delim,
                                  na_value,
                                  select_cols,
                                  record_defaults,
                                  newArraySlice(output_types),
                                  newArraySlice(output_shapes))

converter experimentalCSVDatasetToOut*[oT: ovariant](op: ExperimentalCSVDataset[oT]): oT = return op.output

type UnsortedSegmentMinT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type UnsortedSegmentMinTindices = oint32 | oint64
type UnsortedSegmentMinTnumsegments = oint32 | oint64

type UnsortedSegmentMin*[oT:UnsortedSegmentMinT] {.header:"generated.h", importcpp:"UnsortedSegmentMin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunsortedSegmentMin[oT: UnsortedSegmentMinT](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMinTindices,
                         num_segments: UnsortedSegmentMinTnumsegments): UnsortedSegmentMin[oT] {.header:"generated.h", importcpp:"UnsortedSegmentMin(*#, #, #, #)", constructor.}

proc unsortedSegmentMin*[oT: UnsortedSegmentMinT](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMinTindices,
                         num_segments: UnsortedSegmentMinTnumsegments): UnsortedSegmentMin[oT] =
  return iiunsortedSegmentMin(scope,
                              data,
                              segment_ids,
                              num_segments)

converter unsortedSegmentMinToOut*[oT: UnsortedSegmentMinT](op: UnsortedSegmentMin[oT]): oT = return op.output

type SegmentMinT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type SegmentMinTindices = oint32 | oint64

type SegmentMin*[oT:SegmentMinT] {.header:"generated.h", importcpp:"SegmentMin/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisegmentMin[oT: SegmentMinT](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMinTindices): SegmentMin[oT] {.header:"generated.h", importcpp:"SegmentMin(*#, #, #)", constructor.}

proc segmentMin*[oT: SegmentMinT](scope: Scope,
                 data: oT,
                 segment_ids: SegmentMinTindices): SegmentMin[oT] =
  return iisegmentMin(scope,
                      data,
                      segment_ids)

converter segmentMinToOut*[oT: SegmentMinT](op: SegmentMin[oT]): oT = return op.output


type TensorForestTreePredict*[oT:ofloat] {.header:"generated.h", importcpp:"TensorForestTreePredict/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorForestTreePredict[oT: ofloat](scope: Scope,
                              tree_handle: oresource,
                              dense_features: oT,
                              logits_dimension: int64): TensorForestTreePredict[oT] {.header:"generated.h", importcpp:"TensorForestTreePredict(*#, #, #, #)", constructor.}

proc tensorForestTreePredict*[oT: ofloat](scope: Scope,
                              tree_handle: oresource,
                              dense_features: oT,
                              logits_dimension: int64 = 0): TensorForestTreePredict[oT] =
  return iitensorForestTreePredict(scope,
                                   tree_handle,
                                   dense_features,
                                   logits_dimension)

converter tensorForestTreePredictToOut*[oT: ofloat](op: TensorForestTreePredict[oT]): oT = return op.output


type EncodeProto*[oT:ostring] {.header:"generated.h", importcpp:"EncodeProto/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiencodeProto[oT: ostring](scope: Scope,
                  sizes: oint32,
                  values: oinvalid,
                  field_names: ArraySlice[cstring],
                  message_type: cstring,
                  Tinput_types: ArraySlice[DType],
                  descriptor_source: cstring): EncodeProto[oT] {.header:"generated.h", importcpp:"EncodeProto(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc encodeProto*[oT: ostring](scope: Scope,
                  sizes: oint32,
                  values: oinvalid,
                  field_names: openArray[cstring],
                  message_type: cstring,
                  Tinput_types: openArray[DType],
                  descriptor_source: cstring = "local://"): EncodeProto[oT] =
  return iiencodeProto(scope,
                       sizes,
                       values,
                       newArraySlice(field_names),
                       message_type,
                       newArraySlice(Tinput_types),
                       descriptor_source)

converter encodeProtoToOut*[oT: ostring](op: EncodeProto[oT]): oT = return op.output


type ExperimentalDirectedInterleaveDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalDirectedInterleaveDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalDirectedInterleaveDataset[oT: ovariant](scope: Scope,
                                            selector_input_dataset: oT,
                                            data_input_datasets: oT,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalDirectedInterleaveDataset[oT] {.header:"generated.h", importcpp:"ExperimentalDirectedInterleaveDataset(*#, #, #, #, #)", constructor.}

proc experimentalDirectedInterleaveDataset*[oT: ovariant](scope: Scope,
                                            selector_input_dataset: oT,
                                            data_input_datasets: oT,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalDirectedInterleaveDataset[oT] =
  return iiexperimentalDirectedInterleaveDataset(scope,
                                                 selector_input_dataset,
                                                 data_input_datasets,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalDirectedInterleaveDatasetToOut*[oT: ovariant](op: ExperimentalDirectedInterleaveDataset[oT]): oT = return op.output

type MinimumT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64

type Minimum*[oT:MinimumT] {.header:"generated.h", importcpp:"Minimum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiminimum[oT: MinimumT](scope: Scope,
              x: oT,
              y: oT): Minimum[oT] {.header:"generated.h", importcpp:"Minimum(*#, #, #)", constructor.}

proc minimum*[oT: MinimumT](scope: Scope,
              x: oT,
              y: oT): Minimum[oT] =
  return iiminimum(scope,
                   x,
                   y)

converter minimumToOut*[oT: MinimumT](op: Minimum[oT]): oT = return op.output


type UnicodeDecode*[oT:oint64] {.header:"generated.h", importcpp:"UnicodeDecode/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunicodeDecode[oT: oint64](scope: Scope,
                    input: ostring,
                    input_encoding: cstring,
                    errors: cstring,
                    replacement_char: int64,
                    replace_control_characters: bool): UnicodeDecode[oT] {.header:"generated.h", importcpp:"UnicodeDecode(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unicodeDecode*[oT: oint64](scope: Scope,
                    input: ostring,
                    input_encoding: cstring,
                    errors: cstring = "replace",
                    replacement_char: int64 = 65533,
                    replace_control_characters: bool = false): UnicodeDecode[oT] =
  return iiunicodeDecode(scope,
                         input,
                         input_encoding,
                         errors,
                         replacement_char,
                         replace_control_characters)

converter unicodeDecodeToOut*[oT: oint64](op: UnicodeDecode[oT]): oT = return op.output

type WriteSummaryT = oall

type WriteSummary*{.header:"generated.h", importcpp:"WriteSummary/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteSummary(scope: Scope,
                   writer: oresource,
                   step: oint64,
                   tensor: WriteSummaryT,
                   tag: ostring,
                   summary_metadata: ostring): WriteSummary {.header:"generated.h", importcpp:"WriteSummary(*#, #, #, #, #, #)", constructor.}

proc writeSummary*(scope: Scope,
                   writer: oresource,
                   step: oint64,
                   tensor: WriteSummaryT,
                   tag: ostring,
                   summary_metadata: ostring): WriteSummary =
  return iiwriteSummary(scope,
                        writer,
                        step,
                        tensor,
                        tag,
                        summary_metadata)




type Batch*[oT:oinvalid] {.header:"generated.h", importcpp:"Batch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatch[oT: oinvalid](scope: Scope,
            in_tensors: oT,
            allowed_batch_sizes: ArraySlice[int],
            container: cstring,
            shared_name: cstring,
            batching_queue: cstring,
            T: ArraySlice[DType],
            num_batch_threads: int64,
            max_batch_size: int64,
            max_enqueued_batches: int64,
            batch_timeout_micros: int64,
            grad_timeout_micros: int64): Batch[oT] {.header:"generated.h", importcpp:"Batch(*#, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #, #, #)", constructor.}

proc batch*[oT: oinvalid](scope: Scope,
            in_tensors: oT,
            allowed_batch_sizes: openArray[int],
            container: cstring,
            shared_name: cstring,
            batching_queue: cstring,
            T: openArray[DType],
            num_batch_threads: int64 = 0,
            max_batch_size: int64 = 0,
            max_enqueued_batches: int64 = 10,
            batch_timeout_micros: int64 = 0,
            grad_timeout_micros: int64 = 0): Batch[oT] =
  return iibatch(scope,
                 in_tensors,
                 newArraySlice(allowed_batch_sizes),
                 container,
                 shared_name,
                 batching_queue,
                 newArraySlice(T),
                 num_batch_threads,
                 max_batch_size,
                 max_enqueued_batches,
                 batch_timeout_micros,
                 grad_timeout_micros)

converter batchToOut*[oT: oinvalid](op: Batch[oT]): oT = return op.output


type ParallelInterleaveDatasetV2*[oT:ovariant] {.header:"generated.h", importcpp:"ParallelInterleaveDatasetV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparallelInterleaveDatasetV2[oT: ovariant](scope: Scope,
                                  input_dataset: oT,
                                  other_arguments: oinvalid,
                                  cycle_length: oint64,
                                  block_length: oint64,
                                  num_parallel_calls: oint64,
                                  f: NameAttrList,
                                  Targuments: ArraySlice[DType],
                                  output_types: ArraySlice[DType],
                                  output_shapes: ArraySlice[TensorShape],
                                  sloppy: bool): ParallelInterleaveDatasetV2[oT] {.header:"generated.h", importcpp:"ParallelInterleaveDatasetV2(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parallelInterleaveDatasetV2*[oT: ovariant](scope: Scope,
                                  input_dataset: oT,
                                  other_arguments: oinvalid,
                                  cycle_length: oint64,
                                  block_length: oint64,
                                  num_parallel_calls: oint64,
                                  f: NameAttrList,
                                  Targuments: openArray[DType],
                                  output_types: openArray[DType],
                                  output_shapes: openArray[TensorShape],
                                  sloppy: bool = false): ParallelInterleaveDatasetV2[oT] =
  return iiparallelInterleaveDatasetV2(scope,
                                       input_dataset,
                                       other_arguments,
                                       cycle_length,
                                       block_length,
                                       num_parallel_calls,
                                       f,
                                       newArraySlice(Targuments),
                                       newArraySlice(output_types),
                                       newArraySlice(output_shapes),
                                       sloppy)

converter parallelInterleaveDatasetV2ToOut*[oT: ovariant](op: ParallelInterleaveDatasetV2[oT]): oT = return op.output


type QueueIsClosed*[oT:obool] {.header:"generated.h", importcpp:"QueueIsClosed/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueIsClosed[oT: obool](scope: Scope,
                    handle: ostring): QueueIsClosed[oT] {.header:"generated.h", importcpp:"QueueIsClosed(*#, #)", constructor.}

proc queueIsClosed*[oT: obool](scope: Scope,
                    handle: ostring): QueueIsClosed[oT] =
  return iiqueueIsClosed(scope,
                         handle)

converter queueIsClosedToOut*[oT: obool](op: QueueIsClosed[oT]): oT = return op.output


type MultiDeviceIteratorFromStringHandle*[oT:oresource] {.header:"generated.h", importcpp:"MultiDeviceIteratorFromStringHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimultiDeviceIteratorFromStringHandle[oT: oresource](scope: Scope,
                                          string_handle: ostring,
                                          output_types: ArraySlice[DType],
                                          output_shapes: ArraySlice[TensorShape]): MultiDeviceIteratorFromStringHandle[oT] {.header:"generated.h", importcpp:"MultiDeviceIteratorFromStringHandle(*#, #, #, #)", constructor.}

proc multiDeviceIteratorFromStringHandle*[oT: oresource](scope: Scope,
                                          string_handle: ostring,
                                          output_types: openArray[DType],
                                          output_shapes: openArray[TensorShape]): MultiDeviceIteratorFromStringHandle[oT] =
  return iimultiDeviceIteratorFromStringHandle(scope,
                                               string_handle,
                                               newArraySlice(output_types),
                                               newArraySlice(output_shapes))

converter multiDeviceIteratorFromStringHandleToOut*[oT: oresource](op: MultiDeviceIteratorFromStringHandle[oT]): oT = return op.output

type MaxPoolGradGradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type MaxPoolGradGrad*[oT:MaxPoolGradGradT] {.header:"generated.h", importcpp:"MaxPoolGradGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolGradGrad[oT: MaxPoolGradGradT](scope: Scope,
                      orig_input: oT,
                      orig_output: oT,
                      grad: oT,
                      ksize: ArraySlice[int],
                      strides: ArraySlice[int],
                      padding: cstring,
                      data_format: cstring): MaxPoolGradGrad[oT] {.header:"generated.h", importcpp:"MaxPoolGradGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPoolGradGrad*[oT: MaxPoolGradGradT](scope: Scope,
                      orig_input: oT,
                      orig_output: oT,
                      grad: oT,
                      ksize: openArray[int],
                      strides: openArray[int],
                      padding: cstring,
                      data_format: cstring = "NHWC"): MaxPoolGradGrad[oT] =
  return iimaxPoolGradGrad(scope,
                           orig_input,
                           orig_output,
                           grad,
                           newArraySlice(ksize),
                           newArraySlice(strides),
                           padding,
                           data_format)

converter maxPoolGradGradToOut*[oT: MaxPoolGradGradT](op: MaxPoolGradGrad[oT]): oT = return op.output


type UnwrapDatasetVariant*[oT:ovariant] {.header:"generated.h", importcpp:"UnwrapDatasetVariant/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunwrapDatasetVariant[oT: ovariant](scope: Scope,
                           input_handle: oT): UnwrapDatasetVariant[oT] {.header:"generated.h", importcpp:"UnwrapDatasetVariant(*#, #)", constructor.}

proc unwrapDatasetVariant*[oT: ovariant](scope: Scope,
                           input_handle: oT): UnwrapDatasetVariant[oT] =
  return iiunwrapDatasetVariant(scope,
                                input_handle)

converter unwrapDatasetVariantToOut*[oT: ovariant](op: UnwrapDatasetVariant[oT]): oT = return op.output


type WrapDatasetVariant*[oT:ovariant] {.header:"generated.h", importcpp:"WrapDatasetVariant/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiwrapDatasetVariant[oT: ovariant](scope: Scope,
                         input_handle: oT): WrapDatasetVariant[oT] {.header:"generated.h", importcpp:"WrapDatasetVariant(*#, #)", constructor.}

proc wrapDatasetVariant*[oT: ovariant](scope: Scope,
                         input_handle: oT): WrapDatasetVariant[oT] =
  return iiwrapDatasetVariant(scope,
                              input_handle)

converter wrapDatasetVariantToOut*[oT: ovariant](op: WrapDatasetVariant[oT]): oT = return op.output


type Stage*{.header:"generated.h", importcpp:"Stage/*'0*/".} = object
  operation: Operation[oinvalid]


proc iistage(scope: Scope,
            values: oinvalid,
            dtypes: ArraySlice[DType],
            container: cstring,
            shared_name: cstring,
            capacity: int64,
            memory_limit: int64): Stage {.header:"generated.h", importcpp:"Stage(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stage*(scope: Scope,
            values: oinvalid,
            dtypes: openArray[DType],
            container: cstring,
            shared_name: cstring,
            capacity: int64 = 0,
            memory_limit: int64 = 0): Stage =
  return iistage(scope,
                 values,
                 newArraySlice(dtypes),
                 container,
                 shared_name,
                 capacity,
                 memory_limit)




type IdentityN*[oT:oinvalid] {.header:"generated.h", importcpp:"IdentityN/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiidentityN[oT: oinvalid](scope: Scope,
                input: oT,
                T: ArraySlice[DType]): IdentityN[oT] {.header:"generated.h", importcpp:"IdentityN(*#, #, #)", constructor.}

proc identityN*[oT: oinvalid](scope: Scope,
                input: oT,
                T: openArray[DType]): IdentityN[oT] =
  return iiidentityN(scope,
                     input,
                     newArraySlice(T))

converter identityNToOut*[oT: oinvalid](op: IdentityN[oT]): oT = return op.output


type OptionalHasValue*[oT:obool] {.header:"generated.h", importcpp:"OptionalHasValue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioptionalHasValue[oT: obool](scope: Scope,
                       optional: ovariant): OptionalHasValue[oT] {.header:"generated.h", importcpp:"OptionalHasValue(*#, #)", constructor.}

proc optionalHasValue*[oT: obool](scope: Scope,
                       optional: ovariant): OptionalHasValue[oT] =
  return iioptionalHasValue(scope,
                            optional)

converter optionalHasValueToOut*[oT: obool](op: OptionalHasValue[oT]): oT = return op.output

type QrT = odouble | ofloat | ocomplex64 | ocomplex128

type Qr*[oT:QrT] {.header:"generated.h", importcpp:"Qr/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqr[oT: QrT](scope: Scope,
         input: oT,
         full_matrices: bool): Qr[oT] {.header:"generated.h", importcpp:"Qr(*#, #, #)", constructor.}

proc qr*[oT: QrT](scope: Scope,
         input: oT,
         full_matrices: bool = false): Qr[oT] =
  return iiqr(scope,
              input,
              full_matrices)

converter qrToOut*[oT: QrT](op: Qr[oT]): oT = return op.output


type StatefulPartitionedCall*[oT:oinvalid] {.header:"generated.h", importcpp:"StatefulPartitionedCall/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatefulPartitionedCall[oT: oinvalid](scope: Scope,
                              args: oT,
                              Tin: ArraySlice[DType],
                              Tout: ArraySlice[DType],
                              f: NameAttrList,
                              config: cstring,
                              config_proto: cstring,
                              executor_type: cstring): StatefulPartitionedCall[oT] {.header:"generated.h", importcpp:"StatefulPartitionedCall(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#))", constructor.}

proc statefulPartitionedCall*[oT: oinvalid](scope: Scope,
                              args: oT,
                              Tin: openArray[DType],
                              Tout: openArray[DType],
                              f: NameAttrList,
                              config: cstring,
                              config_proto: cstring,
                              executor_type: cstring): StatefulPartitionedCall[oT] =
  return iistatefulPartitionedCall(scope,
                                   args,
                                   newArraySlice(Tin),
                                   newArraySlice(Tout),
                                   f,
                                   config,
                                   config_proto,
                                   executor_type)

converter statefulPartitionedCallToOut*[oT: oinvalid](op: StatefulPartitionedCall[oT]): oT = return op.output


type OptionalFromValue*[oT:ovariant] {.header:"generated.h", importcpp:"OptionalFromValue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioptionalFromValue[oT: ovariant](scope: Scope,
                        components: oinvalid,
                        Toutput_types: ArraySlice[DType]): OptionalFromValue[oT] {.header:"generated.h", importcpp:"OptionalFromValue(*#, #, #)", constructor.}

proc optionalFromValue*[oT: ovariant](scope: Scope,
                        components: oinvalid,
                        Toutput_types: openArray[DType]): OptionalFromValue[oT] =
  return iioptionalFromValue(scope,
                             components,
                             newArraySlice(Toutput_types))

converter optionalFromValueToOut*[oT: ovariant](op: OptionalFromValue[oT]): oT = return op.output


type DatasetToGraph*[oT:ostring] {.header:"generated.h", importcpp:"DatasetToGraph/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidatasetToGraph[oT: ostring](scope: Scope,
                     input_dataset: ovariant): DatasetToGraph[oT] {.header:"generated.h", importcpp:"DatasetToGraph(*#, #)", constructor.}

proc datasetToGraph*[oT: ostring](scope: Scope,
                     input_dataset: ovariant): DatasetToGraph[oT] =
  return iidatasetToGraph(scope,
                          input_dataset)

converter datasetToGraphToOut*[oT: ostring](op: DatasetToGraph[oT]): oT = return op.output


type ExtractGlimpse*[oT:ofloat] {.header:"generated.h", importcpp:"ExtractGlimpse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiextractGlimpse[oT: ofloat](scope: Scope,
                     input: oT,
                     size: oint32,
                     offsets: oT,
                     centered: bool,
                     normalized: bool,
                     uniform_noise: bool): ExtractGlimpse[oT] {.header:"generated.h", importcpp:"ExtractGlimpse(*#, #, #, #, #, #, #)", constructor.}

proc extractGlimpse*[oT: ofloat](scope: Scope,
                     input: oT,
                     size: oint32,
                     offsets: oT,
                     centered: bool = true,
                     normalized: bool = true,
                     uniform_noise: bool = true): ExtractGlimpse[oT] =
  return iiextractGlimpse(scope,
                          input,
                          size,
                          offsets,
                          centered,
                          normalized,
                          uniform_noise)

converter extractGlimpseToOut*[oT: ofloat](op: ExtractGlimpse[oT]): oT = return op.output


type ExperimentalDatasetToTFRecord*{.header:"generated.h", importcpp:"ExperimentalDatasetToTFRecord/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiexperimentalDatasetToTFRecord(scope: Scope,
                                    input_dataset: ovariant,
                                    filename: ostring,
                                    compression_type: ostring): ExperimentalDatasetToTFRecord {.header:"generated.h", importcpp:"ExperimentalDatasetToTFRecord(*#, #, #, #)", constructor.}

proc experimentalDatasetToTFRecord*(scope: Scope,
                                    input_dataset: ovariant,
                                    filename: ostring,
                                    compression_type: ostring): ExperimentalDatasetToTFRecord =
  return iiexperimentalDatasetToTFRecord(scope,
                                         input_dataset,
                                         filename,
                                         compression_type)




type ShardedFilespec*[oT:ostring] {.header:"generated.h", importcpp:"ShardedFilespec/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iishardedFilespec[oT: ostring](scope: Scope,
                      basename: oT,
                      num_shards: oint32): ShardedFilespec[oT] {.header:"generated.h", importcpp:"ShardedFilespec(*#, #, #)", constructor.}

proc shardedFilespec*[oT: ostring](scope: Scope,
                      basename: oT,
                      num_shards: oint32): ShardedFilespec[oT] =
  return iishardedFilespec(scope,
                           basename,
                           num_shards)

converter shardedFilespecToOut*[oT: ostring](op: ShardedFilespec[oT]): oT = return op.output

type ResourceApplyCenteredRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyCenteredRMSProp*{.header:"generated.h", importcpp:"ResourceApplyCenteredRMSProp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyCenteredRMSProp(scope: Scope,
                                   nvar: oresource,
                                   mg: oresource,
                                   ms: oresource,
                                   mom: oresource,
                                   lr: ResourceApplyCenteredRMSPropT,
                                   rho: ResourceApplyCenteredRMSPropT,
                                   momentum: ResourceApplyCenteredRMSPropT,
                                   epsilon: ResourceApplyCenteredRMSPropT,
                                   grad: ResourceApplyCenteredRMSPropT,
                                   use_locking: bool): ResourceApplyCenteredRMSProp {.header:"generated.h", importcpp:"ResourceApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyCenteredRMSProp*(scope: Scope,
                                   nvar: oresource,
                                   mg: oresource,
                                   ms: oresource,
                                   mom: oresource,
                                   lr: ResourceApplyCenteredRMSPropT,
                                   rho: ResourceApplyCenteredRMSPropT,
                                   momentum: ResourceApplyCenteredRMSPropT,
                                   epsilon: ResourceApplyCenteredRMSPropT,
                                   grad: ResourceApplyCenteredRMSPropT,
                                   use_locking: bool = false): ResourceApplyCenteredRMSProp =
  return iiresourceApplyCenteredRMSProp(scope,
                                        nvar,
                                        mg,
                                        ms,
                                        mom,
                                        lr,
                                        rho,
                                        momentum,
                                        epsilon,
                                        grad,
                                        use_locking)




type SerializeIterator*[oT:ovariant] {.header:"generated.h", importcpp:"SerializeIterator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiserializeIterator[oT: ovariant](scope: Scope,
                        resource_handle: oresource): SerializeIterator[oT] {.header:"generated.h", importcpp:"SerializeIterator(*#, #)", constructor.}

proc serializeIterator*[oT: ovariant](scope: Scope,
                        resource_handle: oresource): SerializeIterator[oT] =
  return iiserializeIterator(scope,
                             resource_handle)

converter serializeIteratorToOut*[oT: ovariant](op: SerializeIterator[oT]): oT = return op.output

type SparseSegmentSqrtNGradT = ofloat | odouble
type SparseSegmentSqrtNGradTidx = oint32 | oint64

type SparseSegmentSqrtNGrad*[oT:SparseSegmentSqrtNGradT] {.header:"generated.h", importcpp:"SparseSegmentSqrtNGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentSqrtNGrad[oT: SparseSegmentSqrtNGradT](scope: Scope,
                             grad: oT,
                             indices: SparseSegmentSqrtNGradTidx,
                             segment_ids: oint32,
                             output_dim0: oint32): SparseSegmentSqrtNGrad[oT] {.header:"generated.h", importcpp:"SparseSegmentSqrtNGrad(*#, #, #, #, #)", constructor.}

proc sparseSegmentSqrtNGrad*[oT: SparseSegmentSqrtNGradT](scope: Scope,
                             grad: oT,
                             indices: SparseSegmentSqrtNGradTidx,
                             segment_ids: oint32,
                             output_dim0: oint32): SparseSegmentSqrtNGrad[oT] =
  return iisparseSegmentSqrtNGrad(scope,
                                  grad,
                                  indices,
                                  segment_ids,
                                  output_dim0)

converter sparseSegmentSqrtNGradToOut*[oT: SparseSegmentSqrtNGradT](op: SparseSegmentSqrtNGrad[oT]): oT = return op.output


type VarIsInitializedOp*[oT:obool] {.header:"generated.h", importcpp:"VarIsInitializedOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iivarIsInitializedOp[oT: obool](scope: Scope,
                         resource: oresource): VarIsInitializedOp[oT] {.header:"generated.h", importcpp:"VarIsInitializedOp(*#, #)", constructor.}

proc varIsInitializedOp*[oT: obool](scope: Scope,
                         resource: oresource): VarIsInitializedOp[oT] =
  return iivarIsInitializedOp(scope,
                              resource)

converter varIsInitializedOpToOut*[oT: obool](op: VarIsInitializedOp[oT]): oT = return op.output


type FakeQuantWithMinMaxVarsPerChannel*[oT:ofloat] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannel/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQuantWithMinMaxVarsPerChannel[oT: ofloat](scope: Scope,
                                        inputs: oT,
                                        min: oT,
                                        max: oT,
                                        num_bits: int64,
                                        narrow_range: bool): FakeQuantWithMinMaxVarsPerChannel[oT] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVarsPerChannel(*#, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVarsPerChannel*[oT: ofloat](scope: Scope,
                                        inputs: oT,
                                        min: oT,
                                        max: oT,
                                        num_bits: int64 = 8,
                                        narrow_range: bool = false): FakeQuantWithMinMaxVarsPerChannel[oT] =
  return iifakeQuantWithMinMaxVarsPerChannel(scope,
                                             inputs,
                                             min,
                                             max,
                                             num_bits,
                                             narrow_range)

converter fakeQuantWithMinMaxVarsPerChannelToOut*[oT: ofloat](op: FakeQuantWithMinMaxVarsPerChannel[oT]): oT = return op.output


type WriteAudioSummary*{.header:"generated.h", importcpp:"WriteAudioSummary/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiwriteAudioSummary(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: ofloat,
                        sample_rate: ofloat,
                        max_outputs: int64): WriteAudioSummary {.header:"generated.h", importcpp:"WriteAudioSummary(*#, #, #, #, #, #, #)", constructor.}

proc writeAudioSummary*(scope: Scope,
                        writer: oresource,
                        step: oint64,
                        tag: ostring,
                        tensor: ofloat,
                        sample_rate: ofloat,
                        max_outputs: int64 = 3): WriteAudioSummary =
  return iiwriteAudioSummary(scope,
                             writer,
                             step,
                             tag,
                             tensor,
                             sample_rate,
                             max_outputs)




type IteratorFromStringHandle*[oT:oresource] {.header:"generated.h", importcpp:"IteratorFromStringHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorFromStringHandle[oT: oresource](scope: Scope,
                               string_handle: ostring,
                               output_types: ArraySlice[DType],
                               output_shapes: ArraySlice[TensorShape]): IteratorFromStringHandle[oT] {.header:"generated.h", importcpp:"IteratorFromStringHandle(*#, #, #, #)", constructor.}

proc iteratorFromStringHandle*[oT: oresource](scope: Scope,
                               string_handle: ostring,
                               output_types: openArray[DType],
                               output_shapes: openArray[TensorShape]): IteratorFromStringHandle[oT] =
  return iiiteratorFromStringHandle(scope,
                                    string_handle,
                                    newArraySlice(output_types),
                                    newArraySlice(output_shapes))

converter iteratorFromStringHandleToOut*[oT: oresource](op: IteratorFromStringHandle[oT]): oT = return op.output

type CheckNumericsT = obfloat16 | ohalf | ofloat | odouble

type CheckNumerics*[oT:CheckNumericsT] {.header:"generated.h", importcpp:"CheckNumerics/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicheckNumerics[oT: CheckNumericsT](scope: Scope,
                    tensor: oT,
                    message: cstring): CheckNumerics[oT] {.header:"generated.h", importcpp:"CheckNumerics(*#, #, tensorflow::string(#))", constructor.}

proc checkNumerics*[oT: CheckNumericsT](scope: Scope,
                    tensor: oT,
                    message: cstring): CheckNumerics[oT] =
  return iicheckNumerics(scope,
                         tensor,
                         message)

converter checkNumericsToOut*[oT: CheckNumericsT](op: CheckNumerics[oT]): oT = return op.output

type BroadcastToT = oall
type BroadcastToTidx = oint32 | oint64

type BroadcastTo*[oT:BroadcastToT] {.header:"generated.h", importcpp:"BroadcastTo/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibroadcastTo[oT: BroadcastToT](scope: Scope,
                  input: oT,
                  shape: BroadcastToTidx): BroadcastTo[oT] {.header:"generated.h", importcpp:"BroadcastTo(*#, #, #)", constructor.}

proc broadcastTo*[oT: BroadcastToT](scope: Scope,
                  input: oT,
                  shape: BroadcastToTidx): BroadcastTo[oT] =
  return iibroadcastTo(scope,
                       input,
                       shape)

converter broadcastToToOut*[oT: BroadcastToT](op: BroadcastTo[oT]): oT = return op.output


type IteratorToStringHandle*[oT:ostring] {.header:"generated.h", importcpp:"IteratorToStringHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorToStringHandle[oT: ostring](scope: Scope,
                             resource_handle: oresource): IteratorToStringHandle[oT] {.header:"generated.h", importcpp:"IteratorToStringHandle(*#, #)", constructor.}

proc iteratorToStringHandle*[oT: ostring](scope: Scope,
                             resource_handle: oresource): IteratorToStringHandle[oT] =
  return iiiteratorToStringHandle(scope,
                                  resource_handle)

converter iteratorToStringHandleToOut*[oT: ostring](op: IteratorToStringHandle[oT]): oT = return op.output

type AtanhT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Atanh*[oT:AtanhT] {.header:"generated.h", importcpp:"Atanh/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiatanh[oT: AtanhT](scope: Scope,
            x: oT): Atanh[oT] {.header:"generated.h", importcpp:"Atanh(*#, #)", constructor.}

proc atanh*[oT: AtanhT](scope: Scope,
            x: oT): Atanh[oT] =
  return iiatanh(scope,
                 x)

converter atanhToOut*[oT: AtanhT](op: Atanh[oT]): oT = return op.output


type MakeIterator*{.header:"generated.h", importcpp:"MakeIterator/*'0*/".} = object
  operation: Operation[oinvalid]


proc iimakeIterator(scope: Scope,
                   dataset: ovariant,
                   niterator: oresource): MakeIterator {.header:"generated.h", importcpp:"MakeIterator(*#, #, #)", constructor.}

proc makeIterator*(scope: Scope,
                   dataset: ovariant,
                   niterator: oresource): MakeIterator =
  return iimakeIterator(scope,
                        dataset,
                        niterator)



type UniqueWithCountsV2T = oall
type UniqueWithCountsV2Taxis = oint32 | oint64

type UniqueWithCountsV2*[oT:UniqueWithCountsV2T] {.header:"generated.h", importcpp:"UniqueWithCountsV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiuniqueWithCountsV2[oT: UniqueWithCountsV2T](scope: Scope,
                         x: oT,
                         axis: UniqueWithCountsV2Taxis,
                         out_idx: DType): UniqueWithCountsV2[oT] {.header:"generated.h", importcpp:"UniqueWithCountsV2(*#, #, #, #)", constructor.}

proc uniqueWithCountsV2*[oT: UniqueWithCountsV2T](scope: Scope,
                         x: oT,
                         axis: UniqueWithCountsV2Taxis,
                         out_idx: DType = DT_INT32): UniqueWithCountsV2[oT] =
  return iiuniqueWithCountsV2(scope,
                              x,
                              axis,
                              out_idx)

converter uniqueWithCountsV2ToOut*[oT: UniqueWithCountsV2T](op: UniqueWithCountsV2[oT]): oT = return op.output


type AnonymousIterator*[oT:oresource] {.header:"generated.h", importcpp:"AnonymousIterator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iianonymousIterator[oT: oresource](scope: Scope,
                        output_types: ArraySlice[DType],
                        output_shapes: ArraySlice[TensorShape]): AnonymousIterator[oT] {.header:"generated.h", importcpp:"AnonymousIterator(*#, #, #)", constructor.}

proc anonymousIterator*[oT: oresource](scope: Scope,
                        output_types: openArray[DType],
                        output_shapes: openArray[TensorShape]): AnonymousIterator[oT] =
  return iianonymousIterator(scope,
                             newArraySlice(output_types),
                             newArraySlice(output_shapes))

converter anonymousIteratorToOut*[oT: oresource](op: AnonymousIterator[oT]): oT = return op.output

type DebugGradientRefIdentityT = oall

type DebugGradientRefIdentity*[oT:DebugGradientRefIdentityT] {.header:"generated.h", importcpp:"DebugGradientRefIdentity/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidebugGradientRefIdentity[oT: DebugGradientRefIdentityT](scope: Scope,
                               input: oT): DebugGradientRefIdentity[oT] {.header:"generated.h", importcpp:"DebugGradientRefIdentity(*#, #)", constructor.}

proc debugGradientRefIdentity*[oT: DebugGradientRefIdentityT](scope: Scope,
                               input: oT): DebugGradientRefIdentity[oT] =
  return iidebugGradientRefIdentity(scope,
                                    input)

converter debugGradientRefIdentityToOut*[oT: DebugGradientRefIdentityT](op: DebugGradientRefIdentity[oT]): oT = return op.output


type IteratorV2*[oT:oresource] {.header:"generated.h", importcpp:"IteratorV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorV2[oT: oresource](scope: Scope,
                 shared_name: cstring,
                 container: cstring,
                 output_types: ArraySlice[DType],
                 output_shapes: ArraySlice[TensorShape]): IteratorV2[oT] {.header:"generated.h", importcpp:"IteratorV2(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iteratorV2*[oT: oresource](scope: Scope,
                 shared_name: cstring,
                 container: cstring,
                 output_types: openArray[DType],
                 output_shapes: openArray[TensorShape]): IteratorV2[oT] =
  return iiiteratorV2(scope,
                      shared_name,
                      container,
                      newArraySlice(output_types),
                      newArraySlice(output_shapes))

converter iteratorV2ToOut*[oT: oresource](op: IteratorV2[oT]): oT = return op.output

type ImmutableConstdtype = oall

type ImmutableConst*[oT:ImmutableConstdtype] {.header:"generated.h", importcpp:"ImmutableConst/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiimmutableConst[oT: ImmutableConstdtype](scope: Scope,
                     memory_region_name: cstring,
                     dtype: DType,
                     shape: TensorShape): ImmutableConst[oT] {.header:"generated.h", importcpp:"ImmutableConst(*#, tensorflow::string(#), #, #)", constructor.}

proc immutableConst*[oT: ImmutableConstdtype](scope: Scope,
                     memory_region_name: cstring,
                     dtype: DType = oT[].oTF,
                     shape: TensorShape = [].shape): ImmutableConst[oT] =
  return iiimmutableConst(scope,
                          memory_region_name,
                          dtype,
                          shape)

converter immutableConstToOut*[oT: ImmutableConstdtype](op: ImmutableConst[oT]): oT = return op.output


type BoostedTreesQuantileStreamResourceAddSummaries*{.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceAddSummaries/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesQuantileStreamResourceAddSummaries(scope: Scope,
                                                     quantile_stream_resource_handle: oresource,
                                                     summaries: ofloat,
                                                     num_features: int64): BoostedTreesQuantileStreamResourceAddSummaries {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceAddSummaries(*#, #, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceAddSummaries*(scope: Scope,
                                                     quantile_stream_resource_handle: oresource,
                                                     summaries: ofloat,
                                                     num_features: int64 = 0): BoostedTreesQuantileStreamResourceAddSummaries =
  return iiboostedTreesQuantileStreamResourceAddSummaries(scope,
                                                          quantile_stream_resource_handle,
                                                          summaries,
                                                          num_features)




type Iterator*[oT:oresource] {.header:"generated.h", importcpp:"Iterator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiniterator[oT: oresource](scope: Scope,
                shared_name: cstring,
                container: cstring,
                output_types: ArraySlice[DType],
                output_shapes: ArraySlice[TensorShape]): Iterator[oT] {.header:"generated.h", importcpp:"Iterator(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc niterator*[oT: oresource](scope: Scope,
                shared_name: cstring,
                container: cstring,
                output_types: openArray[DType],
                output_shapes: openArray[TensorShape]): Iterator[oT] =
  return iiniterator(scope,
                     shared_name,
                     container,
                     newArraySlice(output_types),
                     newArraySlice(output_shapes))

converter niteratorToOut*[oT: oresource](op: Iterator[oT]): oT = return op.output


type Rpc*[oT:ostring] {.header:"generated.h", importcpp:"Rpc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirpc[oT: ostring](scope: Scope,
          address: oT,
          nmethod: oT,
          request: oT,
          protocol: cstring,
          fail_fast: bool,
          timeout_in_ms: int64): Rpc[oT] {.header:"generated.h", importcpp:"Rpc(*#, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc rpc*[oT: ostring](scope: Scope,
          address: oT,
          nmethod: oT,
          request: oT,
          protocol: cstring,
          fail_fast: bool = true,
          timeout_in_ms: int64 = 0): Rpc[oT] =
  return iirpc(scope,
               address,
               nmethod,
               request,
               protocol,
               fail_fast,
               timeout_in_ms)

converter rpcToOut*[oT: ostring](op: Rpc[oT]): oT = return op.output


type TFRecordDataset*[oT:ovariant] {.header:"generated.h", importcpp:"TFRecordDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitFRecordDataset[oT: ovariant](scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TFRecordDataset[oT] {.header:"generated.h", importcpp:"TFRecordDataset(*#, #, #, #)", constructor.}

proc tFRecordDataset*[oT: ovariant](scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TFRecordDataset[oT] =
  return iitFRecordDataset(scope,
                           filenames,
                           compression_type,
                           buffer_size)

converter tFRecordDatasetToOut*[oT: ovariant](op: TFRecordDataset[oT]): oT = return op.output

type SparseReduceMaxSparseT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseReduceMaxSparse*[oT:oint64] {.header:"generated.h", importcpp:"SparseReduceMaxSparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseReduceMaxSparse[oT: oint64](scope: Scope,
                            input_indices: oT,
                            input_values: SparseReduceMaxSparseT,
                            input_shape: oT,
                            reduction_axes: oint32,
                            keep_dims: bool): SparseReduceMaxSparse[oT] {.header:"generated.h", importcpp:"SparseReduceMaxSparse(*#, #, #, #, #, #)", constructor.}

proc sparseReduceMaxSparse*[oT: oint64](scope: Scope,
                            input_indices: oT,
                            input_values: SparseReduceMaxSparseT,
                            input_shape: oT,
                            reduction_axes: oint32,
                            keep_dims: bool = false): SparseReduceMaxSparse[oT] =
  return iisparseReduceMaxSparse(scope,
                                 input_indices,
                                 input_values,
                                 input_shape,
                                 reduction_axes,
                                 keep_dims)

converter sparseReduceMaxSparseToOut*[oT: oint64](op: SparseReduceMaxSparse[oT]): oT = return op.output


type CacheDataset*[oT:ovariant] {.header:"generated.h", importcpp:"CacheDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicacheDataset[oT: ovariant](scope: Scope,
                   input_dataset: oT,
                   filename: ostring,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): CacheDataset[oT] {.header:"generated.h", importcpp:"CacheDataset(*#, #, #, #, #)", constructor.}

proc cacheDataset*[oT: ovariant](scope: Scope,
                   input_dataset: oT,
                   filename: ostring,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): CacheDataset[oT] =
  return iicacheDataset(scope,
                        input_dataset,
                        filename,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter cacheDatasetToOut*[oT: ovariant](op: CacheDataset[oT]): oT = return op.output

type MaxPoolV2T = ohalf | obfloat16 | ofloat | odouble | oint32 | oint64 | ouint8 | oint16 | oint8 | ouint16 | oqint8

type MaxPoolV2*[oT:MaxPoolV2T] {.header:"generated.h", importcpp:"MaxPoolV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolV2[oT: MaxPoolV2T](scope: Scope,
                input: oT,
                ksize: oint32,
                strides: oint32,
                padding: cstring,
                data_format: cstring): MaxPoolV2[oT] {.header:"generated.h", importcpp:"MaxPoolV2(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPoolV2*[oT: MaxPoolV2T](scope: Scope,
                input: oT,
                ksize: oint32,
                strides: oint32,
                padding: cstring,
                data_format: cstring = "NHWC"): MaxPoolV2[oT] =
  return iimaxPoolV2(scope,
                     input,
                     ksize,
                     strides,
                     padding,
                     data_format)

converter maxPoolV2ToOut*[oT: MaxPoolV2T](op: MaxPoolV2[oT]): oT = return op.output

type QuantizedMulT1 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedMulT2 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedMulToutput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedMul*[oT:QuantizedMulToutput] {.header:"generated.h", importcpp:"QuantizedMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedMul[oT: QuantizedMulToutput](scope: Scope,
                   x: QuantizedMulT1,
                   y: QuantizedMulT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat): QuantizedMul[oT] {.header:"generated.h", importcpp:"QuantizedMul(*#, #, #, #, #, #, #)", constructor.}

proc quantizedMul*[oT: QuantizedMulToutput](scope: Scope,
                   x: QuantizedMulT1,
                   y: QuantizedMulT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat): QuantizedMul[oT] =
  return iiquantizedMul(scope,
                        x,
                        y,
                        min_x,
                        max_x,
                        min_y,
                        max_y)

converter quantizedMulToOut*[oT: QuantizedMulToutput](op: QuantizedMul[oT]): oT = return op.output


type ShuffleAndRepeatDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ShuffleAndRepeatDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iishuffleAndRepeatDataset[oT: ovariant](scope: Scope,
                              input_dataset: oT,
                              buffer_size: oint64,
                              seed: oint64,
                              seed2: oint64,
                              count: oint64,
                              output_types: ArraySlice[DType],
                              output_shapes: ArraySlice[TensorShape]): ShuffleAndRepeatDataset[oT] {.header:"generated.h", importcpp:"ShuffleAndRepeatDataset(*#, #, #, #, #, #, #, #)", constructor.}

proc shuffleAndRepeatDataset*[oT: ovariant](scope: Scope,
                              input_dataset: oT,
                              buffer_size: oint64,
                              seed: oint64,
                              seed2: oint64,
                              count: oint64,
                              output_types: openArray[DType],
                              output_shapes: openArray[TensorShape]): ShuffleAndRepeatDataset[oT] =
  return iishuffleAndRepeatDataset(scope,
                                   input_dataset,
                                   buffer_size,
                                   seed,
                                   seed2,
                                   count,
                                   newArraySlice(output_types),
                                   newArraySlice(output_shapes))

converter shuffleAndRepeatDatasetToOut*[oT: ovariant](op: ShuffleAndRepeatDataset[oT]): oT = return op.output

type INcclBroadcastSendT = ohalf | ofloat | odouble | oint32 | oint64

type INcclBroadcastSend*{.header:"generated.h", importcpp:"_NcclBroadcastSend/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiiNcclBroadcastSend(scope: Scope,
                         input: INcclBroadcastSendT,
                         shared_name: cstring,
                         num_devices: int64): INcclBroadcastSend {.header:"generated.h", importcpp:"_NcclBroadcastSend(*#, #, tensorflow::string(#), #)", constructor.}

proc iNcclBroadcastSend*(scope: Scope,
                         input: INcclBroadcastSendT,
                         shared_name: cstring,
                         num_devices: int64 = 0): INcclBroadcastSend =
  return iiiNcclBroadcastSend(scope,
                              input,
                              shared_name,
                              num_devices)



type CudnnRNNT = ohalf | ofloat | odouble

type CudnnRNN*[oT:CudnnRNNT] {.header:"generated.h", importcpp:"CudnnRNN/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNN[oT: CudnnRNNT](scope: Scope,
               input: oT,
               input_h: oT,
               input_c: oT,
               params: oT,
               is_training: bool,
               rnn_mode: cstring,
               input_mode: cstring,
               direction: cstring,
               dropout: float32,
               seed: int64,
               seed2: int64): CudnnRNN[oT] {.header:"generated.h", importcpp:"CudnnRNN(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNN*[oT: CudnnRNNT](scope: Scope,
               input: oT,
               input_h: oT,
               input_c: oT,
               params: oT,
               is_training: bool = true,
               rnn_mode: cstring = "lstm",
               input_mode: cstring = "linear_input",
               direction: cstring = "unidirectional",
               dropout: float32 = 0.0.float32,
               seed: int64 = 0,
               seed2: int64 = 0): CudnnRNN[oT] =
  return iicudnnRNN(scope,
                    input,
                    input_h,
                    input_c,
                    params,
                    is_training,
                    rnn_mode,
                    input_mode,
                    direction,
                    dropout,
                    seed,
                    seed2)

converter cudnnRNNToOut*[oT: CudnnRNNT](op: CudnnRNN[oT]): oT = return op.output


type BatchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"BatchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchDataset[oT: ovariant](scope: Scope,
                   input_dataset: oT,
                   batch_size: oint64,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): BatchDataset[oT] {.header:"generated.h", importcpp:"BatchDataset(*#, #, #, #, #)", constructor.}

proc batchDataset*[oT: ovariant](scope: Scope,
                   input_dataset: oT,
                   batch_size: oint64,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): BatchDataset[oT] =
  return iibatchDataset(scope,
                        input_dataset,
                        batch_size,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter batchDatasetToOut*[oT: ovariant](op: BatchDataset[oT]): oT = return op.output

type SoftsignGradT = ohalf | obfloat16 | ofloat | odouble

type SoftsignGrad*[oT:SoftsignGradT] {.header:"generated.h", importcpp:"SoftsignGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisoftsignGrad[oT: SoftsignGradT](scope: Scope,
                   gradients: oT,
                   features: oT): SoftsignGrad[oT] {.header:"generated.h", importcpp:"SoftsignGrad(*#, #, #)", constructor.}

proc softsignGrad*[oT: SoftsignGradT](scope: Scope,
                   gradients: oT,
                   features: oT): SoftsignGrad[oT] =
  return iisoftsignGrad(scope,
                        gradients,
                        features)

converter softsignGradToOut*[oT: SoftsignGradT](op: SoftsignGrad[oT]): oT = return op.output

type SetSizeT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type SetSize*[oT:oint32] {.header:"generated.h", importcpp:"SetSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisetSize[oT: oint32](scope: Scope,
              set_indices: oint64,
              set_values: SetSizeT,
              set_shape: oint64,
              validate_indices: bool): SetSize[oT] {.header:"generated.h", importcpp:"SetSize(*#, #, #, #, #)", constructor.}

proc setSize*[oT: oint32](scope: Scope,
              set_indices: oint64,
              set_values: SetSizeT,
              set_shape: oint64,
              validate_indices: bool = true): SetSize[oT] =
  return iisetSize(scope,
                   set_indices,
                   set_values,
                   set_shape,
                   validate_indices)

converter setSizeToOut*[oT: oint32](op: SetSize[oT]): oT = return op.output


type WindowDataset*[oT:ovariant] {.header:"generated.h", importcpp:"WindowDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiwindowDataset[oT: ovariant](scope: Scope,
                    input_dataset: oT,
                    size: oint64,
                    shift: oint64,
                    stride: oint64,
                    drop_remainder: obool,
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): WindowDataset[oT] {.header:"generated.h", importcpp:"WindowDataset(*#, #, #, #, #, #, #, #)", constructor.}

proc windowDataset*[oT: ovariant](scope: Scope,
                    input_dataset: oT,
                    size: oint64,
                    shift: oint64,
                    stride: oint64,
                    drop_remainder: obool,
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): WindowDataset[oT] =
  return iiwindowDataset(scope,
                         input_dataset,
                         size,
                         shift,
                         stride,
                         drop_remainder,
                         newArraySlice(output_types),
                         newArraySlice(output_shapes))

converter windowDatasetToOut*[oT: ovariant](op: WindowDataset[oT]): oT = return op.output

type ResourceApplyRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyRMSProp*{.header:"generated.h", importcpp:"ResourceApplyRMSProp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyRMSProp(scope: Scope,
                           nvar: oresource,
                           ms: oresource,
                           mom: oresource,
                           lr: ResourceApplyRMSPropT,
                           rho: ResourceApplyRMSPropT,
                           momentum: ResourceApplyRMSPropT,
                           epsilon: ResourceApplyRMSPropT,
                           grad: ResourceApplyRMSPropT,
                           use_locking: bool): ResourceApplyRMSProp {.header:"generated.h", importcpp:"ResourceApplyRMSProp(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyRMSProp*(scope: Scope,
                           nvar: oresource,
                           ms: oresource,
                           mom: oresource,
                           lr: ResourceApplyRMSPropT,
                           rho: ResourceApplyRMSPropT,
                           momentum: ResourceApplyRMSPropT,
                           epsilon: ResourceApplyRMSPropT,
                           grad: ResourceApplyRMSPropT,
                           use_locking: bool = false): ResourceApplyRMSProp =
  return iiresourceApplyRMSProp(scope,
                                nvar,
                                ms,
                                mom,
                                lr,
                                rho,
                                momentum,
                                epsilon,
                                grad,
                                use_locking)



type MaxPool3DGradTInput = ohalf | obfloat16 | ofloat
type MaxPool3DGradT = ohalf | obfloat16 | ofloat

type MaxPool3DGrad*[oT:MaxPool3DGradT] {.header:"generated.h", importcpp:"MaxPool3DGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPool3DGrad[oT: MaxPool3DGradT](scope: Scope,
                    orig_input: MaxPool3DGradTInput,
                    orig_output: MaxPool3DGradTInput,
                    grad: oT,
                    ksize: ArraySlice[int],
                    strides: ArraySlice[int],
                    padding: cstring,
                    data_format: cstring): MaxPool3DGrad[oT] {.header:"generated.h", importcpp:"MaxPool3DGrad(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPool3DGrad*[oT: MaxPool3DGradT](scope: Scope,
                    orig_input: MaxPool3DGradTInput,
                    orig_output: MaxPool3DGradTInput,
                    grad: oT,
                    ksize: openArray[int],
                    strides: openArray[int],
                    padding: cstring,
                    data_format: cstring = "NDHWC"): MaxPool3DGrad[oT] =
  return iimaxPool3DGrad(scope,
                         orig_input,
                         orig_output,
                         grad,
                         newArraySlice(ksize),
                         newArraySlice(strides),
                         padding,
                         data_format)

converter maxPool3DGradToOut*[oT: MaxPool3DGradT](op: MaxPool3DGrad[oT]): oT = return op.output


type InterleaveDataset*[oT:ovariant] {.header:"generated.h", importcpp:"InterleaveDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinterleaveDataset[oT: ovariant](scope: Scope,
                        input_dataset: oT,
                        other_arguments: oinvalid,
                        cycle_length: oint64,
                        block_length: oint64,
                        f: NameAttrList,
                        Targuments: ArraySlice[DType],
                        output_types: ArraySlice[DType],
                        output_shapes: ArraySlice[TensorShape]): InterleaveDataset[oT] {.header:"generated.h", importcpp:"InterleaveDataset(*#, #, #, #, #, #, #, #, #)", constructor.}

proc interleaveDataset*[oT: ovariant](scope: Scope,
                        input_dataset: oT,
                        other_arguments: oinvalid,
                        cycle_length: oint64,
                        block_length: oint64,
                        f: NameAttrList,
                        Targuments: openArray[DType],
                        output_types: openArray[DType],
                        output_shapes: openArray[TensorShape]): InterleaveDataset[oT] =
  return iiinterleaveDataset(scope,
                             input_dataset,
                             other_arguments,
                             cycle_length,
                             block_length,
                             f,
                             newArraySlice(Targuments),
                             newArraySlice(output_types),
                             newArraySlice(output_shapes))

converter interleaveDatasetToOut*[oT: ovariant](op: InterleaveDataset[oT]): oT = return op.output

type TanhGradT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type TanhGrad*[oT:TanhGradT] {.header:"generated.h", importcpp:"TanhGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitanhGrad[oT: TanhGradT](scope: Scope,
               y: oT,
               dy: oT): TanhGrad[oT] {.header:"generated.h", importcpp:"TanhGrad(*#, #, #)", constructor.}

proc tanhGrad*[oT: TanhGradT](scope: Scope,
               y: oT,
               dy: oT): TanhGrad[oT] =
  return iitanhGrad(scope,
                    y,
                    dy)

converter tanhGradToOut*[oT: TanhGradT](op: TanhGrad[oT]): oT = return op.output


type BoostedTreesTrainingPredict*[oT:ofloat] {.header:"generated.h", importcpp:"BoostedTreesTrainingPredict/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesTrainingPredict[oT: ofloat](scope: Scope,
                                  tree_ensemble_handle: oresource,
                                  cached_tree_ids: oint32,
                                  cached_node_ids: oint32,
                                  bucketized_features: oint32,
                                  num_bucketized_features: int64,
                                  logits_dimension: int64): BoostedTreesTrainingPredict[oT] {.header:"generated.h", importcpp:"BoostedTreesTrainingPredict(*#, #, #, #, #, #, #)", constructor.}

proc boostedTreesTrainingPredict*[oT: ofloat](scope: Scope,
                                  tree_ensemble_handle: oresource,
                                  cached_tree_ids: oint32,
                                  cached_node_ids: oint32,
                                  bucketized_features: oint32,
                                  num_bucketized_features: int64 = 0,
                                  logits_dimension: int64 = 0): BoostedTreesTrainingPredict[oT] =
  return iiboostedTreesTrainingPredict(scope,
                                       tree_ensemble_handle,
                                       cached_tree_ids,
                                       cached_node_ids,
                                       bucketized_features,
                                       num_bucketized_features,
                                       logits_dimension)

converter boostedTreesTrainingPredictToOut*[oT: ofloat](op: BoostedTreesTrainingPredict[oT]): oT = return op.output


type LoopCond*[oT:obool] {.header:"generated.h", importcpp:"LoopCond/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiloopCond[oT: obool](scope: Scope,
               input: oT): LoopCond[oT] {.header:"generated.h", importcpp:"LoopCond(*#, #)", constructor.}

proc loopCond*[oT: obool](scope: Scope,
               input: oT): LoopCond[oT] =
  return iiloopCond(scope,
                    input)

converter loopCondToOut*[oT: obool](op: LoopCond[oT]): oT = return op.output


type ParallelMapDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ParallelMapDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparallelMapDataset[oT: ovariant](scope: Scope,
                         input_dataset: oT,
                         other_arguments: oinvalid,
                         num_parallel_calls: oint32,
                         f: NameAttrList,
                         Targuments: ArraySlice[DType],
                         output_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape],
                         use_inter_op_parallelism: bool,
                         sloppy: bool,
                         preserve_cardinality: bool): ParallelMapDataset[oT] {.header:"generated.h", importcpp:"ParallelMapDataset(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc parallelMapDataset*[oT: ovariant](scope: Scope,
                         input_dataset: oT,
                         other_arguments: oinvalid,
                         num_parallel_calls: oint32,
                         f: NameAttrList,
                         Targuments: openArray[DType],
                         output_types: openArray[DType],
                         output_shapes: openArray[TensorShape],
                         use_inter_op_parallelism: bool = true,
                         sloppy: bool = false,
                         preserve_cardinality: bool = false): ParallelMapDataset[oT] =
  return iiparallelMapDataset(scope,
                              input_dataset,
                              other_arguments,
                              num_parallel_calls,
                              f,
                              newArraySlice(Targuments),
                              newArraySlice(output_types),
                              newArraySlice(output_shapes),
                              use_inter_op_parallelism,
                              sloppy,
                              preserve_cardinality)

converter parallelMapDatasetToOut*[oT: ovariant](op: ParallelMapDataset[oT]): oT = return op.output

type ReciprocalGradT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type ReciprocalGrad*[oT:ReciprocalGradT] {.header:"generated.h", importcpp:"ReciprocalGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireciprocalGrad[oT: ReciprocalGradT](scope: Scope,
                     y: oT,
                     dy: oT): ReciprocalGrad[oT] {.header:"generated.h", importcpp:"ReciprocalGrad(*#, #, #)", constructor.}

proc reciprocalGrad*[oT: ReciprocalGradT](scope: Scope,
                     y: oT,
                     dy: oT): ReciprocalGrad[oT] =
  return iireciprocalGrad(scope,
                          y,
                          dy)

converter reciprocalGradToOut*[oT: ReciprocalGradT](op: ReciprocalGrad[oT]): oT = return op.output

type QuantizedReshapeT = oall
type QuantizedReshapeTshape = oint32 | oint64

type QuantizedReshape*[oT:QuantizedReshapeT] {.header:"generated.h", importcpp:"QuantizedReshape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedReshape[oT: QuantizedReshapeT](scope: Scope,
                       tensor: oT,
                       shape: QuantizedReshapeTshape,
                       input_min: ofloat,
                       input_max: ofloat): QuantizedReshape[oT] {.header:"generated.h", importcpp:"QuantizedReshape(*#, #, #, #, #)", constructor.}

proc quantizedReshape*[oT: QuantizedReshapeT](scope: Scope,
                       tensor: oT,
                       shape: QuantizedReshapeTshape,
                       input_min: ofloat,
                       input_max: ofloat): QuantizedReshape[oT] =
  return iiquantizedReshape(scope,
                            tensor,
                            shape,
                            input_min,
                            input_max)

converter quantizedReshapeToOut*[oT: QuantizedReshapeT](op: QuantizedReshape[oT]): oT = return op.output


type MapDataset*[oT:ovariant] {.header:"generated.h", importcpp:"MapDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapDataset[oT: ovariant](scope: Scope,
                 input_dataset: oT,
                 other_arguments: oinvalid,
                 f: NameAttrList,
                 Targuments: ArraySlice[DType],
                 output_types: ArraySlice[DType],
                 output_shapes: ArraySlice[TensorShape],
                 use_inter_op_parallelism: bool,
                 preserve_cardinality: bool): MapDataset[oT] {.header:"generated.h", importcpp:"MapDataset(*#, #, #, #, #, #, #, #, #)", constructor.}

proc mapDataset*[oT: ovariant](scope: Scope,
                 input_dataset: oT,
                 other_arguments: oinvalid,
                 f: NameAttrList,
                 Targuments: openArray[DType],
                 output_types: openArray[DType],
                 output_shapes: openArray[TensorShape],
                 use_inter_op_parallelism: bool = true,
                 preserve_cardinality: bool = false): MapDataset[oT] =
  return iimapDataset(scope,
                      input_dataset,
                      other_arguments,
                      f,
                      newArraySlice(Targuments),
                      newArraySlice(output_types),
                      newArraySlice(output_shapes),
                      use_inter_op_parallelism,
                      preserve_cardinality)

converter mapDatasetToOut*[oT: ovariant](op: MapDataset[oT]): oT = return op.output


type SkipDataset*[oT:ovariant] {.header:"generated.h", importcpp:"SkipDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiskipDataset[oT: ovariant](scope: Scope,
                  input_dataset: oT,
                  count: oint64,
                  output_types: ArraySlice[DType],
                  output_shapes: ArraySlice[TensorShape]): SkipDataset[oT] {.header:"generated.h", importcpp:"SkipDataset(*#, #, #, #, #)", constructor.}

proc skipDataset*[oT: ovariant](scope: Scope,
                  input_dataset: oT,
                  count: oint64,
                  output_types: openArray[DType],
                  output_shapes: openArray[TensorShape]): SkipDataset[oT] =
  return iiskipDataset(scope,
                       input_dataset,
                       count,
                       newArraySlice(output_types),
                       newArraySlice(output_shapes))

converter skipDatasetToOut*[oT: ovariant](op: SkipDataset[oT]): oT = return op.output

type Conv2DBackpropFilterT = ohalf | obfloat16 | ofloat | odouble

type Conv2DBackpropFilter*[oT:Conv2DBackpropFilterT] {.header:"generated.h", importcpp:"Conv2DBackpropFilter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv2DBackpropFilter[oT: Conv2DBackpropFilterT](scope: Scope,
                           input: oT,
                           filter_sizes: oint32,
                           out_backprop: oT,
                           strides: ArraySlice[int],
                           padding: cstring,
                           dilations: ArraySlice[int],
                           use_cudnn_on_gpu: bool,
                           data_format: cstring): Conv2DBackpropFilter[oT] {.header:"generated.h", importcpp:"Conv2DBackpropFilter(*#, #, #, #, #, tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc conv2DBackpropFilter*[oT: Conv2DBackpropFilterT](scope: Scope,
                           input: oT,
                           filter_sizes: oint32,
                           out_backprop: oT,
                           strides: openArray[int],
                           padding: cstring,
                           dilations: openArray[int] = [1, 1, 1, 1],
                           use_cudnn_on_gpu: bool = true,
                           data_format: cstring = "NHWC"): Conv2DBackpropFilter[oT] =
  return iiconv2DBackpropFilter(scope,
                                input,
                                filter_sizes,
                                out_backprop,
                                newArraySlice(strides),
                                padding,
                                newArraySlice(dilations),
                                use_cudnn_on_gpu,
                                data_format)

converter conv2DBackpropFilterToOut*[oT: Conv2DBackpropFilterT](op: Conv2DBackpropFilter[oT]): oT = return op.output


type IteratorGetNextSync*[oT:oinvalid] {.header:"generated.h", importcpp:"IteratorGetNextSync/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorGetNextSync[oT: oinvalid](scope: Scope,
                          niterator: oresource,
                          output_types: ArraySlice[DType],
                          output_shapes: ArraySlice[TensorShape]): IteratorGetNextSync[oT] {.header:"generated.h", importcpp:"IteratorGetNextSync(*#, #, #, #)", constructor.}

proc iteratorGetNextSync*[oT: oinvalid](scope: Scope,
                          niterator: oresource,
                          output_types: openArray[DType],
                          output_shapes: openArray[TensorShape]): IteratorGetNextSync[oT] =
  return iiiteratorGetNextSync(scope,
                               niterator,
                               newArraySlice(output_types),
                               newArraySlice(output_shapes))

converter iteratorGetNextSyncToOut*[oT: oinvalid](op: IteratorGetNextSync[oT]): oT = return op.output


type ReaderNumRecordsProduced*[oT:oint64] {.header:"generated.h", importcpp:"ReaderNumRecordsProduced/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderNumRecordsProduced[oT: oint64](scope: Scope,
                               reader_handle: ostring): ReaderNumRecordsProduced[oT] {.header:"generated.h", importcpp:"ReaderNumRecordsProduced(*#, #)", constructor.}

proc readerNumRecordsProduced*[oT: oint64](scope: Scope,
                               reader_handle: ostring): ReaderNumRecordsProduced[oT] =
  return iireaderNumRecordsProduced(scope,
                                    reader_handle)

converter readerNumRecordsProducedToOut*[oT: oint64](op: ReaderNumRecordsProduced[oT]): oT = return op.output


type ModelDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ModelDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimodelDataset[oT: ovariant](scope: Scope,
                   input_dataset: oT,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): ModelDataset[oT] {.header:"generated.h", importcpp:"ModelDataset(*#, #, #, #)", constructor.}

proc modelDataset*[oT: ovariant](scope: Scope,
                   input_dataset: oT,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): ModelDataset[oT] =
  return iimodelDataset(scope,
                        input_dataset,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter modelDatasetToOut*[oT: ovariant](op: ModelDataset[oT]): oT = return op.output


type ReaderReadUpToV2*[oT:ostring] {.header:"generated.h", importcpp:"ReaderReadUpToV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderReadUpToV2[oT: ostring](scope: Scope,
                       reader_handle: oresource,
                       queue_handle: oresource,
                       num_records: oint64): ReaderReadUpToV2[oT] {.header:"generated.h", importcpp:"ReaderReadUpToV2(*#, #, #, #)", constructor.}

proc readerReadUpToV2*[oT: ostring](scope: Scope,
                       reader_handle: oresource,
                       queue_handle: oresource,
                       num_records: oint64): ReaderReadUpToV2[oT] =
  return iireaderReadUpToV2(scope,
                            reader_handle,
                            queue_handle,
                            num_records)

converter readerReadUpToV2ToOut*[oT: ostring](op: ReaderReadUpToV2[oT]): oT = return op.output


type QueueDequeueV2*[oT:oinvalid] {.header:"generated.h", importcpp:"QueueDequeueV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueDequeueV2[oT: oinvalid](scope: Scope,
                     handle: oresource,
                     component_types: ArraySlice[DType],
                     timeout_ms: int64): QueueDequeueV2[oT] {.header:"generated.h", importcpp:"QueueDequeueV2(*#, #, #, #)", constructor.}

proc queueDequeueV2*[oT: oinvalid](scope: Scope,
                     handle: oresource,
                     component_types: openArray[DType],
                     timeout_ms: int64 = -1): QueueDequeueV2[oT] =
  return iiqueueDequeueV2(scope,
                          handle,
                          newArraySlice(component_types),
                          timeout_ms)

converter queueDequeueV2ToOut*[oT: oinvalid](op: QueueDequeueV2[oT]): oT = return op.output


type ReaderReadUpTo*[oT:ostring] {.header:"generated.h", importcpp:"ReaderReadUpTo/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireaderReadUpTo[oT: ostring](scope: Scope,
                     reader_handle: oT,
                     queue_handle: oT,
                     num_records: oint64): ReaderReadUpTo[oT] {.header:"generated.h", importcpp:"ReaderReadUpTo(*#, #, #, #)", constructor.}

proc readerReadUpTo*[oT: ostring](scope: Scope,
                     reader_handle: oT,
                     queue_handle: oT,
                     num_records: oint64): ReaderReadUpTo[oT] =
  return iireaderReadUpTo(scope,
                          reader_handle,
                          queue_handle,
                          num_records)

converter readerReadUpToToOut*[oT: ostring](op: ReaderReadUpTo[oT]): oT = return op.output

type UnpackT = oall

type Unpack*[oT:UnpackT] {.header:"generated.h", importcpp:"Unpack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunpack[oT: UnpackT](scope: Scope,
             value: oT,
             num: int64,
             axis: int64): Unpack[oT] {.header:"generated.h", importcpp:"Unpack(*#, #, #, #)", constructor.}

proc unpack*[oT: UnpackT](scope: Scope,
             value: oT,
             num: int64 = 0,
             axis: int64 = 0): Unpack[oT] =
  return iiunpack(scope,
                  value,
                  num,
                  axis)

converter unpackToOut*[oT: UnpackT](op: Unpack[oT]): oT = return op.output


type ConcatenateDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ConcatenateDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconcatenateDataset[oT: ovariant](scope: Scope,
                         input_dataset: oT,
                         another_dataset: oT,
                         output_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape]): ConcatenateDataset[oT] {.header:"generated.h", importcpp:"ConcatenateDataset(*#, #, #, #, #)", constructor.}

proc concatenateDataset*[oT: ovariant](scope: Scope,
                         input_dataset: oT,
                         another_dataset: oT,
                         output_types: openArray[DType],
                         output_shapes: openArray[TensorShape]): ConcatenateDataset[oT] =
  return iiconcatenateDataset(scope,
                              input_dataset,
                              another_dataset,
                              newArraySlice(output_types),
                              newArraySlice(output_shapes))

converter concatenateDatasetToOut*[oT: ovariant](op: ConcatenateDataset[oT]): oT = return op.output

type PlaceholderV2dtype = oall

type PlaceholderV2*[oT:PlaceholderV2dtype] {.header:"generated.h", importcpp:"PlaceholderV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiplaceholderV2[oT: PlaceholderV2dtype](scope: Scope,
                    dtype: DType,
                    shape: TensorShape): PlaceholderV2[oT] {.header:"generated.h", importcpp:"PlaceholderV2(*#, #, #)", constructor.}

proc placeholderV2*[oT: PlaceholderV2dtype](scope: Scope,
                    dtype: DType = oT[].oTF,
                    shape: TensorShape = [].shape): PlaceholderV2[oT] =
  return iiplaceholderV2(scope,
                         dtype,
                         shape)

converter placeholderV2ToOut*[oT: PlaceholderV2dtype](op: PlaceholderV2[oT]): oT = return op.output


type GeneratorDataset*[oT:ovariant] {.header:"generated.h", importcpp:"GeneratorDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigeneratorDataset[oT: ovariant](scope: Scope,
                       init_func_other_args: oinvalid,
                       next_func_other_args: oinvalid,
                       finalize_func_other_args: oinvalid,
                       init_func: NameAttrList,
                       next_func: NameAttrList,
                       finalize_func: NameAttrList,
                       Tinit_func_args: ArraySlice[DType],
                       Tnext_func_args: ArraySlice[DType],
                       Tfinalize_func_args: ArraySlice[DType],
                       output_types: ArraySlice[DType],
                       output_shapes: ArraySlice[TensorShape]): GeneratorDataset[oT] {.header:"generated.h", importcpp:"GeneratorDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc generatorDataset*[oT: ovariant](scope: Scope,
                       init_func_other_args: oinvalid,
                       next_func_other_args: oinvalid,
                       finalize_func_other_args: oinvalid,
                       init_func: NameAttrList,
                       next_func: NameAttrList,
                       finalize_func: NameAttrList,
                       Tinit_func_args: openArray[DType],
                       Tnext_func_args: openArray[DType],
                       Tfinalize_func_args: openArray[DType],
                       output_types: openArray[DType],
                       output_shapes: openArray[TensorShape]): GeneratorDataset[oT] =
  return iigeneratorDataset(scope,
                            init_func_other_args,
                            next_func_other_args,
                            finalize_func_other_args,
                            init_func,
                            next_func,
                            finalize_func,
                            newArraySlice(Tinit_func_args),
                            newArraySlice(Tnext_func_args),
                            newArraySlice(Tfinalize_func_args),
                            newArraySlice(output_types),
                            newArraySlice(output_shapes))

converter generatorDatasetToOut*[oT: ovariant](op: GeneratorDataset[oT]): oT = return op.output


type TensorSliceDataset*[oT:ovariant] {.header:"generated.h", importcpp:"TensorSliceDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorSliceDataset[oT: ovariant](scope: Scope,
                         components: oinvalid,
                         Toutput_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape]): TensorSliceDataset[oT] {.header:"generated.h", importcpp:"TensorSliceDataset(*#, #, #, #)", constructor.}

proc tensorSliceDataset*[oT: ovariant](scope: Scope,
                         components: oinvalid,
                         Toutput_types: openArray[DType],
                         output_shapes: openArray[TensorShape]): TensorSliceDataset[oT] =
  return iitensorSliceDataset(scope,
                              components,
                              newArraySlice(Toutput_types),
                              newArraySlice(output_shapes))

converter tensorSliceDatasetToOut*[oT: ovariant](op: TensorSliceDataset[oT]): oT = return op.output


type StringToHashBucket*[oT:oint64] {.header:"generated.h", importcpp:"StringToHashBucket/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringToHashBucket[oT: oint64](scope: Scope,
                         string_tensor: ostring,
                         num_buckets: int64): StringToHashBucket[oT] {.header:"generated.h", importcpp:"StringToHashBucket(*#, #, #)", constructor.}

proc stringToHashBucket*[oT: oint64](scope: Scope,
                         string_tensor: ostring,
                         num_buckets: int64 = 0): StringToHashBucket[oT] =
  return iistringToHashBucket(scope,
                              string_tensor,
                              num_buckets)

converter stringToHashBucketToOut*[oT: oint64](op: StringToHashBucket[oT]): oT = return op.output

type SoftsignT = ohalf | obfloat16 | ofloat | odouble

type Softsign*[oT:SoftsignT] {.header:"generated.h", importcpp:"Softsign/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisoftsign[oT: SoftsignT](scope: Scope,
               features: oT): Softsign[oT] {.header:"generated.h", importcpp:"Softsign(*#, #)", constructor.}

proc softsign*[oT: SoftsignT](scope: Scope,
               features: oT): Softsign[oT] =
  return iisoftsign(scope,
                    features)

converter softsignToOut*[oT: SoftsignT](op: Softsign[oT]): oT = return op.output

type QuantizedAddT1 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedAddT2 = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedAddToutput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedAdd*[oT:QuantizedAddToutput] {.header:"generated.h", importcpp:"QuantizedAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedAdd[oT: QuantizedAddToutput](scope: Scope,
                   x: QuantizedAddT1,
                   y: QuantizedAddT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat): QuantizedAdd[oT] {.header:"generated.h", importcpp:"QuantizedAdd(*#, #, #, #, #, #, #)", constructor.}

proc quantizedAdd*[oT: QuantizedAddToutput](scope: Scope,
                   x: QuantizedAddT1,
                   y: QuantizedAddT2,
                   min_x: ofloat,
                   max_x: ofloat,
                   min_y: ofloat,
                   max_y: ofloat): QuantizedAdd[oT] =
  return iiquantizedAdd(scope,
                        x,
                        y,
                        min_x,
                        max_x,
                        min_y,
                        max_y)

converter quantizedAddToOut*[oT: QuantizedAddToutput](op: QuantizedAdd[oT]): oT = return op.output


type RandomShuffleQueueV2*[oT:oresource] {.header:"generated.h", importcpp:"RandomShuffleQueueV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomShuffleQueueV2[oT: oresource](scope: Scope,
                           component_types: ArraySlice[DType],
                           shapes: ArraySlice[TensorShape],
                           container: cstring,
                           shared_name: cstring,
                           capacity: int64,
                           min_after_dequeue: int64,
                           seed: int64,
                           seed2: int64): RandomShuffleQueueV2[oT] {.header:"generated.h", importcpp:"RandomShuffleQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc randomShuffleQueueV2*[oT: oresource](scope: Scope,
                           component_types: openArray[DType],
                           shapes: openArray[TensorShape],
                           container: cstring,
                           shared_name: cstring,
                           capacity: int64 = -1,
                           min_after_dequeue: int64 = 0,
                           seed: int64 = 0,
                           seed2: int64 = 0): RandomShuffleQueueV2[oT] =
  return iirandomShuffleQueueV2(scope,
                                newArraySlice(component_types),
                                newArraySlice(shapes),
                                container,
                                shared_name,
                                capacity,
                                min_after_dequeue,
                                seed,
                                seed2)

converter randomShuffleQueueV2ToOut*[oT: oresource](op: RandomShuffleQueueV2[oT]): oT = return op.output

type SparseTensorSliceDatasetTvalues = oall

type SparseTensorSliceDataset*[oT:ovariant] {.header:"generated.h", importcpp:"SparseTensorSliceDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseTensorSliceDataset[oT: ovariant](scope: Scope,
                               indices: oint64,
                               values: SparseTensorSliceDatasetTvalues,
                               dense_shape: oint64): SparseTensorSliceDataset[oT] {.header:"generated.h", importcpp:"SparseTensorSliceDataset(*#, #, #, #)", constructor.}

proc sparseTensorSliceDataset*[oT: ovariant](scope: Scope,
                               indices: oint64,
                               values: SparseTensorSliceDatasetTvalues,
                               dense_shape: oint64): SparseTensorSliceDataset[oT] =
  return iisparseTensorSliceDataset(scope,
                                    indices,
                                    values,
                                    dense_shape)

converter sparseTensorSliceDatasetToOut*[oT: ovariant](op: SparseTensorSliceDataset[oT]): oT = return op.output


type TensorDataset*[oT:ovariant] {.header:"generated.h", importcpp:"TensorDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorDataset[oT: ovariant](scope: Scope,
                    components: oinvalid,
                    Toutput_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): TensorDataset[oT] {.header:"generated.h", importcpp:"TensorDataset(*#, #, #, #)", constructor.}

proc tensorDataset*[oT: ovariant](scope: Scope,
                    components: oinvalid,
                    Toutput_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): TensorDataset[oT] =
  return iitensorDataset(scope,
                         components,
                         newArraySlice(Toutput_types),
                         newArraySlice(output_shapes))

converter tensorDatasetToOut*[oT: ovariant](op: TensorDataset[oT]): oT = return op.output

type TensorListElementShapeshape_type = oint32 | oint64

type TensorListElementShape*[oT:TensorListElementShapeshape_type] {.header:"generated.h", importcpp:"TensorListElementShape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListElementShape[oT: TensorListElementShapeshape_type](scope: Scope,
                             input_handle: ovariant): TensorListElementShape[oT] {.header:"generated.h", importcpp:"TensorListElementShape(*#, #)", constructor.}

proc tensorListElementShape*[oT: TensorListElementShapeshape_type](scope: Scope,
                             input_handle: ovariant): TensorListElementShape[oT] =
  return iitensorListElementShape(scope,
                                  input_handle)

converter tensorListElementShapeToOut*[oT: TensorListElementShapeshape_type](op: TensorListElementShape[oT]): oT = return op.output

type NcclReduceT = ohalf | ofloat | odouble | oint32 | oint64

type NcclReduce*[oT:NcclReduceT] {.header:"generated.h", importcpp:"NcclReduce/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iincclReduce[oT: NcclReduceT](scope: Scope,
                 input: oT,
                 reduction: cstring,
                 num_devices: int64): NcclReduce[oT] {.header:"generated.h", importcpp:"NcclReduce(*#, #, tensorflow::string(#), #)", constructor.}

proc ncclReduce*[oT: NcclReduceT](scope: Scope,
                 input: oT,
                 reduction: cstring,
                 num_devices: int64 = 0): NcclReduce[oT] =
  return iincclReduce(scope,
                      input,
                      reduction,
                      num_devices)

converter ncclReduceToOut*[oT: NcclReduceT](op: NcclReduce[oT]): oT = return op.output

type ApplyProximalAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyProximalAdagrad*[oT:ApplyProximalAdagradT] {.header:"generated.h", importcpp:"ApplyProximalAdagrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyProximalAdagrad[oT: ApplyProximalAdagradT](scope: Scope,
                           nvar: oT,
                           accum: oT,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           grad: oT,
                           use_locking: bool): ApplyProximalAdagrad[oT] {.header:"generated.h", importcpp:"ApplyProximalAdagrad(*#, #, #, #, #, #, #, #)", constructor.}

proc applyProximalAdagrad*[oT: ApplyProximalAdagradT](scope: Scope,
                           nvar: oT,
                           accum: oT,
                           lr: oT,
                           l1: oT,
                           l2: oT,
                           grad: oT,
                           use_locking: bool = false): ApplyProximalAdagrad[oT] =
  return iiapplyProximalAdagrad(scope,
                                nvar,
                                accum,
                                lr,
                                l1,
                                l2,
                                grad,
                                use_locking)

converter applyProximalAdagradToOut*[oT: ApplyProximalAdagradT](op: ApplyProximalAdagrad[oT]): oT = return op.output

type SvdT = odouble | ofloat | ocomplex64 | ocomplex128

type Svd*[oT:SvdT] {.header:"generated.h", importcpp:"Svd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisvd[oT: SvdT](scope: Scope,
          input: oT,
          compute_uv: bool,
          full_matrices: bool): Svd[oT] {.header:"generated.h", importcpp:"Svd(*#, #, #, #)", constructor.}

proc svd*[oT: SvdT](scope: Scope,
          input: oT,
          compute_uv: bool = true,
          full_matrices: bool = false): Svd[oT] =
  return iisvd(scope,
               input,
               compute_uv,
               full_matrices)

converter svdToOut*[oT: SvdT](op: Svd[oT]): oT = return op.output

type SparseSegmentMeanGradT = ofloat | odouble
type SparseSegmentMeanGradTidx = oint32 | oint64

type SparseSegmentMeanGrad*[oT:SparseSegmentMeanGradT] {.header:"generated.h", importcpp:"SparseSegmentMeanGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentMeanGrad[oT: SparseSegmentMeanGradT](scope: Scope,
                            grad: oT,
                            indices: SparseSegmentMeanGradTidx,
                            segment_ids: oint32,
                            output_dim0: oint32): SparseSegmentMeanGrad[oT] {.header:"generated.h", importcpp:"SparseSegmentMeanGrad(*#, #, #, #, #)", constructor.}

proc sparseSegmentMeanGrad*[oT: SparseSegmentMeanGradT](scope: Scope,
                            grad: oT,
                            indices: SparseSegmentMeanGradTidx,
                            segment_ids: oint32,
                            output_dim0: oint32): SparseSegmentMeanGrad[oT] =
  return iisparseSegmentMeanGrad(scope,
                                 grad,
                                 indices,
                                 segment_ids,
                                 output_dim0)

converter sparseSegmentMeanGradToOut*[oT: SparseSegmentMeanGradT](op: SparseSegmentMeanGrad[oT]): oT = return op.output

type MatrixExponentialT = odouble | ofloat | ocomplex64 | ocomplex128

type MatrixExponential*[oT:MatrixExponentialT] {.header:"generated.h", importcpp:"MatrixExponential/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixExponential[oT: MatrixExponentialT](scope: Scope,
                        input: oT): MatrixExponential[oT] {.header:"generated.h", importcpp:"MatrixExponential(*#, #)", constructor.}

proc matrixExponential*[oT: MatrixExponentialT](scope: Scope,
                        input: oT): MatrixExponential[oT] =
  return iimatrixExponential(scope,
                             input)

converter matrixExponentialToOut*[oT: MatrixExponentialT](op: MatrixExponential[oT]): oT = return op.output

type GatherNdTparams = oall
type GatherNdTindices = oint32 | oint64

type GatherNd*[oT:GatherNdTparams] {.header:"generated.h", importcpp:"GatherNd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigatherNd[oT: GatherNdTparams](scope: Scope,
               params: oT,
               indices: GatherNdTindices): GatherNd[oT] {.header:"generated.h", importcpp:"GatherNd(*#, #, #)", constructor.}

proc gatherNd*[oT: GatherNdTparams](scope: Scope,
               params: oT,
               indices: GatherNdTindices): GatherNd[oT] =
  return iigatherNd(scope,
                    params,
                    indices)

converter gatherNdToOut*[oT: GatherNdTparams](op: GatherNd[oT]): oT = return op.output


type QueueCloseV2*{.header:"generated.h", importcpp:"QueueCloseV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiqueueCloseV2(scope: Scope,
                   handle: oresource,
                   cancel_pending_enqueues: bool): QueueCloseV2 {.header:"generated.h", importcpp:"QueueCloseV2(*#, #, #)", constructor.}

proc queueCloseV2*(scope: Scope,
                   handle: oresource,
                   cancel_pending_enqueues: bool = false): QueueCloseV2 =
  return iiqueueCloseV2(scope,
                        handle,
                        cancel_pending_enqueues)



type MaxPoolT = ohalf | obfloat16 | ofloat | odouble | oint32 | oint64 | ouint8 | oint16 | oint8 | ouint16 | oqint8

type MaxPool*[oT:MaxPoolT] {.header:"generated.h", importcpp:"MaxPool/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPool[oT: MaxPoolT](scope: Scope,
              input: oT,
              ksize: ArraySlice[int],
              strides: ArraySlice[int],
              padding: cstring,
              data_format: cstring): MaxPool[oT] {.header:"generated.h", importcpp:"MaxPool(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc maxPool*[oT: MaxPoolT](scope: Scope,
              input: oT,
              ksize: openArray[int],
              strides: openArray[int],
              padding: cstring,
              data_format: cstring = "NHWC"): MaxPool[oT] =
  return iimaxPool(scope,
                   input,
                   newArraySlice(ksize),
                   newArraySlice(strides),
                   padding,
                   data_format)

converter maxPoolToOut*[oT: MaxPoolT](op: MaxPool[oT]): oT = return op.output


type OrderedMapClear*{.header:"generated.h", importcpp:"OrderedMapClear/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiorderedMapClear(scope: Scope,
                      dtypes: ArraySlice[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64,
                      memory_limit: int64): OrderedMapClear {.header:"generated.h", importcpp:"OrderedMapClear(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapClear*(scope: Scope,
                      dtypes: openArray[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = 0,
                      memory_limit: int64 = 0): OrderedMapClear =
  return iiorderedMapClear(scope,
                           newArraySlice(dtypes),
                           container,
                           shared_name,
                           capacity,
                           memory_limit)




type OrderedMapSize*[oT:oint32] {.header:"generated.h", importcpp:"OrderedMapSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiorderedMapSize[oT: oint32](scope: Scope,
                     dtypes: ArraySlice[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64,
                     memory_limit: int64): OrderedMapSize[oT] {.header:"generated.h", importcpp:"OrderedMapSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapSize*[oT: oint32](scope: Scope,
                     dtypes: openArray[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64 = 0,
                     memory_limit: int64 = 0): OrderedMapSize[oT] =
  return iiorderedMapSize(scope,
                          newArraySlice(dtypes),
                          container,
                          shared_name,
                          capacity,
                          memory_limit)

converter orderedMapSizeToOut*[oT: oint32](op: OrderedMapSize[oT]): oT = return op.output


type TensorArrayCloseV3*{.header:"generated.h", importcpp:"TensorArrayCloseV3/*'0*/".} = object
  operation: Operation[oinvalid]


proc iitensorArrayCloseV3(scope: Scope,
                         handle: oresource): TensorArrayCloseV3 {.header:"generated.h", importcpp:"TensorArrayCloseV3(*#, #)", constructor.}

proc tensorArrayCloseV3*(scope: Scope,
                         handle: oresource): TensorArrayCloseV3 =
  return iitensorArrayCloseV3(scope,
                              handle)




type SaveV2*{.header:"generated.h", importcpp:"SaveV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iisaveV2(scope: Scope,
             prefix: ostring,
             tensor_names: ostring,
             shape_and_slices: ostring,
             tensors: oinvalid,
             dtypes: ArraySlice[DType]): SaveV2 {.header:"generated.h", importcpp:"SaveV2(*#, #, #, #, #, #)", constructor.}

proc saveV2*(scope: Scope,
             prefix: ostring,
             tensor_names: ostring,
             shape_and_slices: ostring,
             tensors: oinvalid,
             dtypes: openArray[DType]): SaveV2 =
  return iisaveV2(scope,
                  prefix,
                  tensor_names,
                  shape_and_slices,
                  tensors,
                  newArraySlice(dtypes))




type OrderedMapStage*{.header:"generated.h", importcpp:"OrderedMapStage/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiorderedMapStage(scope: Scope,
                      key: oint64,
                      indices: oint32,
                      values: oinvalid,
                      dtypes: ArraySlice[DType],
                      fake_dtypes: ArraySlice[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64,
                      memory_limit: int64): OrderedMapStage {.header:"generated.h", importcpp:"OrderedMapStage(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapStage*(scope: Scope,
                      key: oint64,
                      indices: oint32,
                      values: oinvalid,
                      dtypes: openArray[DType],
                      fake_dtypes: openArray[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = 0,
                      memory_limit: int64 = 0): OrderedMapStage =
  return iiorderedMapStage(scope,
                           key,
                           indices,
                           values,
                           newArraySlice(dtypes),
                           newArraySlice(fake_dtypes),
                           container,
                           shared_name,
                           capacity,
                           memory_limit)



type RandomGammaS = oint32 | oint64
type RandomGammaT = ohalf | ofloat | odouble

type RandomGamma*[oT:RandomGammaT] {.header:"generated.h", importcpp:"RandomGamma/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomGamma[oT: RandomGammaT](scope: Scope,
                  shape: RandomGammaS,
                  alpha: oT,
                  seed: int64,
                  seed2: int64): RandomGamma[oT] {.header:"generated.h", importcpp:"RandomGamma(*#, #, #, #, #)", constructor.}

proc randomGamma*[oT: RandomGammaT](scope: Scope,
                  shape: RandomGammaS,
                  alpha: oT,
                  seed: int64 = 0,
                  seed2: int64 = 0): RandomGamma[oT] =
  return iirandomGamma(scope,
                       shape,
                       alpha,
                       seed,
                       seed2)

converter randomGammaToOut*[oT: RandomGammaT](op: RandomGamma[oT]): oT = return op.output

type QuantizedResizeBilinearT = oquint8 | oqint32 | ofloat

type QuantizedResizeBilinear*[oT:QuantizedResizeBilinearT] {.header:"generated.h", importcpp:"QuantizedResizeBilinear/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedResizeBilinear[oT: QuantizedResizeBilinearT](scope: Scope,
                              images: oT,
                              size: oint32,
                              min: ofloat,
                              max: ofloat,
                              align_corners: bool): QuantizedResizeBilinear[oT] {.header:"generated.h", importcpp:"QuantizedResizeBilinear(*#, #, #, #, #, #)", constructor.}

proc quantizedResizeBilinear*[oT: QuantizedResizeBilinearT](scope: Scope,
                              images: oT,
                              size: oint32,
                              min: ofloat,
                              max: ofloat,
                              align_corners: bool = false): QuantizedResizeBilinear[oT] =
  return iiquantizedResizeBilinear(scope,
                                   images,
                                   size,
                                   min,
                                   max,
                                   align_corners)

converter quantizedResizeBilinearToOut*[oT: QuantizedResizeBilinearT](op: QuantizedResizeBilinear[oT]): oT = return op.output


type OrderedMapIncompleteSize*[oT:oint32] {.header:"generated.h", importcpp:"OrderedMapIncompleteSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiorderedMapIncompleteSize[oT: oint32](scope: Scope,
                               dtypes: ArraySlice[DType],
                               container: cstring,
                               shared_name: cstring,
                               capacity: int64,
                               memory_limit: int64): OrderedMapIncompleteSize[oT] {.header:"generated.h", importcpp:"OrderedMapIncompleteSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapIncompleteSize*[oT: oint32](scope: Scope,
                               dtypes: openArray[DType],
                               container: cstring,
                               shared_name: cstring,
                               capacity: int64 = 0,
                               memory_limit: int64 = 0): OrderedMapIncompleteSize[oT] =
  return iiorderedMapIncompleteSize(scope,
                                    newArraySlice(dtypes),
                                    container,
                                    shared_name,
                                    capacity,
                                    memory_limit)

converter orderedMapIncompleteSizeToOut*[oT: oint32](op: OrderedMapIncompleteSize[oT]): oT = return op.output


type MapIncompleteSize*[oT:oint32] {.header:"generated.h", importcpp:"MapIncompleteSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapIncompleteSize[oT: oint32](scope: Scope,
                        dtypes: ArraySlice[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64,
                        memory_limit: int64): MapIncompleteSize[oT] {.header:"generated.h", importcpp:"MapIncompleteSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapIncompleteSize*[oT: oint32](scope: Scope,
                        dtypes: openArray[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64 = 0,
                        memory_limit: int64 = 0): MapIncompleteSize[oT] =
  return iimapIncompleteSize(scope,
                             newArraySlice(dtypes),
                             container,
                             shared_name,
                             capacity,
                             memory_limit)

converter mapIncompleteSizeToOut*[oT: oint32](op: MapIncompleteSize[oT]): oT = return op.output

type MatrixInverseT = odouble | ofloat | ocomplex64 | ocomplex128

type MatrixInverse*[oT:MatrixInverseT] {.header:"generated.h", importcpp:"MatrixInverse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixInverse[oT: MatrixInverseT](scope: Scope,
                    input: oT,
                    adjoint: bool): MatrixInverse[oT] {.header:"generated.h", importcpp:"MatrixInverse(*#, #, #)", constructor.}

proc matrixInverse*[oT: MatrixInverseT](scope: Scope,
                    input: oT,
                    adjoint: bool = false): MatrixInverse[oT] =
  return iimatrixInverse(scope,
                         input,
                         adjoint)

converter matrixInverseToOut*[oT: MatrixInverseT](op: MatrixInverse[oT]): oT = return op.output

type ApplyMomentumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyMomentum*[oT:ApplyMomentumT] {.header:"generated.h", importcpp:"ApplyMomentum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyMomentum[oT: ApplyMomentumT](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    lr: oT,
                    grad: oT,
                    momentum: oT,
                    use_nesterov: bool,
                    use_locking: bool): ApplyMomentum[oT] {.header:"generated.h", importcpp:"ApplyMomentum(*#, #, #, #, #, #, #, #)", constructor.}

proc applyMomentum*[oT: ApplyMomentumT](scope: Scope,
                    nvar: oT,
                    accum: oT,
                    lr: oT,
                    grad: oT,
                    momentum: oT,
                    use_nesterov: bool = false,
                    use_locking: bool = false): ApplyMomentum[oT] =
  return iiapplyMomentum(scope,
                         nvar,
                         accum,
                         lr,
                         grad,
                         momentum,
                         use_nesterov,
                         use_locking)

converter applyMomentumToOut*[oT: ApplyMomentumT](op: ApplyMomentum[oT]): oT = return op.output

type AcosT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Acos*[oT:AcosT] {.header:"generated.h", importcpp:"Acos/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiacos[oT: AcosT](scope: Scope,
           x: oT): Acos[oT] {.header:"generated.h", importcpp:"Acos(*#, #)", constructor.}

proc acos*[oT: AcosT](scope: Scope,
           x: oT): Acos[oT] =
  return iiacos(scope,
                x)

converter acosToOut*[oT: AcosT](op: Acos[oT]): oT = return op.output


type ExperimentalGroupByWindowDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalGroupByWindowDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalGroupByWindowDataset[oT: ovariant](scope: Scope,
                                       input_dataset: oT,
                                       key_func_other_arguments: oinvalid,
                                       reduce_func_other_arguments: oinvalid,
                                       window_size_func_other_arguments: oinvalid,
                                       key_func: NameAttrList,
                                       reduce_func: NameAttrList,
                                       window_size_func: NameAttrList,
                                       Tkey_func_other_arguments: ArraySlice[DType],
                                       Treduce_func_other_arguments: ArraySlice[DType],
                                       Twindow_size_func_other_arguments: ArraySlice[DType],
                                       output_types: ArraySlice[DType],
                                       output_shapes: ArraySlice[TensorShape]): ExperimentalGroupByWindowDataset[oT] {.header:"generated.h", importcpp:"ExperimentalGroupByWindowDataset(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalGroupByWindowDataset*[oT: ovariant](scope: Scope,
                                       input_dataset: oT,
                                       key_func_other_arguments: oinvalid,
                                       reduce_func_other_arguments: oinvalid,
                                       window_size_func_other_arguments: oinvalid,
                                       key_func: NameAttrList,
                                       reduce_func: NameAttrList,
                                       window_size_func: NameAttrList,
                                       Tkey_func_other_arguments: openArray[DType],
                                       Treduce_func_other_arguments: openArray[DType],
                                       Twindow_size_func_other_arguments: openArray[DType],
                                       output_types: openArray[DType],
                                       output_shapes: openArray[TensorShape]): ExperimentalGroupByWindowDataset[oT] =
  return iiexperimentalGroupByWindowDataset(scope,
                                            input_dataset,
                                            key_func_other_arguments,
                                            reduce_func_other_arguments,
                                            window_size_func_other_arguments,
                                            key_func,
                                            reduce_func,
                                            window_size_func,
                                            newArraySlice(Tkey_func_other_arguments),
                                            newArraySlice(Treduce_func_other_arguments),
                                            newArraySlice(Twindow_size_func_other_arguments),
                                            newArraySlice(output_types),
                                            newArraySlice(output_shapes))

converter experimentalGroupByWindowDatasetToOut*[oT: ovariant](op: ExperimentalGroupByWindowDataset[oT]): oT = return op.output

type ResourceApplyAdamWithAmsgradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdamWithAmsgrad*{.header:"generated.h", importcpp:"ResourceApplyAdamWithAmsgrad/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAdamWithAmsgrad(scope: Scope,
                                   nvar: oresource,
                                   m: oresource,
                                   v: oresource,
                                   vhat: oresource,
                                   beta1_power: ResourceApplyAdamWithAmsgradT,
                                   beta2_power: ResourceApplyAdamWithAmsgradT,
                                   lr: ResourceApplyAdamWithAmsgradT,
                                   beta1: ResourceApplyAdamWithAmsgradT,
                                   beta2: ResourceApplyAdamWithAmsgradT,
                                   epsilon: ResourceApplyAdamWithAmsgradT,
                                   grad: ResourceApplyAdamWithAmsgradT,
                                   use_locking: bool): ResourceApplyAdamWithAmsgrad {.header:"generated.h", importcpp:"ResourceApplyAdamWithAmsgrad(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdamWithAmsgrad*(scope: Scope,
                                   nvar: oresource,
                                   m: oresource,
                                   v: oresource,
                                   vhat: oresource,
                                   beta1_power: ResourceApplyAdamWithAmsgradT,
                                   beta2_power: ResourceApplyAdamWithAmsgradT,
                                   lr: ResourceApplyAdamWithAmsgradT,
                                   beta1: ResourceApplyAdamWithAmsgradT,
                                   beta2: ResourceApplyAdamWithAmsgradT,
                                   epsilon: ResourceApplyAdamWithAmsgradT,
                                   grad: ResourceApplyAdamWithAmsgradT,
                                   use_locking: bool = false): ResourceApplyAdamWithAmsgrad =
  return iiresourceApplyAdamWithAmsgrad(scope,
                                        nvar,
                                        m,
                                        v,
                                        vhat,
                                        beta1_power,
                                        beta2_power,
                                        lr,
                                        beta1,
                                        beta2,
                                        epsilon,
                                        grad,
                                        use_locking)



type INcclBroadcastRecvT = ohalf | ofloat | odouble | oint32 | oint64

type INcclBroadcastRecv*[oT:INcclBroadcastRecvT] {.header:"generated.h", importcpp:"_NcclBroadcastRecv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiNcclBroadcastRecv[oT: INcclBroadcastRecvT](scope: Scope,
                         shape: oint32,
                         shared_name: cstring,
                         num_devices: int64): INcclBroadcastRecv[oT] {.header:"generated.h", importcpp:"_NcclBroadcastRecv(*#, #, tensorflow::string(#), #)", constructor.}

proc iNcclBroadcastRecv*[oT: INcclBroadcastRecvT](scope: Scope,
                         shape: oint32,
                         shared_name: cstring,
                         num_devices: int64 = 0): INcclBroadcastRecv[oT] =
  return iiiNcclBroadcastRecv(scope,
                              shape,
                              shared_name,
                              num_devices)

converter iNcclBroadcastRecvToOut*[oT: INcclBroadcastRecvT](op: INcclBroadcastRecv[oT]): oT = return op.output

type SegmentSumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SegmentSumTindices = oint32 | oint64

type SegmentSum*[oT:SegmentSumT] {.header:"generated.h", importcpp:"SegmentSum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisegmentSum[oT: SegmentSumT](scope: Scope,
                 data: oT,
                 segment_ids: SegmentSumTindices): SegmentSum[oT] {.header:"generated.h", importcpp:"SegmentSum(*#, #, #)", constructor.}

proc segmentSum*[oT: SegmentSumT](scope: Scope,
                 data: oT,
                 segment_ids: SegmentSumTindices): SegmentSum[oT] =
  return iisegmentSum(scope,
                      data,
                      segment_ids)

converter segmentSumToOut*[oT: SegmentSumT](op: SegmentSum[oT]): oT = return op.output


type TextLineDataset*[oT:ovariant] {.header:"generated.h", importcpp:"TextLineDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitextLineDataset[oT: ovariant](scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TextLineDataset[oT] {.header:"generated.h", importcpp:"TextLineDataset(*#, #, #, #)", constructor.}

proc textLineDataset*[oT: ovariant](scope: Scope,
                      filenames: ostring,
                      compression_type: ostring,
                      buffer_size: oint64): TextLineDataset[oT] =
  return iitextLineDataset(scope,
                           filenames,
                           compression_type,
                           buffer_size)

converter textLineDatasetToOut*[oT: ovariant](op: TextLineDataset[oT]): oT = return op.output

type TensorSummaryV2T = oall

type TensorSummaryV2*[oT:ostring] {.header:"generated.h", importcpp:"TensorSummaryV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorSummaryV2[oT: ostring](scope: Scope,
                      tag: oT,
                      tensor: TensorSummaryV2T,
                      serialized_summary_metadata: oT): TensorSummaryV2[oT] {.header:"generated.h", importcpp:"TensorSummaryV2(*#, #, #, #)", constructor.}

proc tensorSummaryV2*[oT: ostring](scope: Scope,
                      tag: oT,
                      tensor: TensorSummaryV2T,
                      serialized_summary_metadata: oT): TensorSummaryV2[oT] =
  return iitensorSummaryV2(scope,
                           tag,
                           tensor,
                           serialized_summary_metadata)

converter tensorSummaryV2ToOut*[oT: ostring](op: TensorSummaryV2[oT]): oT = return op.output

type UnbatchT = oall

type Unbatch*[oT:UnbatchT] {.header:"generated.h", importcpp:"Unbatch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunbatch[oT: UnbatchT](scope: Scope,
              batched_tensor: oT,
              batch_index: oint64,
              id: oint64,
              container: cstring,
              shared_name: cstring,
              timeout_micros: int64): Unbatch[oT] {.header:"generated.h", importcpp:"Unbatch(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc unbatch*[oT: UnbatchT](scope: Scope,
              batched_tensor: oT,
              batch_index: oint64,
              id: oint64,
              container: cstring,
              shared_name: cstring,
              timeout_micros: int64 = 0): Unbatch[oT] =
  return iiunbatch(scope,
                   batched_tensor,
                   batch_index,
                   id,
                   container,
                   shared_name,
                   timeout_micros)

converter unbatchToOut*[oT: UnbatchT](op: Unbatch[oT]): oT = return op.output


type MapUnstage*[oT:oinvalid] {.header:"generated.h", importcpp:"MapUnstage/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapUnstage[oT: oinvalid](scope: Scope,
                 key: oint64,
                 indices: oint32,
                 dtypes: ArraySlice[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64,
                 memory_limit: int64): MapUnstage[oT] {.header:"generated.h", importcpp:"MapUnstage(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapUnstage*[oT: oinvalid](scope: Scope,
                 key: oint64,
                 indices: oint32,
                 dtypes: openArray[DType],
                 container: cstring,
                 shared_name: cstring,
                 capacity: int64 = 0,
                 memory_limit: int64 = 0): MapUnstage[oT] =
  return iimapUnstage(scope,
                      key,
                      indices,
                      newArraySlice(dtypes),
                      container,
                      shared_name,
                      capacity,
                      memory_limit)

converter mapUnstageToOut*[oT: oinvalid](op: MapUnstage[oT]): oT = return op.output

type TopKT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type TopK*[oT:TopKT] {.header:"generated.h", importcpp:"TopK/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitopK[oT: TopKT](scope: Scope,
           input: oT,
           k: int64,
           sorted: bool): TopK[oT] {.header:"generated.h", importcpp:"TopK(*#, #, #, #)", constructor.}

proc topK*[oT: TopKT](scope: Scope,
           input: oT,
           k: int64 = 0,
           sorted: bool = true): TopK[oT] =
  return iitopK(scope,
                input,
                k,
                sorted)

converter topKToOut*[oT: TopKT](op: TopK[oT]): oT = return op.output

type ConjugateTransposeT = oall
type ConjugateTransposeTperm = oint32 | oint64

type ConjugateTranspose*[oT:ConjugateTransposeT] {.header:"generated.h", importcpp:"ConjugateTranspose/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconjugateTranspose[oT: ConjugateTransposeT](scope: Scope,
                         x: oT,
                         perm: ConjugateTransposeTperm): ConjugateTranspose[oT] {.header:"generated.h", importcpp:"ConjugateTranspose(*#, #, #)", constructor.}

proc conjugateTranspose*[oT: ConjugateTransposeT](scope: Scope,
                         x: oT,
                         perm: ConjugateTransposeTperm): ConjugateTranspose[oT] =
  return iiconjugateTranspose(scope,
                              x,
                              perm)

converter conjugateTransposeToOut*[oT: ConjugateTransposeT](op: ConjugateTranspose[oT]): oT = return op.output


type MapPeek*[oT:oinvalid] {.header:"generated.h", importcpp:"MapPeek/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapPeek[oT: oinvalid](scope: Scope,
              key: oint64,
              indices: oint32,
              dtypes: ArraySlice[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64,
              memory_limit: int64): MapPeek[oT] {.header:"generated.h", importcpp:"MapPeek(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapPeek*[oT: oinvalid](scope: Scope,
              key: oint64,
              indices: oint32,
              dtypes: openArray[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = 0,
              memory_limit: int64 = 0): MapPeek[oT] =
  return iimapPeek(scope,
                   key,
                   indices,
                   newArraySlice(dtypes),
                   container,
                   shared_name,
                   capacity,
                   memory_limit)

converter mapPeekToOut*[oT: oinvalid](op: MapPeek[oT]): oT = return op.output

type SparseTensorDenseMatMulTindices = oint32 | oint64
type SparseTensorDenseMatMulT = oall

type SparseTensorDenseMatMul*[oT:SparseTensorDenseMatMulT] {.header:"generated.h", importcpp:"SparseTensorDenseMatMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseTensorDenseMatMul[oT: SparseTensorDenseMatMulT](scope: Scope,
                              a_indices: SparseTensorDenseMatMulTindices,
                              a_values: oT,
                              a_shape: oint64,
                              b: oT,
                              adjoint_a: bool,
                              adjoint_b: bool): SparseTensorDenseMatMul[oT] {.header:"generated.h", importcpp:"SparseTensorDenseMatMul(*#, #, #, #, #, #, #)", constructor.}

proc sparseTensorDenseMatMul*[oT: SparseTensorDenseMatMulT](scope: Scope,
                              a_indices: SparseTensorDenseMatMulTindices,
                              a_values: oT,
                              a_shape: oint64,
                              b: oT,
                              adjoint_a: bool = false,
                              adjoint_b: bool = false): SparseTensorDenseMatMul[oT] =
  return iisparseTensorDenseMatMul(scope,
                                   a_indices,
                                   a_values,
                                   a_shape,
                                   b,
                                   adjoint_a,
                                   adjoint_b)

converter sparseTensorDenseMatMulToOut*[oT: SparseTensorDenseMatMulT](op: SparseTensorDenseMatMul[oT]): oT = return op.output

type FusedBatchNormGradV2T = ohalf | obfloat16 | ofloat
type FusedBatchNormGradV2U = ofloat

type FusedBatchNormGradV2*[oT:FusedBatchNormGradV2T] {.header:"generated.h", importcpp:"FusedBatchNormGradV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifusedBatchNormGradV2[oT: FusedBatchNormGradV2T](scope: Scope,
                           y_backprop: oT,
                           x: oT,
                           scale: ofloat,
                           reserve_space_1: FusedBatchNormGradV2U,
                           reserve_space_2: FusedBatchNormGradV2U,
                           is_training: bool,
                           data_format: cstring,
                           epsilon: float32): FusedBatchNormGradV2[oT] {.header:"generated.h", importcpp:"FusedBatchNormGradV2(*#, #, #, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc fusedBatchNormGradV2*[oT: FusedBatchNormGradV2T](scope: Scope,
                           y_backprop: oT,
                           x: oT,
                           scale: ofloat,
                           reserve_space_1: FusedBatchNormGradV2U,
                           reserve_space_2: FusedBatchNormGradV2U,
                           is_training: bool = true,
                           data_format: cstring = "NHWC",
                           epsilon: float32 = 9.999999747378752e-05.float32): FusedBatchNormGradV2[oT] =
  return iifusedBatchNormGradV2(scope,
                                y_backprop,
                                x,
                                scale,
                                reserve_space_1,
                                reserve_space_2,
                                is_training,
                                data_format,
                                epsilon)

converter fusedBatchNormGradV2ToOut*[oT: FusedBatchNormGradV2T](op: FusedBatchNormGradV2[oT]): oT = return op.output


type BarrierReadySize*[oT:oint32] {.header:"generated.h", importcpp:"BarrierReadySize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibarrierReadySize[oT: oint32](scope: Scope,
                       handle: ostring): BarrierReadySize[oT] {.header:"generated.h", importcpp:"BarrierReadySize(*#, #)", constructor.}

proc barrierReadySize*[oT: oint32](scope: Scope,
                       handle: ostring): BarrierReadySize[oT] =
  return iibarrierReadySize(scope,
                            handle)

converter barrierReadySizeToOut*[oT: oint32](op: BarrierReadySize[oT]): oT = return op.output


type MapStage*{.header:"generated.h", importcpp:"MapStage/*'0*/".} = object
  operation: Operation[oinvalid]


proc iimapStage(scope: Scope,
               key: oint64,
               indices: oint32,
               values: oinvalid,
               dtypes: ArraySlice[DType],
               fake_dtypes: ArraySlice[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64,
               memory_limit: int64): MapStage {.header:"generated.h", importcpp:"MapStage(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapStage*(scope: Scope,
               key: oint64,
               indices: oint32,
               values: oinvalid,
               dtypes: openArray[DType],
               fake_dtypes: openArray[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64 = 0,
               memory_limit: int64 = 0): MapStage =
  return iimapStage(scope,
                    key,
                    indices,
                    values,
                    newArraySlice(dtypes),
                    newArraySlice(fake_dtypes),
                    container,
                    shared_name,
                    capacity,
                    memory_limit)




type Unstage*[oT:oinvalid] {.header:"generated.h", importcpp:"Unstage/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunstage[oT: oinvalid](scope: Scope,
              dtypes: ArraySlice[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64,
              memory_limit: int64): Unstage[oT] {.header:"generated.h", importcpp:"Unstage(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc unstage*[oT: oinvalid](scope: Scope,
              dtypes: openArray[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = 0,
              memory_limit: int64 = 0): Unstage[oT] =
  return iiunstage(scope,
                   newArraySlice(dtypes),
                   container,
                   shared_name,
                   capacity,
                   memory_limit)

converter unstageToOut*[oT: oinvalid](op: Unstage[oT]): oT = return op.output

type Variabledtype = oall

type Variable*[oT:Variabledtype] {.header:"generated.h", importcpp:"Variable/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iivariable[oT: Variabledtype](scope: Scope,
               container: cstring,
               shared_name: cstring,
               shape: TensorShape,
               dtype: DType): Variable[oT] {.header:"generated.h", importcpp:"Variable(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc variable*[oT: Variabledtype](scope: Scope,
               container: cstring,
               shared_name: cstring,
               shape: TensorShape = [].shape,
               dtype: DType = oT[].oTF): Variable[oT] =
  return iivariable(scope,
                    container,
                    shared_name,
                    shape,
                    dtype)

converter variableToOut*[oT: Variabledtype](op: Variable[oT]): oT = return op.output


type TensorArray*[oT:ostring] {.header:"generated.h", importcpp:"TensorArray/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArray[oT: ostring](scope: Scope,
                  size: oint32,
                  tensor_array_name: cstring,
                  dtype: DType,
                  dynamic_size: bool,
                  clear_after_read: bool,
                  element_shape: TensorShape): TensorArray[oT] {.header:"generated.h", importcpp:"TensorArray(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc tensorArray*[oT: ostring](scope: Scope,
                  size: oint32,
                  tensor_array_name: cstring,
                  dtype: DType = oT[].oTF,
                  dynamic_size: bool = false,
                  clear_after_read: bool = true,
                  element_shape: TensorShape = [].shape): TensorArray[oT] =
  return iitensorArray(scope,
                       size,
                       tensor_array_name,
                       dtype,
                       dynamic_size,
                       clear_after_read,
                       element_shape)

converter tensorArrayToOut*[oT: ostring](op: TensorArray[oT]): oT = return op.output

type SigmoidGradT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type SigmoidGrad*[oT:SigmoidGradT] {.header:"generated.h", importcpp:"SigmoidGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisigmoidGrad[oT: SigmoidGradT](scope: Scope,
                  y: oT,
                  dy: oT): SigmoidGrad[oT] {.header:"generated.h", importcpp:"SigmoidGrad(*#, #, #)", constructor.}

proc sigmoidGrad*[oT: SigmoidGradT](scope: Scope,
                  y: oT,
                  dy: oT): SigmoidGrad[oT] =
  return iisigmoidGrad(scope,
                       y,
                       dy)

converter sigmoidGradToOut*[oT: SigmoidGradT](op: SigmoidGrad[oT]): oT = return op.output

type TensorListGatherelement_dtype = oall

type TensorListGather*[oT:TensorListGatherelement_dtype] {.header:"generated.h", importcpp:"TensorListGather/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListGather[oT: TensorListGatherelement_dtype](scope: Scope,
                       input_handle: ovariant,
                       indices: oint32): TensorListGather[oT] {.header:"generated.h", importcpp:"TensorListGather(*#, #, #)", constructor.}

proc tensorListGather*[oT: TensorListGatherelement_dtype](scope: Scope,
                       input_handle: ovariant,
                       indices: oint32): TensorListGather[oT] =
  return iitensorListGather(scope,
                            input_handle,
                            indices)

converter tensorListGatherToOut*[oT: TensorListGatherelement_dtype](op: TensorListGather[oT]): oT = return op.output


type DeleteSessionTensor*{.header:"generated.h", importcpp:"DeleteSessionTensor/*'0*/".} = object
  operation: Operation[oinvalid]


proc iideleteSessionTensor(scope: Scope,
                          handle: ostring): DeleteSessionTensor {.header:"generated.h", importcpp:"DeleteSessionTensor(*#, #)", constructor.}

proc deleteSessionTensor*(scope: Scope,
                          handle: ostring): DeleteSessionTensor =
  return iideleteSessionTensor(scope,
                               handle)



type ResourceApplyAdamT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdam*{.header:"generated.h", importcpp:"ResourceApplyAdam/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAdam(scope: Scope,
                        nvar: oresource,
                        m: oresource,
                        v: oresource,
                        beta1_power: ResourceApplyAdamT,
                        beta2_power: ResourceApplyAdamT,
                        lr: ResourceApplyAdamT,
                        beta1: ResourceApplyAdamT,
                        beta2: ResourceApplyAdamT,
                        epsilon: ResourceApplyAdamT,
                        grad: ResourceApplyAdamT,
                        use_nesterov: bool,
                        use_locking: bool): ResourceApplyAdam {.header:"generated.h", importcpp:"ResourceApplyAdam(*#, #, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdam*(scope: Scope,
                        nvar: oresource,
                        m: oresource,
                        v: oresource,
                        beta1_power: ResourceApplyAdamT,
                        beta2_power: ResourceApplyAdamT,
                        lr: ResourceApplyAdamT,
                        beta1: ResourceApplyAdamT,
                        beta2: ResourceApplyAdamT,
                        epsilon: ResourceApplyAdamT,
                        grad: ResourceApplyAdamT,
                        use_nesterov: bool = false,
                        use_locking: bool = false): ResourceApplyAdam =
  return iiresourceApplyAdam(scope,
                             nvar,
                             m,
                             v,
                             beta1_power,
                             beta2_power,
                             lr,
                             beta1,
                             beta2,
                             epsilon,
                             grad,
                             use_nesterov,
                             use_locking)



type ResourceSparseApplyAdadeltaT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyAdadeltaTindices = oint32 | oint64

type ResourceSparseApplyAdadelta*{.header:"generated.h", importcpp:"ResourceSparseApplyAdadelta/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyAdadelta(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  accum_update: oresource,
                                  lr: ResourceSparseApplyAdadeltaT,
                                  rho: ResourceSparseApplyAdadeltaT,
                                  epsilon: ResourceSparseApplyAdadeltaT,
                                  grad: ResourceSparseApplyAdadeltaT,
                                  indices: ResourceSparseApplyAdadeltaTindices,
                                  use_locking: bool): ResourceSparseApplyAdadelta {.header:"generated.h", importcpp:"ResourceSparseApplyAdadelta(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyAdadelta*(scope: Scope,
                                  nvar: oresource,
                                  accum: oresource,
                                  accum_update: oresource,
                                  lr: ResourceSparseApplyAdadeltaT,
                                  rho: ResourceSparseApplyAdadeltaT,
                                  epsilon: ResourceSparseApplyAdadeltaT,
                                  grad: ResourceSparseApplyAdadeltaT,
                                  indices: ResourceSparseApplyAdadeltaTindices,
                                  use_locking: bool = false): ResourceSparseApplyAdadelta =
  return iiresourceSparseApplyAdadelta(scope,
                                       nvar,
                                       accum,
                                       accum_update,
                                       lr,
                                       rho,
                                       epsilon,
                                       grad,
                                       indices,
                                       use_locking)



type SigmoidT = obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Sigmoid*[oT:SigmoidT] {.header:"generated.h", importcpp:"Sigmoid/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisigmoid[oT: SigmoidT](scope: Scope,
              x: oT): Sigmoid[oT] {.header:"generated.h", importcpp:"Sigmoid(*#, #)", constructor.}

proc sigmoid*[oT: SigmoidT](scope: Scope,
              x: oT): Sigmoid[oT] =
  return iisigmoid(scope,
                   x)

converter sigmoidToOut*[oT: SigmoidT](op: Sigmoid[oT]): oT = return op.output

type ResourceApplyAdagradDAT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdagradDA*{.header:"generated.h", importcpp:"ResourceApplyAdagradDA/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAdagradDA(scope: Scope,
                             nvar: oresource,
                             gradient_accumulator: oresource,
                             gradient_squared_accumulator: oresource,
                             grad: ResourceApplyAdagradDAT,
                             lr: ResourceApplyAdagradDAT,
                             l1: ResourceApplyAdagradDAT,
                             l2: ResourceApplyAdagradDAT,
                             global_step: oint64,
                             use_locking: bool): ResourceApplyAdagradDA {.header:"generated.h", importcpp:"ResourceApplyAdagradDA(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdagradDA*(scope: Scope,
                             nvar: oresource,
                             gradient_accumulator: oresource,
                             gradient_squared_accumulator: oresource,
                             grad: ResourceApplyAdagradDAT,
                             lr: ResourceApplyAdagradDAT,
                             l1: ResourceApplyAdagradDAT,
                             l2: ResourceApplyAdagradDAT,
                             global_step: oint64,
                             use_locking: bool = false): ResourceApplyAdagradDA =
  return iiresourceApplyAdagradDA(scope,
                                  nvar,
                                  gradient_accumulator,
                                  gradient_squared_accumulator,
                                  grad,
                                  lr,
                                  l1,
                                  l2,
                                  global_step,
                                  use_locking)



type SparseToDenseTindices = oint32 | oint64
type SparseToDenseT = oall

type SparseToDense*[oT:SparseToDenseT] {.header:"generated.h", importcpp:"SparseToDense/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseToDense[oT: SparseToDenseT](scope: Scope,
                    sparse_indices: SparseToDenseTindices,
                    output_shape: SparseToDenseTindices,
                    sparse_values: oT,
                    default_value: oT,
                    validate_indices: bool): SparseToDense[oT] {.header:"generated.h", importcpp:"SparseToDense(*#, #, #, #, #, #)", constructor.}

proc sparseToDense*[oT: SparseToDenseT](scope: Scope,
                    sparse_indices: SparseToDenseTindices,
                    output_shape: SparseToDenseTindices,
                    sparse_values: oT,
                    default_value: oT,
                    validate_indices: bool = true): SparseToDense[oT] =
  return iisparseToDense(scope,
                         sparse_indices,
                         output_shape,
                         sparse_values,
                         default_value,
                         validate_indices)

converter sparseToDenseToOut*[oT: SparseToDenseT](op: SparseToDense[oT]): oT = return op.output

type BitcastT = obfloat16 | ohalf | ofloat | odouble | oint64 | oint32 | ouint8 | ouint16 | ouint32 | ouint64 | oint8 | oint16 | ocomplex64 | ocomplex128 | oqint8 | oquint8 | oqint16 | oquint16 | oqint32
type Bitcastntype = obfloat16 | ohalf | ofloat | odouble | oint64 | oint32 | ouint8 | ouint16 | ouint32 | ouint64 | oint8 | oint16 | ocomplex64 | ocomplex128 | oqint8 | oquint8 | oqint16 | oquint16 | oqint32

type Bitcast*[oT:Bitcastntype] {.header:"generated.h", importcpp:"Bitcast/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibitcast[oT: Bitcastntype](scope: Scope,
              input: BitcastT): Bitcast[oT] {.header:"generated.h", importcpp:"Bitcast(*#, #)", constructor.}

proc bitcast*[oT: Bitcastntype](scope: Scope,
              input: BitcastT): Bitcast[oT] =
  return iibitcast(scope,
                   input)

converter bitcastToOut*[oT: Bitcastntype](op: Bitcast[oT]): oT = return op.output

type GetSessionHandleV2T = oall

type GetSessionHandleV2*[oT:oresource] {.header:"generated.h", importcpp:"GetSessionHandleV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigetSessionHandleV2[oT: oresource](scope: Scope,
                         value: GetSessionHandleV2T): GetSessionHandleV2[oT] {.header:"generated.h", importcpp:"GetSessionHandleV2(*#, #)", constructor.}

proc getSessionHandleV2*[oT: oresource](scope: Scope,
                         value: GetSessionHandleV2T): GetSessionHandleV2[oT] =
  return iigetSessionHandleV2(scope,
                              value)

converter getSessionHandleV2ToOut*[oT: oresource](op: GetSessionHandleV2[oT]): oT = return op.output


type FakeQuantWithMinMaxVars*[oT:ofloat] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVars/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQuantWithMinMaxVars[oT: ofloat](scope: Scope,
                              inputs: oT,
                              min: oT,
                              max: oT,
                              num_bits: int64,
                              narrow_range: bool): FakeQuantWithMinMaxVars[oT] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVars(*#, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVars*[oT: ofloat](scope: Scope,
                              inputs: oT,
                              min: oT,
                              max: oT,
                              num_bits: int64 = 8,
                              narrow_range: bool = false): FakeQuantWithMinMaxVars[oT] =
  return iifakeQuantWithMinMaxVars(scope,
                                   inputs,
                                   min,
                                   max,
                                   num_bits,
                                   narrow_range)

converter fakeQuantWithMinMaxVarsToOut*[oT: ofloat](op: FakeQuantWithMinMaxVars[oT]): oT = return op.output


type BarrierIncompleteSize*[oT:oint32] {.header:"generated.h", importcpp:"BarrierIncompleteSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibarrierIncompleteSize[oT: oint32](scope: Scope,
                            handle: ostring): BarrierIncompleteSize[oT] {.header:"generated.h", importcpp:"BarrierIncompleteSize(*#, #)", constructor.}

proc barrierIncompleteSize*[oT: oint32](scope: Scope,
                            handle: ostring): BarrierIncompleteSize[oT] =
  return iibarrierIncompleteSize(scope,
                                 handle)

converter barrierIncompleteSizeToOut*[oT: oint32](op: BarrierIncompleteSize[oT]): oT = return op.output

type AnyTidx = oint32 | oint64

type Any*[oT:obool] {.header:"generated.h", importcpp:"Any/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiany[oT: obool](scope: Scope,
          input: oT,
          reduction_indices: AnyTidx,
          keep_dims: bool): Any[oT] {.header:"generated.h", importcpp:"Any(*#, #, #, #)", constructor.}

proc any*[oT: obool](scope: Scope,
          input: oT,
          reduction_indices: AnyTidx,
          keep_dims: bool = false): Any[oT] =
  return iiany(scope,
               input,
               reduction_indices,
               keep_dims)

converter anyToOut*[oT: obool](op: Any[oT]): oT = return op.output


type TensorForestCreateTreeVariable*{.header:"generated.h", importcpp:"TensorForestCreateTreeVariable/*'0*/".} = object
  operation: Operation[oinvalid]


proc iitensorForestCreateTreeVariable(scope: Scope,
                                     tree_handle: oresource,
                                     tree_config: ostring): TensorForestCreateTreeVariable {.header:"generated.h", importcpp:"TensorForestCreateTreeVariable(*#, #, #)", constructor.}

proc tensorForestCreateTreeVariable*(scope: Scope,
                                     tree_handle: oresource,
                                     tree_config: ostring): TensorForestCreateTreeVariable =
  return iitensorForestCreateTreeVariable(scope,
                                          tree_handle,
                                          tree_config)




type BatchFunction*[oT:oinvalid] {.header:"generated.h", importcpp:"BatchFunction/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchFunction[oT: oinvalid](scope: Scope,
                    in_tensors: oT,
                    captured_tensors: oT,
                    f: NameAttrList,
                    allowed_batch_sizes: ArraySlice[int],
                    container: cstring,
                    shared_name: cstring,
                    batching_queue: cstring,
                    Tin: ArraySlice[DType],
                    Tcaptured: ArraySlice[DType],
                    Tout: ArraySlice[DType],
                    num_batch_threads: int64,
                    max_batch_size: int64,
                    batch_timeout_micros: int64,
                    max_enqueued_batches: int64): BatchFunction[oT] {.header:"generated.h", importcpp:"BatchFunction(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #, #, #, #, #)", constructor.}

proc batchFunction*[oT: oinvalid](scope: Scope,
                    in_tensors: oT,
                    captured_tensors: oT,
                    f: NameAttrList,
                    allowed_batch_sizes: openArray[int],
                    container: cstring,
                    shared_name: cstring,
                    batching_queue: cstring,
                    Tin: openArray[DType],
                    Tcaptured: openArray[DType],
                    Tout: openArray[DType],
                    num_batch_threads: int64 = 0,
                    max_batch_size: int64 = 0,
                    batch_timeout_micros: int64 = 0,
                    max_enqueued_batches: int64 = 10): BatchFunction[oT] =
  return iibatchFunction(scope,
                         in_tensors,
                         captured_tensors,
                         f,
                         newArraySlice(allowed_batch_sizes),
                         container,
                         shared_name,
                         batching_queue,
                         newArraySlice(Tin),
                         newArraySlice(Tcaptured),
                         newArraySlice(Tout),
                         num_batch_threads,
                         max_batch_size,
                         batch_timeout_micros,
                         max_enqueued_batches)

converter batchFunctionToOut*[oT: oinvalid](op: BatchFunction[oT]): oT = return op.output


type BatchDatasetV2*[oT:ovariant] {.header:"generated.h", importcpp:"BatchDatasetV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchDatasetV2[oT: ovariant](scope: Scope,
                     input_dataset: oT,
                     batch_size: oint64,
                     drop_remainder: obool,
                     output_types: ArraySlice[DType],
                     output_shapes: ArraySlice[TensorShape]): BatchDatasetV2[oT] {.header:"generated.h", importcpp:"BatchDatasetV2(*#, #, #, #, #, #)", constructor.}

proc batchDatasetV2*[oT: ovariant](scope: Scope,
                     input_dataset: oT,
                     batch_size: oint64,
                     drop_remainder: obool,
                     output_types: openArray[DType],
                     output_shapes: openArray[TensorShape]): BatchDatasetV2[oT] =
  return iibatchDatasetV2(scope,
                          input_dataset,
                          batch_size,
                          drop_remainder,
                          newArraySlice(output_types),
                          newArraySlice(output_shapes))

converter batchDatasetV2ToOut*[oT: ovariant](op: BatchDatasetV2[oT]): oT = return op.output

type SelfAdjointEigV2T = odouble | ofloat | ocomplex64 | ocomplex128

type SelfAdjointEigV2*[oT:SelfAdjointEigV2T] {.header:"generated.h", importcpp:"SelfAdjointEigV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiselfAdjointEigV2[oT: SelfAdjointEigV2T](scope: Scope,
                       input: oT,
                       compute_v: bool): SelfAdjointEigV2[oT] {.header:"generated.h", importcpp:"SelfAdjointEigV2(*#, #, #)", constructor.}

proc selfAdjointEigV2*[oT: SelfAdjointEigV2T](scope: Scope,
                       input: oT,
                       compute_v: bool = true): SelfAdjointEigV2[oT] =
  return iiselfAdjointEigV2(scope,
                            input,
                            compute_v)

converter selfAdjointEigV2ToOut*[oT: SelfAdjointEigV2T](op: SelfAdjointEigV2[oT]): oT = return op.output

type PackT = oall

type Pack*[oT:PackT] {.header:"generated.h", importcpp:"Pack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipack[oT: PackT](scope: Scope,
           values: oT,
           axis: int64): Pack[oT] {.header:"generated.h", importcpp:"Pack(*#, #, #)", constructor.}

proc pack*[oT: PackT](scope: Scope,
           values: oT,
           axis: int64 = 0): Pack[oT] =
  return iipack(scope,
                values,
                axis)

converter packToOut*[oT: PackT](op: Pack[oT]): oT = return op.output


type BarrierClose*{.header:"generated.h", importcpp:"BarrierClose/*'0*/".} = object
  operation: Operation[oinvalid]


proc iibarrierClose(scope: Scope,
                   handle: ostring,
                   cancel_pending_enqueues: bool): BarrierClose {.header:"generated.h", importcpp:"BarrierClose(*#, #, #)", constructor.}

proc barrierClose*(scope: Scope,
                   handle: ostring,
                   cancel_pending_enqueues: bool = false): BarrierClose =
  return iibarrierClose(scope,
                        handle,
                        cancel_pending_enqueues)




type PyFunc*[oT:oinvalid] {.header:"generated.h", importcpp:"PyFunc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipyFunc[oT: oinvalid](scope: Scope,
             input: oT,
             token: cstring,
             Tin: ArraySlice[DType],
             Tout: ArraySlice[DType]): PyFunc[oT] {.header:"generated.h", importcpp:"PyFunc(*#, #, tensorflow::string(#), #, #)", constructor.}

proc pyFunc*[oT: oinvalid](scope: Scope,
             input: oT,
             token: cstring,
             Tin: openArray[DType],
             Tout: openArray[DType]): PyFunc[oT] =
  return iipyFunc(scope,
                  input,
                  token,
                  newArraySlice(Tin),
                  newArraySlice(Tout))

converter pyFuncToOut*[oT: oinvalid](op: PyFunc[oT]): oT = return op.output

type AddNT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64 | ovariant

type AddN*[oT:AddNT] {.header:"generated.h", importcpp:"AddN/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaddN[oT: AddNT](scope: Scope,
           inputs: oT): AddN[oT] {.header:"generated.h", importcpp:"AddN(*#, #)", constructor.}

proc addN*[oT: AddNT](scope: Scope,
           inputs: oT): AddN[oT] =
  return iiaddN(scope,
                inputs)

converter addNToOut*[oT: AddNT](op: AddN[oT]): oT = return op.output


type TensorArrayV2*[oT:ostring] {.header:"generated.h", importcpp:"TensorArrayV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayV2[oT: ostring](scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: DType,
                    element_shape: TensorShape,
                    dynamic_size: bool,
                    clear_after_read: bool): TensorArrayV2[oT] {.header:"generated.h", importcpp:"TensorArrayV2(*#, #, tensorflow::string(#), #, #, #, #)", constructor.}

proc tensorArrayV2*[oT: ostring](scope: Scope,
                    size: oint32,
                    tensor_array_name: cstring,
                    dtype: DType = oT[].oTF,
                    element_shape: TensorShape = [].shape,
                    dynamic_size: bool = false,
                    clear_after_read: bool = true): TensorArrayV2[oT] =
  return iitensorArrayV2(scope,
                         size,
                         tensor_array_name,
                         dtype,
                         element_shape,
                         dynamic_size,
                         clear_after_read)

converter tensorArrayV2ToOut*[oT: ostring](op: TensorArrayV2[oT]): oT = return op.output

type ResourceApplyGradientDescentT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyGradientDescent*{.header:"generated.h", importcpp:"ResourceApplyGradientDescent/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyGradientDescent(scope: Scope,
                                   nvar: oresource,
                                   alpha: ResourceApplyGradientDescentT,
                                   delta: ResourceApplyGradientDescentT,
                                   use_locking: bool): ResourceApplyGradientDescent {.header:"generated.h", importcpp:"ResourceApplyGradientDescent(*#, #, #, #, #)", constructor.}

proc resourceApplyGradientDescent*(scope: Scope,
                                   nvar: oresource,
                                   alpha: ResourceApplyGradientDescentT,
                                   delta: ResourceApplyGradientDescentT,
                                   use_locking: bool = false): ResourceApplyGradientDescent =
  return iiresourceApplyGradientDescent(scope,
                                        nvar,
                                        alpha,
                                        delta,
                                        use_locking)



type MatrixLogarithmT = ocomplex64 | ocomplex128

type MatrixLogarithm*[oT:MatrixLogarithmT] {.header:"generated.h", importcpp:"MatrixLogarithm/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixLogarithm[oT: MatrixLogarithmT](scope: Scope,
                      input: oT): MatrixLogarithm[oT] {.header:"generated.h", importcpp:"MatrixLogarithm(*#, #)", constructor.}

proc matrixLogarithm*[oT: MatrixLogarithmT](scope: Scope,
                      input: oT): MatrixLogarithm[oT] =
  return iimatrixLogarithm(scope,
                           input)

converter matrixLogarithmToOut*[oT: MatrixLogarithmT](op: MatrixLogarithm[oT]): oT = return op.output


type BarrierTakeMany*[oT:oint64] {.header:"generated.h", importcpp:"BarrierTakeMany/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibarrierTakeMany[oT: oint64](scope: Scope,
                      handle: ostring,
                      num_elements: oint32,
                      component_types: ArraySlice[DType],
                      allow_small_batch: bool,
                      wait_for_incomplete: bool,
                      timeout_ms: int64): BarrierTakeMany[oT] {.header:"generated.h", importcpp:"BarrierTakeMany(*#, #, #, #, #, #, #)", constructor.}

proc barrierTakeMany*[oT: oint64](scope: Scope,
                      handle: ostring,
                      num_elements: oint32,
                      component_types: openArray[DType],
                      allow_small_batch: bool = false,
                      wait_for_incomplete: bool = false,
                      timeout_ms: int64 = -1): BarrierTakeMany[oT] =
  return iibarrierTakeMany(scope,
                           handle,
                           num_elements,
                           newArraySlice(component_types),
                           allow_small_batch,
                           wait_for_incomplete,
                           timeout_ms)

converter barrierTakeManyToOut*[oT: oint64](op: BarrierTakeMany[oT]): oT = return op.output

type ResourceSparseApplyProximalAdagradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ResourceSparseApplyProximalAdagradTindices = oint32 | oint64

type ResourceSparseApplyProximalAdagrad*{.header:"generated.h", importcpp:"ResourceSparseApplyProximalAdagrad/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceSparseApplyProximalAdagrad(scope: Scope,
                                         nvar: oresource,
                                         accum: oresource,
                                         lr: ResourceSparseApplyProximalAdagradT,
                                         l1: ResourceSparseApplyProximalAdagradT,
                                         l2: ResourceSparseApplyProximalAdagradT,
                                         grad: ResourceSparseApplyProximalAdagradT,
                                         indices: ResourceSparseApplyProximalAdagradTindices,
                                         use_locking: bool): ResourceSparseApplyProximalAdagrad {.header:"generated.h", importcpp:"ResourceSparseApplyProximalAdagrad(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceSparseApplyProximalAdagrad*(scope: Scope,
                                         nvar: oresource,
                                         accum: oresource,
                                         lr: ResourceSparseApplyProximalAdagradT,
                                         l1: ResourceSparseApplyProximalAdagradT,
                                         l2: ResourceSparseApplyProximalAdagradT,
                                         grad: ResourceSparseApplyProximalAdagradT,
                                         indices: ResourceSparseApplyProximalAdagradTindices,
                                         use_locking: bool = false): ResourceSparseApplyProximalAdagrad =
  return iiresourceSparseApplyProximalAdagrad(scope,
                                              nvar,
                                              accum,
                                              lr,
                                              l1,
                                              l2,
                                              grad,
                                              indices,
                                              use_locking)



type NegT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Neg*[oT:NegT] {.header:"generated.h", importcpp:"Neg/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iineg[oT: NegT](scope: Scope,
          x: oT): Neg[oT] {.header:"generated.h", importcpp:"Neg(*#, #)", constructor.}

proc neg*[oT: NegT](scope: Scope,
          x: oT): Neg[oT] =
  return iineg(scope,
               x)

converter negToOut*[oT: NegT](op: Neg[oT]): oT = return op.output


type Barrier*[oT:ostring] {.header:"generated.h", importcpp:"Barrier/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibarrier[oT: ostring](scope: Scope,
              component_types: ArraySlice[DType],
              shapes: ArraySlice[TensorShape],
              container: cstring,
              shared_name: cstring,
              capacity: int64): Barrier[oT] {.header:"generated.h", importcpp:"Barrier(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc barrier*[oT: ostring](scope: Scope,
              component_types: openArray[DType],
              shapes: openArray[TensorShape],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = -1): Barrier[oT] =
  return iibarrier(scope,
                   newArraySlice(component_types),
                   newArraySlice(shapes),
                   container,
                   shared_name,
                   capacity)

converter barrierToOut*[oT: ostring](op: Barrier[oT]): oT = return op.output

type DivT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type Div*[oT:DivT] {.header:"generated.h", importcpp:"Div/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iindiv[oT: DivT](scope: Scope,
           x: oT,
           y: oT): Div[oT] {.header:"generated.h", importcpp:"Div(*#, #, #)", constructor.}

proc ndiv*[oT: DivT](scope: Scope,
           x: oT,
           y: oT): Div[oT] =
  return iindiv(scope,
                x,
                y)

converter ndivToOut*[oT: DivT](op: Div[oT]): oT = return op.output


type TensorArraySizeV2*[oT:oint32] {.header:"generated.h", importcpp:"TensorArraySizeV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArraySizeV2[oT: oint32](scope: Scope,
                        handle: ostring,
                        flow_in: ofloat): TensorArraySizeV2[oT] {.header:"generated.h", importcpp:"TensorArraySizeV2(*#, #, #)", constructor.}

proc tensorArraySizeV2*[oT: oint32](scope: Scope,
                        handle: ostring,
                        flow_in: ofloat): TensorArraySizeV2[oT] =
  return iitensorArraySizeV2(scope,
                             handle,
                             flow_in)

converter tensorArraySizeV2ToOut*[oT: oint32](op: TensorArraySizeV2[oT]): oT = return op.output

type AdjustContrastT = ouint8 | oint8 | oint16 | oint32 | oint64 | ofloat | odouble

type AdjustContrast*[oT:ofloat] {.header:"generated.h", importcpp:"AdjustContrast/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiadjustContrast[oT: ofloat](scope: Scope,
                     images: AdjustContrastT,
                     contrast_factor: oT,
                     min_value: oT,
                     max_value: oT): AdjustContrast[oT] {.header:"generated.h", importcpp:"AdjustContrast(*#, #, #, #, #)", constructor.}

proc adjustContrast*[oT: ofloat](scope: Scope,
                     images: AdjustContrastT,
                     contrast_factor: oT,
                     min_value: oT,
                     max_value: oT): AdjustContrast[oT] =
  return iiadjustContrast(scope,
                          images,
                          contrast_factor,
                          min_value,
                          max_value)

converter adjustContrastToOut*[oT: ofloat](op: AdjustContrast[oT]): oT = return op.output


type MultiDeviceIteratorInit*[oT:oint64] {.header:"generated.h", importcpp:"MultiDeviceIteratorInit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimultiDeviceIteratorInit[oT: oint64](scope: Scope,
                              dataset: ovariant,
                              multi_device_iterator: oresource,
                              max_buffer_size: oT): MultiDeviceIteratorInit[oT] {.header:"generated.h", importcpp:"MultiDeviceIteratorInit(*#, #, #, #)", constructor.}

proc multiDeviceIteratorInit*[oT: oint64](scope: Scope,
                              dataset: ovariant,
                              multi_device_iterator: oresource,
                              max_buffer_size: oT): MultiDeviceIteratorInit[oT] =
  return iimultiDeviceIteratorInit(scope,
                                   dataset,
                                   multi_device_iterator,
                                   max_buffer_size)

converter multiDeviceIteratorInitToOut*[oT: oint64](op: MultiDeviceIteratorInit[oT]): oT = return op.output

type ComplexAbsT = ocomplex64 | ocomplex128
type ComplexAbsTout = ofloat | odouble

type ComplexAbs*[oT:ComplexAbsTout] {.header:"generated.h", importcpp:"ComplexAbs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicomplexAbs[oT: ComplexAbsTout](scope: Scope,
                 x: ComplexAbsT): ComplexAbs[oT] {.header:"generated.h", importcpp:"ComplexAbs(*#, #)", constructor.}

proc complexAbs*[oT: ComplexAbsTout](scope: Scope,
                 x: ComplexAbsT): ComplexAbs[oT] =
  return iicomplexAbs(scope,
                      x)

converter complexAbsToOut*[oT: ComplexAbsTout](op: ComplexAbs[oT]): oT = return op.output

type RGBToHSVT = ohalf | obfloat16 | ofloat | odouble

type RGBToHSV*[oT:RGBToHSVT] {.header:"generated.h", importcpp:"RGBToHSV/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirGBToHSV[oT: RGBToHSVT](scope: Scope,
               images: oT): RGBToHSV[oT] {.header:"generated.h", importcpp:"RGBToHSV(*#, #)", constructor.}

proc rGBToHSV*[oT: RGBToHSVT](scope: Scope,
               images: oT): RGBToHSV[oT] =
  return iirGBToHSV(scope,
                    images)

converter rGBToHSVToOut*[oT: RGBToHSVT](op: RGBToHSV[oT]): oT = return op.output

type ListDiffT = oall

type ListDiff*[oT:ListDiffT] {.header:"generated.h", importcpp:"ListDiff/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilistDiff[oT: ListDiffT](scope: Scope,
               x: oT,
               y: oT,
               out_idx: DType): ListDiff[oT] {.header:"generated.h", importcpp:"ListDiff(*#, #, #, #)", constructor.}

proc listDiff*[oT: ListDiffT](scope: Scope,
               x: oT,
               y: oT,
               out_idx: DType = DT_INT32): ListDiff[oT] =
  return iilistDiff(scope,
                    x,
                    y,
                    out_idx)

converter listDiffToOut*[oT: ListDiffT](op: ListDiff[oT]): oT = return op.output

type TensorArrayScatterV2T = oall

type TensorArrayScatterV2*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayScatterV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayScatterV2[oT: ofloat](scope: Scope,
                           handle: ostring,
                           indices: oint32,
                           value: TensorArrayScatterV2T,
                           flow_in: oT): TensorArrayScatterV2[oT] {.header:"generated.h", importcpp:"TensorArrayScatterV2(*#, #, #, #, #)", constructor.}

proc tensorArrayScatterV2*[oT: ofloat](scope: Scope,
                           handle: ostring,
                           indices: oint32,
                           value: TensorArrayScatterV2T,
                           flow_in: oT): TensorArrayScatterV2[oT] =
  return iitensorArrayScatterV2(scope,
                                handle,
                                indices,
                                value,
                                flow_in)

converter tensorArrayScatterV2ToOut*[oT: ofloat](op: TensorArrayScatterV2[oT]): oT = return op.output


type RFFT3D*[oT:ocomplex64] {.header:"generated.h", importcpp:"RFFT3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirFFT3D[oT: ocomplex64](scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT3D[oT] {.header:"generated.h", importcpp:"RFFT3D(*#, #, #)", constructor.}

proc rFFT3D*[oT: ocomplex64](scope: Scope,
             input: ofloat,
             fft_length: oint32): RFFT3D[oT] =
  return iirFFT3D(scope,
                  input,
                  fft_length)

converter rFFT3DToOut*[oT: ocomplex64](op: RFFT3D[oT]): oT = return op.output

type TensorArrayGatherV2dtype = oall

type TensorArrayGatherV2*[oT:TensorArrayGatherV2dtype] {.header:"generated.h", importcpp:"TensorArrayGatherV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGatherV2[oT: TensorArrayGatherV2dtype](scope: Scope,
                          handle: ostring,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape: TensorShape): TensorArrayGatherV2[oT] {.header:"generated.h", importcpp:"TensorArrayGatherV2(*#, #, #, #, #, #)", constructor.}

proc tensorArrayGatherV2*[oT: TensorArrayGatherV2dtype](scope: Scope,
                          handle: ostring,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: DType = oT[].oTF,
                          element_shape: TensorShape = [].shape): TensorArrayGatherV2[oT] =
  return iitensorArrayGatherV2(scope,
                               handle,
                               indices,
                               flow_in,
                               dtype,
                               element_shape)

converter tensorArrayGatherV2ToOut*[oT: TensorArrayGatherV2dtype](op: TensorArrayGatherV2[oT]): oT = return op.output


type ReaderRestoreStateV2*{.header:"generated.h", importcpp:"ReaderRestoreStateV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iireaderRestoreStateV2(scope: Scope,
                           reader_handle: oresource,
                           state: ostring): ReaderRestoreStateV2 {.header:"generated.h", importcpp:"ReaderRestoreStateV2(*#, #, #)", constructor.}

proc readerRestoreStateV2*(scope: Scope,
                           reader_handle: oresource,
                           state: ostring): ReaderRestoreStateV2 =
  return iireaderRestoreStateV2(scope,
                                reader_handle,
                                state)



type IDeviceArgT = oall

type IDeviceArg*[oT:IDeviceArgT] {.header:"generated.h", importcpp:"_DeviceArg/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiDeviceArg[oT: IDeviceArgT](scope: Scope,
                 index: int64): IDeviceArg[oT] {.header:"generated.h", importcpp:"_DeviceArg(*#, #)", constructor.}

proc iDeviceArg*[oT: IDeviceArgT](scope: Scope,
                 index: int64 = 0): IDeviceArg[oT] =
  return iiiDeviceArg(scope,
                      index)

converter iDeviceArgToOut*[oT: IDeviceArgT](op: IDeviceArg[oT]): oT = return op.output


type StagePeek*[oT:oinvalid] {.header:"generated.h", importcpp:"StagePeek/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistagePeek[oT: oinvalid](scope: Scope,
                index: oint32,
                dtypes: ArraySlice[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64,
                memory_limit: int64): StagePeek[oT] {.header:"generated.h", importcpp:"StagePeek(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stagePeek*[oT: oinvalid](scope: Scope,
                index: oint32,
                dtypes: openArray[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64 = 0,
                memory_limit: int64 = 0): StagePeek[oT] =
  return iistagePeek(scope,
                     index,
                     newArraySlice(dtypes),
                     container,
                     shared_name,
                     capacity,
                     memory_limit)

converter stagePeekToOut*[oT: oinvalid](op: StagePeek[oT]): oT = return op.output

type TensorArrayReadV2dtype = oall

type TensorArrayReadV2*[oT:TensorArrayReadV2dtype] {.header:"generated.h", importcpp:"TensorArrayReadV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayReadV2[oT: TensorArrayReadV2dtype](scope: Scope,
                        handle: ostring,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: DType): TensorArrayReadV2[oT] {.header:"generated.h", importcpp:"TensorArrayReadV2(*#, #, #, #, #)", constructor.}

proc tensorArrayReadV2*[oT: TensorArrayReadV2dtype](scope: Scope,
                        handle: ostring,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: DType = oT[].oTF): TensorArrayReadV2[oT] =
  return iitensorArrayReadV2(scope,
                             handle,
                             index,
                             flow_in,
                             dtype)

converter tensorArrayReadV2ToOut*[oT: TensorArrayReadV2dtype](op: TensorArrayReadV2[oT]): oT = return op.output


type AudioSpectrogram*[oT:ofloat] {.header:"generated.h", importcpp:"AudioSpectrogram/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaudioSpectrogram[oT: ofloat](scope: Scope,
                       input: oT,
                       window_size: int64,
                       stride: int64,
                       magnitude_squared: bool): AudioSpectrogram[oT] {.header:"generated.h", importcpp:"AudioSpectrogram(*#, #, #, #, #)", constructor.}

proc audioSpectrogram*[oT: ofloat](scope: Scope,
                       input: oT,
                       window_size: int64 = 0,
                       stride: int64 = 0,
                       magnitude_squared: bool = false): AudioSpectrogram[oT] =
  return iiaudioSpectrogram(scope,
                            input,
                            window_size,
                            stride,
                            magnitude_squared)

converter audioSpectrogramToOut*[oT: ofloat](op: AudioSpectrogram[oT]): oT = return op.output

type TensorArrayReaddtype = oall

type TensorArrayRead*[oT:TensorArrayReaddtype] {.header:"generated.h", importcpp:"TensorArrayRead/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayRead[oT: TensorArrayReaddtype](scope: Scope,
                      handle: ostring,
                      index: oint32,
                      flow_in: ofloat,
                      dtype: DType): TensorArrayRead[oT] {.header:"generated.h", importcpp:"TensorArrayRead(*#, #, #, #, #)", constructor.}

proc tensorArrayRead*[oT: TensorArrayReaddtype](scope: Scope,
                      handle: ostring,
                      index: oint32,
                      flow_in: ofloat,
                      dtype: DType = oT[].oTF): TensorArrayRead[oT] =
  return iitensorArrayRead(scope,
                           handle,
                           index,
                           flow_in,
                           dtype)

converter tensorArrayReadToOut*[oT: TensorArrayReaddtype](op: TensorArrayRead[oT]): oT = return op.output

type SparseAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseAddTreal = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type SparseAdd*[oT:oint64] {.header:"generated.h", importcpp:"SparseAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseAdd[oT: oint64](scope: Scope,
                a_indices: oT,
                a_values: SparseAddT,
                a_shape: oT,
                b_indices: oT,
                b_values: SparseAddT,
                b_shape: oT,
                thresh: SparseAddTreal): SparseAdd[oT] {.header:"generated.h", importcpp:"SparseAdd(*#, #, #, #, #, #, #, #)", constructor.}

proc sparseAdd*[oT: oint64](scope: Scope,
                a_indices: oT,
                a_values: SparseAddT,
                a_shape: oT,
                b_indices: oT,
                b_values: SparseAddT,
                b_shape: oT,
                thresh: SparseAddTreal): SparseAdd[oT] =
  return iisparseAdd(scope,
                     a_indices,
                     a_values,
                     a_shape,
                     b_indices,
                     b_values,
                     b_shape,
                     thresh)

converter sparseAddToOut*[oT: oint64](op: SparseAdd[oT]): oT = return op.output

type BitwiseXorT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type BitwiseXor*[oT:BitwiseXorT] {.header:"generated.h", importcpp:"BitwiseXor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibitwiseXor[oT: BitwiseXorT](scope: Scope,
                 x: oT,
                 y: oT): BitwiseXor[oT] {.header:"generated.h", importcpp:"BitwiseXor(*#, #, #)", constructor.}

proc bitwiseXor*[oT: BitwiseXorT](scope: Scope,
                 x: oT,
                 y: oT): BitwiseXor[oT] =
  return iibitwiseXor(scope,
                      x,
                      y)

converter bitwiseXorToOut*[oT: BitwiseXorT](op: BitwiseXor[oT]): oT = return op.output

type DenseToSparseSetOperationT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ostring

type DenseToSparseSetOperation*[oT:oint64] {.header:"generated.h", importcpp:"DenseToSparseSetOperation/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidenseToSparseSetOperation[oT: oint64](scope: Scope,
                                set1: DenseToSparseSetOperationT,
                                set2_indices: oT,
                                set2_values: DenseToSparseSetOperationT,
                                set2_shape: oT,
                                set_operation: cstring,
                                validate_indices: bool): DenseToSparseSetOperation[oT] {.header:"generated.h", importcpp:"DenseToSparseSetOperation(*#, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc denseToSparseSetOperation*[oT: oint64](scope: Scope,
                                set1: DenseToSparseSetOperationT,
                                set2_indices: oT,
                                set2_values: DenseToSparseSetOperationT,
                                set2_shape: oT,
                                set_operation: cstring,
                                validate_indices: bool = true): DenseToSparseSetOperation[oT] =
  return iidenseToSparseSetOperation(scope,
                                     set1,
                                     set2_indices,
                                     set2_values,
                                     set2_shape,
                                     set_operation,
                                     validate_indices)

converter denseToSparseSetOperationToOut*[oT: oint64](op: DenseToSparseSetOperation[oT]): oT = return op.output

type TensorArrayWriteV2T = oall

type TensorArrayWriteV2*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayWriteV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayWriteV2[oT: ofloat](scope: Scope,
                         handle: ostring,
                         index: oint32,
                         value: TensorArrayWriteV2T,
                         flow_in: oT): TensorArrayWriteV2[oT] {.header:"generated.h", importcpp:"TensorArrayWriteV2(*#, #, #, #, #)", constructor.}

proc tensorArrayWriteV2*[oT: ofloat](scope: Scope,
                         handle: ostring,
                         index: oint32,
                         value: TensorArrayWriteV2T,
                         flow_in: oT): TensorArrayWriteV2[oT] =
  return iitensorArrayWriteV2(scope,
                              handle,
                              index,
                              value,
                              flow_in)

converter tensorArrayWriteV2ToOut*[oT: ofloat](op: TensorArrayWriteV2[oT]): oT = return op.output

type TensorArrayWriteT = oall

type TensorArrayWrite*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayWrite/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayWrite[oT: ofloat](scope: Scope,
                       handle: ostring,
                       index: oint32,
                       value: TensorArrayWriteT,
                       flow_in: oT): TensorArrayWrite[oT] {.header:"generated.h", importcpp:"TensorArrayWrite(*#, #, #, #, #)", constructor.}

proc tensorArrayWrite*[oT: ofloat](scope: Scope,
                       handle: ostring,
                       index: oint32,
                       value: TensorArrayWriteT,
                       flow_in: oT): TensorArrayWrite[oT] =
  return iitensorArrayWrite(scope,
                            handle,
                            index,
                            value,
                            flow_in)

converter tensorArrayWriteToOut*[oT: ofloat](op: TensorArrayWrite[oT]): oT = return op.output

type ReverseSequenceT = oall
type ReverseSequenceTlen = oint32 | oint64

type ReverseSequence*[oT:ReverseSequenceT] {.header:"generated.h", importcpp:"ReverseSequence/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireverseSequence[oT: ReverseSequenceT](scope: Scope,
                      input: oT,
                      seq_lengths: ReverseSequenceTlen,
                      seq_dim: int64,
                      batch_dim: int64): ReverseSequence[oT] {.header:"generated.h", importcpp:"ReverseSequence(*#, #, #, #, #)", constructor.}

proc reverseSequence*[oT: ReverseSequenceT](scope: Scope,
                      input: oT,
                      seq_lengths: ReverseSequenceTlen,
                      seq_dim: int64 = 0,
                      batch_dim: int64 = 0): ReverseSequence[oT] =
  return iireverseSequence(scope,
                           input,
                           seq_lengths,
                           seq_dim,
                           batch_dim)

converter reverseSequenceToOut*[oT: ReverseSequenceT](op: ReverseSequence[oT]): oT = return op.output

type TensorArrayGatherV3dtype = oall

type TensorArrayGatherV3*[oT:TensorArrayGatherV3dtype] {.header:"generated.h", importcpp:"TensorArrayGatherV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGatherV3[oT: TensorArrayGatherV3dtype](scope: Scope,
                          handle: oresource,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape: TensorShape): TensorArrayGatherV3[oT] {.header:"generated.h", importcpp:"TensorArrayGatherV3(*#, #, #, #, #, #)", constructor.}

proc tensorArrayGatherV3*[oT: TensorArrayGatherV3dtype](scope: Scope,
                          handle: oresource,
                          indices: oint32,
                          flow_in: ofloat,
                          dtype: DType = oT[].oTF,
                          element_shape: TensorShape = [].shape): TensorArrayGatherV3[oT] =
  return iitensorArrayGatherV3(scope,
                               handle,
                               indices,
                               flow_in,
                               dtype,
                               element_shape)

converter tensorArrayGatherV3ToOut*[oT: TensorArrayGatherV3dtype](op: TensorArrayGatherV3[oT]): oT = return op.output


type FilterByLastComponentDataset*[oT:ovariant] {.header:"generated.h", importcpp:"FilterByLastComponentDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifilterByLastComponentDataset[oT: ovariant](scope: Scope,
                                   input_dataset: oT,
                                   output_types: ArraySlice[DType],
                                   output_shapes: ArraySlice[TensorShape]): FilterByLastComponentDataset[oT] {.header:"generated.h", importcpp:"FilterByLastComponentDataset(*#, #, #, #)", constructor.}

proc filterByLastComponentDataset*[oT: ovariant](scope: Scope,
                                   input_dataset: oT,
                                   output_types: openArray[DType],
                                   output_shapes: openArray[TensorShape]): FilterByLastComponentDataset[oT] =
  return iifilterByLastComponentDataset(scope,
                                        input_dataset,
                                        newArraySlice(output_types),
                                        newArraySlice(output_shapes))

converter filterByLastComponentDatasetToOut*[oT: ovariant](op: FilterByLastComponentDataset[oT]): oT = return op.output


type ShuffleDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ShuffleDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iishuffleDataset[oT: ovariant](scope: Scope,
                     input_dataset: oT,
                     buffer_size: oint64,
                     seed: oint64,
                     seed2: oint64,
                     output_types: ArraySlice[DType],
                     output_shapes: ArraySlice[TensorShape],
                     reshuffle_each_iteration: bool): ShuffleDataset[oT] {.header:"generated.h", importcpp:"ShuffleDataset(*#, #, #, #, #, #, #, #)", constructor.}

proc shuffleDataset*[oT: ovariant](scope: Scope,
                     input_dataset: oT,
                     buffer_size: oint64,
                     seed: oint64,
                     seed2: oint64,
                     output_types: openArray[DType],
                     output_shapes: openArray[TensorShape],
                     reshuffle_each_iteration: bool = true): ShuffleDataset[oT] =
  return iishuffleDataset(scope,
                          input_dataset,
                          buffer_size,
                          seed,
                          seed2,
                          newArraySlice(output_types),
                          newArraySlice(output_shapes),
                          reshuffle_each_iteration)

converter shuffleDatasetToOut*[oT: ovariant](op: ShuffleDataset[oT]): oT = return op.output

type DivNoNanT = ofloat | odouble

type DivNoNan*[oT:DivNoNanT] {.header:"generated.h", importcpp:"DivNoNan/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidivNoNan[oT: DivNoNanT](scope: Scope,
               x: oT,
               y: oT): DivNoNan[oT] {.header:"generated.h", importcpp:"DivNoNan(*#, #, #)", constructor.}

proc divNoNan*[oT: DivNoNanT](scope: Scope,
               x: oT,
               y: oT): DivNoNan[oT] =
  return iidivNoNan(scope,
                    x,
                    y)

converter divNoNanToOut*[oT: DivNoNanT](op: DivNoNan[oT]): oT = return op.output

type EditDistanceT = oall

type EditDistance*[oT:ofloat] {.header:"generated.h", importcpp:"EditDistance/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iieditDistance[oT: ofloat](scope: Scope,
                   hypothesis_indices: oint64,
                   hypothesis_values: EditDistanceT,
                   hypothesis_shape: oint64,
                   truth_indices: oint64,
                   truth_values: EditDistanceT,
                   truth_shape: oint64,
                   normalize: bool): EditDistance[oT] {.header:"generated.h", importcpp:"EditDistance(*#, #, #, #, #, #, #, #)", constructor.}

proc editDistance*[oT: ofloat](scope: Scope,
                   hypothesis_indices: oint64,
                   hypothesis_values: EditDistanceT,
                   hypothesis_shape: oint64,
                   truth_indices: oint64,
                   truth_values: EditDistanceT,
                   truth_shape: oint64,
                   normalize: bool = true): EditDistance[oT] =
  return iieditDistance(scope,
                        hypothesis_indices,
                        hypothesis_values,
                        hypothesis_shape,
                        truth_indices,
                        truth_values,
                        truth_shape,
                        normalize)

converter editDistanceToOut*[oT: ofloat](op: EditDistance[oT]): oT = return op.output

type AvgPoolGradT = ohalf | obfloat16 | ofloat | odouble

type AvgPoolGrad*[oT:AvgPoolGradT] {.header:"generated.h", importcpp:"AvgPoolGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiavgPoolGrad[oT: AvgPoolGradT](scope: Scope,
                  orig_input_shape: oint32,
                  grad: oT,
                  ksize: ArraySlice[int],
                  strides: ArraySlice[int],
                  padding: cstring,
                  data_format: cstring): AvgPoolGrad[oT] {.header:"generated.h", importcpp:"AvgPoolGrad(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc avgPoolGrad*[oT: AvgPoolGradT](scope: Scope,
                  orig_input_shape: oint32,
                  grad: oT,
                  ksize: openArray[int],
                  strides: openArray[int],
                  padding: cstring,
                  data_format: cstring = "NHWC"): AvgPoolGrad[oT] =
  return iiavgPoolGrad(scope,
                       orig_input_shape,
                       grad,
                       newArraySlice(ksize),
                       newArraySlice(strides),
                       padding,
                       data_format)

converter avgPoolGradToOut*[oT: AvgPoolGradT](op: AvgPoolGrad[oT]): oT = return op.output

type ParallelConcatT = oall

type ParallelConcat*[oT:ParallelConcatT] {.header:"generated.h", importcpp:"ParallelConcat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparallelConcat[oT: ParallelConcatT](scope: Scope,
                     values: oT,
                     shape: TensorShape): ParallelConcat[oT] {.header:"generated.h", importcpp:"ParallelConcat(*#, #, #)", constructor.}

proc parallelConcat*[oT: ParallelConcatT](scope: Scope,
                     values: oT,
                     shape: TensorShape = [].shape): ParallelConcat[oT] =
  return iiparallelConcat(scope,
                          values,
                          shape)

converter parallelConcatToOut*[oT: ParallelConcatT](op: ParallelConcat[oT]): oT = return op.output


type RangeDataset*[oT:ovariant] {.header:"generated.h", importcpp:"RangeDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirangeDataset[oT: ovariant](scope: Scope,
                   start: oint64,
                   stop: oint64,
                   step: oint64,
                   output_types: ArraySlice[DType],
                   output_shapes: ArraySlice[TensorShape]): RangeDataset[oT] {.header:"generated.h", importcpp:"RangeDataset(*#, #, #, #, #, #)", constructor.}

proc rangeDataset*[oT: ovariant](scope: Scope,
                   start: oint64,
                   stop: oint64,
                   step: oint64,
                   output_types: openArray[DType],
                   output_shapes: openArray[TensorShape]): RangeDataset[oT] =
  return iirangeDataset(scope,
                        start,
                        stop,
                        step,
                        newArraySlice(output_types),
                        newArraySlice(output_shapes))

converter rangeDatasetToOut*[oT: ovariant](op: RangeDataset[oT]): oT = return op.output

type UnsortedSegmentMaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type UnsortedSegmentMaxTindices = oint32 | oint64
type UnsortedSegmentMaxTnumsegments = oint32 | oint64

type UnsortedSegmentMax*[oT:UnsortedSegmentMaxT] {.header:"generated.h", importcpp:"UnsortedSegmentMax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunsortedSegmentMax[oT: UnsortedSegmentMaxT](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMaxTindices,
                         num_segments: UnsortedSegmentMaxTnumsegments): UnsortedSegmentMax[oT] {.header:"generated.h", importcpp:"UnsortedSegmentMax(*#, #, #, #)", constructor.}

proc unsortedSegmentMax*[oT: UnsortedSegmentMaxT](scope: Scope,
                         data: oT,
                         segment_ids: UnsortedSegmentMaxTindices,
                         num_segments: UnsortedSegmentMaxTnumsegments): UnsortedSegmentMax[oT] =
  return iiunsortedSegmentMax(scope,
                              data,
                              segment_ids,
                              num_segments)

converter unsortedSegmentMaxToOut*[oT: UnsortedSegmentMaxT](op: UnsortedSegmentMax[oT]): oT = return op.output


type TensorArrayGradWithShape*[oT:oresource] {.header:"generated.h", importcpp:"TensorArrayGradWithShape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGradWithShape[oT: oresource](scope: Scope,
                               handle: oT,
                               flow_in: ofloat,
                               shape_to_prepend: oint32,
                               source: cstring): TensorArrayGradWithShape[oT] {.header:"generated.h", importcpp:"TensorArrayGradWithShape(*#, #, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGradWithShape*[oT: oresource](scope: Scope,
                               handle: oT,
                               flow_in: ofloat,
                               shape_to_prepend: oint32,
                               source: cstring): TensorArrayGradWithShape[oT] =
  return iitensorArrayGradWithShape(scope,
                                    handle,
                                    flow_in,
                                    shape_to_prepend,
                                    source)

converter tensorArrayGradWithShapeToOut*[oT: oresource](op: TensorArrayGradWithShape[oT]): oT = return op.output


type MultiDeviceIteratorToStringHandle*[oT:ostring] {.header:"generated.h", importcpp:"MultiDeviceIteratorToStringHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimultiDeviceIteratorToStringHandle[oT: ostring](scope: Scope,
                                        multi_device_iterator: oresource): MultiDeviceIteratorToStringHandle[oT] {.header:"generated.h", importcpp:"MultiDeviceIteratorToStringHandle(*#, #)", constructor.}

proc multiDeviceIteratorToStringHandle*[oT: ostring](scope: Scope,
                                        multi_device_iterator: oresource): MultiDeviceIteratorToStringHandle[oT] =
  return iimultiDeviceIteratorToStringHandle(scope,
                                             multi_device_iterator)

converter multiDeviceIteratorToStringHandleToOut*[oT: ostring](op: MultiDeviceIteratorToStringHandle[oT]): oT = return op.output


type TensorArrayGradV3*[oT:oresource] {.header:"generated.h", importcpp:"TensorArrayGradV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGradV3[oT: oresource](scope: Scope,
                        handle: oT,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV3[oT] {.header:"generated.h", importcpp:"TensorArrayGradV3(*#, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGradV3*[oT: oresource](scope: Scope,
                        handle: oT,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV3[oT] =
  return iitensorArrayGradV3(scope,
                             handle,
                             flow_in,
                             source)

converter tensorArrayGradV3ToOut*[oT: oresource](op: TensorArrayGradV3[oT]): oT = return op.output

type SparseApplyFtrlV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyFtrlV2Tindices = oint32 | oint64

type SparseApplyFtrlV2*[oT:SparseApplyFtrlV2T] {.header:"generated.h", importcpp:"SparseApplyFtrlV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyFtrlV2[oT: SparseApplyFtrlV2T](scope: Scope,
                        nvar: oT,
                        accum: oT,
                        linear: oT,
                        grad: oT,
                        indices: SparseApplyFtrlV2Tindices,
                        lr: oT,
                        l1: oT,
                        l2: oT,
                        l2_shrinkage: oT,
                        lr_power: oT,
                        use_locking: bool): SparseApplyFtrlV2[oT] {.header:"generated.h", importcpp:"SparseApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyFtrlV2*[oT: SparseApplyFtrlV2T](scope: Scope,
                        nvar: oT,
                        accum: oT,
                        linear: oT,
                        grad: oT,
                        indices: SparseApplyFtrlV2Tindices,
                        lr: oT,
                        l1: oT,
                        l2: oT,
                        l2_shrinkage: oT,
                        lr_power: oT,
                        use_locking: bool = false): SparseApplyFtrlV2[oT] =
  return iisparseApplyFtrlV2(scope,
                             nvar,
                             accum,
                             linear,
                             grad,
                             indices,
                             lr,
                             l1,
                             l2,
                             l2_shrinkage,
                             lr_power,
                             use_locking)

converter sparseApplyFtrlV2ToOut*[oT: SparseApplyFtrlV2T](op: SparseApplyFtrlV2[oT]): oT = return op.output

type StackPopelem_type = oall

type StackPop*[oT:StackPopelem_type] {.header:"generated.h", importcpp:"StackPop/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistackPop[oT: StackPopelem_type](scope: Scope,
               handle: ostring): StackPop[oT] {.header:"generated.h", importcpp:"StackPop(*#, #)", constructor.}

proc stackPop*[oT: StackPopelem_type](scope: Scope,
               handle: ostring): StackPop[oT] =
  return iistackPop(scope,
                    handle)

converter stackPopToOut*[oT: StackPopelem_type](op: StackPop[oT]): oT = return op.output


type Stack*[oT:ostring] {.header:"generated.h", importcpp:"Stack/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistack[oT: ostring](scope: Scope,
            stack_name: cstring,
            elem_type: DType): Stack[oT] {.header:"generated.h", importcpp:"Stack(*#, tensorflow::string(#), #)", constructor.}

proc stack*[oT: ostring](scope: Scope,
            stack_name: cstring,
            elem_type: DType = DT_INVALID): Stack[oT] =
  return iistack(scope,
                 stack_name,
                 elem_type)

converter stackToOut*[oT: ostring](op: Stack[oT]): oT = return op.output

type AbsT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64

type Abs*[oT:AbsT] {.header:"generated.h", importcpp:"Abs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiabs[oT: AbsT](scope: Scope,
          x: oT): Abs[oT] {.header:"generated.h", importcpp:"Abs(*#, #)", constructor.}

proc abs*[oT: AbsT](scope: Scope,
          x: oT): Abs[oT] =
  return iiabs(scope,
               x)

converter absToOut*[oT: AbsT](op: Abs[oT]): oT = return op.output

type GatherTparams = oall
type GatherTindices = oint32 | oint64

type Gather*[oT:GatherTparams] {.header:"generated.h", importcpp:"Gather/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigather[oT: GatherTparams](scope: Scope,
             params: oT,
             indices: GatherTindices,
             validate_indices: bool): Gather[oT] {.header:"generated.h", importcpp:"Gather(*#, #, #, #)", constructor.}

proc gather*[oT: GatherTparams](scope: Scope,
             params: oT,
             indices: GatherTindices,
             validate_indices: bool = true): Gather[oT] =
  return iigather(scope,
                  params,
                  indices,
                  validate_indices)

converter gatherToOut*[oT: GatherTparams](op: Gather[oT]): oT = return op.output

type TensorArrayReadV3dtype = oall

type TensorArrayReadV3*[oT:TensorArrayReadV3dtype] {.header:"generated.h", importcpp:"TensorArrayReadV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayReadV3[oT: TensorArrayReadV3dtype](scope: Scope,
                        handle: oresource,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: DType): TensorArrayReadV3[oT] {.header:"generated.h", importcpp:"TensorArrayReadV3(*#, #, #, #, #)", constructor.}

proc tensorArrayReadV3*[oT: TensorArrayReadV3dtype](scope: Scope,
                        handle: oresource,
                        index: oint32,
                        flow_in: ofloat,
                        dtype: DType = oT[].oTF): TensorArrayReadV3[oT] =
  return iitensorArrayReadV3(scope,
                             handle,
                             index,
                             flow_in,
                             dtype)

converter tensorArrayReadV3ToOut*[oT: TensorArrayReadV3dtype](op: TensorArrayReadV3[oT]): oT = return op.output

type AvgPool3DGradT = ohalf | obfloat16 | ofloat | odouble

type AvgPool3DGrad*[oT:AvgPool3DGradT] {.header:"generated.h", importcpp:"AvgPool3DGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiavgPool3DGrad[oT: AvgPool3DGradT](scope: Scope,
                    orig_input_shape: oint32,
                    grad: oT,
                    ksize: ArraySlice[int],
                    strides: ArraySlice[int],
                    padding: cstring,
                    data_format: cstring): AvgPool3DGrad[oT] {.header:"generated.h", importcpp:"AvgPool3DGrad(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc avgPool3DGrad*[oT: AvgPool3DGradT](scope: Scope,
                    orig_input_shape: oint32,
                    grad: oT,
                    ksize: openArray[int],
                    strides: openArray[int],
                    padding: cstring,
                    data_format: cstring = "NDHWC"): AvgPool3DGrad[oT] =
  return iiavgPool3DGrad(scope,
                         orig_input_shape,
                         grad,
                         newArraySlice(ksize),
                         newArraySlice(strides),
                         padding,
                         data_format)

converter avgPool3DGradToOut*[oT: AvgPool3DGradT](op: AvgPool3DGrad[oT]): oT = return op.output


type TensorArrayCloseV2*{.header:"generated.h", importcpp:"TensorArrayCloseV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iitensorArrayCloseV2(scope: Scope,
                         handle: ostring): TensorArrayCloseV2 {.header:"generated.h", importcpp:"TensorArrayCloseV2(*#, #)", constructor.}

proc tensorArrayCloseV2*(scope: Scope,
                         handle: ostring): TensorArrayCloseV2 =
  return iitensorArrayCloseV2(scope,
                              handle)




type ThreadUnsafeUnigramCandidateSampler*[oT:oint64] {.header:"generated.h", importcpp:"ThreadUnsafeUnigramCandidateSampler/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iithreadUnsafeUnigramCandidateSampler[oT: oint64](scope: Scope,
                                          true_classes: oT,
                                          num_true: int64,
                                          num_sampled: int64,
                                          unique: bool,
                                          range_max: int64,
                                          seed: int64,
                                          seed2: int64): ThreadUnsafeUnigramCandidateSampler[oT] {.header:"generated.h", importcpp:"ThreadUnsafeUnigramCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc threadUnsafeUnigramCandidateSampler*[oT: oint64](scope: Scope,
                                          true_classes: oT,
                                          num_true: int64 = 0,
                                          num_sampled: int64 = 0,
                                          unique: bool = false,
                                          range_max: int64 = 0,
                                          seed: int64 = 0,
                                          seed2: int64 = 0): ThreadUnsafeUnigramCandidateSampler[oT] =
  return iithreadUnsafeUnigramCandidateSampler(scope,
                                               true_classes,
                                               num_true,
                                               num_sampled,
                                               unique,
                                               range_max,
                                               seed,
                                               seed2)

converter threadUnsafeUnigramCandidateSamplerToOut*[oT: oint64](op: ThreadUnsafeUnigramCandidateSampler[oT]): oT = return op.output


type StackCloseV2*{.header:"generated.h", importcpp:"StackCloseV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iistackCloseV2(scope: Scope,
                   handle: oresource): StackCloseV2 {.header:"generated.h", importcpp:"StackCloseV2(*#, #)", constructor.}

proc stackCloseV2*(scope: Scope,
                   handle: oresource): StackCloseV2 =
  return iistackCloseV2(scope,
                        handle)



type StackPopV2elem_type = oall

type StackPopV2*[oT:StackPopV2elem_type] {.header:"generated.h", importcpp:"StackPopV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistackPopV2[oT: StackPopV2elem_type](scope: Scope,
                 handle: oresource): StackPopV2[oT] {.header:"generated.h", importcpp:"StackPopV2(*#, #)", constructor.}

proc stackPopV2*[oT: StackPopV2elem_type](scope: Scope,
                 handle: oresource): StackPopV2[oT] =
  return iistackPopV2(scope,
                      handle)

converter stackPopV2ToOut*[oT: StackPopV2elem_type](op: StackPopV2[oT]): oT = return op.output

type StackPushV2T = oall

type StackPushV2*[oT:StackPushV2T] {.header:"generated.h", importcpp:"StackPushV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistackPushV2[oT: StackPushV2T](scope: Scope,
                  handle: oresource,
                  elem: oT,
                  swap_memory: bool): StackPushV2[oT] {.header:"generated.h", importcpp:"StackPushV2(*#, #, #, #)", constructor.}

proc stackPushV2*[oT: StackPushV2T](scope: Scope,
                  handle: oresource,
                  elem: oT,
                  swap_memory: bool = false): StackPushV2[oT] =
  return iistackPushV2(scope,
                       handle,
                       elem,
                       swap_memory)

converter stackPushV2ToOut*[oT: StackPushV2T](op: StackPushV2[oT]): oT = return op.output

type TileGradT = oall

type TileGrad*[oT:TileGradT] {.header:"generated.h", importcpp:"TileGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitileGrad[oT: TileGradT](scope: Scope,
               input: oT,
               multiples: oint32): TileGrad[oT] {.header:"generated.h", importcpp:"TileGrad(*#, #, #)", constructor.}

proc tileGrad*[oT: TileGradT](scope: Scope,
               input: oT,
               multiples: oint32): TileGrad[oT] =
  return iitileGrad(scope,
                    input,
                    multiples)

converter tileGradToOut*[oT: TileGradT](op: TileGrad[oT]): oT = return op.output


type QueueDequeueUpTo*[oT:oinvalid] {.header:"generated.h", importcpp:"QueueDequeueUpTo/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueDequeueUpTo[oT: oinvalid](scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: ArraySlice[DType],
                       timeout_ms: int64): QueueDequeueUpTo[oT] {.header:"generated.h", importcpp:"QueueDequeueUpTo(*#, #, #, #, #)", constructor.}

proc queueDequeueUpTo*[oT: oinvalid](scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: openArray[DType],
                       timeout_ms: int64 = -1): QueueDequeueUpTo[oT] =
  return iiqueueDequeueUpTo(scope,
                            handle,
                            n,
                            newArraySlice(component_types),
                            timeout_ms)

converter queueDequeueUpToToOut*[oT: oinvalid](op: QueueDequeueUpTo[oT]): oT = return op.output


type AudioSummary*[oT:ostring] {.header:"generated.h", importcpp:"AudioSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaudioSummary[oT: ostring](scope: Scope,
                   tag: oT,
                   tensor: ofloat,
                   sample_rate: float32,
                   max_outputs: int64): AudioSummary[oT] {.header:"generated.h", importcpp:"AudioSummary(*#, #, #, #, #)", constructor.}

proc audioSummary*[oT: ostring](scope: Scope,
                   tag: oT,
                   tensor: ofloat,
                   sample_rate: float32 = 0.0.float32,
                   max_outputs: int64 = 3): AudioSummary[oT] =
  return iiaudioSummary(scope,
                        tag,
                        tensor,
                        sample_rate,
                        max_outputs)

converter audioSummaryToOut*[oT: ostring](op: AudioSummary[oT]): oT = return op.output


type PaddedBatchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"PaddedBatchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipaddedBatchDataset[oT: ovariant](scope: Scope,
                         input_dataset: oT,
                         batch_size: oint64,
                         padded_shapes: oint64,
                         padding_values: oinvalid,
                         Toutput_types: ArraySlice[DType],
                         output_shapes: ArraySlice[TensorShape]): PaddedBatchDataset[oT] {.header:"generated.h", importcpp:"PaddedBatchDataset(*#, #, #, #, #, #, #)", constructor.}

proc paddedBatchDataset*[oT: ovariant](scope: Scope,
                         input_dataset: oT,
                         batch_size: oint64,
                         padded_shapes: oint64,
                         padding_values: oinvalid,
                         Toutput_types: openArray[DType],
                         output_shapes: openArray[TensorShape]): PaddedBatchDataset[oT] =
  return iipaddedBatchDataset(scope,
                              input_dataset,
                              batch_size,
                              padded_shapes,
                              padding_values,
                              newArraySlice(Toutput_types),
                              newArraySlice(output_shapes))

converter paddedBatchDatasetToOut*[oT: ovariant](op: PaddedBatchDataset[oT]): oT = return op.output


type StackV2*[oT:oresource] {.header:"generated.h", importcpp:"StackV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistackV2[oT: oresource](scope: Scope,
              max_size: oint32,
              stack_name: cstring,
              elem_type: DType): StackV2[oT] {.header:"generated.h", importcpp:"StackV2(*#, #, tensorflow::string(#), #)", constructor.}

proc stackV2*[oT: oresource](scope: Scope,
              max_size: oint32,
              stack_name: cstring,
              elem_type: DType = DT_INVALID): StackV2[oT] =
  return iistackV2(scope,
                   max_size,
                   stack_name,
                   elem_type)

converter stackV2ToOut*[oT: oresource](op: StackV2[oT]): oT = return op.output


type SparseConditionalAccumulator*[oT:ostring] {.header:"generated.h", importcpp:"SparseConditionalAccumulator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseConditionalAccumulator[oT: ostring](scope: Scope,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: DType,
                                   shape: TensorShape,
                                   reduction_type: cstring): SparseConditionalAccumulator[oT] {.header:"generated.h", importcpp:"SparseConditionalAccumulator(*#, tensorflow::string(#), tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc sparseConditionalAccumulator*[oT: ostring](scope: Scope,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: DType = oT[].oTF,
                                   shape: TensorShape = [].shape,
                                   reduction_type: cstring = "MEAN"): SparseConditionalAccumulator[oT] =
  return iisparseConditionalAccumulator(scope,
                                        container,
                                        shared_name,
                                        dtype,
                                        shape,
                                        reduction_type)

converter sparseConditionalAccumulatorToOut*[oT: ostring](op: SparseConditionalAccumulator[oT]): oT = return op.output


type OrderedMapUnstage*[oT:oinvalid] {.header:"generated.h", importcpp:"OrderedMapUnstage/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiorderedMapUnstage[oT: oinvalid](scope: Scope,
                        key: oint64,
                        indices: oint32,
                        dtypes: ArraySlice[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64,
                        memory_limit: int64): OrderedMapUnstage[oT] {.header:"generated.h", importcpp:"OrderedMapUnstage(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapUnstage*[oT: oinvalid](scope: Scope,
                        key: oint64,
                        indices: oint32,
                        dtypes: openArray[DType],
                        container: cstring,
                        shared_name: cstring,
                        capacity: int64 = 0,
                        memory_limit: int64 = 0): OrderedMapUnstage[oT] =
  return iiorderedMapUnstage(scope,
                             key,
                             indices,
                             newArraySlice(dtypes),
                             container,
                             shared_name,
                             capacity,
                             memory_limit)

converter orderedMapUnstageToOut*[oT: oinvalid](op: OrderedMapUnstage[oT]): oT = return op.output


type IVarHandlesOp*[oT:oresource] {.header:"generated.h", importcpp:"_VarHandlesOp/*'0*/".} = object
  operation: Operation[oT]
  output: olist[oT]

proc iiiVarHandlesOp[oT: oresource](scope: Scope,
                    containers: ArraySlice[cstring],
                    shared_names: ArraySlice[cstring],
                    dtypes: ArraySlice[DType],
                    shapes: ArraySlice[TensorShape]): IVarHandlesOp[oT] {.header:"generated.h", importcpp:"_VarHandlesOp(*#, #, #, #, #)", constructor.}

proc iVarHandlesOp*[oT: oresource](scope: Scope,
                    containers: openArray[cstring],
                    shared_names: openArray[cstring],
                    dtypes: openArray[DType],
                    shapes: openArray[TensorShape]): IVarHandlesOp[oT] =
  return iiiVarHandlesOp(scope,
                         newArraySlice(containers),
                         newArraySlice(shared_names),
                         newArraySlice(dtypes),
                         newArraySlice(shapes))

converter iVarHandlesOpToOutList*[oT: oresource](op: IVarHandlesOp[oT]): olist[oT] = return op.output

type TensorArraySplitV2T = oall

type TensorArraySplitV2*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArraySplitV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArraySplitV2[oT: ofloat](scope: Scope,
                         handle: ostring,
                         value: TensorArraySplitV2T,
                         lengths: oint64,
                         flow_in: oT): TensorArraySplitV2[oT] {.header:"generated.h", importcpp:"TensorArraySplitV2(*#, #, #, #, #)", constructor.}

proc tensorArraySplitV2*[oT: ofloat](scope: Scope,
                         handle: ostring,
                         value: TensorArraySplitV2T,
                         lengths: oint64,
                         flow_in: oT): TensorArraySplitV2[oT] =
  return iitensorArraySplitV2(scope,
                              handle,
                              value,
                              lengths,
                              flow_in)

converter tensorArraySplitV2ToOut*[oT: ofloat](op: TensorArraySplitV2[oT]): oT = return op.output

type AccumulatorTakeGradientdtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type AccumulatorTakeGradient*[oT:AccumulatorTakeGradientdtype] {.header:"generated.h", importcpp:"AccumulatorTakeGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaccumulatorTakeGradient[oT: AccumulatorTakeGradientdtype](scope: Scope,
                              handle: ostring,
                              num_required: oint32,
                              dtype: DType): AccumulatorTakeGradient[oT] {.header:"generated.h", importcpp:"AccumulatorTakeGradient(*#, #, #, #)", constructor.}

proc accumulatorTakeGradient*[oT: AccumulatorTakeGradientdtype](scope: Scope,
                              handle: ostring,
                              num_required: oint32,
                              dtype: DType = oT[].oTF): AccumulatorTakeGradient[oT] =
  return iiaccumulatorTakeGradient(scope,
                                   handle,
                                   num_required,
                                   dtype)

converter accumulatorTakeGradientToOut*[oT: AccumulatorTakeGradientdtype](op: AccumulatorTakeGradient[oT]): oT = return op.output

type ExtractJpegShapeoutput_type = oint32 | oint64

type ExtractJpegShape*[oT:ExtractJpegShapeoutput_type] {.header:"generated.h", importcpp:"ExtractJpegShape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiextractJpegShape[oT: ExtractJpegShapeoutput_type](scope: Scope,
                       contents: ostring): ExtractJpegShape[oT] {.header:"generated.h", importcpp:"ExtractJpegShape(*#, #)", constructor.}

proc extractJpegShape*[oT: ExtractJpegShapeoutput_type](scope: Scope,
                       contents: ostring): ExtractJpegShape[oT] =
  return iiextractJpegShape(scope,
                            contents)

converter extractJpegShapeToOut*[oT: ExtractJpegShapeoutput_type](op: ExtractJpegShape[oT]): oT = return op.output


type ConditionalAccumulator*[oT:ostring] {.header:"generated.h", importcpp:"ConditionalAccumulator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconditionalAccumulator[oT: ostring](scope: Scope,
                             container: cstring,
                             shared_name: cstring,
                             dtype: DType,
                             shape: TensorShape,
                             reduction_type: cstring): ConditionalAccumulator[oT] {.header:"generated.h", importcpp:"ConditionalAccumulator(*#, tensorflow::string(#), tensorflow::string(#), #, #, tensorflow::string(#))", constructor.}

proc conditionalAccumulator*[oT: ostring](scope: Scope,
                             container: cstring,
                             shared_name: cstring,
                             dtype: DType = oT[].oTF,
                             shape: TensorShape = [].shape,
                             reduction_type: cstring = "MEAN"): ConditionalAccumulator[oT] =
  return iiconditionalAccumulator(scope,
                                  container,
                                  shared_name,
                                  dtype,
                                  shape,
                                  reduction_type)

converter conditionalAccumulatorToOut*[oT: ostring](op: ConditionalAccumulator[oT]): oT = return op.output


type AccumulatorNumAccumulated*[oT:oint32] {.header:"generated.h", importcpp:"AccumulatorNumAccumulated/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiaccumulatorNumAccumulated[oT: oint32](scope: Scope,
                                handle: ostring): AccumulatorNumAccumulated[oT] {.header:"generated.h", importcpp:"AccumulatorNumAccumulated(*#, #)", constructor.}

proc accumulatorNumAccumulated*[oT: oint32](scope: Scope,
                                handle: ostring): AccumulatorNumAccumulated[oT] =
  return iiaccumulatorNumAccumulated(scope,
                                     handle)

converter accumulatorNumAccumulatedToOut*[oT: oint32](op: AccumulatorNumAccumulated[oT]): oT = return op.output


type LogicalNot*[oT:obool] {.header:"generated.h", importcpp:"LogicalNot/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilogicalNot[oT: obool](scope: Scope,
                 x: oT): LogicalNot[oT] {.header:"generated.h", importcpp:"LogicalNot(*#, #)", constructor.}

proc logicalNot*[oT: obool](scope: Scope,
                 x: oT): LogicalNot[oT] =
  return iilogicalNot(scope,
                      x)

converter logicalNotToOut*[oT: obool](op: LogicalNot[oT]): oT = return op.output

type LuT = odouble | ofloat | ocomplex64 | ocomplex128

type Lu*[oT:LuT] {.header:"generated.h", importcpp:"Lu/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilu[oT: LuT](scope: Scope,
         input: oT,
         output_idx_type: DType): Lu[oT] {.header:"generated.h", importcpp:"Lu(*#, #, #)", constructor.}

proc lu*[oT: LuT](scope: Scope,
         input: oT,
         output_idx_type: DType = DT_INT32): Lu[oT] =
  return iilu(scope,
              input,
              output_idx_type)

converter luToOut*[oT: LuT](op: Lu[oT]): oT = return op.output


type QueueSize*[oT:oint32] {.header:"generated.h", importcpp:"QueueSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueSize[oT: oint32](scope: Scope,
                handle: ostring): QueueSize[oT] {.header:"generated.h", importcpp:"QueueSize(*#, #)", constructor.}

proc queueSize*[oT: oint32](scope: Scope,
                handle: ostring): QueueSize[oT] =
  return iiqueueSize(scope,
                     handle)

converter queueSizeToOut*[oT: oint32](op: QueueSize[oT]): oT = return op.output

type TensorArraySplitV3T = oall

type TensorArraySplitV3*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArraySplitV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArraySplitV3[oT: ofloat](scope: Scope,
                         handle: oresource,
                         value: TensorArraySplitV3T,
                         lengths: oint64,
                         flow_in: oT): TensorArraySplitV3[oT] {.header:"generated.h", importcpp:"TensorArraySplitV3(*#, #, #, #, #)", constructor.}

proc tensorArraySplitV3*[oT: ofloat](scope: Scope,
                         handle: oresource,
                         value: TensorArraySplitV3T,
                         lengths: oint64,
                         flow_in: oT): TensorArraySplitV3[oT] =
  return iitensorArraySplitV3(scope,
                              handle,
                              value,
                              lengths,
                              flow_in)

converter tensorArraySplitV3ToOut*[oT: ofloat](op: TensorArraySplitV3[oT]): oT = return op.output


type IteratorGetNextAsOptional*[oT:ovariant] {.header:"generated.h", importcpp:"IteratorGetNextAsOptional/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorGetNextAsOptional[oT: ovariant](scope: Scope,
                                niterator: oresource,
                                output_types: ArraySlice[DType],
                                output_shapes: ArraySlice[TensorShape]): IteratorGetNextAsOptional[oT] {.header:"generated.h", importcpp:"IteratorGetNextAsOptional(*#, #, #, #)", constructor.}

proc iteratorGetNextAsOptional*[oT: ovariant](scope: Scope,
                                niterator: oresource,
                                output_types: openArray[DType],
                                output_shapes: openArray[TensorShape]): IteratorGetNextAsOptional[oT] =
  return iiiteratorGetNextAsOptional(scope,
                                     niterator,
                                     newArraySlice(output_types),
                                     newArraySlice(output_shapes))

converter iteratorGetNextAsOptionalToOut*[oT: ovariant](op: IteratorGetNextAsOptional[oT]): oT = return op.output


type GcsConfigureCredentials*{.header:"generated.h", importcpp:"GcsConfigureCredentials/*'0*/".} = object
  operation: Operation[oinvalid]


proc iigcsConfigureCredentials(scope: Scope,
                              json: ostring): GcsConfigureCredentials {.header:"generated.h", importcpp:"GcsConfigureCredentials(*#, #)", constructor.}

proc gcsConfigureCredentials*(scope: Scope,
                              json: ostring): GcsConfigureCredentials =
  return iigcsConfigureCredentials(scope,
                                   json)




type QueueDequeueManyV2*[oT:oinvalid] {.header:"generated.h", importcpp:"QueueDequeueManyV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueDequeueManyV2[oT: oinvalid](scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: ArraySlice[DType],
                         timeout_ms: int64): QueueDequeueManyV2[oT] {.header:"generated.h", importcpp:"QueueDequeueManyV2(*#, #, #, #, #)", constructor.}

proc queueDequeueManyV2*[oT: oinvalid](scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: openArray[DType],
                         timeout_ms: int64 = -1): QueueDequeueManyV2[oT] =
  return iiqueueDequeueManyV2(scope,
                              handle,
                              n,
                              newArraySlice(component_types),
                              timeout_ms)

converter queueDequeueManyV2ToOut*[oT: oinvalid](op: QueueDequeueManyV2[oT]): oT = return op.output


type VarHandleOp*[oT:oresource] {.header:"generated.h", importcpp:"VarHandleOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iivarHandleOp[oT: oresource](scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  dtype: DType,
                  shape: TensorShape): VarHandleOp[oT] {.header:"generated.h", importcpp:"VarHandleOp(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc varHandleOp*[oT: oresource](scope: Scope,
                  container: cstring,
                  shared_name: cstring,
                  dtype: DType = oT[].oTF,
                  shape: TensorShape = [].shape): VarHandleOp[oT] =
  return iivarHandleOp(scope,
                       container,
                       shared_name,
                       dtype,
                       shape)

converter varHandleOpToOut*[oT: oresource](op: VarHandleOp[oT]): oT = return op.output


type ComputeAccidentalHits*[oT:oint32] {.header:"generated.h", importcpp:"ComputeAccidentalHits/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicomputeAccidentalHits[oT: oint32](scope: Scope,
                            true_classes: oint64,
                            sampled_candidates: oint64,
                            num_true: int64,
                            seed: int64,
                            seed2: int64): ComputeAccidentalHits[oT] {.header:"generated.h", importcpp:"ComputeAccidentalHits(*#, #, #, #, #, #)", constructor.}

proc computeAccidentalHits*[oT: oint32](scope: Scope,
                            true_classes: oint64,
                            sampled_candidates: oint64,
                            num_true: int64 = 0,
                            seed: int64 = 0,
                            seed2: int64 = 0): ComputeAccidentalHits[oT] =
  return iicomputeAccidentalHits(scope,
                                 true_classes,
                                 sampled_candidates,
                                 num_true,
                                 seed,
                                 seed2)

converter computeAccidentalHitsToOut*[oT: oint32](op: ComputeAccidentalHits[oT]): oT = return op.output


type QueueDequeueMany*[oT:oinvalid] {.header:"generated.h", importcpp:"QueueDequeueMany/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueDequeueMany[oT: oinvalid](scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: ArraySlice[DType],
                       timeout_ms: int64): QueueDequeueMany[oT] {.header:"generated.h", importcpp:"QueueDequeueMany(*#, #, #, #, #)", constructor.}

proc queueDequeueMany*[oT: oinvalid](scope: Scope,
                       handle: ostring,
                       n: oint32,
                       component_types: openArray[DType],
                       timeout_ms: int64 = -1): QueueDequeueMany[oT] =
  return iiqueueDequeueMany(scope,
                            handle,
                            n,
                            newArraySlice(component_types),
                            timeout_ms)

converter queueDequeueManyToOut*[oT: oinvalid](op: QueueDequeueMany[oT]): oT = return op.output


type ExperimentalMaxIntraOpParallelismDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalMaxIntraOpParallelismDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalMaxIntraOpParallelismDataset[oT: ovariant](scope: Scope,
                                               input_dataset: oT,
                                               max_intra_op_parallelism: oint64,
                                               output_types: ArraySlice[DType],
                                               output_shapes: ArraySlice[TensorShape]): ExperimentalMaxIntraOpParallelismDataset[oT] {.header:"generated.h", importcpp:"ExperimentalMaxIntraOpParallelismDataset(*#, #, #, #, #)", constructor.}

proc experimentalMaxIntraOpParallelismDataset*[oT: ovariant](scope: Scope,
                                               input_dataset: oT,
                                               max_intra_op_parallelism: oint64,
                                               output_types: openArray[DType],
                                               output_shapes: openArray[TensorShape]): ExperimentalMaxIntraOpParallelismDataset[oT] =
  return iiexperimentalMaxIntraOpParallelismDataset(scope,
                                                    input_dataset,
                                                    max_intra_op_parallelism,
                                                    newArraySlice(output_types),
                                                    newArraySlice(output_shapes))

converter experimentalMaxIntraOpParallelismDatasetToOut*[oT: ovariant](op: ExperimentalMaxIntraOpParallelismDataset[oT]): oT = return op.output


type QueueEnqueueMany*{.header:"generated.h", importcpp:"QueueEnqueueMany/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiqueueEnqueueMany(scope: Scope,
                       handle: ostring,
                       components: oinvalid,
                       Tcomponents: ArraySlice[DType],
                       timeout_ms: int64): QueueEnqueueMany {.header:"generated.h", importcpp:"QueueEnqueueMany(*#, #, #, #, #)", constructor.}

proc queueEnqueueMany*(scope: Scope,
                       handle: ostring,
                       components: oinvalid,
                       Tcomponents: openArray[DType],
                       timeout_ms: int64 = -1): QueueEnqueueMany =
  return iiqueueEnqueueMany(scope,
                            handle,
                            components,
                            newArraySlice(Tcomponents),
                            timeout_ms)




type PaddingFIFOQueue*[oT:ostring] {.header:"generated.h", importcpp:"PaddingFIFOQueue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipaddingFIFOQueue[oT: ostring](scope: Scope,
                       component_types: ArraySlice[DType],
                       shapes: ArraySlice[TensorShape],
                       container: cstring,
                       shared_name: cstring,
                       capacity: int64): PaddingFIFOQueue[oT] {.header:"generated.h", importcpp:"PaddingFIFOQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc paddingFIFOQueue*[oT: ostring](scope: Scope,
                       component_types: openArray[DType],
                       shapes: openArray[TensorShape],
                       container: cstring,
                       shared_name: cstring,
                       capacity: int64 = -1): PaddingFIFOQueue[oT] =
  return iipaddingFIFOQueue(scope,
                            newArraySlice(component_types),
                            newArraySlice(shapes),
                            container,
                            shared_name,
                            capacity)

converter paddingFIFOQueueToOut*[oT: ostring](op: PaddingFIFOQueue[oT]): oT = return op.output


type OrderedMapUnstageNoKey*[oT:oint64] {.header:"generated.h", importcpp:"OrderedMapUnstageNoKey/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiorderedMapUnstageNoKey[oT: oint64](scope: Scope,
                             indices: oint32,
                             dtypes: ArraySlice[DType],
                             container: cstring,
                             shared_name: cstring,
                             capacity: int64,
                             memory_limit: int64): OrderedMapUnstageNoKey[oT] {.header:"generated.h", importcpp:"OrderedMapUnstageNoKey(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapUnstageNoKey*[oT: oint64](scope: Scope,
                             indices: oint32,
                             dtypes: openArray[DType],
                             container: cstring,
                             shared_name: cstring,
                             capacity: int64 = 0,
                             memory_limit: int64 = 0): OrderedMapUnstageNoKey[oT] =
  return iiorderedMapUnstageNoKey(scope,
                                  indices,
                                  newArraySlice(dtypes),
                                  container,
                                  shared_name,
                                  capacity,
                                  memory_limit)

converter orderedMapUnstageNoKeyToOut*[oT: oint64](op: OrderedMapUnstageNoKey[oT]): oT = return op.output


type TensorForestTreeResourceHandleOp*[oT:oresource] {.header:"generated.h", importcpp:"TensorForestTreeResourceHandleOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorForestTreeResourceHandleOp[oT: oresource](scope: Scope,
                                       container: cstring,
                                       shared_name: cstring): TensorForestTreeResourceHandleOp[oT] {.header:"generated.h", importcpp:"TensorForestTreeResourceHandleOp(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc tensorForestTreeResourceHandleOp*[oT: oresource](scope: Scope,
                                       container: cstring,
                                       shared_name: cstring): TensorForestTreeResourceHandleOp[oT] =
  return iitensorForestTreeResourceHandleOp(scope,
                                            container,
                                            shared_name)

converter tensorForestTreeResourceHandleOpToOut*[oT: oresource](op: TensorForestTreeResourceHandleOp[oT]): oT = return op.output

type SparseSegmentSumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type SparseSegmentSumTidx = oint32 | oint64

type SparseSegmentSum*[oT:SparseSegmentSumT] {.header:"generated.h", importcpp:"SparseSegmentSum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseSegmentSum[oT: SparseSegmentSumT](scope: Scope,
                       data: oT,
                       indices: SparseSegmentSumTidx,
                       segment_ids: oint32): SparseSegmentSum[oT] {.header:"generated.h", importcpp:"SparseSegmentSum(*#, #, #, #)", constructor.}

proc sparseSegmentSum*[oT: SparseSegmentSumT](scope: Scope,
                       data: oT,
                       indices: SparseSegmentSumTidx,
                       segment_ids: oint32): SparseSegmentSum[oT] =
  return iisparseSegmentSum(scope,
                            data,
                            indices,
                            segment_ids)

converter sparseSegmentSumToOut*[oT: SparseSegmentSumT](op: SparseSegmentSum[oT]): oT = return op.output


type FIFOQueue*[oT:ostring] {.header:"generated.h", importcpp:"FIFOQueue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifIFOQueue[oT: ostring](scope: Scope,
                component_types: ArraySlice[DType],
                shapes: ArraySlice[TensorShape],
                container: cstring,
                shared_name: cstring,
                capacity: int64): FIFOQueue[oT] {.header:"generated.h", importcpp:"FIFOQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc fIFOQueue*[oT: ostring](scope: Scope,
                component_types: openArray[DType],
                shapes: openArray[TensorShape],
                container: cstring,
                shared_name: cstring,
                capacity: int64 = -1): FIFOQueue[oT] =
  return iifIFOQueue(scope,
                     newArraySlice(component_types),
                     newArraySlice(shapes),
                     container,
                     shared_name,
                     capacity)

converter fIFOQueueToOut*[oT: ostring](op: FIFOQueue[oT]): oT = return op.output

type TensorArrayWriteV3T = oall

type TensorArrayWriteV3*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayWriteV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayWriteV3[oT: ofloat](scope: Scope,
                         handle: oresource,
                         index: oint32,
                         value: TensorArrayWriteV3T,
                         flow_in: oT): TensorArrayWriteV3[oT] {.header:"generated.h", importcpp:"TensorArrayWriteV3(*#, #, #, #, #)", constructor.}

proc tensorArrayWriteV3*[oT: ofloat](scope: Scope,
                         handle: oresource,
                         index: oint32,
                         value: TensorArrayWriteV3T,
                         flow_in: oT): TensorArrayWriteV3[oT] =
  return iitensorArrayWriteV3(scope,
                              handle,
                              index,
                              value,
                              flow_in)

converter tensorArrayWriteV3ToOut*[oT: ofloat](op: TensorArrayWriteV3[oT]): oT = return op.output

type RefMergeT = oall

type RefMerge*[oT:RefMergeT] {.header:"generated.h", importcpp:"RefMerge/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefMerge[oT: RefMergeT](scope: Scope,
               inputs: oT): RefMerge[oT] {.header:"generated.h", importcpp:"RefMerge(*#, #)", constructor.}

proc refMerge*[oT: RefMergeT](scope: Scope,
               inputs: oT): RefMerge[oT] =
  return iirefMerge(scope,
                    inputs)

converter refMergeToOut*[oT: RefMergeT](op: RefMerge[oT]): oT = return op.output

type BitwiseOrT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type BitwiseOr*[oT:BitwiseOrT] {.header:"generated.h", importcpp:"BitwiseOr/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibitwiseOr[oT: BitwiseOrT](scope: Scope,
                x: oT,
                y: oT): BitwiseOr[oT] {.header:"generated.h", importcpp:"BitwiseOr(*#, #, #)", constructor.}

proc bitwiseOr*[oT: BitwiseOrT](scope: Scope,
                x: oT,
                y: oT): BitwiseOr[oT] =
  return iibitwiseOr(scope,
                     x,
                     y)

converter bitwiseOrToOut*[oT: BitwiseOrT](op: BitwiseOr[oT]): oT = return op.output

type TensorArrayScatterT = oall

type TensorArrayScatter*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArrayScatter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayScatter[oT: ofloat](scope: Scope,
                         handle: ostring,
                         indices: oint32,
                         value: TensorArrayScatterT,
                         flow_in: oT): TensorArrayScatter[oT] {.header:"generated.h", importcpp:"TensorArrayScatter(*#, #, #, #, #)", constructor.}

proc tensorArrayScatter*[oT: ofloat](scope: Scope,
                         handle: ostring,
                         indices: oint32,
                         value: TensorArrayScatterT,
                         flow_in: oT): TensorArrayScatter[oT] =
  return iitensorArrayScatter(scope,
                              handle,
                              indices,
                              value,
                              flow_in)

converter tensorArrayScatterToOut*[oT: ofloat](op: TensorArrayScatter[oT]): oT = return op.output


type RestoreV2*[oT:oinvalid] {.header:"generated.h", importcpp:"RestoreV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirestoreV2[oT: oinvalid](scope: Scope,
                prefix: ostring,
                tensor_names: ostring,
                shape_and_slices: ostring,
                dtypes: ArraySlice[DType]): RestoreV2[oT] {.header:"generated.h", importcpp:"RestoreV2(*#, #, #, #, #)", constructor.}

proc restoreV2*[oT: oinvalid](scope: Scope,
                prefix: ostring,
                tensor_names: ostring,
                shape_and_slices: ostring,
                dtypes: openArray[DType]): RestoreV2[oT] =
  return iirestoreV2(scope,
                     prefix,
                     tensor_names,
                     shape_and_slices,
                     newArraySlice(dtypes))

converter restoreV2ToOut*[oT: oinvalid](op: RestoreV2[oT]): oT = return op.output


type RandomShuffleQueue*[oT:ostring] {.header:"generated.h", importcpp:"RandomShuffleQueue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirandomShuffleQueue[oT: ostring](scope: Scope,
                         component_types: ArraySlice[DType],
                         shapes: ArraySlice[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64,
                         min_after_dequeue: int64,
                         seed: int64,
                         seed2: int64): RandomShuffleQueue[oT] {.header:"generated.h", importcpp:"RandomShuffleQueue(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc randomShuffleQueue*[oT: ostring](scope: Scope,
                         component_types: openArray[DType],
                         shapes: openArray[TensorShape],
                         container: cstring,
                         shared_name: cstring,
                         capacity: int64 = -1,
                         min_after_dequeue: int64 = 0,
                         seed: int64 = 0,
                         seed2: int64 = 0): RandomShuffleQueue[oT] =
  return iirandomShuffleQueue(scope,
                              newArraySlice(component_types),
                              newArraySlice(shapes),
                              container,
                              shared_name,
                              capacity,
                              min_after_dequeue,
                              seed,
                              seed2)

converter randomShuffleQueueToOut*[oT: ostring](op: RandomShuffleQueue[oT]): oT = return op.output

type InvertT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type Invert*[oT:InvertT] {.header:"generated.h", importcpp:"Invert/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinvert[oT: InvertT](scope: Scope,
             x: oT): Invert[oT] {.header:"generated.h", importcpp:"Invert(*#, #)", constructor.}

proc invert*[oT: InvertT](scope: Scope,
             x: oT): Invert[oT] =
  return iiinvert(scope,
                  x)

converter invertToOut*[oT: InvertT](op: Invert[oT]): oT = return op.output

type DecodePngdtype = ouint8 | ouint16

type DecodePng*[oT:DecodePngdtype] {.header:"generated.h", importcpp:"DecodePng/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodePng[oT: DecodePngdtype](scope: Scope,
                contents: ostring,
                channels: int64,
                dtype: DType): DecodePng[oT] {.header:"generated.h", importcpp:"DecodePng(*#, #, #, #)", constructor.}

proc decodePng*[oT: DecodePngdtype](scope: Scope,
                contents: ostring,
                channels: int64 = 0,
                dtype: DType = oT[].oTF): DecodePng[oT] =
  return iidecodePng(scope,
                     contents,
                     channels,
                     dtype)

converter decodePngToOut*[oT: DecodePngdtype](op: DecodePng[oT]): oT = return op.output


type ControlTrigger*{.header:"generated.h", importcpp:"ControlTrigger/*'0*/".} = object
  operation: Operation[oinvalid]


proc iicontrolTrigger(scope: Scope): ControlTrigger {.header:"generated.h", importcpp:"ControlTrigger(*#)", constructor.}

proc controlTrigger*(scope: Scope): ControlTrigger =
  return iicontrolTrigger(scope)



type ParallelDynamicStitchT = oall

type ParallelDynamicStitch*[oT:ParallelDynamicStitchT] {.header:"generated.h", importcpp:"ParallelDynamicStitch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparallelDynamicStitch[oT: ParallelDynamicStitchT](scope: Scope,
                            indices: oint32,
                            data: oT): ParallelDynamicStitch[oT] {.header:"generated.h", importcpp:"ParallelDynamicStitch(*#, #, #)", constructor.}

proc parallelDynamicStitch*[oT: ParallelDynamicStitchT](scope: Scope,
                            indices: oint32,
                            data: oT): ParallelDynamicStitch[oT] =
  return iiparallelDynamicStitch(scope,
                                 indices,
                                 data)

converter parallelDynamicStitchToOut*[oT: ParallelDynamicStitchT](op: ParallelDynamicStitch[oT]): oT = return op.output


type MapSize*[oT:oint32] {.header:"generated.h", importcpp:"MapSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapSize[oT: oint32](scope: Scope,
              dtypes: ArraySlice[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64,
              memory_limit: int64): MapSize[oT] {.header:"generated.h", importcpp:"MapSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapSize*[oT: oint32](scope: Scope,
              dtypes: openArray[DType],
              container: cstring,
              shared_name: cstring,
              capacity: int64 = 0,
              memory_limit: int64 = 0): MapSize[oT] =
  return iimapSize(scope,
                   newArraySlice(dtypes),
                   container,
                   shared_name,
                   capacity,
                   memory_limit)

converter mapSizeToOut*[oT: oint32](op: MapSize[oT]): oT = return op.output

type SparseReduceSumT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseReduceSum*[oT:SparseReduceSumT] {.header:"generated.h", importcpp:"SparseReduceSum/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseReduceSum[oT: SparseReduceSumT](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool): SparseReduceSum[oT] {.header:"generated.h", importcpp:"SparseReduceSum(*#, #, #, #, #, #)", constructor.}

proc sparseReduceSum*[oT: SparseReduceSumT](scope: Scope,
                      input_indices: oint64,
                      input_values: oT,
                      input_shape: oint64,
                      reduction_axes: oint32,
                      keep_dims: bool = false): SparseReduceSum[oT] =
  return iisparseReduceSum(scope,
                           input_indices,
                           input_values,
                           input_shape,
                           reduction_axes,
                           keep_dims)

converter sparseReduceSumToOut*[oT: SparseReduceSumT](op: SparseReduceSum[oT]): oT = return op.output

type ZetaT = ofloat | odouble

type Zeta*[oT:ZetaT] {.header:"generated.h", importcpp:"Zeta/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iizeta[oT: ZetaT](scope: Scope,
           x: oT,
           q: oT): Zeta[oT] {.header:"generated.h", importcpp:"Zeta(*#, #, #)", constructor.}

proc zeta*[oT: ZetaT](scope: Scope,
           x: oT,
           q: oT): Zeta[oT] =
  return iizeta(scope,
                x,
                q)

converter zetaToOut*[oT: ZetaT](op: Zeta[oT]): oT = return op.output


type TensorArrayGradV2*[oT:ostring] {.header:"generated.h", importcpp:"TensorArrayGradV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGradV2[oT: ostring](scope: Scope,
                        handle: oT,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV2[oT] {.header:"generated.h", importcpp:"TensorArrayGradV2(*#, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGradV2*[oT: ostring](scope: Scope,
                        handle: oT,
                        flow_in: ofloat,
                        source: cstring): TensorArrayGradV2[oT] =
  return iitensorArrayGradV2(scope,
                             handle,
                             flow_in,
                             source)

converter tensorArrayGradV2ToOut*[oT: ostring](op: TensorArrayGradV2[oT]): oT = return op.output

type MaxPoolGradGradWithArgmaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64
type MaxPoolGradGradWithArgmaxTargmax = oint32 | oint64

type MaxPoolGradGradWithArgmax*[oT:MaxPoolGradGradWithArgmaxT] {.header:"generated.h", importcpp:"MaxPoolGradGradWithArgmax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolGradGradWithArgmax[oT: MaxPoolGradGradWithArgmaxT](scope: Scope,
                                input: oT,
                                grad: oT,
                                argmax: MaxPoolGradGradWithArgmaxTargmax,
                                ksize: ArraySlice[int],
                                strides: ArraySlice[int],
                                padding: cstring): MaxPoolGradGradWithArgmax[oT] {.header:"generated.h", importcpp:"MaxPoolGradGradWithArgmax(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc maxPoolGradGradWithArgmax*[oT: MaxPoolGradGradWithArgmaxT](scope: Scope,
                                input: oT,
                                grad: oT,
                                argmax: MaxPoolGradGradWithArgmaxTargmax,
                                ksize: openArray[int],
                                strides: openArray[int],
                                padding: cstring): MaxPoolGradGradWithArgmax[oT] =
  return iimaxPoolGradGradWithArgmax(scope,
                                     input,
                                     grad,
                                     argmax,
                                     newArraySlice(ksize),
                                     newArraySlice(strides),
                                     padding)

converter maxPoolGradGradWithArgmaxToOut*[oT: MaxPoolGradGradWithArgmaxT](op: MaxPoolGradGradWithArgmax[oT]): oT = return op.output

type LessT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Less*[oT:obool] {.header:"generated.h", importcpp:"Less/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiless[oT: obool](scope: Scope,
           x: LessT,
           y: LessT): Less[oT] {.header:"generated.h", importcpp:"Less(*#, #, #)", constructor.}

proc less*[oT: obool](scope: Scope,
           x: LessT,
           y: LessT): Less[oT] =
  return iiless(scope,
                x,
                y)

converter lessToOut*[oT: obool](op: Less[oT]): oT = return op.output

type ApplyGradientDescentT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyGradientDescent*[oT:ApplyGradientDescentT] {.header:"generated.h", importcpp:"ApplyGradientDescent/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyGradientDescent[oT: ApplyGradientDescentT](scope: Scope,
                           nvar: oT,
                           alpha: oT,
                           delta: oT,
                           use_locking: bool): ApplyGradientDescent[oT] {.header:"generated.h", importcpp:"ApplyGradientDescent(*#, #, #, #, #)", constructor.}

proc applyGradientDescent*[oT: ApplyGradientDescentT](scope: Scope,
                           nvar: oT,
                           alpha: oT,
                           delta: oT,
                           use_locking: bool = false): ApplyGradientDescent[oT] =
  return iiapplyGradientDescent(scope,
                                nvar,
                                alpha,
                                delta,
                                use_locking)

converter applyGradientDescentToOut*[oT: ApplyGradientDescentT](op: ApplyGradientDescent[oT]): oT = return op.output

type CollectiveReduceT = ofloat | ohalf | odouble | oint32 | oint64

type CollectiveReduce*[oT:CollectiveReduceT] {.header:"generated.h", importcpp:"CollectiveReduce/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicollectiveReduce[oT: CollectiveReduceT](scope: Scope,
                       input: oT,
                       merge_op: cstring,
                       final_op: cstring,
                       subdiv_offsets: ArraySlice[int],
                       instance_key: int64,
                       group_size: int64,
                       group_key: int64): CollectiveReduce[oT] {.header:"generated.h", importcpp:"CollectiveReduce(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc collectiveReduce*[oT: CollectiveReduceT](scope: Scope,
                       input: oT,
                       merge_op: cstring,
                       final_op: cstring,
                       subdiv_offsets: openArray[int],
                       instance_key: int64 = 0,
                       group_size: int64 = 0,
                       group_key: int64 = 0): CollectiveReduce[oT] =
  return iicollectiveReduce(scope,
                            input,
                            merge_op,
                            final_op,
                            newArraySlice(subdiv_offsets),
                            instance_key,
                            group_size,
                            group_key)

converter collectiveReduceToOut*[oT: CollectiveReduceT](op: CollectiveReduce[oT]): oT = return op.output


type CreateSummaryFileWriter*{.header:"generated.h", importcpp:"CreateSummaryFileWriter/*'0*/".} = object
  operation: Operation[oinvalid]


proc iicreateSummaryFileWriter(scope: Scope,
                              writer: oresource,
                              logdir: ostring,
                              max_queue: oint32,
                              flush_millis: oint32,
                              filename_suffix: ostring): CreateSummaryFileWriter {.header:"generated.h", importcpp:"CreateSummaryFileWriter(*#, #, #, #, #, #)", constructor.}

proc createSummaryFileWriter*(scope: Scope,
                              writer: oresource,
                              logdir: ostring,
                              max_queue: oint32,
                              flush_millis: oint32,
                              filename_suffix: ostring): CreateSummaryFileWriter =
  return iicreateSummaryFileWriter(scope,
                                   writer,
                                   logdir,
                                   max_queue,
                                   flush_millis,
                                   filename_suffix)




type QueueIsClosedV2*[oT:obool] {.header:"generated.h", importcpp:"QueueIsClosedV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueIsClosedV2[oT: obool](scope: Scope,
                      handle: oresource): QueueIsClosedV2[oT] {.header:"generated.h", importcpp:"QueueIsClosedV2(*#, #)", constructor.}

proc queueIsClosedV2*[oT: obool](scope: Scope,
                      handle: oresource): QueueIsClosedV2[oT] =
  return iiqueueIsClosedV2(scope,
                           handle)

converter queueIsClosedV2ToOut*[oT: obool](op: QueueIsClosedV2[oT]): oT = return op.output

type IParallelConcatUpdateT = oall

type IParallelConcatUpdate*[oT:IParallelConcatUpdateT] {.header:"generated.h", importcpp:"_ParallelConcatUpdate/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiParallelConcatUpdate[oT: IParallelConcatUpdateT](scope: Scope,
                            value: oT,
                            update: oT,
                            loc: int64): IParallelConcatUpdate[oT] {.header:"generated.h", importcpp:"_ParallelConcatUpdate(*#, #, #, #)", constructor.}

proc iParallelConcatUpdate*[oT: IParallelConcatUpdateT](scope: Scope,
                            value: oT,
                            update: oT,
                            loc: int64 = 0): IParallelConcatUpdate[oT] =
  return iiiParallelConcatUpdate(scope,
                                 value,
                                 update,
                                 loc)

converter iParallelConcatUpdateToOut*[oT: IParallelConcatUpdateT](op: IParallelConcatUpdate[oT]): oT = return op.output

type CudnnRNNCanonicalToParamsT = ohalf | ofloat | odouble

type CudnnRNNCanonicalToParams*[oT:CudnnRNNCanonicalToParamsT] {.header:"generated.h", importcpp:"CudnnRNNCanonicalToParams/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNNCanonicalToParams[oT: CudnnRNNCanonicalToParamsT](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                weights: oT,
                                biases: oT,
                                seed2: int64,
                                num_params: int64,
                                rnn_mode: cstring,
                                input_mode: cstring,
                                direction: cstring,
                                dropout: float32,
                                seed: int64): CudnnRNNCanonicalToParams[oT] {.header:"generated.h", importcpp:"CudnnRNNCanonicalToParams(*#, #, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc cudnnRNNCanonicalToParams*[oT: CudnnRNNCanonicalToParamsT](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                weights: oT,
                                biases: oT,
                                seed2: int64 = 0,
                                num_params: int64 = 0,
                                rnn_mode: cstring = "lstm",
                                input_mode: cstring = "linear_input",
                                direction: cstring = "unidirectional",
                                dropout: float32 = 0.0.float32,
                                seed: int64 = 0): CudnnRNNCanonicalToParams[oT] =
  return iicudnnRNNCanonicalToParams(scope,
                                     num_layers,
                                     num_units,
                                     input_size,
                                     weights,
                                     biases,
                                     seed2,
                                     num_params,
                                     rnn_mode,
                                     input_mode,
                                     direction,
                                     dropout,
                                     seed)

converter cudnnRNNCanonicalToParamsToOut*[oT: CudnnRNNCanonicalToParamsT](op: CudnnRNNCanonicalToParams[oT]): oT = return op.output


type TensorArraySizeV3*[oT:oint32] {.header:"generated.h", importcpp:"TensorArraySizeV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArraySizeV3[oT: oint32](scope: Scope,
                        handle: oresource,
                        flow_in: ofloat): TensorArraySizeV3[oT] {.header:"generated.h", importcpp:"TensorArraySizeV3(*#, #, #)", constructor.}

proc tensorArraySizeV3*[oT: oint32](scope: Scope,
                        handle: oresource,
                        flow_in: ofloat): TensorArraySizeV3[oT] =
  return iitensorArraySizeV3(scope,
                             handle,
                             flow_in)

converter tensorArraySizeV3ToOut*[oT: oint32](op: TensorArraySizeV3[oT]): oT = return op.output

type DiagPartT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type DiagPart*[oT:DiagPartT] {.header:"generated.h", importcpp:"DiagPart/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidiagPart[oT: DiagPartT](scope: Scope,
               input: oT): DiagPart[oT] {.header:"generated.h", importcpp:"DiagPart(*#, #)", constructor.}

proc diagPart*[oT: DiagPartT](scope: Scope,
               input: oT): DiagPart[oT] =
  return iidiagPart(scope,
                    input)

converter diagPartToOut*[oT: DiagPartT](op: DiagPart[oT]): oT = return op.output

type CudnnRNNParamsToCanonicalT = ohalf | ofloat | odouble

type CudnnRNNParamsToCanonical*[oT:CudnnRNNParamsToCanonicalT] {.header:"generated.h", importcpp:"CudnnRNNParamsToCanonical/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNNParamsToCanonical[oT: CudnnRNNParamsToCanonicalT](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                params: oT,
                                seed2: int64,
                                num_params: int64,
                                rnn_mode: cstring,
                                input_mode: cstring,
                                direction: cstring,
                                dropout: float32,
                                seed: int64): CudnnRNNParamsToCanonical[oT] {.header:"generated.h", importcpp:"CudnnRNNParamsToCanonical(*#, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc cudnnRNNParamsToCanonical*[oT: CudnnRNNParamsToCanonicalT](scope: Scope,
                                num_layers: oint32,
                                num_units: oint32,
                                input_size: oint32,
                                params: oT,
                                seed2: int64 = 0,
                                num_params: int64 = 0,
                                rnn_mode: cstring = "lstm",
                                input_mode: cstring = "linear_input",
                                direction: cstring = "unidirectional",
                                dropout: float32 = 0.0.float32,
                                seed: int64 = 0): CudnnRNNParamsToCanonical[oT] =
  return iicudnnRNNParamsToCanonical(scope,
                                     num_layers,
                                     num_units,
                                     input_size,
                                     params,
                                     seed2,
                                     num_params,
                                     rnn_mode,
                                     input_mode,
                                     direction,
                                     dropout,
                                     seed)

converter cudnnRNNParamsToCanonicalToOut*[oT: CudnnRNNParamsToCanonicalT](op: CudnnRNNParamsToCanonical[oT]): oT = return op.output

type IParallelConcatStartdtype = oall

type IParallelConcatStart*[oT:IParallelConcatStartdtype] {.header:"generated.h", importcpp:"_ParallelConcatStart/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiParallelConcatStart[oT: IParallelConcatStartdtype](scope: Scope,
                           shape: TensorShape,
                           dtype: DType): IParallelConcatStart[oT] {.header:"generated.h", importcpp:"_ParallelConcatStart(*#, #, #)", constructor.}

proc iParallelConcatStart*[oT: IParallelConcatStartdtype](scope: Scope,
                           shape: TensorShape = [].shape,
                           dtype: DType = oT[].oTF): IParallelConcatStart[oT] =
  return iiiParallelConcatStart(scope,
                                shape,
                                dtype)

converter iParallelConcatStartToOut*[oT: IParallelConcatStartdtype](op: IParallelConcatStart[oT]): oT = return op.output

type SizeT = oall
type Sizeout_type = oint32 | oint64

type Size*[oT:Sizeout_type] {.header:"generated.h", importcpp:"Size/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisize[oT: Sizeout_type](scope: Scope,
           input: SizeT): Size[oT] {.header:"generated.h", importcpp:"Size(*#, #)", constructor.}

proc size*[oT: Sizeout_type](scope: Scope,
           input: SizeT): Size[oT] =
  return iisize(scope,
                input)

converter sizeToOut*[oT: Sizeout_type](op: Size[oT]): oT = return op.output


type FakeQuantWithMinMaxVarsGradient*[oT:ofloat] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVarsGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQuantWithMinMaxVarsGradient[oT: ofloat](scope: Scope,
                                      gradients: oT,
                                      inputs: oT,
                                      min: oT,
                                      max: oT,
                                      num_bits: int64,
                                      narrow_range: bool): FakeQuantWithMinMaxVarsGradient[oT] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxVarsGradient(*#, #, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxVarsGradient*[oT: ofloat](scope: Scope,
                                      gradients: oT,
                                      inputs: oT,
                                      min: oT,
                                      max: oT,
                                      num_bits: int64 = 8,
                                      narrow_range: bool = false): FakeQuantWithMinMaxVarsGradient[oT] =
  return iifakeQuantWithMinMaxVarsGradient(scope,
                                           gradients,
                                           inputs,
                                           min,
                                           max,
                                           num_bits,
                                           narrow_range)

converter fakeQuantWithMinMaxVarsGradientToOut*[oT: ofloat](op: FakeQuantWithMinMaxVarsGradient[oT]): oT = return op.output

type NonMaxSuppressionV4T = ohalf | ofloat

type NonMaxSuppressionV4*[oT:oint32] {.header:"generated.h", importcpp:"NonMaxSuppressionV4/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinonMaxSuppressionV4[oT: oint32](scope: Scope,
                          boxes: NonMaxSuppressionV4T,
                          scores: NonMaxSuppressionV4T,
                          max_output_size: oT,
                          iou_threshold: ofloat,
                          score_threshold: ofloat,
                          pad_to_max_output_size: bool): NonMaxSuppressionV4[oT] {.header:"generated.h", importcpp:"NonMaxSuppressionV4(*#, #, #, #, #, #, #)", constructor.}

proc nonMaxSuppressionV4*[oT: oint32](scope: Scope,
                          boxes: NonMaxSuppressionV4T,
                          scores: NonMaxSuppressionV4T,
                          max_output_size: oT,
                          iou_threshold: ofloat,
                          score_threshold: ofloat,
                          pad_to_max_output_size: bool = false): NonMaxSuppressionV4[oT] =
  return iinonMaxSuppressionV4(scope,
                               boxes,
                               scores,
                               max_output_size,
                               iou_threshold,
                               score_threshold,
                               pad_to_max_output_size)

converter nonMaxSuppressionV4ToOut*[oT: oint32](op: NonMaxSuppressionV4[oT]): oT = return op.output

type CudnnRNNBackpropT = ohalf | ofloat | odouble

type CudnnRNNBackprop*[oT:CudnnRNNBackpropT] {.header:"generated.h", importcpp:"CudnnRNNBackprop/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNNBackprop[oT: CudnnRNNBackpropT](scope: Scope,
                       input: oT,
                       input_h: oT,
                       input_c: oT,
                       params: oT,
                       output: oT,
                       output_h: oT,
                       output_c: oT,
                       output_backprop: oT,
                       output_h_backprop: oT,
                       output_c_backprop: oT,
                       reserve_space: oT,
                       seed2: int64,
                       rnn_mode: cstring,
                       input_mode: cstring,
                       direction: cstring,
                       dropout: float32,
                       seed: int64): CudnnRNNBackprop[oT] {.header:"generated.h", importcpp:"CudnnRNNBackprop(*#, #, #, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc cudnnRNNBackprop*[oT: CudnnRNNBackpropT](scope: Scope,
                       input: oT,
                       input_h: oT,
                       input_c: oT,
                       params: oT,
                       output: oT,
                       output_h: oT,
                       output_c: oT,
                       output_backprop: oT,
                       output_h_backprop: oT,
                       output_c_backprop: oT,
                       reserve_space: oT,
                       seed2: int64 = 0,
                       rnn_mode: cstring = "lstm",
                       input_mode: cstring = "linear_input",
                       direction: cstring = "unidirectional",
                       dropout: float32 = 0.0.float32,
                       seed: int64 = 0): CudnnRNNBackprop[oT] =
  return iicudnnRNNBackprop(scope,
                            input,
                            input_h,
                            input_c,
                            params,
                            output,
                            output_h,
                            output_c,
                            output_backprop,
                            output_h_backprop,
                            output_c_backprop,
                            reserve_space,
                            seed2,
                            rnn_mode,
                            input_mode,
                            direction,
                            dropout,
                            seed)

converter cudnnRNNBackpropToOut*[oT: CudnnRNNBackpropT](op: CudnnRNNBackprop[oT]): oT = return op.output

type PadT = oall
type PadTpaddings = oint32 | oint64

type Pad*[oT:PadT] {.header:"generated.h", importcpp:"Pad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipad[oT: PadT](scope: Scope,
          input: oT,
          paddings: PadTpaddings): Pad[oT] {.header:"generated.h", importcpp:"Pad(*#, #, #)", constructor.}

proc pad*[oT: PadT](scope: Scope,
          input: oT,
          paddings: PadTpaddings): Pad[oT] =
  return iipad(scope,
               input,
               paddings)

converter padToOut*[oT: PadT](op: Pad[oT]): oT = return op.output

type CudnnRNNV2T = ohalf | ofloat | odouble

type CudnnRNNV2*[oT:CudnnRNNV2T] {.header:"generated.h", importcpp:"CudnnRNNV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNNV2[oT: CudnnRNNV2T](scope: Scope,
                 input: oT,
                 input_h: oT,
                 input_c: oT,
                 params: oT,
                 is_training: bool,
                 rnn_mode: cstring,
                 input_mode: cstring,
                 direction: cstring,
                 dropout: float32,
                 seed: int64,
                 seed2: int64): CudnnRNNV2[oT] {.header:"generated.h", importcpp:"CudnnRNNV2(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #, #)", constructor.}

proc cudnnRNNV2*[oT: CudnnRNNV2T](scope: Scope,
                 input: oT,
                 input_h: oT,
                 input_c: oT,
                 params: oT,
                 is_training: bool = true,
                 rnn_mode: cstring = "lstm",
                 input_mode: cstring = "linear_input",
                 direction: cstring = "unidirectional",
                 dropout: float32 = 0.0.float32,
                 seed: int64 = 0,
                 seed2: int64 = 0): CudnnRNNV2[oT] =
  return iicudnnRNNV2(scope,
                      input,
                      input_h,
                      input_c,
                      params,
                      is_training,
                      rnn_mode,
                      input_mode,
                      direction,
                      dropout,
                      seed,
                      seed2)

converter cudnnRNNV2ToOut*[oT: CudnnRNNV2T](op: CudnnRNNV2[oT]): oT = return op.output

type DynamicStitchT = oall

type DynamicStitch*[oT:DynamicStitchT] {.header:"generated.h", importcpp:"DynamicStitch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidynamicStitch[oT: DynamicStitchT](scope: Scope,
                    indices: oint32,
                    data: oT): DynamicStitch[oT] {.header:"generated.h", importcpp:"DynamicStitch(*#, #, #)", constructor.}

proc dynamicStitch*[oT: DynamicStitchT](scope: Scope,
                    indices: oint32,
                    data: oT): DynamicStitch[oT] =
  return iidynamicStitch(scope,
                         indices,
                         data)

converter dynamicStitchToOut*[oT: DynamicStitchT](op: DynamicStitch[oT]): oT = return op.output

type IRetvalT = oall

type IRetval*{.header:"generated.h", importcpp:"_Retval/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiiRetval(scope: Scope,
              input: IRetvalT,
              index: int64): IRetval {.header:"generated.h", importcpp:"_Retval(*#, #, #)", constructor.}

proc iRetval*(scope: Scope,
              input: IRetvalT,
              index: int64 = 0): IRetval =
  return iiiRetval(scope,
                   input,
                   index)




type CTCBeamSearchDecoder*[oT:oint64] {.header:"generated.h", importcpp:"CTCBeamSearchDecoder/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicTCBeamSearchDecoder[oT: oint64](scope: Scope,
                           inputs: ofloat,
                           sequence_length: oint32,
                           beam_width: int64,
                           top_paths: int64,
                           merge_repeated: bool): CTCBeamSearchDecoder[oT] {.header:"generated.h", importcpp:"CTCBeamSearchDecoder(*#, #, #, #, #, #)", constructor.}

proc cTCBeamSearchDecoder*[oT: oint64](scope: Scope,
                           inputs: ofloat,
                           sequence_length: oint32,
                           beam_width: int64 = 0,
                           top_paths: int64 = 0,
                           merge_repeated: bool = true): CTCBeamSearchDecoder[oT] =
  return iicTCBeamSearchDecoder(scope,
                                inputs,
                                sequence_length,
                                beam_width,
                                top_paths,
                                merge_repeated)

converter cTCBeamSearchDecoderToOut*[oT: oint64](op: CTCBeamSearchDecoder[oT]): oT = return op.output


type OrderedMapPeek*[oT:oinvalid] {.header:"generated.h", importcpp:"OrderedMapPeek/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiorderedMapPeek[oT: oinvalid](scope: Scope,
                     key: oint64,
                     indices: oint32,
                     dtypes: ArraySlice[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64,
                     memory_limit: int64): OrderedMapPeek[oT] {.header:"generated.h", importcpp:"OrderedMapPeek(*#, #, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc orderedMapPeek*[oT: oinvalid](scope: Scope,
                     key: oint64,
                     indices: oint32,
                     dtypes: openArray[DType],
                     container: cstring,
                     shared_name: cstring,
                     capacity: int64 = 0,
                     memory_limit: int64 = 0): OrderedMapPeek[oT] =
  return iiorderedMapPeek(scope,
                          key,
                          indices,
                          newArraySlice(dtypes),
                          container,
                          shared_name,
                          capacity,
                          memory_limit)

converter orderedMapPeekToOut*[oT: oinvalid](op: OrderedMapPeek[oT]): oT = return op.output

type FusedResizeAndPadConv2DT = ohalf | ofloat | odouble

type FusedResizeAndPadConv2D*[oT:FusedResizeAndPadConv2DT] {.header:"generated.h", importcpp:"FusedResizeAndPadConv2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifusedResizeAndPadConv2D[oT: FusedResizeAndPadConv2DT](scope: Scope,
                              input: oT,
                              size: oint32,
                              paddings: oint32,
                              filter: oT,
                              mode: cstring,
                              strides: ArraySlice[int],
                              padding: cstring,
                              resize_align_corners: bool): FusedResizeAndPadConv2D[oT] {.header:"generated.h", importcpp:"FusedResizeAndPadConv2D(*#, #, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc fusedResizeAndPadConv2D*[oT: FusedResizeAndPadConv2DT](scope: Scope,
                              input: oT,
                              size: oint32,
                              paddings: oint32,
                              filter: oT,
                              mode: cstring,
                              strides: openArray[int],
                              padding: cstring,
                              resize_align_corners: bool = false): FusedResizeAndPadConv2D[oT] =
  return iifusedResizeAndPadConv2D(scope,
                                   input,
                                   size,
                                   paddings,
                                   filter,
                                   mode,
                                   newArraySlice(strides),
                                   padding,
                                   resize_align_corners)

converter fusedResizeAndPadConv2DToOut*[oT: FusedResizeAndPadConv2DT](op: FusedResizeAndPadConv2D[oT]): oT = return op.output

type XdivyT = ohalf | ofloat | odouble | ocomplex64 | ocomplex128

type Xdivy*[oT:XdivyT] {.header:"generated.h", importcpp:"Xdivy/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iixdivy[oT: XdivyT](scope: Scope,
            x: oT,
            y: oT): Xdivy[oT] {.header:"generated.h", importcpp:"Xdivy(*#, #, #)", constructor.}

proc xdivy*[oT: XdivyT](scope: Scope,
            x: oT,
            y: oT): Xdivy[oT] =
  return iixdivy(scope,
                 x,
                 y)

converter xdivyToOut*[oT: XdivyT](op: Xdivy[oT]): oT = return op.output

type RefNextIterationT = oall

type RefNextIteration*[oT:RefNextIterationT] {.header:"generated.h", importcpp:"RefNextIteration/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefNextIteration[oT: RefNextIterationT](scope: Scope,
                       data: oT): RefNextIteration[oT] {.header:"generated.h", importcpp:"RefNextIteration(*#, #)", constructor.}

proc refNextIteration*[oT: RefNextIterationT](scope: Scope,
                       data: oT): RefNextIteration[oT] =
  return iirefNextIteration(scope,
                            data)

converter refNextIterationToOut*[oT: RefNextIterationT](op: RefNextIteration[oT]): oT = return op.output

type LogMatrixDeterminantT = ofloat | odouble | ocomplex64 | ocomplex128

type LogMatrixDeterminant*[oT:LogMatrixDeterminantT] {.header:"generated.h", importcpp:"LogMatrixDeterminant/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilogMatrixDeterminant[oT: LogMatrixDeterminantT](scope: Scope,
                           input: oT): LogMatrixDeterminant[oT] {.header:"generated.h", importcpp:"LogMatrixDeterminant(*#, #)", constructor.}

proc logMatrixDeterminant*[oT: LogMatrixDeterminantT](scope: Scope,
                           input: oT): LogMatrixDeterminant[oT] =
  return iilogMatrixDeterminant(scope,
                                input)

converter logMatrixDeterminantToOut*[oT: LogMatrixDeterminantT](op: LogMatrixDeterminant[oT]): oT = return op.output


type ExperimentalNonSerializableDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalNonSerializableDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalNonSerializableDataset[oT: ovariant](scope: Scope,
                                         input_dataset: oT,
                                         output_types: ArraySlice[DType],
                                         output_shapes: ArraySlice[TensorShape]): ExperimentalNonSerializableDataset[oT] {.header:"generated.h", importcpp:"ExperimentalNonSerializableDataset(*#, #, #, #)", constructor.}

proc experimentalNonSerializableDataset*[oT: ovariant](scope: Scope,
                                         input_dataset: oT,
                                         output_types: openArray[DType],
                                         output_shapes: openArray[TensorShape]): ExperimentalNonSerializableDataset[oT] =
  return iiexperimentalNonSerializableDataset(scope,
                                              input_dataset,
                                              newArraySlice(output_types),
                                              newArraySlice(output_shapes))

converter experimentalNonSerializableDatasetToOut*[oT: ovariant](op: ExperimentalNonSerializableDataset[oT]): oT = return op.output

type ExitT = oall

type Exit*[oT:ExitT] {.header:"generated.h", importcpp:"Exit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexit[oT: ExitT](scope: Scope,
           data: oT): Exit[oT] {.header:"generated.h", importcpp:"Exit(*#, #)", constructor.}

proc exit*[oT: ExitT](scope: Scope,
           data: oT): Exit[oT] =
  return iiexit(scope,
                data)

converter exitToOut*[oT: ExitT](op: Exit[oT]): oT = return op.output


type StringStrip*[oT:ostring] {.header:"generated.h", importcpp:"StringStrip/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringStrip[oT: ostring](scope: Scope,
                  input: oT): StringStrip[oT] {.header:"generated.h", importcpp:"StringStrip(*#, #)", constructor.}

proc stringStrip*[oT: ostring](scope: Scope,
                  input: oT): StringStrip[oT] =
  return iistringStrip(scope,
                       input)

converter stringStripToOut*[oT: ostring](op: StringStrip[oT]): oT = return op.output

type RefSelectT = oall

type RefSelect*[oT:RefSelectT] {.header:"generated.h", importcpp:"RefSelect/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefSelect[oT: RefSelectT](scope: Scope,
                index: oint32,
                inputs: oT): RefSelect[oT] {.header:"generated.h", importcpp:"RefSelect(*#, #, #)", constructor.}

proc refSelect*[oT: RefSelectT](scope: Scope,
                index: oint32,
                inputs: oT): RefSelect[oT] =
  return iirefSelect(scope,
                     index,
                     inputs)

converter refSelectToOut*[oT: RefSelectT](op: RefSelect[oT]): oT = return op.output

type SoftmaxT = ohalf | obfloat16 | ofloat | odouble

type Softmax*[oT:SoftmaxT] {.header:"generated.h", importcpp:"Softmax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisoftmax[oT: SoftmaxT](scope: Scope,
              logits: oT): Softmax[oT] {.header:"generated.h", importcpp:"Softmax(*#, #)", constructor.}

proc softmax*[oT: SoftmaxT](scope: Scope,
              logits: oT): Softmax[oT] =
  return iisoftmax(scope,
                   logits)

converter softmaxToOut*[oT: SoftmaxT](op: Softmax[oT]): oT = return op.output

type ScalarSummaryT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type ScalarSummary*[oT:ostring] {.header:"generated.h", importcpp:"ScalarSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscalarSummary[oT: ostring](scope: Scope,
                    tags: oT,
                    values: ScalarSummaryT): ScalarSummary[oT] {.header:"generated.h", importcpp:"ScalarSummary(*#, #, #)", constructor.}

proc scalarSummary*[oT: ostring](scope: Scope,
                    tags: oT,
                    values: ScalarSummaryT): ScalarSummary[oT] =
  return iiscalarSummary(scope,
                         tags,
                         values)

converter scalarSummaryToOut*[oT: ostring](op: ScalarSummary[oT]): oT = return op.output

type IdentityT = oall

type Identity*[oT:IdentityT] {.header:"generated.h", importcpp:"Identity/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiidentity[oT: IdentityT](scope: Scope,
               input: oT): Identity[oT] {.header:"generated.h", importcpp:"Identity(*#, #)", constructor.}

proc identity*[oT: IdentityT](scope: Scope,
               input: oT): Identity[oT] =
  return iiidentity(scope,
                    input)

converter identityToOut*[oT: IdentityT](op: Identity[oT]): oT = return op.output

type ReverseV2T = ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | obool | obfloat16 | ohalf | ofloat | odouble | ocomplex64 | ocomplex128 | ostring
type ReverseV2Tidx = oint32 | oint64

type ReverseV2*[oT:ReverseV2T] {.header:"generated.h", importcpp:"ReverseV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireverseV2[oT: ReverseV2T](scope: Scope,
                tensor: oT,
                axis: ReverseV2Tidx): ReverseV2[oT] {.header:"generated.h", importcpp:"ReverseV2(*#, #, #)", constructor.}

proc reverseV2*[oT: ReverseV2T](scope: Scope,
                tensor: oT,
                axis: ReverseV2Tidx): ReverseV2[oT] =
  return iireverseV2(scope,
                     tensor,
                     axis)

converter reverseV2ToOut*[oT: ReverseV2T](op: ReverseV2[oT]): oT = return op.output

type RefSwitchT = oall

type RefSwitch*[oT:RefSwitchT] {.header:"generated.h", importcpp:"RefSwitch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefSwitch[oT: RefSwitchT](scope: Scope,
                data: oT,
                pred: obool): RefSwitch[oT] {.header:"generated.h", importcpp:"RefSwitch(*#, #, #)", constructor.}

proc refSwitch*[oT: RefSwitchT](scope: Scope,
                data: oT,
                pred: obool): RefSwitch[oT] =
  return iirefSwitch(scope,
                     data,
                     pred)

converter refSwitchToOut*[oT: RefSwitchT](op: RefSwitch[oT]): oT = return op.output


type NoOp*{.header:"generated.h", importcpp:"NoOp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iinoOp(scope: Scope): NoOp {.header:"generated.h", importcpp:"NoOp(*#)", constructor.}

proc noOp*(scope: Scope): NoOp =
  return iinoOp(scope)




type LoadAndRemapMatrix*[oT:ofloat] {.header:"generated.h", importcpp:"LoadAndRemapMatrix/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiloadAndRemapMatrix[oT: ofloat](scope: Scope,
                         ckpt_path: ostring,
                         old_tensor_name: ostring,
                         row_remapping: oint64,
                         col_remapping: oint64,
                         initializing_values: oT,
                         num_rows: int64,
                         num_cols: int64,
                         max_rows_in_memory: int64): LoadAndRemapMatrix[oT] {.header:"generated.h", importcpp:"LoadAndRemapMatrix(*#, #, #, #, #, #, #, #, #)", constructor.}

proc loadAndRemapMatrix*[oT: ofloat](scope: Scope,
                         ckpt_path: ostring,
                         old_tensor_name: ostring,
                         row_remapping: oint64,
                         col_remapping: oint64,
                         initializing_values: oT,
                         num_rows: int64 = 0,
                         num_cols: int64 = 0,
                         max_rows_in_memory: int64 = -1): LoadAndRemapMatrix[oT] =
  return iiloadAndRemapMatrix(scope,
                              ckpt_path,
                              old_tensor_name,
                              row_remapping,
                              col_remapping,
                              initializing_values,
                              num_rows,
                              num_cols,
                              max_rows_in_memory)

converter loadAndRemapMatrixToOut*[oT: ofloat](op: LoadAndRemapMatrix[oT]): oT = return op.output


type IteratorFromStringHandleV2*[oT:oresource] {.header:"generated.h", importcpp:"IteratorFromStringHandleV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorFromStringHandleV2[oT: oresource](scope: Scope,
                                 string_handle: ostring,
                                 output_types: ArraySlice[DType],
                                 output_shapes: ArraySlice[TensorShape]): IteratorFromStringHandleV2[oT] {.header:"generated.h", importcpp:"IteratorFromStringHandleV2(*#, #, #, #)", constructor.}

proc iteratorFromStringHandleV2*[oT: oresource](scope: Scope,
                                 string_handle: ostring,
                                 output_types: openArray[DType],
                                 output_shapes: openArray[TensorShape]): IteratorFromStringHandleV2[oT] =
  return iiiteratorFromStringHandleV2(scope,
                                      string_handle,
                                      newArraySlice(output_types),
                                      newArraySlice(output_shapes))

converter iteratorFromStringHandleV2ToOut*[oT: oresource](op: IteratorFromStringHandleV2[oT]): oT = return op.output


type GenerateVocabRemapping*[oT:oint64] {.header:"generated.h", importcpp:"GenerateVocabRemapping/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigenerateVocabRemapping[oT: oint64](scope: Scope,
                             new_vocab_file: ostring,
                             old_vocab_file: ostring,
                             new_vocab_offset: int64,
                             num_new_vocab: int64,
                             old_vocab_size: int64): GenerateVocabRemapping[oT] {.header:"generated.h", importcpp:"GenerateVocabRemapping(*#, #, #, #, #, #)", constructor.}

proc generateVocabRemapping*[oT: oint64](scope: Scope,
                             new_vocab_file: ostring,
                             old_vocab_file: ostring,
                             new_vocab_offset: int64 = 0,
                             num_new_vocab: int64 = 0,
                             old_vocab_size: int64 = -1): GenerateVocabRemapping[oT] =
  return iigenerateVocabRemapping(scope,
                                  new_vocab_file,
                                  old_vocab_file,
                                  new_vocab_offset,
                                  num_new_vocab,
                                  old_vocab_size)

converter generateVocabRemappingToOut*[oT: oint64](op: GenerateVocabRemapping[oT]): oT = return op.output

type IfTcond = oall

type If*[oT:oinvalid] {.header:"generated.h", importcpp:"If/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinif[oT: oinvalid](scope: Scope,
          cond: IfTcond,
          input: oT,
          Tin: ArraySlice[DType],
          Tout: ArraySlice[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList,
          output_shapes: ArraySlice[TensorShape]): If[oT] {.header:"generated.h", importcpp:"If(*#, #, #, #, #, #, #, #)", constructor.}

proc nif*[oT: oinvalid](scope: Scope,
          cond: IfTcond,
          input: oT,
          Tin: openArray[DType],
          Tout: openArray[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList,
          output_shapes: openArray[TensorShape]): If[oT] =
  return iinif(scope,
               cond,
               input,
               newArraySlice(Tin),
               newArraySlice(Tout),
               then_branch,
               else_branch,
               newArraySlice(output_shapes))

converter nifToOut*[oT: oinvalid](op: If[oT]): oT = return op.output


type TensorForestTreeDeserialize*{.header:"generated.h", importcpp:"TensorForestTreeDeserialize/*'0*/".} = object
  operation: Operation[oinvalid]


proc iitensorForestTreeDeserialize(scope: Scope,
                                  tree_handle: oresource,
                                  tree_config: ostring): TensorForestTreeDeserialize {.header:"generated.h", importcpp:"TensorForestTreeDeserialize(*#, #, #)", constructor.}

proc tensorForestTreeDeserialize*(scope: Scope,
                                  tree_handle: oresource,
                                  tree_config: ostring): TensorForestTreeDeserialize =
  return iitensorForestTreeDeserialize(scope,
                                       tree_handle,
                                       tree_config)



type ResourceScatterNdAddTindices = oint32 | oint64
type ResourceScatterNdAddT = oall

type ResourceScatterNdAdd*{.header:"generated.h", importcpp:"ResourceScatterNdAdd/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterNdAdd(scope: Scope,
                           nref: oresource,
                           indices: ResourceScatterNdAddTindices,
                           updates: ResourceScatterNdAddT,
                           use_locking: bool): ResourceScatterNdAdd {.header:"generated.h", importcpp:"ResourceScatterNdAdd(*#, #, #, #, #)", constructor.}

proc resourceScatterNdAdd*(scope: Scope,
                           nref: oresource,
                           indices: ResourceScatterNdAddTindices,
                           updates: ResourceScatterNdAddT,
                           use_locking: bool = true): ResourceScatterNdAdd =
  return iiresourceScatterNdAdd(scope,
                                nref,
                                indices,
                                updates,
                                use_locking)




type BoostedTreesGetEnsembleStates*[oT:oint64] {.header:"generated.h", importcpp:"BoostedTreesGetEnsembleStates/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesGetEnsembleStates[oT: oint64](scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesGetEnsembleStates[oT] {.header:"generated.h", importcpp:"BoostedTreesGetEnsembleStates(*#, #)", constructor.}

proc boostedTreesGetEnsembleStates*[oT: oint64](scope: Scope,
                                    tree_ensemble_handle: oresource): BoostedTreesGetEnsembleStates[oT] =
  return iiboostedTreesGetEnsembleStates(scope,
                                         tree_ensemble_handle)

converter boostedTreesGetEnsembleStatesToOut*[oT: oint64](op: BoostedTreesGetEnsembleStates[oT]): oT = return op.output


type TensorForestTreeSerialize*[oT:ostring] {.header:"generated.h", importcpp:"TensorForestTreeSerialize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorForestTreeSerialize[oT: ostring](scope: Scope,
                                tree_handle: oresource): TensorForestTreeSerialize[oT] {.header:"generated.h", importcpp:"TensorForestTreeSerialize(*#, #)", constructor.}

proc tensorForestTreeSerialize*[oT: ostring](scope: Scope,
                                tree_handle: oresource): TensorForestTreeSerialize[oT] =
  return iitensorForestTreeSerialize(scope,
                                     tree_handle)

converter tensorForestTreeSerializeToOut*[oT: ostring](op: TensorForestTreeSerialize[oT]): oT = return op.output


type MultiDeviceIterator*[oT:oresource] {.header:"generated.h", importcpp:"MultiDeviceIterator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimultiDeviceIterator[oT: oresource](scope: Scope,
                          devices: ArraySlice[cstring],
                          shared_name: cstring,
                          container: cstring,
                          output_types: ArraySlice[DType],
                          output_shapes: ArraySlice[TensorShape]): MultiDeviceIterator[oT] {.header:"generated.h", importcpp:"MultiDeviceIterator(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc multiDeviceIterator*[oT: oresource](scope: Scope,
                          devices: openArray[cstring],
                          shared_name: cstring,
                          container: cstring,
                          output_types: openArray[DType],
                          output_shapes: openArray[TensorShape]): MultiDeviceIterator[oT] =
  return iimultiDeviceIterator(scope,
                               newArraySlice(devices),
                               shared_name,
                               container,
                               newArraySlice(output_types),
                               newArraySlice(output_shapes))

converter multiDeviceIteratorToOut*[oT: oresource](op: MultiDeviceIterator[oT]): oT = return op.output

type CudnnRNNParamsSizeS = oint32 | oint64

type CudnnRNNParamsSize*[oT:CudnnRNNParamsSizeS] {.header:"generated.h", importcpp:"CudnnRNNParamsSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNNParamsSize[oT: CudnnRNNParamsSizeS](scope: Scope,
                         num_layers: oint32,
                         num_units: oint32,
                         input_size: oint32,
                         T: DType,
                         seed2: int64,
                         rnn_mode: cstring,
                         input_mode: cstring,
                         direction: cstring,
                         dropout: float32,
                         seed: int64): CudnnRNNParamsSize[oT] {.header:"generated.h", importcpp:"CudnnRNNParamsSize(*#, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc cudnnRNNParamsSize*[oT: CudnnRNNParamsSizeS](scope: Scope,
                         num_layers: oint32,
                         num_units: oint32,
                         input_size: oint32,
                         T: DType = DT_INVALID,
                         seed2: int64 = 0,
                         rnn_mode: cstring = "lstm",
                         input_mode: cstring = "linear_input",
                         direction: cstring = "unidirectional",
                         dropout: float32 = 0.0.float32,
                         seed: int64 = 0): CudnnRNNParamsSize[oT] =
  return iicudnnRNNParamsSize(scope,
                              num_layers,
                              num_units,
                              input_size,
                              T,
                              seed2,
                              rnn_mode,
                              input_mode,
                              direction,
                              dropout,
                              seed)

converter cudnnRNNParamsSizeToOut*[oT: CudnnRNNParamsSizeS](op: CudnnRNNParamsSize[oT]): oT = return op.output


type ExperimentalDenseToSparseBatchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalDenseToSparseBatchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalDenseToSparseBatchDataset[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            batch_size: oint64,
                                            row_shape: oint64,
                                            output_types: ArraySlice[DType],
                                            output_shapes: ArraySlice[TensorShape]): ExperimentalDenseToSparseBatchDataset[oT] {.header:"generated.h", importcpp:"ExperimentalDenseToSparseBatchDataset(*#, #, #, #, #, #)", constructor.}

proc experimentalDenseToSparseBatchDataset*[oT: ovariant](scope: Scope,
                                            input_dataset: oT,
                                            batch_size: oint64,
                                            row_shape: oint64,
                                            output_types: openArray[DType],
                                            output_shapes: openArray[TensorShape]): ExperimentalDenseToSparseBatchDataset[oT] =
  return iiexperimentalDenseToSparseBatchDataset(scope,
                                                 input_dataset,
                                                 batch_size,
                                                 row_shape,
                                                 newArraySlice(output_types),
                                                 newArraySlice(output_shapes))

converter experimentalDenseToSparseBatchDatasetToOut*[oT: ovariant](op: ExperimentalDenseToSparseBatchDataset[oT]): oT = return op.output

type InplaceAddT = oall

type InplaceAdd*[oT:InplaceAddT] {.header:"generated.h", importcpp:"InplaceAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinplaceAdd[oT: InplaceAddT](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT): InplaceAdd[oT] {.header:"generated.h", importcpp:"InplaceAdd(*#, #, #, #)", constructor.}

proc inplaceAdd*[oT: InplaceAddT](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT): InplaceAdd[oT] =
  return iiinplaceAdd(scope,
                      x,
                      i,
                      v)

converter inplaceAddToOut*[oT: InplaceAddT](op: InplaceAdd[oT]): oT = return op.output

type EnsureShapeT = oall

type EnsureShape*[oT:EnsureShapeT] {.header:"generated.h", importcpp:"EnsureShape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiensureShape[oT: EnsureShapeT](scope: Scope,
                  input: oT,
                  shape: TensorShape): EnsureShape[oT] {.header:"generated.h", importcpp:"EnsureShape(*#, #, #)", constructor.}

proc ensureShape*[oT: EnsureShapeT](scope: Scope,
                  input: oT,
                  shape: TensorShape = [].shape): EnsureShape[oT] =
  return iiensureShape(scope,
                       input,
                       shape)

converter ensureShapeToOut*[oT: EnsureShapeT](op: EnsureShape[oT]): oT = return op.output


type TensorForestTreeIsInitializedOp*[oT:obool] {.header:"generated.h", importcpp:"TensorForestTreeIsInitializedOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorForestTreeIsInitializedOp[oT: obool](scope: Scope,
                                      tree_handle: oresource): TensorForestTreeIsInitializedOp[oT] {.header:"generated.h", importcpp:"TensorForestTreeIsInitializedOp(*#, #)", constructor.}

proc tensorForestTreeIsInitializedOp*[oT: obool](scope: Scope,
                                      tree_handle: oresource): TensorForestTreeIsInitializedOp[oT] =
  return iitensorForestTreeIsInitializedOp(scope,
                                           tree_handle)

converter tensorForestTreeIsInitializedOpToOut*[oT: obool](op: TensorForestTreeIsInitializedOp[oT]): oT = return op.output

type BatchSvdT = odouble | ofloat | ocomplex64 | ocomplex128

type BatchSvd*[oT:BatchSvdT] {.header:"generated.h", importcpp:"BatchSvd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchSvd[oT: BatchSvdT](scope: Scope,
               input: oT,
               compute_uv: bool,
               full_matrices: bool): BatchSvd[oT] {.header:"generated.h", importcpp:"BatchSvd(*#, #, #, #)", constructor.}

proc batchSvd*[oT: BatchSvdT](scope: Scope,
               input: oT,
               compute_uv: bool = true,
               full_matrices: bool = false): BatchSvd[oT] =
  return iibatchSvd(scope,
                    input,
                    compute_uv,
                    full_matrices)

converter batchSvdToOut*[oT: BatchSvdT](op: BatchSvd[oT]): oT = return op.output

type GatherV2Tparams = oall
type GatherV2Tindices = oint32 | oint64
type GatherV2Taxis = oint32 | oint64

type GatherV2*[oT:GatherV2Tparams] {.header:"generated.h", importcpp:"GatherV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigatherV2[oT: GatherV2Tparams](scope: Scope,
               params: oT,
               indices: GatherV2Tindices,
               axis: GatherV2Taxis): GatherV2[oT] {.header:"generated.h", importcpp:"GatherV2(*#, #, #, #)", constructor.}

proc gatherV2*[oT: GatherV2Tparams](scope: Scope,
               params: oT,
               indices: GatherV2Tindices,
               axis: GatherV2Taxis): GatherV2[oT] =
  return iigatherV2(scope,
                    params,
                    indices,
                    axis)

converter gatherV2ToOut*[oT: GatherV2Tparams](op: GatherV2[oT]): oT = return op.output


type ExperimentalParseExampleDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalParseExampleDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalParseExampleDataset[oT: ovariant](scope: Scope,
                                      input_dataset: oT,
                                      num_parallel_calls: oint64,
                                      dense_defaults: oinvalid,
                                      sparse_keys: ArraySlice[cstring],
                                      dense_keys: ArraySlice[cstring],
                                      sparse_types: ArraySlice[DType],
                                      Tdense: ArraySlice[DType],
                                      dense_shapes: ArraySlice[TensorShape],
                                      output_types: ArraySlice[DType],
                                      output_shapes: ArraySlice[TensorShape],
                                      sloppy: bool): ExperimentalParseExampleDataset[oT] {.header:"generated.h", importcpp:"ExperimentalParseExampleDataset(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalParseExampleDataset*[oT: ovariant](scope: Scope,
                                      input_dataset: oT,
                                      num_parallel_calls: oint64,
                                      dense_defaults: oinvalid,
                                      sparse_keys: openArray[cstring],
                                      dense_keys: openArray[cstring],
                                      sparse_types: openArray[DType],
                                      Tdense: openArray[DType],
                                      dense_shapes: openArray[TensorShape],
                                      output_types: openArray[DType],
                                      output_shapes: openArray[TensorShape],
                                      sloppy: bool = false): ExperimentalParseExampleDataset[oT] =
  return iiexperimentalParseExampleDataset(scope,
                                           input_dataset,
                                           num_parallel_calls,
                                           dense_defaults,
                                           newArraySlice(sparse_keys),
                                           newArraySlice(dense_keys),
                                           newArraySlice(sparse_types),
                                           newArraySlice(Tdense),
                                           newArraySlice(dense_shapes),
                                           newArraySlice(output_types),
                                           newArraySlice(output_shapes),
                                           sloppy)

converter experimentalParseExampleDatasetToOut*[oT: ovariant](op: ExperimentalParseExampleDataset[oT]): oT = return op.output


type BoostedTreesBucketize*[oT:oint32] {.header:"generated.h", importcpp:"BoostedTreesBucketize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesBucketize[oT: oint32](scope: Scope,
                            float_values: ofloat,
                            bucket_boundaries: ofloat,
                            num_features: int64): BoostedTreesBucketize[oT] {.header:"generated.h", importcpp:"BoostedTreesBucketize(*#, #, #, #)", constructor.}

proc boostedTreesBucketize*[oT: oint32](scope: Scope,
                            float_values: ofloat,
                            bucket_boundaries: ofloat,
                            num_features: int64 = 0): BoostedTreesBucketize[oT] =
  return iiboostedTreesBucketize(scope,
                                 float_values,
                                 bucket_boundaries,
                                 num_features)

converter boostedTreesBucketizeToOut*[oT: oint32](op: BoostedTreesBucketize[oT]): oT = return op.output

type ScatterNdNonAliasingAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64 | obool
type ScatterNdNonAliasingAddTindices = oint32 | oint64

type ScatterNdNonAliasingAdd*[oT:ScatterNdNonAliasingAddT] {.header:"generated.h", importcpp:"ScatterNdNonAliasingAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterNdNonAliasingAdd[oT: ScatterNdNonAliasingAddT](scope: Scope,
                              input: oT,
                              indices: ScatterNdNonAliasingAddTindices,
                              updates: oT): ScatterNdNonAliasingAdd[oT] {.header:"generated.h", importcpp:"ScatterNdNonAliasingAdd(*#, #, #, #)", constructor.}

proc scatterNdNonAliasingAdd*[oT: ScatterNdNonAliasingAddT](scope: Scope,
                              input: oT,
                              indices: ScatterNdNonAliasingAddTindices,
                              updates: oT): ScatterNdNonAliasingAdd[oT] =
  return iiscatterNdNonAliasingAdd(scope,
                                   input,
                                   indices,
                                   updates)

converter scatterNdNonAliasingAddToOut*[oT: ScatterNdNonAliasingAddT](op: ScatterNdNonAliasingAdd[oT]): oT = return op.output


type BoostedTreesQuantileStreamResourceGetBucketBoundaries*[oT:ofloat] {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceGetBucketBoundaries/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesQuantileStreamResourceGetBucketBoundaries[oT: ofloat](scope: Scope,
                                                            quantile_stream_resource_handle: oresource,
                                                            num_features: int64): BoostedTreesQuantileStreamResourceGetBucketBoundaries[oT] {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceGetBucketBoundaries(*#, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceGetBucketBoundaries*[oT: ofloat](scope: Scope,
                                                            quantile_stream_resource_handle: oresource,
                                                            num_features: int64 = 0): BoostedTreesQuantileStreamResourceGetBucketBoundaries[oT] =
  return iiboostedTreesQuantileStreamResourceGetBucketBoundaries(scope,
                                                                 quantile_stream_resource_handle,
                                                                 num_features)

converter boostedTreesQuantileStreamResourceGetBucketBoundariesToOut*[oT: ofloat](op: BoostedTreesQuantileStreamResourceGetBucketBoundaries[oT]): oT = return op.output

type PopulationCountT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type PopulationCount*[oT:ouint8] {.header:"generated.h", importcpp:"PopulationCount/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipopulationCount[oT: ouint8](scope: Scope,
                      x: PopulationCountT): PopulationCount[oT] {.header:"generated.h", importcpp:"PopulationCount(*#, #)", constructor.}

proc populationCount*[oT: ouint8](scope: Scope,
                      x: PopulationCountT): PopulationCount[oT] =
  return iipopulationCount(scope,
                           x)

converter populationCountToOut*[oT: ouint8](op: PopulationCount[oT]): oT = return op.output


type WholeFileReaderV2*[oT:oresource] {.header:"generated.h", importcpp:"WholeFileReaderV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiwholeFileReaderV2[oT: oresource](scope: Scope,
                        container: cstring,
                        shared_name: cstring): WholeFileReaderV2[oT] {.header:"generated.h", importcpp:"WholeFileReaderV2(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc wholeFileReaderV2*[oT: oresource](scope: Scope,
                        container: cstring,
                        shared_name: cstring): WholeFileReaderV2[oT] =
  return iiwholeFileReaderV2(scope,
                             container,
                             shared_name)

converter wholeFileReaderV2ToOut*[oT: oresource](op: WholeFileReaderV2[oT]): oT = return op.output


type BoostedTreesQuantileStreamResourceFlush*{.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceFlush/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesQuantileStreamResourceFlush(scope: Scope,
                                              quantile_stream_resource_handle: oresource,
                                              num_buckets: oint64,
                                              generate_quantiles: bool): BoostedTreesQuantileStreamResourceFlush {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceFlush(*#, #, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceFlush*(scope: Scope,
                                              quantile_stream_resource_handle: oresource,
                                              num_buckets: oint64,
                                              generate_quantiles: bool = false): BoostedTreesQuantileStreamResourceFlush =
  return iiboostedTreesQuantileStreamResourceFlush(scope,
                                                   quantile_stream_resource_handle,
                                                   num_buckets,
                                                   generate_quantiles)



type AtanT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Atan*[oT:AtanT] {.header:"generated.h", importcpp:"Atan/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiatan[oT: AtanT](scope: Scope,
           x: oT): Atan[oT] {.header:"generated.h", importcpp:"Atan(*#, #)", constructor.}

proc atan*[oT: AtanT](scope: Scope,
           x: oT): Atan[oT] =
  return iiatan(scope,
                x)

converter atanToOut*[oT: AtanT](op: Atan[oT]): oT = return op.output


type FakeQueue*[oT:ostring] {.header:"generated.h", importcpp:"FakeQueue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQueue[oT: ostring](scope: Scope,
                resource: oresource): FakeQueue[oT] {.header:"generated.h", importcpp:"FakeQueue(*#, #)", constructor.}

proc fakeQueue*[oT: ostring](scope: Scope,
                resource: oresource): FakeQueue[oT] =
  return iifakeQueue(scope,
                     resource)

converter fakeQueueToOut*[oT: ostring](op: FakeQueue[oT]): oT = return op.output


type BoostedTreesPredict*[oT:ofloat] {.header:"generated.h", importcpp:"BoostedTreesPredict/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesPredict[oT: ofloat](scope: Scope,
                          tree_ensemble_handle: oresource,
                          bucketized_features: oint32,
                          num_bucketized_features: int64,
                          logits_dimension: int64): BoostedTreesPredict[oT] {.header:"generated.h", importcpp:"BoostedTreesPredict(*#, #, #, #, #)", constructor.}

proc boostedTreesPredict*[oT: ofloat](scope: Scope,
                          tree_ensemble_handle: oresource,
                          bucketized_features: oint32,
                          num_bucketized_features: int64 = 0,
                          logits_dimension: int64 = 0): BoostedTreesPredict[oT] =
  return iiboostedTreesPredict(scope,
                               tree_ensemble_handle,
                               bucketized_features,
                               num_bucketized_features,
                               logits_dimension)

converter boostedTreesPredictToOut*[oT: ofloat](op: BoostedTreesPredict[oT]): oT = return op.output


type BoostedTreesMakeStatsSummary*[oT:ofloat] {.header:"generated.h", importcpp:"BoostedTreesMakeStatsSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesMakeStatsSummary[oT: ofloat](scope: Scope,
                                   node_ids: oint32,
                                   gradients: oT,
                                   hessians: oT,
                                   bucketized_features_list: oint32,
                                   max_splits: int64,
                                   num_buckets: int64,
                                   num_features: int64): BoostedTreesMakeStatsSummary[oT] {.header:"generated.h", importcpp:"BoostedTreesMakeStatsSummary(*#, #, #, #, #, #, #, #)", constructor.}

proc boostedTreesMakeStatsSummary*[oT: ofloat](scope: Scope,
                                   node_ids: oint32,
                                   gradients: oT,
                                   hessians: oT,
                                   bucketized_features_list: oint32,
                                   max_splits: int64 = 0,
                                   num_buckets: int64 = 0,
                                   num_features: int64 = 0): BoostedTreesMakeStatsSummary[oT] =
  return iiboostedTreesMakeStatsSummary(scope,
                                        node_ids,
                                        gradients,
                                        hessians,
                                        bucketized_features_list,
                                        max_splits,
                                        num_buckets,
                                        num_features)

converter boostedTreesMakeStatsSummaryToOut*[oT: ofloat](op: BoostedTreesMakeStatsSummary[oT]): oT = return op.output

type BiasAddV1T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type BiasAddV1*[oT:BiasAddV1T] {.header:"generated.h", importcpp:"BiasAddV1/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibiasAddV1[oT: BiasAddV1T](scope: Scope,
                value: oT,
                bias: oT): BiasAddV1[oT] {.header:"generated.h", importcpp:"BiasAddV1(*#, #, #)", constructor.}

proc biasAddV1*[oT: BiasAddV1T](scope: Scope,
                value: oT,
                bias: oT): BiasAddV1[oT] =
  return iibiasAddV1(scope,
                     value,
                     bias)

converter biasAddV1ToOut*[oT: BiasAddV1T](op: BiasAddV1[oT]): oT = return op.output


type LogicalOr*[oT:obool] {.header:"generated.h", importcpp:"LogicalOr/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilogicalOr[oT: obool](scope: Scope,
                x: oT,
                y: oT): LogicalOr[oT] {.header:"generated.h", importcpp:"LogicalOr(*#, #, #)", constructor.}

proc logicalOr*[oT: obool](scope: Scope,
                x: oT,
                y: oT): LogicalOr[oT] =
  return iilogicalOr(scope,
                     x,
                     y)

converter logicalOrToOut*[oT: obool](op: LogicalOr[oT]): oT = return op.output


type BoostedTreesDeserializeEnsemble*{.header:"generated.h", importcpp:"BoostedTreesDeserializeEnsemble/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesDeserializeEnsemble(scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      stamp_token: oint64,
                                      tree_ensemble_serialized: ostring): BoostedTreesDeserializeEnsemble {.header:"generated.h", importcpp:"BoostedTreesDeserializeEnsemble(*#, #, #, #)", constructor.}

proc boostedTreesDeserializeEnsemble*(scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      stamp_token: oint64,
                                      tree_ensemble_serialized: ostring): BoostedTreesDeserializeEnsemble =
  return iiboostedTreesDeserializeEnsemble(scope,
                                           tree_ensemble_handle,
                                           stamp_token,
                                           tree_ensemble_serialized)




type NegTrain*{.header:"generated.h", importcpp:"NegTrain/*'0*/".} = object
  operation: Operation[oinvalid]


proc iinegTrain(scope: Scope,
               w_in: ofloat,
               w_out: ofloat,
               examples: oint32,
               labels: oint32,
               lr: ofloat,
               vocab_count: ArraySlice[int],
               num_negative_samples: int64): NegTrain {.header:"generated.h", importcpp:"NegTrain(*#, #, #, #, #, #, #, #)", constructor.}

proc negTrain*(scope: Scope,
               w_in: ofloat,
               w_out: ofloat,
               examples: oint32,
               labels: oint32,
               lr: ofloat,
               vocab_count: openArray[int],
               num_negative_samples: int64 = 0): NegTrain =
  return iinegTrain(scope,
                    w_in,
                    w_out,
                    examples,
                    labels,
                    lr,
                    newArraySlice(vocab_count),
                    num_negative_samples)



type ConcatV2T = oall
type ConcatV2Tidx = oint32 | oint64

type ConcatV2*[oT:ConcatV2T] {.header:"generated.h", importcpp:"ConcatV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconcatV2[oT: ConcatV2T](scope: Scope,
               values: oT,
               axis: ConcatV2Tidx): ConcatV2[oT] {.header:"generated.h", importcpp:"ConcatV2(*#, #, #)", constructor.}

proc concatV2*[oT: ConcatV2T](scope: Scope,
               values: oT,
               axis: ConcatV2Tidx): ConcatV2[oT] =
  return iiconcatV2(scope,
                    values,
                    axis)

converter concatV2ToOut*[oT: ConcatV2T](op: ConcatV2[oT]): oT = return op.output


type ConcatOffset*[oT:oint32] {.header:"generated.h", importcpp:"ConcatOffset/*'0*/".} = object
  operation: Operation[oT]
  output: olist[oT]

proc iiconcatOffset[oT: oint32](scope: Scope,
                   concat_dim: oT,
                   shape: oT): ConcatOffset[oT] {.header:"generated.h", importcpp:"ConcatOffset(*#, #, #)", constructor.}

proc concatOffset*[oT: oint32](scope: Scope,
                   concat_dim: oT,
                   shape: oT): ConcatOffset[oT] =
  return iiconcatOffset(scope,
                        concat_dim,
                        shape)

converter concatOffsetToOutList*[oT: oint32](op: ConcatOffset[oT]): olist[oT] = return op.output


type BoostedTreesExampleDebugOutputs*[oT:ostring] {.header:"generated.h", importcpp:"BoostedTreesExampleDebugOutputs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesExampleDebugOutputs[oT: ostring](scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      bucketized_features: oint32,
                                      num_bucketized_features: int64,
                                      logits_dimension: int64): BoostedTreesExampleDebugOutputs[oT] {.header:"generated.h", importcpp:"BoostedTreesExampleDebugOutputs(*#, #, #, #, #)", constructor.}

proc boostedTreesExampleDebugOutputs*[oT: ostring](scope: Scope,
                                      tree_ensemble_handle: oresource,
                                      bucketized_features: oint32,
                                      num_bucketized_features: int64 = 0,
                                      logits_dimension: int64 = 0): BoostedTreesExampleDebugOutputs[oT] =
  return iiboostedTreesExampleDebugOutputs(scope,
                                           tree_ensemble_handle,
                                           bucketized_features,
                                           num_bucketized_features,
                                           logits_dimension)

converter boostedTreesExampleDebugOutputsToOut*[oT: ostring](op: BoostedTreesExampleDebugOutputs[oT]): oT = return op.output


type DecodeGif*[oT:ouint8] {.header:"generated.h", importcpp:"DecodeGif/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeGif[oT: ouint8](scope: Scope,
                contents: ostring): DecodeGif[oT] {.header:"generated.h", importcpp:"DecodeGif(*#, #)", constructor.}

proc decodeGif*[oT: ouint8](scope: Scope,
                contents: ostring): DecodeGif[oT] =
  return iidecodeGif(scope,
                     contents)

converter decodeGifToOut*[oT: ouint8](op: DecodeGif[oT]): oT = return op.output


type BoostedTreesCalculateBestGainsPerFeature*[oT:oint32] {.header:"generated.h", importcpp:"BoostedTreesCalculateBestGainsPerFeature/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesCalculateBestGainsPerFeature[oT: oint32](scope: Scope,
                                               node_id_range: oT,
                                               stats_summary_list: ofloat,
                                               l1: ofloat,
                                               l2: ofloat,
                                               tree_complexity: ofloat,
                                               min_node_weight: ofloat,
                                               max_splits: int64,
                                               num_features: int64): BoostedTreesCalculateBestGainsPerFeature[oT] {.header:"generated.h", importcpp:"BoostedTreesCalculateBestGainsPerFeature(*#, #, #, #, #, #, #, #, #)", constructor.}

proc boostedTreesCalculateBestGainsPerFeature*[oT: oint32](scope: Scope,
                                               node_id_range: oT,
                                               stats_summary_list: ofloat,
                                               l1: ofloat,
                                               l2: ofloat,
                                               tree_complexity: ofloat,
                                               min_node_weight: ofloat,
                                               max_splits: int64 = 0,
                                               num_features: int64 = 0): BoostedTreesCalculateBestGainsPerFeature[oT] =
  return iiboostedTreesCalculateBestGainsPerFeature(scope,
                                                    node_id_range,
                                                    stats_summary_list,
                                                    l1,
                                                    l2,
                                                    tree_complexity,
                                                    min_node_weight,
                                                    max_splits,
                                                    num_features)

converter boostedTreesCalculateBestGainsPerFeatureToOut*[oT: oint32](op: BoostedTreesCalculateBestGainsPerFeature[oT]): oT = return op.output

type SampleDistortedBoundingBoxT = ouint8 | oint8 | oint16 | oint32 | oint64

type SampleDistortedBoundingBox*[oT:SampleDistortedBoundingBoxT] {.header:"generated.h", importcpp:"SampleDistortedBoundingBox/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisampleDistortedBoundingBox[oT: SampleDistortedBoundingBoxT](scope: Scope,
                                 image_size: oT,
                                 bounding_boxes: ofloat,
                                 use_image_if_no_bounding_boxes: bool,
                                 seed: int64,
                                 seed2: int64,
                                 min_object_covered: float32,
                                 aspect_ratio_range: ArraySlice[float32],
                                 area_range: ArraySlice[float32],
                                 max_attempts: int64): SampleDistortedBoundingBox[oT] {.header:"generated.h", importcpp:"SampleDistortedBoundingBox(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc sampleDistortedBoundingBox*[oT: SampleDistortedBoundingBoxT](scope: Scope,
                                 image_size: oT,
                                 bounding_boxes: ofloat,
                                 use_image_if_no_bounding_boxes: bool = false,
                                 seed: int64 = 0,
                                 seed2: int64 = 0,
                                 min_object_covered: float32 = 0.1000000014901161.float32,
                                 aspect_ratio_range: openArray[float32] = [0.75.float32, 1.330000042915344.float32],
                                 area_range: openArray[float32] = [0.05000000074505806.float32, 1.0.float32],
                                 max_attempts: int64 = 100): SampleDistortedBoundingBox[oT] =
  return iisampleDistortedBoundingBox(scope,
                                      image_size,
                                      bounding_boxes,
                                      use_image_if_no_bounding_boxes,
                                      seed,
                                      seed2,
                                      min_object_covered,
                                      newArraySlice(aspect_ratio_range),
                                      newArraySlice(area_range),
                                      max_attempts)

converter sampleDistortedBoundingBoxToOut*[oT: SampleDistortedBoundingBoxT](op: SampleDistortedBoundingBox[oT]): oT = return op.output


type DecodeBmp*[oT:ouint8] {.header:"generated.h", importcpp:"DecodeBmp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeBmp[oT: ouint8](scope: Scope,
                contents: ostring,
                channels: int64): DecodeBmp[oT] {.header:"generated.h", importcpp:"DecodeBmp(*#, #, #)", constructor.}

proc decodeBmp*[oT: ouint8](scope: Scope,
                contents: ostring,
                channels: int64 = 0): DecodeBmp[oT] =
  return iidecodeBmp(scope,
                     contents,
                     channels)

converter decodeBmpToOut*[oT: ouint8](op: DecodeBmp[oT]): oT = return op.output

type RightShiftT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type RightShift*[oT:RightShiftT] {.header:"generated.h", importcpp:"RightShift/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirightShift[oT: RightShiftT](scope: Scope,
                 x: oT,
                 y: oT): RightShift[oT] {.header:"generated.h", importcpp:"RightShift(*#, #, #)", constructor.}

proc rightShift*[oT: RightShiftT](scope: Scope,
                 x: oT,
                 y: oT): RightShift[oT] =
  return iirightShift(scope,
                      x,
                      y)

converter rightShiftToOut*[oT: RightShiftT](op: RightShift[oT]): oT = return op.output

type ImagT = ocomplex64 | ocomplex128
type ImagTout = ofloat | odouble

type Imag*[oT:ImagTout] {.header:"generated.h", importcpp:"Imag/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiimag[oT: ImagTout](scope: Scope,
           input: ImagT): Imag[oT] {.header:"generated.h", importcpp:"Imag(*#, #)", constructor.}

proc imag*[oT: ImagTout](scope: Scope,
           input: ImagT): Imag[oT] =
  return iiimag(scope,
                input)

converter imagToOut*[oT: ImagTout](op: Imag[oT]): oT = return op.output

type MutableDenseHashTablekey_dtype = oall

type MutableDenseHashTable*[oT:ostring] {.header:"generated.h", importcpp:"MutableDenseHashTable/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutableDenseHashTable[oT: ostring](scope: Scope,
                            empty_key: MutableDenseHashTablekey_dtype,
                            container: cstring,
                            shared_name: cstring,
                            use_node_name_sharing: bool,
                            max_load_factor: float32,
                            value_dtype: DType,
                            value_shape: TensorShape,
                            initial_num_buckets: int64): MutableDenseHashTable[oT] {.header:"generated.h", importcpp:"MutableDenseHashTable(*#, #, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc mutableDenseHashTable*[oT: ostring](scope: Scope,
                            empty_key: MutableDenseHashTablekey_dtype,
                            container: cstring,
                            shared_name: cstring,
                            use_node_name_sharing: bool = false,
                            max_load_factor: float32 = 0.800000011920929.float32,
                            value_dtype: DType = DT_INVALID,
                            value_shape: TensorShape = [].shape,
                            initial_num_buckets: int64 = 131072): MutableDenseHashTable[oT] =
  return iimutableDenseHashTable(scope,
                                 empty_key,
                                 container,
                                 shared_name,
                                 use_node_name_sharing,
                                 max_load_factor,
                                 value_dtype,
                                 value_shape,
                                 initial_num_buckets)

converter mutableDenseHashTableToOut*[oT: ostring](op: MutableDenseHashTable[oT]): oT = return op.output


type TensorArrayGrad*[oT:ostring] {.header:"generated.h", importcpp:"TensorArrayGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGrad[oT: ostring](scope: Scope,
                      handle: oT,
                      flow_in: ofloat,
                      source: cstring): TensorArrayGrad[oT] {.header:"generated.h", importcpp:"TensorArrayGrad(*#, #, #, tensorflow::string(#))", constructor.}

proc tensorArrayGrad*[oT: ostring](scope: Scope,
                      handle: oT,
                      flow_in: ofloat,
                      source: cstring): TensorArrayGrad[oT] =
  return iitensorArrayGrad(scope,
                           handle,
                           flow_in,
                           source)

converter tensorArrayGradToOut*[oT: ostring](op: TensorArrayGrad[oT]): oT = return op.output

type IMklSquaredDifferenceT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type IMklSquaredDifference*[oT:IMklSquaredDifferenceT] {.header:"generated.h", importcpp:"_MklSquaredDifference/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiMklSquaredDifference[oT: IMklSquaredDifferenceT](scope: Scope,
                            x: oT,
                            y: oT,
                            mkl_x: ouint8,
                            mkl_y: ouint8): IMklSquaredDifference[oT] {.header:"generated.h", importcpp:"_MklSquaredDifference(*#, #, #, #, #)", constructor.}

proc iMklSquaredDifference*[oT: IMklSquaredDifferenceT](scope: Scope,
                            x: oT,
                            y: oT,
                            mkl_x: ouint8,
                            mkl_y: ouint8): IMklSquaredDifference[oT] =
  return iiiMklSquaredDifference(scope,
                                 x,
                                 y,
                                 mkl_x,
                                 mkl_y)

converter iMklSquaredDifferenceToOut*[oT: IMklSquaredDifferenceT](op: IMklSquaredDifference[oT]): oT = return op.output

type UnbatchGradT = oall

type UnbatchGrad*[oT:UnbatchGradT] {.header:"generated.h", importcpp:"UnbatchGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunbatchGrad[oT: UnbatchGradT](scope: Scope,
                  original_input: oT,
                  batch_index: oint64,
                  grad: oT,
                  id: oint64,
                  container: cstring,
                  shared_name: cstring): UnbatchGrad[oT] {.header:"generated.h", importcpp:"UnbatchGrad(*#, #, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc unbatchGrad*[oT: UnbatchGradT](scope: Scope,
                  original_input: oT,
                  batch_index: oint64,
                  grad: oT,
                  id: oint64,
                  container: cstring,
                  shared_name: cstring): UnbatchGrad[oT] =
  return iiunbatchGrad(scope,
                       original_input,
                       batch_index,
                       grad,
                       id,
                       container,
                       shared_name)

converter unbatchGradToOut*[oT: UnbatchGradT](op: UnbatchGrad[oT]): oT = return op.output


type Mfcc*[oT:ofloat] {.header:"generated.h", importcpp:"Mfcc/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimfcc[oT: ofloat](scope: Scope,
           spectrogram: oT,
           sample_rate: oint32,
           upper_frequency_limit: float32,
           lower_frequency_limit: float32,
           filterbank_channel_count: int64,
           dct_coefficient_count: int64): Mfcc[oT] {.header:"generated.h", importcpp:"Mfcc(*#, #, #, #, #, #, #)", constructor.}

proc mfcc*[oT: ofloat](scope: Scope,
           spectrogram: oT,
           sample_rate: oint32,
           upper_frequency_limit: float32 = 4000.0.float32,
           lower_frequency_limit: float32 = 20.0.float32,
           filterbank_channel_count: int64 = 40,
           dct_coefficient_count: int64 = 13): Mfcc[oT] =
  return iimfcc(scope,
                spectrogram,
                sample_rate,
                upper_frequency_limit,
                lower_frequency_limit,
                filterbank_channel_count,
                dct_coefficient_count)

converter mfccToOut*[oT: ofloat](op: Mfcc[oT]): oT = return op.output

type BroadcastGradientArgsT = oint32 | oint64

type BroadcastGradientArgs*[oT:BroadcastGradientArgsT] {.header:"generated.h", importcpp:"BroadcastGradientArgs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibroadcastGradientArgs[oT: BroadcastGradientArgsT](scope: Scope,
                            s0: oT,
                            s1: oT): BroadcastGradientArgs[oT] {.header:"generated.h", importcpp:"BroadcastGradientArgs(*#, #, #)", constructor.}

proc broadcastGradientArgs*[oT: BroadcastGradientArgsT](scope: Scope,
                            s0: oT,
                            s1: oT): BroadcastGradientArgs[oT] =
  return iibroadcastGradientArgs(scope,
                                 s0,
                                 s1)

converter broadcastGradientArgsToOut*[oT: BroadcastGradientArgsT](op: BroadcastGradientArgs[oT]): oT = return op.output

type NonMaxSuppressionV3T = ohalf | ofloat

type NonMaxSuppressionV3*[oT:oint32] {.header:"generated.h", importcpp:"NonMaxSuppressionV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinonMaxSuppressionV3[oT: oint32](scope: Scope,
                          boxes: NonMaxSuppressionV3T,
                          scores: NonMaxSuppressionV3T,
                          max_output_size: oT,
                          iou_threshold: ofloat,
                          score_threshold: ofloat): NonMaxSuppressionV3[oT] {.header:"generated.h", importcpp:"NonMaxSuppressionV3(*#, #, #, #, #, #)", constructor.}

proc nonMaxSuppressionV3*[oT: oint32](scope: Scope,
                          boxes: NonMaxSuppressionV3T,
                          scores: NonMaxSuppressionV3T,
                          max_output_size: oT,
                          iou_threshold: ofloat,
                          score_threshold: ofloat): NonMaxSuppressionV3[oT] =
  return iinonMaxSuppressionV3(scope,
                               boxes,
                               scores,
                               max_output_size,
                               iou_threshold,
                               score_threshold)

converter nonMaxSuppressionV3ToOut*[oT: oint32](op: NonMaxSuppressionV3[oT]): oT = return op.output

type IIfTcond = oall

type IIf*[oT:oinvalid] {.header:"generated.h", importcpp:"_If/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiIf[oT: oinvalid](scope: Scope,
          cond: IIfTcond,
          input: oT,
          Tin: ArraySlice[DType],
          Tout: ArraySlice[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList): IIf[oT] {.header:"generated.h", importcpp:"_If(*#, #, #, #, #, #, #)", constructor.}

proc iIf*[oT: oinvalid](scope: Scope,
          cond: IIfTcond,
          input: oT,
          Tin: openArray[DType],
          Tout: openArray[DType],
          then_branch: NameAttrList,
          else_branch: NameAttrList): IIf[oT] =
  return iiiIf(scope,
               cond,
               input,
               newArraySlice(Tin),
               newArraySlice(Tout),
               then_branch,
               else_branch)

converter iIfToOut*[oT: oinvalid](op: IIf[oT]): oT = return op.output


type BatchIFFT*[oT:ocomplex64] {.header:"generated.h", importcpp:"BatchIFFT/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchIFFT[oT: ocomplex64](scope: Scope,
                input: oT): BatchIFFT[oT] {.header:"generated.h", importcpp:"BatchIFFT(*#, #)", constructor.}

proc batchIFFT*[oT: ocomplex64](scope: Scope,
                input: oT): BatchIFFT[oT] =
  return iibatchIFFT(scope,
                     input)

converter batchIFFTToOut*[oT: ocomplex64](op: BatchIFFT[oT]): oT = return op.output


type QueueDequeueUpToV2*[oT:oinvalid] {.header:"generated.h", importcpp:"QueueDequeueUpToV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueDequeueUpToV2[oT: oinvalid](scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: ArraySlice[DType],
                         timeout_ms: int64): QueueDequeueUpToV2[oT] {.header:"generated.h", importcpp:"QueueDequeueUpToV2(*#, #, #, #, #)", constructor.}

proc queueDequeueUpToV2*[oT: oinvalid](scope: Scope,
                         handle: oresource,
                         n: oint32,
                         component_types: openArray[DType],
                         timeout_ms: int64 = -1): QueueDequeueUpToV2[oT] =
  return iiqueueDequeueUpToV2(scope,
                              handle,
                              n,
                              newArraySlice(component_types),
                              timeout_ms)

converter queueDequeueUpToV2ToOut*[oT: oinvalid](op: QueueDequeueUpToV2[oT]): oT = return op.output


type DecodeWav*[oT:ofloat] {.header:"generated.h", importcpp:"DecodeWav/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeWav[oT: ofloat](scope: Scope,
                contents: ostring,
                desired_channels: int64,
                desired_samples: int64): DecodeWav[oT] {.header:"generated.h", importcpp:"DecodeWav(*#, #, #, #)", constructor.}

proc decodeWav*[oT: ofloat](scope: Scope,
                contents: ostring,
                desired_channels: int64 = -1,
                desired_samples: int64 = -1): DecodeWav[oT] =
  return iidecodeWav(scope,
                     contents,
                     desired_channels,
                     desired_samples)

converter decodeWavToOut*[oT: ofloat](op: DecodeWav[oT]): oT = return op.output

type SparseAccumulatorApplyGradientdtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseAccumulatorApplyGradient*{.header:"generated.h", importcpp:"SparseAccumulatorApplyGradient/*'0*/".} = object
  operation: Operation[oinvalid]


proc iisparseAccumulatorApplyGradient(scope: Scope,
                                     handle: ostring,
                                     local_step: oint64,
                                     gradient_indices: oint64,
                                     gradient_values: SparseAccumulatorApplyGradientdtype,
                                     gradient_shape: oint64,
                                     dtype: DType,
                                     has_known_shape: bool): SparseAccumulatorApplyGradient {.header:"generated.h", importcpp:"SparseAccumulatorApplyGradient(*#, #, #, #, #, #, #, #)", constructor.}

proc sparseAccumulatorApplyGradient*(scope: Scope,
                                     handle: ostring,
                                     local_step: oint64,
                                     gradient_indices: oint64,
                                     gradient_values: SparseAccumulatorApplyGradientdtype,
                                     gradient_shape: oint64,
                                     dtype: DType = DT_INVALID,
                                     has_known_shape: bool = false): SparseAccumulatorApplyGradient =
  return iisparseAccumulatorApplyGradient(scope,
                                          handle,
                                          local_step,
                                          gradient_indices,
                                          gradient_values,
                                          gradient_shape,
                                          dtype,
                                          has_known_shape)



type AssignSubVariableOpdtype = oall

type AssignSubVariableOp*{.header:"generated.h", importcpp:"AssignSubVariableOp/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiassignSubVariableOp(scope: Scope,
                          resource: oresource,
                          value: AssignSubVariableOpdtype,
                          dtype: DType): AssignSubVariableOp {.header:"generated.h", importcpp:"AssignSubVariableOp(*#, #, #, #)", constructor.}

proc assignSubVariableOp*(scope: Scope,
                          resource: oresource,
                          value: AssignSubVariableOpdtype,
                          dtype: DType = DT_INVALID): AssignSubVariableOp =
  return iiassignSubVariableOp(scope,
                               resource,
                               value,
                               dtype)



type FusedBatchNormGradT = ofloat

type FusedBatchNormGrad*[oT:FusedBatchNormGradT] {.header:"generated.h", importcpp:"FusedBatchNormGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifusedBatchNormGrad[oT: FusedBatchNormGradT](scope: Scope,
                         y_backprop: oT,
                         x: oT,
                         scale: oT,
                         reserve_space_1: oT,
                         reserve_space_2: oT,
                         is_training: bool,
                         epsilon: float32,
                         data_format: cstring): FusedBatchNormGrad[oT] {.header:"generated.h", importcpp:"FusedBatchNormGrad(*#, #, #, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc fusedBatchNormGrad*[oT: FusedBatchNormGradT](scope: Scope,
                         y_backprop: oT,
                         x: oT,
                         scale: oT,
                         reserve_space_1: oT,
                         reserve_space_2: oT,
                         is_training: bool = true,
                         epsilon: float32 = 9.999999747378752e-05.float32,
                         data_format: cstring = "NHWC"): FusedBatchNormGrad[oT] =
  return iifusedBatchNormGrad(scope,
                              y_backprop,
                              x,
                              scale,
                              reserve_space_1,
                              reserve_space_2,
                              is_training,
                              epsilon,
                              data_format)

converter fusedBatchNormGradToOut*[oT: FusedBatchNormGradT](op: FusedBatchNormGrad[oT]): oT = return op.output

type UnravelIndexTidx = oint32 | oint64

type UnravelIndex*[oT:UnravelIndexTidx] {.header:"generated.h", importcpp:"UnravelIndex/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunravelIndex[oT: UnravelIndexTidx](scope: Scope,
                   indices: oT,
                   dims: oT): UnravelIndex[oT] {.header:"generated.h", importcpp:"UnravelIndex(*#, #, #)", constructor.}

proc unravelIndex*[oT: UnravelIndexTidx](scope: Scope,
                   indices: oT,
                   dims: oT): UnravelIndex[oT] =
  return iiunravelIndex(scope,
                        indices,
                        dims)

converter unravelIndexToOut*[oT: UnravelIndexTidx](op: UnravelIndex[oT]): oT = return op.output

type MatrixBandPartT = oall
type MatrixBandPartTindex = oint32 | oint64

type MatrixBandPart*[oT:MatrixBandPartT] {.header:"generated.h", importcpp:"MatrixBandPart/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixBandPart[oT: MatrixBandPartT](scope: Scope,
                     input: oT,
                     num_lower: MatrixBandPartTindex,
                     num_upper: MatrixBandPartTindex): MatrixBandPart[oT] {.header:"generated.h", importcpp:"MatrixBandPart(*#, #, #, #)", constructor.}

proc matrixBandPart*[oT: MatrixBandPartT](scope: Scope,
                     input: oT,
                     num_lower: MatrixBandPartTindex,
                     num_upper: MatrixBandPartTindex): MatrixBandPart[oT] =
  return iimatrixBandPart(scope,
                          input,
                          num_lower,
                          num_upper)

converter matrixBandPartToOut*[oT: MatrixBandPartT](op: MatrixBandPart[oT]): oT = return op.output


type TensorArrayClose*{.header:"generated.h", importcpp:"TensorArrayClose/*'0*/".} = object
  operation: Operation[oinvalid]


proc iitensorArrayClose(scope: Scope,
                       handle: ostring): TensorArrayClose {.header:"generated.h", importcpp:"TensorArrayClose(*#, #)", constructor.}

proc tensorArrayClose*(scope: Scope,
                       handle: ostring): TensorArrayClose =
  return iitensorArrayClose(scope,
                            handle)



type BatchMatrixBandPartT = oall

type BatchMatrixBandPart*[oT:BatchMatrixBandPartT] {.header:"generated.h", importcpp:"BatchMatrixBandPart/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixBandPart[oT: BatchMatrixBandPartT](scope: Scope,
                          input: oT,
                          num_lower: oint64,
                          num_upper: oint64): BatchMatrixBandPart[oT] {.header:"generated.h", importcpp:"BatchMatrixBandPart(*#, #, #, #)", constructor.}

proc batchMatrixBandPart*[oT: BatchMatrixBandPartT](scope: Scope,
                          input: oT,
                          num_lower: oint64,
                          num_upper: oint64): BatchMatrixBandPart[oT] =
  return iibatchMatrixBandPart(scope,
                               input,
                               num_lower,
                               num_upper)

converter batchMatrixBandPartToOut*[oT: BatchMatrixBandPartT](op: BatchMatrixBandPart[oT]): oT = return op.output

type ResizeNearestNeighborT = oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | ohalf | ofloat | odouble

type ResizeNearestNeighbor*[oT:ResizeNearestNeighborT] {.header:"generated.h", importcpp:"ResizeNearestNeighbor/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiresizeNearestNeighbor[oT: ResizeNearestNeighborT](scope: Scope,
                            images: oT,
                            size: oint32,
                            align_corners: bool): ResizeNearestNeighbor[oT] {.header:"generated.h", importcpp:"ResizeNearestNeighbor(*#, #, #, #)", constructor.}

proc resizeNearestNeighbor*[oT: ResizeNearestNeighborT](scope: Scope,
                            images: oT,
                            size: oint32,
                            align_corners: bool = false): ResizeNearestNeighbor[oT] =
  return iiresizeNearestNeighbor(scope,
                                 images,
                                 size,
                                 align_corners)

converter resizeNearestNeighborToOut*[oT: ResizeNearestNeighborT](op: ResizeNearestNeighbor[oT]): oT = return op.output

type BatchMatrixDiagPartT = oall

type BatchMatrixDiagPart*[oT:BatchMatrixDiagPartT] {.header:"generated.h", importcpp:"BatchMatrixDiagPart/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixDiagPart[oT: BatchMatrixDiagPartT](scope: Scope,
                          input: oT): BatchMatrixDiagPart[oT] {.header:"generated.h", importcpp:"BatchMatrixDiagPart(*#, #)", constructor.}

proc batchMatrixDiagPart*[oT: BatchMatrixDiagPartT](scope: Scope,
                          input: oT): BatchMatrixDiagPart[oT] =
  return iibatchMatrixDiagPart(scope,
                               input)

converter batchMatrixDiagPartToOut*[oT: BatchMatrixDiagPartT](op: BatchMatrixDiagPart[oT]): oT = return op.output

type BatchMatrixSetDiagT = oall

type BatchMatrixSetDiag*[oT:BatchMatrixSetDiagT] {.header:"generated.h", importcpp:"BatchMatrixSetDiag/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixSetDiag[oT: BatchMatrixSetDiagT](scope: Scope,
                         input: oT,
                         diagonal: oT): BatchMatrixSetDiag[oT] {.header:"generated.h", importcpp:"BatchMatrixSetDiag(*#, #, #)", constructor.}

proc batchMatrixSetDiag*[oT: BatchMatrixSetDiagT](scope: Scope,
                         input: oT,
                         diagonal: oT): BatchMatrixSetDiag[oT] =
  return iibatchMatrixSetDiag(scope,
                              input,
                              diagonal)

converter batchMatrixSetDiagToOut*[oT: BatchMatrixSetDiagT](op: BatchMatrixSetDiag[oT]): oT = return op.output

type OnesLikeT = obfloat16 | ohalf | ofloat | odouble | oint8 | ouint8 | oint16 | ouint16 | oint32 | oint64 | ocomplex64 | ocomplex128 | obool

type OnesLike*[oT:OnesLikeT] {.header:"generated.h", importcpp:"OnesLike/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iionesLike[oT: OnesLikeT](scope: Scope,
               x: oT): OnesLike[oT] {.header:"generated.h", importcpp:"OnesLike(*#, #)", constructor.}

proc onesLike*[oT: OnesLikeT](scope: Scope,
               x: oT): OnesLike[oT] =
  return iionesLike(scope,
                    x)

converter onesLikeToOut*[oT: OnesLikeT](op: OnesLike[oT]): oT = return op.output


type EncodeWav*[oT:ostring] {.header:"generated.h", importcpp:"EncodeWav/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiencodeWav[oT: ostring](scope: Scope,
                audio: ofloat,
                sample_rate: oint32): EncodeWav[oT] {.header:"generated.h", importcpp:"EncodeWav(*#, #, #)", constructor.}

proc encodeWav*[oT: ostring](scope: Scope,
                audio: ofloat,
                sample_rate: oint32): EncodeWav[oT] =
  return iiencodeWav(scope,
                     audio,
                     sample_rate)

converter encodeWavToOut*[oT: ostring](op: EncodeWav[oT]): oT = return op.output


type FixedLengthRecordDatasetV2*[oT:ovariant] {.header:"generated.h", importcpp:"FixedLengthRecordDatasetV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifixedLengthRecordDatasetV2[oT: ovariant](scope: Scope,
                                 filenames: ostring,
                                 header_bytes: oint64,
                                 record_bytes: oint64,
                                 footer_bytes: oint64,
                                 buffer_size: oint64,
                                 compression_type: ostring): FixedLengthRecordDatasetV2[oT] {.header:"generated.h", importcpp:"FixedLengthRecordDatasetV2(*#, #, #, #, #, #, #)", constructor.}

proc fixedLengthRecordDatasetV2*[oT: ovariant](scope: Scope,
                                 filenames: ostring,
                                 header_bytes: oint64,
                                 record_bytes: oint64,
                                 footer_bytes: oint64,
                                 buffer_size: oint64,
                                 compression_type: ostring): FixedLengthRecordDatasetV2[oT] =
  return iifixedLengthRecordDatasetV2(scope,
                                      filenames,
                                      header_bytes,
                                      record_bytes,
                                      footer_bytes,
                                      buffer_size,
                                      compression_type)

converter fixedLengthRecordDatasetV2ToOut*[oT: ovariant](op: FixedLengthRecordDatasetV2[oT]): oT = return op.output


type IteratorGetNext*[oT:oinvalid] {.header:"generated.h", importcpp:"IteratorGetNext/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiteratorGetNext[oT: oinvalid](scope: Scope,
                      niterator: oresource,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape]): IteratorGetNext[oT] {.header:"generated.h", importcpp:"IteratorGetNext(*#, #, #, #)", constructor.}

proc iteratorGetNext*[oT: oinvalid](scope: Scope,
                      niterator: oresource,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape]): IteratorGetNext[oT] =
  return iiiteratorGetNext(scope,
                           niterator,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes))

converter iteratorGetNextToOut*[oT: oinvalid](op: IteratorGetNext[oT]): oT = return op.output


type FakeQuantWithMinMaxArgsGradient*[oT:ofloat] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxArgsGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifakeQuantWithMinMaxArgsGradient[oT: ofloat](scope: Scope,
                                      gradients: oT,
                                      inputs: oT,
                                      min: float32,
                                      max: float32,
                                      num_bits: int64,
                                      narrow_range: bool): FakeQuantWithMinMaxArgsGradient[oT] {.header:"generated.h", importcpp:"FakeQuantWithMinMaxArgsGradient(*#, #, #, #, #, #, #)", constructor.}

proc fakeQuantWithMinMaxArgsGradient*[oT: ofloat](scope: Scope,
                                      gradients: oT,
                                      inputs: oT,
                                      min: float32 = -6.0.float32,
                                      max: float32 = 6.0.float32,
                                      num_bits: int64 = 8,
                                      narrow_range: bool = false): FakeQuantWithMinMaxArgsGradient[oT] =
  return iifakeQuantWithMinMaxArgsGradient(scope,
                                           gradients,
                                           inputs,
                                           min,
                                           max,
                                           num_bits,
                                           narrow_range)

converter fakeQuantWithMinMaxArgsGradientToOut*[oT: ofloat](op: FakeQuantWithMinMaxArgsGradient[oT]): oT = return op.output

type ResourceApplyAdadeltaT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyAdadelta*{.header:"generated.h", importcpp:"ResourceApplyAdadelta/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyAdadelta(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            accum_update: oresource,
                            lr: ResourceApplyAdadeltaT,
                            rho: ResourceApplyAdadeltaT,
                            epsilon: ResourceApplyAdadeltaT,
                            grad: ResourceApplyAdadeltaT,
                            use_locking: bool): ResourceApplyAdadelta {.header:"generated.h", importcpp:"ResourceApplyAdadelta(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyAdadelta*(scope: Scope,
                            nvar: oresource,
                            accum: oresource,
                            accum_update: oresource,
                            lr: ResourceApplyAdadeltaT,
                            rho: ResourceApplyAdadeltaT,
                            epsilon: ResourceApplyAdadeltaT,
                            grad: ResourceApplyAdadeltaT,
                            use_locking: bool = false): ResourceApplyAdadelta =
  return iiresourceApplyAdadelta(scope,
                                 nvar,
                                 accum,
                                 accum_update,
                                 lr,
                                 rho,
                                 epsilon,
                                 grad,
                                 use_locking)




type BoostedTreesQuantileStreamResourceDeserialize*{.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceDeserialize/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesQuantileStreamResourceDeserialize(scope: Scope,
                                                    quantile_stream_resource_handle: oresource,
                                                    bucket_boundaries: ofloat,
                                                    num_streams: int64): BoostedTreesQuantileStreamResourceDeserialize {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceDeserialize(*#, #, #, #)", constructor.}

proc boostedTreesQuantileStreamResourceDeserialize*(scope: Scope,
                                                    quantile_stream_resource_handle: oresource,
                                                    bucket_boundaries: ofloat,
                                                    num_streams: int64 = 0): BoostedTreesQuantileStreamResourceDeserialize =
  return iiboostedTreesQuantileStreamResourceDeserialize(scope,
                                                         quantile_stream_resource_handle,
                                                         bucket_boundaries,
                                                         num_streams)



type GetSessionHandleT = oall

type GetSessionHandle*[oT:ostring] {.header:"generated.h", importcpp:"GetSessionHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iigetSessionHandle[oT: ostring](scope: Scope,
                       value: GetSessionHandleT): GetSessionHandle[oT] {.header:"generated.h", importcpp:"GetSessionHandle(*#, #)", constructor.}

proc getSessionHandle*[oT: ostring](scope: Scope,
                       value: GetSessionHandleT): GetSessionHandle[oT] =
  return iigetSessionHandle(scope,
                            value)

converter getSessionHandleToOut*[oT: ostring](op: GetSessionHandle[oT]): oT = return op.output

type TensorListConcatelement_dtype = oall

type TensorListConcat*[oT:TensorListConcatelement_dtype] {.header:"generated.h", importcpp:"TensorListConcat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListConcat[oT: TensorListConcatelement_dtype](scope: Scope,
                       input_handle: ovariant): TensorListConcat[oT] {.header:"generated.h", importcpp:"TensorListConcat(*#, #)", constructor.}

proc tensorListConcat*[oT: TensorListConcatelement_dtype](scope: Scope,
                       input_handle: ovariant): TensorListConcat[oT] =
  return iitensorListConcat(scope,
                            input_handle)

converter tensorListConcatToOut*[oT: TensorListConcatelement_dtype](op: TensorListConcat[oT]): oT = return op.output


type FixedLengthRecordReader*[oT:ostring] {.header:"generated.h", importcpp:"FixedLengthRecordReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifixedLengthRecordReader[oT: ostring](scope: Scope,
                              container: cstring,
                              shared_name: cstring,
                              header_bytes: int64,
                              record_bytes: int64,
                              footer_bytes: int64,
                              hop_bytes: int64): FixedLengthRecordReader[oT] {.header:"generated.h", importcpp:"FixedLengthRecordReader(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc fixedLengthRecordReader*[oT: ostring](scope: Scope,
                              container: cstring,
                              shared_name: cstring,
                              header_bytes: int64 = 0,
                              record_bytes: int64 = 0,
                              footer_bytes: int64 = 0,
                              hop_bytes: int64 = 0): FixedLengthRecordReader[oT] =
  return iifixedLengthRecordReader(scope,
                                   container,
                                   shared_name,
                                   header_bytes,
                                   record_bytes,
                                   footer_bytes,
                                   hop_bytes)

converter fixedLengthRecordReaderToOut*[oT: ostring](op: FixedLengthRecordReader[oT]): oT = return op.output

type AssignAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type AssignAdd*[oT:AssignAddT] {.header:"generated.h", importcpp:"AssignAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiassignAdd[oT: AssignAddT](scope: Scope,
                nref: oT,
                value: oT,
                use_locking: bool): AssignAdd[oT] {.header:"generated.h", importcpp:"AssignAdd(*#, #, #, #)", constructor.}

proc assignAdd*[oT: AssignAddT](scope: Scope,
                nref: oT,
                value: oT,
                use_locking: bool = false): AssignAdd[oT] =
  return iiassignAdd(scope,
                     nref,
                     value,
                     use_locking)

converter assignAddToOut*[oT: AssignAddT](op: AssignAdd[oT]): oT = return op.output


type IsBoostedTreesQuantileStreamResourceInitialized*[oT:obool] {.header:"generated.h", importcpp:"IsBoostedTreesQuantileStreamResourceInitialized/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiisBoostedTreesQuantileStreamResourceInitialized[oT: obool](scope: Scope,
                                                      quantile_stream_resource_handle: oresource): IsBoostedTreesQuantileStreamResourceInitialized[oT] {.header:"generated.h", importcpp:"IsBoostedTreesQuantileStreamResourceInitialized(*#, #)", constructor.}

proc isBoostedTreesQuantileStreamResourceInitialized*[oT: obool](scope: Scope,
                                                      quantile_stream_resource_handle: oresource): IsBoostedTreesQuantileStreamResourceInitialized[oT] =
  return iiisBoostedTreesQuantileStreamResourceInitialized(scope,
                                                           quantile_stream_resource_handle)

converter isBoostedTreesQuantileStreamResourceInitializedToOut*[oT: obool](op: IsBoostedTreesQuantileStreamResourceInitialized[oT]): oT = return op.output

type LeftShiftT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type LeftShift*[oT:LeftShiftT] {.header:"generated.h", importcpp:"LeftShift/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iileftShift[oT: LeftShiftT](scope: Scope,
                x: oT,
                y: oT): LeftShift[oT] {.header:"generated.h", importcpp:"LeftShift(*#, #, #)", constructor.}

proc leftShift*[oT: LeftShiftT](scope: Scope,
                x: oT,
                y: oT): LeftShift[oT] =
  return iileftShift(scope,
                     x,
                     y)

converter leftShiftToOut*[oT: LeftShiftT](op: LeftShift[oT]): oT = return op.output

type EncodePngT = ouint8 | ouint16

type EncodePng*[oT:ostring] {.header:"generated.h", importcpp:"EncodePng/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiencodePng[oT: ostring](scope: Scope,
                image: EncodePngT,
                compression: int64): EncodePng[oT] {.header:"generated.h", importcpp:"EncodePng(*#, #, #)", constructor.}

proc encodePng*[oT: ostring](scope: Scope,
                image: EncodePngT,
                compression: int64 = -1): EncodePng[oT] =
  return iiencodePng(scope,
                     image,
                     compression)

converter encodePngToOut*[oT: ostring](op: EncodePng[oT]): oT = return op.output

type EnterT = oall

type Enter*[oT:EnterT] {.header:"generated.h", importcpp:"Enter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iienter[oT: EnterT](scope: Scope,
            data: oT,
            frame_name: cstring,
            parallel_iterations: int64,
            is_constant: bool): Enter[oT] {.header:"generated.h", importcpp:"Enter(*#, #, tensorflow::string(#), #, #)", constructor.}

proc enter*[oT: EnterT](scope: Scope,
            data: oT,
            frame_name: cstring,
            parallel_iterations: int64 = 10,
            is_constant: bool = false): Enter[oT] =
  return iienter(scope,
                 data,
                 frame_name,
                 parallel_iterations,
                 is_constant)

converter enterToOut*[oT: EnterT](op: Enter[oT]): oT = return op.output


type StageSize*[oT:oint32] {.header:"generated.h", importcpp:"StageSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistageSize[oT: oint32](scope: Scope,
                dtypes: ArraySlice[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64,
                memory_limit: int64): StageSize[oT] {.header:"generated.h", importcpp:"StageSize(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc stageSize*[oT: oint32](scope: Scope,
                dtypes: openArray[DType],
                container: cstring,
                shared_name: cstring,
                capacity: int64 = 0,
                memory_limit: int64 = 0): StageSize[oT] =
  return iistageSize(scope,
                     newArraySlice(dtypes),
                     container,
                     shared_name,
                     capacity,
                     memory_limit)

converter stageSizeToOut*[oT: oint32](op: StageSize[oT]): oT = return op.output

type RaggedTensorToSparseT = oall

type RaggedTensorToSparse*[oT:oint64] {.header:"generated.h", importcpp:"RaggedTensorToSparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiraggedTensorToSparse[oT: oint64](scope: Scope,
                           rt_nested_splits: oT,
                           rt_dense_values: RaggedTensorToSparseT,
                           RAGGED_RANK: int64): RaggedTensorToSparse[oT] {.header:"generated.h", importcpp:"RaggedTensorToSparse(*#, #, #, #)", constructor.}

proc raggedTensorToSparse*[oT: oint64](scope: Scope,
                           rt_nested_splits: oT,
                           rt_dense_values: RaggedTensorToSparseT,
                           RAGGED_RANK: int64 = 0): RaggedTensorToSparse[oT] =
  return iiraggedTensorToSparse(scope,
                                rt_nested_splits,
                                rt_dense_values,
                                RAGGED_RANK)

converter raggedTensorToSparseToOut*[oT: oint64](op: RaggedTensorToSparse[oT]): oT = return op.output

type UniqueT = oall

type Unique*[oT:UniqueT] {.header:"generated.h", importcpp:"Unique/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunique[oT: UniqueT](scope: Scope,
             x: oT,
             out_idx: DType): Unique[oT] {.header:"generated.h", importcpp:"Unique(*#, #, #)", constructor.}

proc unique*[oT: UniqueT](scope: Scope,
             x: oT,
             out_idx: DType = DT_INT32): Unique[oT] =
  return iiunique(scope,
                  x,
                  out_idx)

converter uniqueToOut*[oT: UniqueT](op: Unique[oT]): oT = return op.output

type ScatterNdTindices = oint32 | oint64
type ScatterNdT = oall

type ScatterNd*[oT:ScatterNdT] {.header:"generated.h", importcpp:"ScatterNd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterNd[oT: ScatterNdT](scope: Scope,
                indices: ScatterNdTindices,
                updates: oT,
                shape: ScatterNdTindices): ScatterNd[oT] {.header:"generated.h", importcpp:"ScatterNd(*#, #, #, #)", constructor.}

proc scatterNd*[oT: ScatterNdT](scope: Scope,
                indices: ScatterNdTindices,
                updates: oT,
                shape: ScatterNdTindices): ScatterNd[oT] =
  return iiscatterNd(scope,
                     indices,
                     updates,
                     shape)

converter scatterNdToOut*[oT: ScatterNdT](op: ScatterNd[oT]): oT = return op.output

type TensorArrayConcatV3dtype = oall

type TensorArrayConcatV3*[oT:TensorArrayConcatV3dtype] {.header:"generated.h", importcpp:"TensorArrayConcatV3/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayConcatV3[oT: TensorArrayConcatV3dtype](scope: Scope,
                          handle: oresource,
                          flow_in: ofloat,
                          dtype: DType,
                          element_shape_except0: TensorShape): TensorArrayConcatV3[oT] {.header:"generated.h", importcpp:"TensorArrayConcatV3(*#, #, #, #, #)", constructor.}

proc tensorArrayConcatV3*[oT: TensorArrayConcatV3dtype](scope: Scope,
                          handle: oresource,
                          flow_in: ofloat,
                          dtype: DType = oT[].oTF,
                          element_shape_except0: TensorShape = [].shape): TensorArrayConcatV3[oT] =
  return iitensorArrayConcatV3(scope,
                               handle,
                               flow_in,
                               dtype,
                               element_shape_except0)

converter tensorArrayConcatV3ToOut*[oT: TensorArrayConcatV3dtype](op: TensorArrayConcatV3[oT]): oT = return op.output

type ResourceApplyFtrlV2T = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyFtrlV2*{.header:"generated.h", importcpp:"ResourceApplyFtrlV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyFtrlV2(scope: Scope,
                          nvar: oresource,
                          accum: oresource,
                          linear: oresource,
                          grad: ResourceApplyFtrlV2T,
                          lr: ResourceApplyFtrlV2T,
                          l1: ResourceApplyFtrlV2T,
                          l2: ResourceApplyFtrlV2T,
                          l2_shrinkage: ResourceApplyFtrlV2T,
                          lr_power: ResourceApplyFtrlV2T,
                          use_locking: bool): ResourceApplyFtrlV2 {.header:"generated.h", importcpp:"ResourceApplyFtrlV2(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyFtrlV2*(scope: Scope,
                          nvar: oresource,
                          accum: oresource,
                          linear: oresource,
                          grad: ResourceApplyFtrlV2T,
                          lr: ResourceApplyFtrlV2T,
                          l1: ResourceApplyFtrlV2T,
                          l2: ResourceApplyFtrlV2T,
                          l2_shrinkage: ResourceApplyFtrlV2T,
                          lr_power: ResourceApplyFtrlV2T,
                          use_locking: bool = false): ResourceApplyFtrlV2 =
  return iiresourceApplyFtrlV2(scope,
                               nvar,
                               accum,
                               linear,
                               grad,
                               lr,
                               l1,
                               l2,
                               l2_shrinkage,
                               lr_power,
                               use_locking)



type UpperBoundT = oall
type UpperBoundout_type = oint32 | oint64

type UpperBound*[oT:UpperBoundout_type] {.header:"generated.h", importcpp:"UpperBound/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiupperBound[oT: UpperBoundout_type](scope: Scope,
                 sorted_inputs: UpperBoundT,
                 values: UpperBoundT): UpperBound[oT] {.header:"generated.h", importcpp:"UpperBound(*#, #, #)", constructor.}

proc upperBound*[oT: UpperBoundout_type](scope: Scope,
                 sorted_inputs: UpperBoundT,
                 values: UpperBoundT): UpperBound[oT] =
  return iiupperBound(scope,
                      sorted_inputs,
                      values)

converter upperBoundToOut*[oT: UpperBoundout_type](op: UpperBound[oT]): oT = return op.output

type StridedSliceAssignT = oall
type StridedSliceAssignIndex = oint32 | oint64

type StridedSliceAssign*[oT:StridedSliceAssignT] {.header:"generated.h", importcpp:"StridedSliceAssign/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistridedSliceAssign[oT: StridedSliceAssignT](scope: Scope,
                         nref: oT,
                         begin: StridedSliceAssignIndex,
                         nend: StridedSliceAssignIndex,
                         strides: StridedSliceAssignIndex,
                         value: oT,
                         shrink_axis_mask: int64,
                         new_axis_mask: int64,
                         begin_mask: int64,
                         end_mask: int64,
                         ellipsis_mask: int64): StridedSliceAssign[oT] {.header:"generated.h", importcpp:"StridedSliceAssign(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc stridedSliceAssign*[oT: StridedSliceAssignT](scope: Scope,
                         nref: oT,
                         begin: StridedSliceAssignIndex,
                         nend: StridedSliceAssignIndex,
                         strides: StridedSliceAssignIndex,
                         value: oT,
                         shrink_axis_mask: int64 = 0,
                         new_axis_mask: int64 = 0,
                         begin_mask: int64 = 0,
                         end_mask: int64 = 0,
                         ellipsis_mask: int64 = 0): StridedSliceAssign[oT] =
  return iistridedSliceAssign(scope,
                              nref,
                              begin,
                              nend,
                              strides,
                              value,
                              shrink_axis_mask,
                              new_axis_mask,
                              begin_mask,
                              end_mask,
                              ellipsis_mask)

converter stridedSliceAssignToOut*[oT: StridedSliceAssignT](op: StridedSliceAssign[oT]): oT = return op.output

type QuantizedConcatT = oall

type QuantizedConcat*[oT:QuantizedConcatT] {.header:"generated.h", importcpp:"QuantizedConcat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedConcat[oT: QuantizedConcatT](scope: Scope,
                      concat_dim: oint32,
                      values: oT,
                      input_mins: ofloat,
                      input_maxes: ofloat): QuantizedConcat[oT] {.header:"generated.h", importcpp:"QuantizedConcat(*#, #, #, #, #)", constructor.}

proc quantizedConcat*[oT: QuantizedConcatT](scope: Scope,
                      concat_dim: oint32,
                      values: oT,
                      input_mins: ofloat,
                      input_maxes: ofloat): QuantizedConcat[oT] =
  return iiquantizedConcat(scope,
                           concat_dim,
                           values,
                           input_mins,
                           input_maxes)

converter quantizedConcatToOut*[oT: QuantizedConcatT](op: QuantizedConcat[oT]): oT = return op.output

type LookupTableInsertTin = oall
type LookupTableInsertTout = oall

type LookupTableInsert*{.header:"generated.h", importcpp:"LookupTableInsert/*'0*/".} = object
  operation: Operation[oinvalid]


proc iilookupTableInsert(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableInsertTin,
                        values: LookupTableInsertTout): LookupTableInsert {.header:"generated.h", importcpp:"LookupTableInsert(*#, #, #, #)", constructor.}

proc lookupTableInsert*(scope: Scope,
                        table_handle: ostring,
                        keys: LookupTableInsertTin,
                        values: LookupTableInsertTout): LookupTableInsert =
  return iilookupTableInsert(scope,
                             table_handle,
                             keys,
                             values)



type ExtractVolumePatchesT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type ExtractVolumePatches*[oT:ExtractVolumePatchesT] {.header:"generated.h", importcpp:"ExtractVolumePatches/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiextractVolumePatches[oT: ExtractVolumePatchesT](scope: Scope,
                           input: oT,
                           ksizes: ArraySlice[int],
                           strides: ArraySlice[int],
                           padding: cstring): ExtractVolumePatches[oT] {.header:"generated.h", importcpp:"ExtractVolumePatches(*#, #, #, #, tensorflow::string(#))", constructor.}

proc extractVolumePatches*[oT: ExtractVolumePatchesT](scope: Scope,
                           input: oT,
                           ksizes: openArray[int],
                           strides: openArray[int],
                           padding: cstring): ExtractVolumePatches[oT] =
  return iiextractVolumePatches(scope,
                                input,
                                newArraySlice(ksizes),
                                newArraySlice(strides),
                                padding)

converter extractVolumePatchesToOut*[oT: ExtractVolumePatchesT](op: ExtractVolumePatches[oT]): oT = return op.output


type FixedUnigramCandidateSampler*[oT:oint64] {.header:"generated.h", importcpp:"FixedUnigramCandidateSampler/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifixedUnigramCandidateSampler[oT: oint64](scope: Scope,
                                   true_classes: oT,
                                   vocab_file: cstring,
                                   unigrams: ArraySlice[float32],
                                   num_true: int64,
                                   num_sampled: int64,
                                   unique: bool,
                                   range_max: int64,
                                   distortion: float32,
                                   num_reserved_ids: int64,
                                   num_shards: int64,
                                   shard: int64,
                                   seed: int64,
                                   seed2: int64): FixedUnigramCandidateSampler[oT] {.header:"generated.h", importcpp:"FixedUnigramCandidateSampler(*#, #, tensorflow::string(#), #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc fixedUnigramCandidateSampler*[oT: oint64](scope: Scope,
                                   true_classes: oT,
                                   vocab_file: cstring,
                                   unigrams: openArray[float32],
                                   num_true: int64 = 0,
                                   num_sampled: int64 = 0,
                                   unique: bool = false,
                                   range_max: int64 = 0,
                                   distortion: float32 = 1.0.float32,
                                   num_reserved_ids: int64 = 0,
                                   num_shards: int64 = 1,
                                   shard: int64 = 0,
                                   seed: int64 = 0,
                                   seed2: int64 = 0): FixedUnigramCandidateSampler[oT] =
  return iifixedUnigramCandidateSampler(scope,
                                        true_classes,
                                        vocab_file,
                                        newArraySlice(unigrams),
                                        num_true,
                                        num_sampled,
                                        unique,
                                        range_max,
                                        distortion,
                                        num_reserved_ids,
                                        num_shards,
                                        shard,
                                        seed,
                                        seed2)

converter fixedUnigramCandidateSamplerToOut*[oT: oint64](op: FixedUnigramCandidateSampler[oT]): oT = return op.output

type MergeT = oall

type Merge*[oT:MergeT] {.header:"generated.h", importcpp:"Merge/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimerge[oT: MergeT](scope: Scope,
            inputs: oT): Merge[oT] {.header:"generated.h", importcpp:"Merge(*#, #)", constructor.}

proc merge*[oT: MergeT](scope: Scope,
            inputs: oT): Merge[oT] =
  return iimerge(scope,
                 inputs)

converter mergeToOut*[oT: MergeT](op: Merge[oT]): oT = return op.output


type PaddedBatchDatasetV2*[oT:ovariant] {.header:"generated.h", importcpp:"PaddedBatchDatasetV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipaddedBatchDatasetV2[oT: ovariant](scope: Scope,
                           input_dataset: oT,
                           batch_size: oint64,
                           padded_shapes: oint64,
                           padding_values: oinvalid,
                           drop_remainder: obool,
                           Toutput_types: ArraySlice[DType],
                           output_shapes: ArraySlice[TensorShape]): PaddedBatchDatasetV2[oT] {.header:"generated.h", importcpp:"PaddedBatchDatasetV2(*#, #, #, #, #, #, #, #)", constructor.}

proc paddedBatchDatasetV2*[oT: ovariant](scope: Scope,
                           input_dataset: oT,
                           batch_size: oint64,
                           padded_shapes: oint64,
                           padding_values: oinvalid,
                           drop_remainder: obool,
                           Toutput_types: openArray[DType],
                           output_shapes: openArray[TensorShape]): PaddedBatchDatasetV2[oT] =
  return iipaddedBatchDatasetV2(scope,
                                input_dataset,
                                batch_size,
                                padded_shapes,
                                padding_values,
                                drop_remainder,
                                newArraySlice(Toutput_types),
                                newArraySlice(output_shapes))

converter paddedBatchDatasetV2ToOut*[oT: ovariant](op: PaddedBatchDatasetV2[oT]): oT = return op.output

type ExtractImagePatchesT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type ExtractImagePatches*[oT:ExtractImagePatchesT] {.header:"generated.h", importcpp:"ExtractImagePatches/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiextractImagePatches[oT: ExtractImagePatchesT](scope: Scope,
                          images: oT,
                          ksizes: ArraySlice[int],
                          strides: ArraySlice[int],
                          rates: ArraySlice[int],
                          padding: cstring): ExtractImagePatches[oT] {.header:"generated.h", importcpp:"ExtractImagePatches(*#, #, #, #, #, tensorflow::string(#))", constructor.}

proc extractImagePatches*[oT: ExtractImagePatchesT](scope: Scope,
                          images: oT,
                          ksizes: openArray[int],
                          strides: openArray[int],
                          rates: openArray[int],
                          padding: cstring): ExtractImagePatches[oT] =
  return iiextractImagePatches(scope,
                               images,
                               newArraySlice(ksizes),
                               newArraySlice(strides),
                               newArraySlice(rates),
                               padding)

converter extractImagePatchesToOut*[oT: ExtractImagePatchesT](op: ExtractImagePatches[oT]): oT = return op.output


type AllCandidateSampler*[oT:oint64] {.header:"generated.h", importcpp:"AllCandidateSampler/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiallCandidateSampler[oT: oint64](scope: Scope,
                          true_classes: oT,
                          num_true: int64,
                          num_sampled: int64,
                          unique: bool,
                          seed: int64,
                          seed2: int64): AllCandidateSampler[oT] {.header:"generated.h", importcpp:"AllCandidateSampler(*#, #, #, #, #, #, #)", constructor.}

proc allCandidateSampler*[oT: oint64](scope: Scope,
                          true_classes: oT,
                          num_true: int64 = 0,
                          num_sampled: int64 = 0,
                          unique: bool = false,
                          seed: int64 = 0,
                          seed2: int64 = 0): AllCandidateSampler[oT] =
  return iiallCandidateSampler(scope,
                               true_classes,
                               num_true,
                               num_sampled,
                               unique,
                               seed,
                               seed2)

converter allCandidateSamplerToOut*[oT: oint64](op: AllCandidateSampler[oT]): oT = return op.output

type DepthToSpaceT = oall

type DepthToSpace*[oT:DepthToSpaceT] {.header:"generated.h", importcpp:"DepthToSpace/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidepthToSpace[oT: DepthToSpaceT](scope: Scope,
                   input: oT,
                   data_format: cstring,
                   block_size: int64): DepthToSpace[oT] {.header:"generated.h", importcpp:"DepthToSpace(*#, #, tensorflow::string(#), #)", constructor.}

proc depthToSpace*[oT: DepthToSpaceT](scope: Scope,
                   input: oT,
                   data_format: cstring = "NHWC",
                   block_size: int64 = 0): DepthToSpace[oT] =
  return iidepthToSpace(scope,
                        input,
                        data_format,
                        block_size)

converter depthToSpaceToOut*[oT: DepthToSpaceT](op: DepthToSpace[oT]): oT = return op.output

type SpaceToDepthT = oall

type SpaceToDepth*[oT:SpaceToDepthT] {.header:"generated.h", importcpp:"SpaceToDepth/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iispaceToDepth[oT: SpaceToDepthT](scope: Scope,
                   input: oT,
                   data_format: cstring,
                   block_size: int64): SpaceToDepth[oT] {.header:"generated.h", importcpp:"SpaceToDepth(*#, #, tensorflow::string(#), #)", constructor.}

proc spaceToDepth*[oT: SpaceToDepthT](scope: Scope,
                   input: oT,
                   data_format: cstring = "NHWC",
                   block_size: int64 = 0): SpaceToDepth[oT] =
  return iispaceToDepth(scope,
                        input,
                        data_format,
                        block_size)

converter spaceToDepthToOut*[oT: SpaceToDepthT](op: SpaceToDepth[oT]): oT = return op.output

type InplaceSubT = oall

type InplaceSub*[oT:InplaceSubT] {.header:"generated.h", importcpp:"InplaceSub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinplaceSub[oT: InplaceSubT](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT): InplaceSub[oT] {.header:"generated.h", importcpp:"InplaceSub(*#, #, #, #)", constructor.}

proc inplaceSub*[oT: InplaceSubT](scope: Scope,
                 x: oT,
                 i: oint32,
                 v: oT): InplaceSub[oT] =
  return iiinplaceSub(scope,
                      x,
                      i,
                      v)

converter inplaceSubToOut*[oT: InplaceSubT](op: InplaceSub[oT]): oT = return op.output

type RefIdentityT = oall

type RefIdentity*[oT:RefIdentityT] {.header:"generated.h", importcpp:"RefIdentity/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefIdentity[oT: RefIdentityT](scope: Scope,
                  input: oT): RefIdentity[oT] {.header:"generated.h", importcpp:"RefIdentity(*#, #)", constructor.}

proc refIdentity*[oT: RefIdentityT](scope: Scope,
                  input: oT): RefIdentity[oT] =
  return iirefIdentity(scope,
                       input)

converter refIdentityToOut*[oT: RefIdentityT](op: RefIdentity[oT]): oT = return op.output


type FilterDataset*[oT:ovariant] {.header:"generated.h", importcpp:"FilterDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifilterDataset[oT: ovariant](scope: Scope,
                    input_dataset: oT,
                    other_arguments: oinvalid,
                    predicate: NameAttrList,
                    Targuments: ArraySlice[DType],
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): FilterDataset[oT] {.header:"generated.h", importcpp:"FilterDataset(*#, #, #, #, #, #, #)", constructor.}

proc filterDataset*[oT: ovariant](scope: Scope,
                    input_dataset: oT,
                    other_arguments: oinvalid,
                    predicate: NameAttrList,
                    Targuments: openArray[DType],
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): FilterDataset[oT] =
  return iifilterDataset(scope,
                         input_dataset,
                         other_arguments,
                         predicate,
                         newArraySlice(Targuments),
                         newArraySlice(output_types),
                         newArraySlice(output_shapes))

converter filterDatasetToOut*[oT: ovariant](op: FilterDataset[oT]): oT = return op.output

type DeserializeSparseTserialized = ostring | ovariant

type DeserializeSparse*[oT:oint64] {.header:"generated.h", importcpp:"DeserializeSparse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iideserializeSparse[oT: oint64](scope: Scope,
                        serialized_sparse: DeserializeSparseTserialized,
                        dtype: DType): DeserializeSparse[oT] {.header:"generated.h", importcpp:"DeserializeSparse(*#, #, #)", constructor.}

proc deserializeSparse*[oT: oint64](scope: Scope,
                        serialized_sparse: DeserializeSparseTserialized,
                        dtype: DType = oT[].oTF): DeserializeSparse[oT] =
  return iideserializeSparse(scope,
                             serialized_sparse,
                             dtype)

converter deserializeSparseToOut*[oT: oint64](op: DeserializeSparse[oT]): oT = return op.output


type MapClear*{.header:"generated.h", importcpp:"MapClear/*'0*/".} = object
  operation: Operation[oinvalid]


proc iimapClear(scope: Scope,
               dtypes: ArraySlice[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64,
               memory_limit: int64): MapClear {.header:"generated.h", importcpp:"MapClear(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapClear*(scope: Scope,
               dtypes: openArray[DType],
               container: cstring,
               shared_name: cstring,
               capacity: int64 = 0,
               memory_limit: int64 = 0): MapClear =
  return iimapClear(scope,
                    newArraySlice(dtypes),
                    container,
                    shared_name,
                    capacity,
                    memory_limit)



type QuantizedRelu6Tinput = oqint8 | oquint8 | oqint32 | oqint16 | oquint16
type QuantizedRelu6out_type = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedRelu6*[oT:QuantizedRelu6out_type] {.header:"generated.h", importcpp:"QuantizedRelu6/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedRelu6[oT: QuantizedRelu6out_type](scope: Scope,
                     features: QuantizedRelu6Tinput,
                     min_features: ofloat,
                     max_features: ofloat): QuantizedRelu6[oT] {.header:"generated.h", importcpp:"QuantizedRelu6(*#, #, #, #)", constructor.}

proc quantizedRelu6*[oT: QuantizedRelu6out_type](scope: Scope,
                     features: QuantizedRelu6Tinput,
                     min_features: ofloat,
                     max_features: ofloat): QuantizedRelu6[oT] =
  return iiquantizedRelu6(scope,
                          features,
                          min_features,
                          max_features)

converter quantizedRelu6ToOut*[oT: QuantizedRelu6out_type](op: QuantizedRelu6[oT]): oT = return op.output

type ResourceStridedSliceAssignIndex = oint32 | oint64
type ResourceStridedSliceAssignT = oall

type ResourceStridedSliceAssign*{.header:"generated.h", importcpp:"ResourceStridedSliceAssign/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceStridedSliceAssign(scope: Scope,
                                 nref: oresource,
                                 begin: ResourceStridedSliceAssignIndex,
                                 nend: ResourceStridedSliceAssignIndex,
                                 strides: ResourceStridedSliceAssignIndex,
                                 value: ResourceStridedSliceAssignT,
                                 new_axis_mask: int64,
                                 shrink_axis_mask: int64,
                                 begin_mask: int64,
                                 end_mask: int64,
                                 ellipsis_mask: int64): ResourceStridedSliceAssign {.header:"generated.h", importcpp:"ResourceStridedSliceAssign(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceStridedSliceAssign*(scope: Scope,
                                 nref: oresource,
                                 begin: ResourceStridedSliceAssignIndex,
                                 nend: ResourceStridedSliceAssignIndex,
                                 strides: ResourceStridedSliceAssignIndex,
                                 value: ResourceStridedSliceAssignT,
                                 new_axis_mask: int64 = 0,
                                 shrink_axis_mask: int64 = 0,
                                 begin_mask: int64 = 0,
                                 end_mask: int64 = 0,
                                 ellipsis_mask: int64 = 0): ResourceStridedSliceAssign =
  return iiresourceStridedSliceAssign(scope,
                                      nref,
                                      begin,
                                      nend,
                                      strides,
                                      value,
                                      new_axis_mask,
                                      shrink_axis_mask,
                                      begin_mask,
                                      end_mask,
                                      ellipsis_mask)



type SqueezeT = oall

type Squeeze*[oT:SqueezeT] {.header:"generated.h", importcpp:"Squeeze/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisqueeze[oT: SqueezeT](scope: Scope,
              input: oT,
              squeeze_dims: ArraySlice[int]): Squeeze[oT] {.header:"generated.h", importcpp:"Squeeze(*#, #, #)", constructor.}

proc squeeze*[oT: SqueezeT](scope: Scope,
              input: oT,
              squeeze_dims: openArray[int]): Squeeze[oT] =
  return iisqueeze(scope,
                   input,
                   newArraySlice(squeeze_dims))

converter squeezeToOut*[oT: SqueezeT](op: Squeeze[oT]): oT = return op.output

type InplaceUpdateT = oall

type InplaceUpdate*[oT:InplaceUpdateT] {.header:"generated.h", importcpp:"InplaceUpdate/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinplaceUpdate[oT: InplaceUpdateT](scope: Scope,
                    x: oT,
                    i: oint32,
                    v: oT): InplaceUpdate[oT] {.header:"generated.h", importcpp:"InplaceUpdate(*#, #, #, #)", constructor.}

proc inplaceUpdate*[oT: InplaceUpdateT](scope: Scope,
                    x: oT,
                    i: oint32,
                    v: oT): InplaceUpdate[oT] =
  return iiinplaceUpdate(scope,
                         x,
                         i,
                         v)

converter inplaceUpdateToOut*[oT: InplaceUpdateT](op: InplaceUpdate[oT]): oT = return op.output

type InitializeTableV2Tkey = oall
type InitializeTableV2Tval = oall

type InitializeTableV2*{.header:"generated.h", importcpp:"InitializeTableV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiinitializeTableV2(scope: Scope,
                        table_handle: oresource,
                        keys: InitializeTableV2Tkey,
                        values: InitializeTableV2Tval): InitializeTableV2 {.header:"generated.h", importcpp:"InitializeTableV2(*#, #, #, #)", constructor.}

proc initializeTableV2*(scope: Scope,
                        table_handle: oresource,
                        keys: InitializeTableV2Tkey,
                        values: InitializeTableV2Tval): InitializeTableV2 =
  return iiinitializeTableV2(scope,
                             table_handle,
                             keys,
                             values)



type NextIterationT = oall

type NextIteration*[oT:NextIterationT] {.header:"generated.h", importcpp:"NextIteration/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinextIteration[oT: NextIterationT](scope: Scope,
                    data: oT): NextIteration[oT] {.header:"generated.h", importcpp:"NextIteration(*#, #)", constructor.}

proc nextIteration*[oT: NextIterationT](scope: Scope,
                    data: oT): NextIteration[oT] =
  return iinextIteration(scope,
                         data)

converter nextIterationToOut*[oT: NextIterationT](op: NextIteration[oT]): oT = return op.output

type CopyT = oall

type Copy*[oT:CopyT] {.header:"generated.h", importcpp:"Copy/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicopy[oT: CopyT](scope: Scope,
           input: oT,
           tensor_name: cstring,
           debug_ops_spec: ArraySlice[cstring]): Copy[oT] {.header:"generated.h", importcpp:"Copy(*#, #, tensorflow::string(#), #)", constructor.}

proc copy*[oT: CopyT](scope: Scope,
           input: oT,
           tensor_name: cstring,
           debug_ops_spec: openArray[cstring]): Copy[oT] =
  return iicopy(scope,
                input,
                tensor_name,
                newArraySlice(debug_ops_spec))

converter copyToOut*[oT: CopyT](op: Copy[oT]): oT = return op.output


type StringLength*[oT:oint32] {.header:"generated.h", importcpp:"StringLength/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistringLength[oT: oint32](scope: Scope,
                   input: ostring,
                   unit: cstring): StringLength[oT] {.header:"generated.h", importcpp:"StringLength(*#, #, tensorflow::string(#))", constructor.}

proc stringLength*[oT: oint32](scope: Scope,
                   input: ostring,
                   unit: cstring = "BYTE"): StringLength[oT] =
  return iistringLength(scope,
                        input,
                        unit)

converter stringLengthToOut*[oT: oint32](op: StringLength[oT]): oT = return op.output

type ScatterDivT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type ScatterDivTindices = oint32 | oint64

type ScatterDiv*[oT:ScatterDivT] {.header:"generated.h", importcpp:"ScatterDiv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiscatterDiv[oT: ScatterDivT](scope: Scope,
                 nref: oT,
                 indices: ScatterDivTindices,
                 updates: oT,
                 use_locking: bool): ScatterDiv[oT] {.header:"generated.h", importcpp:"ScatterDiv(*#, #, #, #, #)", constructor.}

proc scatterDiv*[oT: ScatterDivT](scope: Scope,
                 nref: oT,
                 indices: ScatterDivTindices,
                 updates: oT,
                 use_locking: bool = false): ScatterDiv[oT] =
  return iiscatterDiv(scope,
                      nref,
                      indices,
                      updates,
                      use_locking)

converter scatterDivToOut*[oT: ScatterDivT](op: ScatterDiv[oT]): oT = return op.output

type TensorSummaryT = oall

type TensorSummary*[oT:ostring] {.header:"generated.h", importcpp:"TensorSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorSummary[oT: ostring](scope: Scope,
                    tensor: TensorSummaryT,
                    description: cstring,
                    labels: ArraySlice[cstring],
                    display_name: cstring): TensorSummary[oT] {.header:"generated.h", importcpp:"TensorSummary(*#, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc tensorSummary*[oT: ostring](scope: Scope,
                    tensor: TensorSummaryT,
                    description: cstring,
                    labels: openArray[cstring],
                    display_name: cstring): TensorSummary[oT] =
  return iitensorSummary(scope,
                         tensor,
                         description,
                         newArraySlice(labels),
                         display_name)

converter tensorSummaryToOut*[oT: ostring](op: TensorSummary[oT]): oT = return op.output

type SparseApplyProximalGradientDescentT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SparseApplyProximalGradientDescentTindices = oint32 | oint64

type SparseApplyProximalGradientDescent*[oT:SparseApplyProximalGradientDescentT] {.header:"generated.h", importcpp:"SparseApplyProximalGradientDescent/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseApplyProximalGradientDescent[oT: SparseApplyProximalGradientDescentT](scope: Scope,
                                         nvar: oT,
                                         alpha: oT,
                                         l1: oT,
                                         l2: oT,
                                         grad: oT,
                                         indices: SparseApplyProximalGradientDescentTindices,
                                         use_locking: bool): SparseApplyProximalGradientDescent[oT] {.header:"generated.h", importcpp:"SparseApplyProximalGradientDescent(*#, #, #, #, #, #, #, #)", constructor.}

proc sparseApplyProximalGradientDescent*[oT: SparseApplyProximalGradientDescentT](scope: Scope,
                                         nvar: oT,
                                         alpha: oT,
                                         l1: oT,
                                         l2: oT,
                                         grad: oT,
                                         indices: SparseApplyProximalGradientDescentTindices,
                                         use_locking: bool = false): SparseApplyProximalGradientDescent[oT] =
  return iisparseApplyProximalGradientDescent(scope,
                                              nvar,
                                              alpha,
                                              l1,
                                              l2,
                                              grad,
                                              indices,
                                              use_locking)

converter sparseApplyProximalGradientDescentToOut*[oT: SparseApplyProximalGradientDescentT](op: SparseApplyProximalGradientDescent[oT]): oT = return op.output

type TileT = oall
type TileTmultiples = oint32 | oint64

type Tile*[oT:TileT] {.header:"generated.h", importcpp:"Tile/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitile[oT: TileT](scope: Scope,
           input: oT,
           multiples: TileTmultiples): Tile[oT] {.header:"generated.h", importcpp:"Tile(*#, #, #)", constructor.}

proc tile*[oT: TileT](scope: Scope,
           input: oT,
           multiples: TileTmultiples): Tile[oT] =
  return iitile(scope,
                input,
                multiples)

converter tileToOut*[oT: TileT](op: Tile[oT]): oT = return op.output

type IHostSendT = oall

type IHostSend*{.header:"generated.h", importcpp:"_HostSend/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiiHostSend(scope: Scope,
                tensor: IHostSendT,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                client_terminated: bool,
                send_device_incarnation: int64): IHostSend {.header:"generated.h", importcpp:"_HostSend(*#, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc iHostSend*(scope: Scope,
                tensor: IHostSendT,
                tensor_name: cstring,
                send_device: cstring,
                recv_device: cstring,
                client_terminated: bool = false,
                send_device_incarnation: int64 = 0): IHostSend =
  return iiiHostSend(scope,
                     tensor,
                     tensor_name,
                     send_device,
                     recv_device,
                     client_terminated,
                     send_device_incarnation)



type ExpandDimsT = oall
type ExpandDimsTdim = oint32 | oint64

type ExpandDims*[oT:ExpandDimsT] {.header:"generated.h", importcpp:"ExpandDims/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexpandDims[oT: ExpandDimsT](scope: Scope,
                 input: oT,
                 dim: ExpandDimsTdim): ExpandDims[oT] {.header:"generated.h", importcpp:"ExpandDims(*#, #, #)", constructor.}

proc expandDims*[oT: ExpandDimsT](scope: Scope,
                 input: oT,
                 dim: ExpandDimsTdim): ExpandDims[oT] =
  return iiexpandDims(scope,
                      input,
                      dim)

converter expandDimsToOut*[oT: ExpandDimsT](op: ExpandDims[oT]): oT = return op.output

type SpaceToBatchT = oall
type SpaceToBatchTpaddings = oint32 | oint64

type SpaceToBatch*[oT:SpaceToBatchT] {.header:"generated.h", importcpp:"SpaceToBatch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iispaceToBatch[oT: SpaceToBatchT](scope: Scope,
                   input: oT,
                   paddings: SpaceToBatchTpaddings,
                   block_size: int64): SpaceToBatch[oT] {.header:"generated.h", importcpp:"SpaceToBatch(*#, #, #, #)", constructor.}

proc spaceToBatch*[oT: SpaceToBatchT](scope: Scope,
                   input: oT,
                   paddings: SpaceToBatchTpaddings,
                   block_size: int64 = 0): SpaceToBatch[oT] =
  return iispaceToBatch(scope,
                        input,
                        paddings,
                        block_size)

converter spaceToBatchToOut*[oT: SpaceToBatchT](op: SpaceToBatch[oT]): oT = return op.output

type MaxPoolWithArgmaxT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type MaxPoolWithArgmax*[oT:MaxPoolWithArgmaxT] {.header:"generated.h", importcpp:"MaxPoolWithArgmax/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimaxPoolWithArgmax[oT: MaxPoolWithArgmaxT](scope: Scope,
                        input: oT,
                        ksize: ArraySlice[int],
                        strides: ArraySlice[int],
                        padding: cstring,
                        Targmax: DType): MaxPoolWithArgmax[oT] {.header:"generated.h", importcpp:"MaxPoolWithArgmax(*#, #, #, #, tensorflow::string(#), #)", constructor.}

proc maxPoolWithArgmax*[oT: MaxPoolWithArgmaxT](scope: Scope,
                        input: oT,
                        ksize: openArray[int],
                        strides: openArray[int],
                        padding: cstring,
                        Targmax: DType = DT_INT64): MaxPoolWithArgmax[oT] =
  return iimaxPoolWithArgmax(scope,
                             input,
                             newArraySlice(ksize),
                             newArraySlice(strides),
                             padding,
                             Targmax)

converter maxPoolWithArgmaxToOut*[oT: MaxPoolWithArgmaxT](op: MaxPoolWithArgmax[oT]): oT = return op.output

type RefEnterT = oall

type RefEnter*[oT:RefEnterT] {.header:"generated.h", importcpp:"RefEnter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirefEnter[oT: RefEnterT](scope: Scope,
               data: oT,
               frame_name: cstring,
               parallel_iterations: int64,
               is_constant: bool): RefEnter[oT] {.header:"generated.h", importcpp:"RefEnter(*#, #, tensorflow::string(#), #, #)", constructor.}

proc refEnter*[oT: RefEnterT](scope: Scope,
               data: oT,
               frame_name: cstring,
               parallel_iterations: int64 = 10,
               is_constant: bool = false): RefEnter[oT] =
  return iirefEnter(scope,
                    data,
                    frame_name,
                    parallel_iterations,
                    is_constant)

converter refEnterToOut*[oT: RefEnterT](op: RefEnter[oT]): oT = return op.output


type PriorityQueueV2*[oT:oresource] {.header:"generated.h", importcpp:"PriorityQueueV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipriorityQueueV2[oT: oresource](scope: Scope,
                      component_types: ArraySlice[DType],
                      shapes: ArraySlice[TensorShape],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64): PriorityQueueV2[oT] {.header:"generated.h", importcpp:"PriorityQueueV2(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc priorityQueueV2*[oT: oresource](scope: Scope,
                      component_types: openArray[DType],
                      shapes: openArray[TensorShape],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = -1): PriorityQueueV2[oT] =
  return iipriorityQueueV2(scope,
                           newArraySlice(component_types),
                           newArraySlice(shapes),
                           container,
                           shared_name,
                           capacity)

converter priorityQueueV2ToOut*[oT: oresource](op: PriorityQueueV2[oT]): oT = return op.output


type IsBoostedTreesEnsembleInitialized*[oT:obool] {.header:"generated.h", importcpp:"IsBoostedTreesEnsembleInitialized/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiisBoostedTreesEnsembleInitialized[oT: obool](scope: Scope,
                                        tree_ensemble_handle: oresource): IsBoostedTreesEnsembleInitialized[oT] {.header:"generated.h", importcpp:"IsBoostedTreesEnsembleInitialized(*#, #)", constructor.}

proc isBoostedTreesEnsembleInitialized*[oT: obool](scope: Scope,
                                        tree_ensemble_handle: oresource): IsBoostedTreesEnsembleInitialized[oT] =
  return iiisBoostedTreesEnsembleInitialized(scope,
                                             tree_ensemble_handle)

converter isBoostedTreesEnsembleInitializedToOut*[oT: obool](op: IsBoostedTreesEnsembleInitialized[oT]): oT = return op.output


type RepeatDataset*[oT:ovariant] {.header:"generated.h", importcpp:"RepeatDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirepeatDataset[oT: ovariant](scope: Scope,
                    input_dataset: oT,
                    count: oint64,
                    output_types: ArraySlice[DType],
                    output_shapes: ArraySlice[TensorShape]): RepeatDataset[oT] {.header:"generated.h", importcpp:"RepeatDataset(*#, #, #, #, #)", constructor.}

proc repeatDataset*[oT: ovariant](scope: Scope,
                    input_dataset: oT,
                    count: oint64,
                    output_types: openArray[DType],
                    output_shapes: openArray[TensorShape]): RepeatDataset[oT] =
  return iirepeatDataset(scope,
                         input_dataset,
                         count,
                         newArraySlice(output_types),
                         newArraySlice(output_shapes))

converter repeatDatasetToOut*[oT: ovariant](op: RepeatDataset[oT]): oT = return op.output


type BoostedTreesCreateEnsemble*{.header:"generated.h", importcpp:"BoostedTreesCreateEnsemble/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesCreateEnsemble(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 stamp_token: oint64,
                                 tree_ensemble_serialized: ostring): BoostedTreesCreateEnsemble {.header:"generated.h", importcpp:"BoostedTreesCreateEnsemble(*#, #, #, #)", constructor.}

proc boostedTreesCreateEnsemble*(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 stamp_token: oint64,
                                 tree_ensemble_serialized: ostring): BoostedTreesCreateEnsemble =
  return iiboostedTreesCreateEnsemble(scope,
                                      tree_ensemble_handle,
                                      stamp_token,
                                      tree_ensemble_serialized)



type Fillindex_type = oint32 | oint64
type FillT = oall

type Fill*[oT:FillT] {.header:"generated.h", importcpp:"Fill/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifill[oT: FillT](scope: Scope,
           dims: Fillindex_type,
           value: oT): Fill[oT] {.header:"generated.h", importcpp:"Fill(*#, #, #)", constructor.}

proc fill*[oT: FillT](scope: Scope,
           dims: Fillindex_type,
           value: oT): Fill[oT] =
  return iifill(scope,
                dims,
                value)

converter fillToOut*[oT: FillT](op: Fill[oT]): oT = return op.output

type ApplyCenteredRMSPropT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyCenteredRMSProp*[oT:ApplyCenteredRMSPropT] {.header:"generated.h", importcpp:"ApplyCenteredRMSProp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyCenteredRMSProp[oT: ApplyCenteredRMSPropT](scope: Scope,
                           nvar: oT,
                           mg: oT,
                           ms: oT,
                           mom: oT,
                           lr: oT,
                           rho: oT,
                           momentum: oT,
                           epsilon: oT,
                           grad: oT,
                           use_locking: bool): ApplyCenteredRMSProp[oT] {.header:"generated.h", importcpp:"ApplyCenteredRMSProp(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc applyCenteredRMSProp*[oT: ApplyCenteredRMSPropT](scope: Scope,
                           nvar: oT,
                           mg: oT,
                           ms: oT,
                           mom: oT,
                           lr: oT,
                           rho: oT,
                           momentum: oT,
                           epsilon: oT,
                           grad: oT,
                           use_locking: bool = false): ApplyCenteredRMSProp[oT] =
  return iiapplyCenteredRMSProp(scope,
                                nvar,
                                mg,
                                ms,
                                mom,
                                lr,
                                rho,
                                momentum,
                                epsilon,
                                grad,
                                use_locking)

converter applyCenteredRMSPropToOut*[oT: ApplyCenteredRMSPropT](op: ApplyCenteredRMSProp[oT]): oT = return op.output

type Constdtype = oall

type Const*[oT:Constdtype] {.header:"generated.h", importcpp:"Const/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iinconst[oT: Constdtype](scope: Scope,
             value: Tensor[oT],
             dtype: DType): Const[oT] {.header:"generated.h", importcpp:"Const(*#, *#, #)", constructor.}

proc nconst*[oT: Constdtype](scope: Scope,
             value: Tensor[oT],
             dtype: DType = oT[].oTF): Const[oT] =
  return iinconst(scope,
                  value,
                  dtype)

converter nconstToOut*[oT: Constdtype](op: Const[oT]): oT = return op.output

type PlaceholderWithDefaultdtype = oall

type PlaceholderWithDefault*[oT:PlaceholderWithDefaultdtype] {.header:"generated.h", importcpp:"PlaceholderWithDefault/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiplaceholderWithDefault[oT: PlaceholderWithDefaultdtype](scope: Scope,
                             input: oT,
                             dtype: DType,
                             shape: TensorShape): PlaceholderWithDefault[oT] {.header:"generated.h", importcpp:"PlaceholderWithDefault(*#, #, #, #)", constructor.}

proc placeholderWithDefault*[oT: PlaceholderWithDefaultdtype](scope: Scope,
                             input: oT,
                             dtype: DType = oT[].oTF,
                             shape: TensorShape = [].shape): PlaceholderWithDefault[oT] =
  return iiplaceholderWithDefault(scope,
                                  input,
                                  dtype,
                                  shape)

converter placeholderWithDefaultToOut*[oT: PlaceholderWithDefaultdtype](op: PlaceholderWithDefault[oT]): oT = return op.output

type Placeholderdtype = oall

type Placeholder*[oT:Placeholderdtype] {.header:"generated.h", importcpp:"Placeholder/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiplaceholder[oT: Placeholderdtype](scope: Scope,
                  dtype: DType,
                  shape: TensorShape): Placeholder[oT] {.header:"generated.h", importcpp:"Placeholder(*#, #, #)", constructor.}

proc placeholder*[oT: Placeholderdtype](scope: Scope,
                  dtype: DType = oT[].oTF,
                  shape: TensorShape = [].shape): Placeholder[oT] =
  return iiplaceholder(scope,
                       dtype,
                       shape)

converter placeholderToOut*[oT: Placeholderdtype](op: Placeholder[oT]): oT = return op.output


type QueueEnqueueManyV2*{.header:"generated.h", importcpp:"QueueEnqueueManyV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiqueueEnqueueManyV2(scope: Scope,
                         handle: oresource,
                         components: oinvalid,
                         Tcomponents: ArraySlice[DType],
                         timeout_ms: int64): QueueEnqueueManyV2 {.header:"generated.h", importcpp:"QueueEnqueueManyV2(*#, #, #, #, #)", constructor.}

proc queueEnqueueManyV2*(scope: Scope,
                         handle: oresource,
                         components: oinvalid,
                         Tcomponents: openArray[DType],
                         timeout_ms: int64 = -1): QueueEnqueueManyV2 =
  return iiqueueEnqueueManyV2(scope,
                              handle,
                              components,
                              newArraySlice(Tcomponents),
                              timeout_ms)



type ShapeT = oall
type Shapeout_type = oint32 | oint64

type Shape*[oT:Shapeout_type] {.header:"generated.h", importcpp:"Shape/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iishape[oT: Shapeout_type](scope: Scope,
            input: ShapeT): Shape[oT] {.header:"generated.h", importcpp:"Shape(*#, #)", constructor.}

proc shape*[oT: Shapeout_type](scope: Scope,
            input: ShapeT): Shape[oT] =
  return iishape(scope,
                 input)

converter shapeToOut*[oT: Shapeout_type](op: Shape[oT]): oT = return op.output

type Dilation2DBackpropFilterT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Dilation2DBackpropFilter*[oT:Dilation2DBackpropFilterT] {.header:"generated.h", importcpp:"Dilation2DBackpropFilter/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidilation2DBackpropFilter[oT: Dilation2DBackpropFilterT](scope: Scope,
                               input: oT,
                               filter: oT,
                               out_backprop: oT,
                               strides: ArraySlice[int],
                               rates: ArraySlice[int],
                               padding: cstring): Dilation2DBackpropFilter[oT] {.header:"generated.h", importcpp:"Dilation2DBackpropFilter(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc dilation2DBackpropFilter*[oT: Dilation2DBackpropFilterT](scope: Scope,
                               input: oT,
                               filter: oT,
                               out_backprop: oT,
                               strides: openArray[int],
                               rates: openArray[int],
                               padding: cstring): Dilation2DBackpropFilter[oT] =
  return iidilation2DBackpropFilter(scope,
                                    input,
                                    filter,
                                    out_backprop,
                                    newArraySlice(strides),
                                    newArraySlice(rates),
                                    padding)

converter dilation2DBackpropFilterToOut*[oT: Dilation2DBackpropFilterT](op: Dilation2DBackpropFilter[oT]): oT = return op.output


type BatchIFFT3D*[oT:ocomplex64] {.header:"generated.h", importcpp:"BatchIFFT3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchIFFT3D[oT: ocomplex64](scope: Scope,
                  input: oT): BatchIFFT3D[oT] {.header:"generated.h", importcpp:"BatchIFFT3D(*#, #)", constructor.}

proc batchIFFT3D*[oT: ocomplex64](scope: Scope,
                  input: oT): BatchIFFT3D[oT] =
  return iibatchIFFT3D(scope,
                       input)

converter batchIFFT3DToOut*[oT: ocomplex64](op: BatchIFFT3D[oT]): oT = return op.output

type AvgPool3DT = ohalf | obfloat16 | ofloat | odouble

type AvgPool3D*[oT:AvgPool3DT] {.header:"generated.h", importcpp:"AvgPool3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiavgPool3D[oT: AvgPool3DT](scope: Scope,
                input: oT,
                ksize: ArraySlice[int],
                strides: ArraySlice[int],
                padding: cstring,
                data_format: cstring): AvgPool3D[oT] {.header:"generated.h", importcpp:"AvgPool3D(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc avgPool3D*[oT: AvgPool3DT](scope: Scope,
                input: oT,
                ksize: openArray[int],
                strides: openArray[int],
                padding: cstring,
                data_format: cstring = "NDHWC"): AvgPool3D[oT] =
  return iiavgPool3D(scope,
                     input,
                     newArraySlice(ksize),
                     newArraySlice(strides),
                     padding,
                     data_format)

converter avgPool3DToOut*[oT: AvgPool3DT](op: AvgPool3D[oT]): oT = return op.output

type DataFormatDimMapT = oint32 | oint64

type DataFormatDimMap*[oT:DataFormatDimMapT] {.header:"generated.h", importcpp:"DataFormatDimMap/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidataFormatDimMap[oT: DataFormatDimMapT](scope: Scope,
                       x: oT,
                       dst_format: cstring,
                       src_format: cstring): DataFormatDimMap[oT] {.header:"generated.h", importcpp:"DataFormatDimMap(*#, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc dataFormatDimMap*[oT: DataFormatDimMapT](scope: Scope,
                       x: oT,
                       dst_format: cstring = "NCHW",
                       src_format: cstring = "NHWC"): DataFormatDimMap[oT] =
  return iidataFormatDimMap(scope,
                            x,
                            dst_format,
                            src_format)

converter dataFormatDimMapToOut*[oT: DataFormatDimMapT](op: DataFormatDimMap[oT]): oT = return op.output


type StackClose*{.header:"generated.h", importcpp:"StackClose/*'0*/".} = object
  operation: Operation[oinvalid]


proc iistackClose(scope: Scope,
                 handle: ostring): StackClose {.header:"generated.h", importcpp:"StackClose(*#, #)", constructor.}

proc stackClose*(scope: Scope,
                 handle: ostring): StackClose =
  return iistackClose(scope,
                      handle)




type QueueSizeV2*[oT:oint32] {.header:"generated.h", importcpp:"QueueSizeV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiqueueSizeV2[oT: oint32](scope: Scope,
                  handle: oresource): QueueSizeV2[oT] {.header:"generated.h", importcpp:"QueueSizeV2(*#, #)", constructor.}

proc queueSizeV2*[oT: oint32](scope: Scope,
                  handle: oresource): QueueSizeV2[oT] =
  return iiqueueSizeV2(scope,
                       handle)

converter queueSizeV2ToOut*[oT: oint32](op: QueueSizeV2[oT]): oT = return op.output


type StatelessWhile*[oT:oinvalid] {.header:"generated.h", importcpp:"StatelessWhile/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessWhile[oT: oinvalid](scope: Scope,
                     input: oT,
                     T: ArraySlice[DType],
                     cond: NameAttrList,
                     body: NameAttrList): StatelessWhile[oT] {.header:"generated.h", importcpp:"StatelessWhile(*#, #, #, #, #)", constructor.}

proc statelessWhile*[oT: oinvalid](scope: Scope,
                     input: oT,
                     T: openArray[DType],
                     cond: NameAttrList,
                     body: NameAttrList): StatelessWhile[oT] =
  return iistatelessWhile(scope,
                          input,
                          newArraySlice(T),
                          cond,
                          body)

converter statelessWhileToOut*[oT: oinvalid](op: StatelessWhile[oT]): oT = return op.output

type MatrixDiagPartT = oall

type MatrixDiagPart*[oT:MatrixDiagPartT] {.header:"generated.h", importcpp:"MatrixDiagPart/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixDiagPart[oT: MatrixDiagPartT](scope: Scope,
                     input: oT): MatrixDiagPart[oT] {.header:"generated.h", importcpp:"MatrixDiagPart(*#, #)", constructor.}

proc matrixDiagPart*[oT: MatrixDiagPartT](scope: Scope,
                     input: oT): MatrixDiagPart[oT] =
  return iimatrixDiagPart(scope,
                          input)

converter matrixDiagPartToOut*[oT: MatrixDiagPartT](op: MatrixDiagPart[oT]): oT = return op.output


type DecodeProtoV2*[oT:oint32] {.header:"generated.h", importcpp:"DecodeProtoV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeProtoV2[oT: oint32](scope: Scope,
                    bytes: ostring,
                    message_type: cstring,
                    field_names: ArraySlice[cstring],
                    output_types: ArraySlice[DType],
                    descriptor_source: cstring,
                    message_format: cstring,
                    sanitize: bool): DecodeProtoV2[oT] {.header:"generated.h", importcpp:"DecodeProtoV2(*#, #, tensorflow::string(#), #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc decodeProtoV2*[oT: oint32](scope: Scope,
                    bytes: ostring,
                    message_type: cstring,
                    field_names: openArray[cstring],
                    output_types: openArray[DType],
                    descriptor_source: cstring = "local://",
                    message_format: cstring = "binary",
                    sanitize: bool = false): DecodeProtoV2[oT] =
  return iidecodeProtoV2(scope,
                         bytes,
                         message_type,
                         newArraySlice(field_names),
                         newArraySlice(output_types),
                         descriptor_source,
                         message_format,
                         sanitize)

converter decodeProtoV2ToOut*[oT: oint32](op: DecodeProtoV2[oT]): oT = return op.output

type PrintT = oall

type Print*[oT:PrintT] {.header:"generated.h", importcpp:"Print/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiprint[oT: PrintT](scope: Scope,
            input: oT,
            data: oinvalid,
            U: ArraySlice[DType],
            message: cstring,
            summarize: int64,
            first_n: int64): Print[oT] {.header:"generated.h", importcpp:"Print(*#, #, #, #, tensorflow::string(#), #, #)", constructor.}

proc print*[oT: PrintT](scope: Scope,
            input: oT,
            data: oinvalid,
            U: openArray[DType],
            message: cstring,
            summarize: int64 = 3,
            first_n: int64 = -1): Print[oT] =
  return iiprint(scope,
                 input,
                 data,
                 newArraySlice(U),
                 message,
                 summarize,
                 first_n)

converter printToOut*[oT: PrintT](op: Print[oT]): oT = return op.output

type QuantizeAndDequantizeV2T = obfloat16 | ohalf | ofloat | odouble

type QuantizeAndDequantizeV2*[oT:QuantizeAndDequantizeV2T] {.header:"generated.h", importcpp:"QuantizeAndDequantizeV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizeAndDequantizeV2[oT: QuantizeAndDequantizeV2T](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              signed_input: bool,
                              num_bits: int64,
                              range_given: bool,
                              round_mode: cstring): QuantizeAndDequantizeV2[oT] {.header:"generated.h", importcpp:"QuantizeAndDequantizeV2(*#, #, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc quantizeAndDequantizeV2*[oT: QuantizeAndDequantizeV2T](scope: Scope,
                              input: oT,
                              input_min: oT,
                              input_max: oT,
                              signed_input: bool = true,
                              num_bits: int64 = 8,
                              range_given: bool = false,
                              round_mode: cstring = "HALF_TO_EVEN"): QuantizeAndDequantizeV2[oT] =
  return iiquantizeAndDequantizeV2(scope,
                                   input,
                                   input_min,
                                   input_max,
                                   signed_input,
                                   num_bits,
                                   range_given,
                                   round_mode)

converter quantizeAndDequantizeV2ToOut*[oT: QuantizeAndDequantizeV2T](op: QuantizeAndDequantizeV2[oT]): oT = return op.output

type FractionalAvgPoolT = ofloat | odouble | oint32 | oint64

type FractionalAvgPool*[oT:FractionalAvgPoolT] {.header:"generated.h", importcpp:"FractionalAvgPool/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifractionalAvgPool[oT: FractionalAvgPoolT](scope: Scope,
                        value: oT,
                        pooling_ratio: ArraySlice[float32],
                        pseudo_random: bool,
                        overlapping: bool,
                        deterministic: bool,
                        seed: int64,
                        seed2: int64): FractionalAvgPool[oT] {.header:"generated.h", importcpp:"FractionalAvgPool(*#, #, #, #, #, #, #, #)", constructor.}

proc fractionalAvgPool*[oT: FractionalAvgPoolT](scope: Scope,
                        value: oT,
                        pooling_ratio: openArray[float32],
                        pseudo_random: bool = false,
                        overlapping: bool = false,
                        deterministic: bool = false,
                        seed: int64 = 0,
                        seed2: int64 = 0): FractionalAvgPool[oT] =
  return iifractionalAvgPool(scope,
                             value,
                             newArraySlice(pooling_ratio),
                             pseudo_random,
                             overlapping,
                             deterministic,
                             seed,
                             seed2)

converter fractionalAvgPoolToOut*[oT: FractionalAvgPoolT](op: FractionalAvgPool[oT]): oT = return op.output


type SparseAccumulatorTakeGradient*[oT:oint64] {.header:"generated.h", importcpp:"SparseAccumulatorTakeGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseAccumulatorTakeGradient[oT: oint64](scope: Scope,
                                    handle: ostring,
                                    num_required: oint32,
                                    dtype: DType): SparseAccumulatorTakeGradient[oT] {.header:"generated.h", importcpp:"SparseAccumulatorTakeGradient(*#, #, #, #)", constructor.}

proc sparseAccumulatorTakeGradient*[oT: oint64](scope: Scope,
                                    handle: ostring,
                                    num_required: oint32,
                                    dtype: DType = oT[].oTF): SparseAccumulatorTakeGradient[oT] =
  return iisparseAccumulatorTakeGradient(scope,
                                         handle,
                                         num_required,
                                         dtype)

converter sparseAccumulatorTakeGradientToOut*[oT: oint64](op: SparseAccumulatorTakeGradient[oT]): oT = return op.output

type TruncateModT = oint32 | oint64 | obfloat16 | ohalf | ofloat | odouble

type TruncateMod*[oT:TruncateModT] {.header:"generated.h", importcpp:"TruncateMod/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitruncateMod[oT: TruncateModT](scope: Scope,
                  x: oT,
                  y: oT): TruncateMod[oT] {.header:"generated.h", importcpp:"TruncateMod(*#, #, #)", constructor.}

proc truncateMod*[oT: TruncateModT](scope: Scope,
                  x: oT,
                  y: oT): TruncateMod[oT] =
  return iitruncateMod(scope,
                       x,
                       y)

converter truncateModToOut*[oT: TruncateModT](op: TruncateMod[oT]): oT = return op.output

type ResourceApplyFtrlT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyFtrl*{.header:"generated.h", importcpp:"ResourceApplyFtrl/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyFtrl(scope: Scope,
                        nvar: oresource,
                        accum: oresource,
                        linear: oresource,
                        grad: ResourceApplyFtrlT,
                        lr: ResourceApplyFtrlT,
                        l1: ResourceApplyFtrlT,
                        l2: ResourceApplyFtrlT,
                        lr_power: ResourceApplyFtrlT,
                        use_locking: bool): ResourceApplyFtrl {.header:"generated.h", importcpp:"ResourceApplyFtrl(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyFtrl*(scope: Scope,
                        nvar: oresource,
                        accum: oresource,
                        linear: oresource,
                        grad: ResourceApplyFtrlT,
                        lr: ResourceApplyFtrlT,
                        l1: ResourceApplyFtrlT,
                        l2: ResourceApplyFtrlT,
                        lr_power: ResourceApplyFtrlT,
                        use_locking: bool = false): ResourceApplyFtrl =
  return iiresourceApplyFtrl(scope,
                             nvar,
                             accum,
                             linear,
                             grad,
                             lr,
                             l1,
                             l2,
                             lr_power,
                             use_locking)



type StridedSliceGradIndex = oint32 | oint64
type StridedSliceGradT = oall

type StridedSliceGrad*[oT:StridedSliceGradT] {.header:"generated.h", importcpp:"StridedSliceGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistridedSliceGrad[oT: StridedSliceGradT](scope: Scope,
                       shape: StridedSliceGradIndex,
                       begin: StridedSliceGradIndex,
                       nend: StridedSliceGradIndex,
                       strides: StridedSliceGradIndex,
                       dy: oT,
                       new_axis_mask: int64,
                       shrink_axis_mask: int64,
                       begin_mask: int64,
                       end_mask: int64,
                       ellipsis_mask: int64): StridedSliceGrad[oT] {.header:"generated.h", importcpp:"StridedSliceGrad(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc stridedSliceGrad*[oT: StridedSliceGradT](scope: Scope,
                       shape: StridedSliceGradIndex,
                       begin: StridedSliceGradIndex,
                       nend: StridedSliceGradIndex,
                       strides: StridedSliceGradIndex,
                       dy: oT,
                       new_axis_mask: int64 = 0,
                       shrink_axis_mask: int64 = 0,
                       begin_mask: int64 = 0,
                       end_mask: int64 = 0,
                       ellipsis_mask: int64 = 0): StridedSliceGrad[oT] =
  return iistridedSliceGrad(scope,
                            shape,
                            begin,
                            nend,
                            strides,
                            dy,
                            new_axis_mask,
                            shrink_axis_mask,
                            begin_mask,
                            end_mask,
                            ellipsis_mask)

converter stridedSliceGradToOut*[oT: StridedSliceGradT](op: StridedSliceGrad[oT]): oT = return op.output

type QuantizeAndDequantizeT = obfloat16 | ohalf | ofloat | odouble

type QuantizeAndDequantize*[oT:QuantizeAndDequantizeT] {.header:"generated.h", importcpp:"QuantizeAndDequantize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizeAndDequantize[oT: QuantizeAndDequantizeT](scope: Scope,
                            input: oT,
                            signed_input: bool,
                            num_bits: int64,
                            range_given: bool,
                            input_min: float32,
                            input_max: float32): QuantizeAndDequantize[oT] {.header:"generated.h", importcpp:"QuantizeAndDequantize(*#, #, #, #, #, #, #)", constructor.}

proc quantizeAndDequantize*[oT: QuantizeAndDequantizeT](scope: Scope,
                            input: oT,
                            signed_input: bool = true,
                            num_bits: int64 = 8,
                            range_given: bool = false,
                            input_min: float32 = 0.0.float32,
                            input_max: float32 = 0.0.float32): QuantizeAndDequantize[oT] =
  return iiquantizeAndDequantize(scope,
                                 input,
                                 signed_input,
                                 num_bits,
                                 range_given,
                                 input_min,
                                 input_max)

converter quantizeAndDequantizeToOut*[oT: QuantizeAndDequantizeT](op: QuantizeAndDequantize[oT]): oT = return op.output


type BoostedTreesUpdateEnsemble*{.header:"generated.h", importcpp:"BoostedTreesUpdateEnsemble/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesUpdateEnsemble(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 feature_ids: oint32,
                                 node_ids: oint32,
                                 gains: ofloat,
                                 thresholds: oint32,
                                 left_node_contribs: ofloat,
                                 right_node_contribs: ofloat,
                                 max_depth: oint32,
                                 learning_rate: ofloat,
                                 pruning_mode: int64,
                                 num_features: int64): BoostedTreesUpdateEnsemble {.header:"generated.h", importcpp:"BoostedTreesUpdateEnsemble(*#, #, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc boostedTreesUpdateEnsemble*(scope: Scope,
                                 tree_ensemble_handle: oresource,
                                 feature_ids: oint32,
                                 node_ids: oint32,
                                 gains: ofloat,
                                 thresholds: oint32,
                                 left_node_contribs: ofloat,
                                 right_node_contribs: ofloat,
                                 max_depth: oint32,
                                 learning_rate: ofloat,
                                 pruning_mode: int64 = 0,
                                 num_features: int64 = 0): BoostedTreesUpdateEnsemble =
  return iiboostedTreesUpdateEnsemble(scope,
                                      tree_ensemble_handle,
                                      feature_ids,
                                      node_ids,
                                      gains,
                                      thresholds,
                                      left_node_contribs,
                                      right_node_contribs,
                                      max_depth,
                                      learning_rate,
                                      pruning_mode,
                                      num_features)



type Relu6GradT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | oint64 | obfloat16 | ouint16 | ohalf | ouint32 | ouint64

type Relu6Grad*[oT:Relu6GradT] {.header:"generated.h", importcpp:"Relu6Grad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirelu6Grad[oT: Relu6GradT](scope: Scope,
                gradients: oT,
                features: oT): Relu6Grad[oT] {.header:"generated.h", importcpp:"Relu6Grad(*#, #, #)", constructor.}

proc relu6Grad*[oT: Relu6GradT](scope: Scope,
                gradients: oT,
                features: oT): Relu6Grad[oT] =
  return iirelu6Grad(scope,
                     gradients,
                     features)

converter relu6GradToOut*[oT: Relu6GradT](op: Relu6Grad[oT]): oT = return op.output

type RangeTidx = obfloat16 | ofloat | odouble | oint32 | oint64

type Range*[oT:RangeTidx] {.header:"generated.h", importcpp:"Range/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirange[oT: RangeTidx](scope: Scope,
            start: oT,
            limit: oT,
            delta: oT): Range[oT] {.header:"generated.h", importcpp:"Range(*#, #, #, #)", constructor.}

proc range*[oT: RangeTidx](scope: Scope,
            start: oT,
            limit: oT,
            delta: oT): Range[oT] =
  return iirange(scope,
                 start,
                 limit,
                 delta)

converter rangeToOut*[oT: RangeTidx](op: Range[oT]): oT = return op.output


type PrefetchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"PrefetchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiprefetchDataset[oT: ovariant](scope: Scope,
                      input_dataset: oT,
                      buffer_size: oint64,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape]): PrefetchDataset[oT] {.header:"generated.h", importcpp:"PrefetchDataset(*#, #, #, #, #)", constructor.}

proc prefetchDataset*[oT: ovariant](scope: Scope,
                      input_dataset: oT,
                      buffer_size: oint64,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape]): PrefetchDataset[oT] =
  return iiprefetchDataset(scope,
                           input_dataset,
                           buffer_size,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes))

converter prefetchDatasetToOut*[oT: ovariant](op: PrefetchDataset[oT]): oT = return op.output

type DeepCopyT = oall

type DeepCopy*[oT:DeepCopyT] {.header:"generated.h", importcpp:"DeepCopy/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iideepCopy[oT: DeepCopyT](scope: Scope,
               x: oT): DeepCopy[oT] {.header:"generated.h", importcpp:"DeepCopy(*#, #)", constructor.}

proc deepCopy*[oT: DeepCopyT](scope: Scope,
               x: oT): DeepCopy[oT] =
  return iideepCopy(scope,
                    x)

converter deepCopyToOut*[oT: DeepCopyT](op: DeepCopy[oT]): oT = return op.output


type ExperimentalLatencyStatsDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalLatencyStatsDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalLatencyStatsDataset[oT: ovariant](scope: Scope,
                                      input_dataset: oT,
                                      tag: ostring,
                                      output_types: ArraySlice[DType],
                                      output_shapes: ArraySlice[TensorShape]): ExperimentalLatencyStatsDataset[oT] {.header:"generated.h", importcpp:"ExperimentalLatencyStatsDataset(*#, #, #, #, #)", constructor.}

proc experimentalLatencyStatsDataset*[oT: ovariant](scope: Scope,
                                      input_dataset: oT,
                                      tag: ostring,
                                      output_types: openArray[DType],
                                      output_shapes: openArray[TensorShape]): ExperimentalLatencyStatsDataset[oT] =
  return iiexperimentalLatencyStatsDataset(scope,
                                           input_dataset,
                                           tag,
                                           newArraySlice(output_types),
                                           newArraySlice(output_shapes))

converter experimentalLatencyStatsDatasetToOut*[oT: ovariant](op: ExperimentalLatencyStatsDataset[oT]): oT = return op.output


type MultiDeviceIteratorGetNextFromShard*[oT:oinvalid] {.header:"generated.h", importcpp:"MultiDeviceIteratorGetNextFromShard/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimultiDeviceIteratorGetNextFromShard[oT: oinvalid](scope: Scope,
                                          multi_device_iterator: oresource,
                                          shard_num: oint32,
                                          incarnation_id: oint64,
                                          output_types: ArraySlice[DType],
                                          output_shapes: ArraySlice[TensorShape]): MultiDeviceIteratorGetNextFromShard[oT] {.header:"generated.h", importcpp:"MultiDeviceIteratorGetNextFromShard(*#, #, #, #, #, #)", constructor.}

proc multiDeviceIteratorGetNextFromShard*[oT: oinvalid](scope: Scope,
                                          multi_device_iterator: oresource,
                                          shard_num: oint32,
                                          incarnation_id: oint64,
                                          output_types: openArray[DType],
                                          output_shapes: openArray[TensorShape]): MultiDeviceIteratorGetNextFromShard[oT] =
  return iimultiDeviceIteratorGetNextFromShard(scope,
                                               multi_device_iterator,
                                               shard_num,
                                               incarnation_id,
                                               newArraySlice(output_types),
                                               newArraySlice(output_shapes))

converter multiDeviceIteratorGetNextFromShardToOut*[oT: oinvalid](op: MultiDeviceIteratorGetNextFromShard[oT]): oT = return op.output

type BatchCholeskyT = odouble | ofloat

type BatchCholesky*[oT:BatchCholeskyT] {.header:"generated.h", importcpp:"BatchCholesky/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchCholesky[oT: BatchCholeskyT](scope: Scope,
                    input: oT): BatchCholesky[oT] {.header:"generated.h", importcpp:"BatchCholesky(*#, #)", constructor.}

proc batchCholesky*[oT: BatchCholeskyT](scope: Scope,
                    input: oT): BatchCholesky[oT] =
  return iibatchCholesky(scope,
                         input)

converter batchCholeskyToOut*[oT: BatchCholeskyT](op: BatchCholesky[oT]): oT = return op.output

type TensorArrayGatherdtype = oall

type TensorArrayGather*[oT:TensorArrayGatherdtype] {.header:"generated.h", importcpp:"TensorArrayGather/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArrayGather[oT: TensorArrayGatherdtype](scope: Scope,
                        handle: ostring,
                        indices: oint32,
                        flow_in: ofloat,
                        dtype: DType,
                        element_shape: TensorShape): TensorArrayGather[oT] {.header:"generated.h", importcpp:"TensorArrayGather(*#, #, #, #, #, #)", constructor.}

proc tensorArrayGather*[oT: TensorArrayGatherdtype](scope: Scope,
                        handle: ostring,
                        indices: oint32,
                        flow_in: ofloat,
                        dtype: DType = oT[].oTF,
                        element_shape: TensorShape = [].shape): TensorArrayGather[oT] =
  return iitensorArrayGather(scope,
                             handle,
                             indices,
                             flow_in,
                             dtype,
                             element_shape)

converter tensorArrayGatherToOut*[oT: TensorArrayGatherdtype](op: TensorArrayGather[oT]): oT = return op.output

type RoundT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Round*[oT:RoundT] {.header:"generated.h", importcpp:"Round/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiround[oT: RoundT](scope: Scope,
            x: oT): Round[oT] {.header:"generated.h", importcpp:"Round(*#, #)", constructor.}

proc round*[oT: RoundT](scope: Scope,
            x: oT): Round[oT] =
  return iiround(scope,
                 x)

converter roundToOut*[oT: RoundT](op: Round[oT]): oT = return op.output


type ZipDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ZipDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iizipDataset[oT: ovariant](scope: Scope,
                 input_datasets: oT,
                 output_types: ArraySlice[DType],
                 output_shapes: ArraySlice[TensorShape]): ZipDataset[oT] {.header:"generated.h", importcpp:"ZipDataset(*#, #, #, #)", constructor.}

proc zipDataset*[oT: ovariant](scope: Scope,
                 input_datasets: oT,
                 output_types: openArray[DType],
                 output_shapes: openArray[TensorShape]): ZipDataset[oT] =
  return iizipDataset(scope,
                      input_datasets,
                      newArraySlice(output_types),
                      newArraySlice(output_shapes))

converter zipDatasetToOut*[oT: ovariant](op: ZipDataset[oT]): oT = return op.output


type QueueClose*{.header:"generated.h", importcpp:"QueueClose/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiqueueClose(scope: Scope,
                 handle: ostring,
                 cancel_pending_enqueues: bool): QueueClose {.header:"generated.h", importcpp:"QueueClose(*#, #, #)", constructor.}

proc queueClose*(scope: Scope,
                 handle: ostring,
                 cancel_pending_enqueues: bool = false): QueueClose =
  return iiqueueClose(scope,
                      handle,
                      cancel_pending_enqueues)



type SparseTensorDenseAddTindices = oint32 | oint64
type SparseTensorDenseAddT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseTensorDenseAdd*[oT:SparseTensorDenseAddT] {.header:"generated.h", importcpp:"SparseTensorDenseAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseTensorDenseAdd[oT: SparseTensorDenseAddT](scope: Scope,
                           a_indices: SparseTensorDenseAddTindices,
                           a_values: oT,
                           a_shape: SparseTensorDenseAddTindices,
                           b: oT): SparseTensorDenseAdd[oT] {.header:"generated.h", importcpp:"SparseTensorDenseAdd(*#, #, #, #, #)", constructor.}

proc sparseTensorDenseAdd*[oT: SparseTensorDenseAddT](scope: Scope,
                           a_indices: SparseTensorDenseAddTindices,
                           a_values: oT,
                           a_shape: SparseTensorDenseAddTindices,
                           b: oT): SparseTensorDenseAdd[oT] =
  return iisparseTensorDenseAdd(scope,
                                a_indices,
                                a_values,
                                a_shape,
                                b)

converter sparseTensorDenseAddToOut*[oT: SparseTensorDenseAddT](op: SparseTensorDenseAdd[oT]): oT = return op.output

type SnapshotT = oall

type Snapshot*[oT:SnapshotT] {.header:"generated.h", importcpp:"Snapshot/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisnapshot[oT: SnapshotT](scope: Scope,
               input: oT): Snapshot[oT] {.header:"generated.h", importcpp:"Snapshot(*#, #)", constructor.}

proc snapshot*[oT: SnapshotT](scope: Scope,
               input: oT): Snapshot[oT] =
  return iisnapshot(scope,
                    input)

converter snapshotToOut*[oT: SnapshotT](op: Snapshot[oT]): oT = return op.output

type UniqueV2T = oall
type UniqueV2Taxis = oint32 | oint64

type UniqueV2*[oT:UniqueV2T] {.header:"generated.h", importcpp:"UniqueV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiuniqueV2[oT: UniqueV2T](scope: Scope,
               x: oT,
               axis: UniqueV2Taxis,
               out_idx: DType): UniqueV2[oT] {.header:"generated.h", importcpp:"UniqueV2(*#, #, #, #)", constructor.}

proc uniqueV2*[oT: UniqueV2T](scope: Scope,
               x: oT,
               axis: UniqueV2Taxis,
               out_idx: DType = DT_INT32): UniqueV2[oT] =
  return iiuniqueV2(scope,
                    x,
                    axis,
                    out_idx)

converter uniqueV2ToOut*[oT: UniqueV2T](op: UniqueV2[oT]): oT = return op.output

type CudnnRNNBackpropV2T = ohalf | ofloat | odouble

type CudnnRNNBackpropV2*[oT:CudnnRNNBackpropV2T] {.header:"generated.h", importcpp:"CudnnRNNBackpropV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicudnnRNNBackpropV2[oT: CudnnRNNBackpropV2T](scope: Scope,
                         input: oT,
                         input_h: oT,
                         input_c: oT,
                         params: oT,
                         output: oT,
                         output_h: oT,
                         output_c: oT,
                         output_backprop: oT,
                         output_h_backprop: oT,
                         output_c_backprop: oT,
                         reserve_space: oT,
                         host_reserved: oint8,
                         seed2: int64,
                         rnn_mode: cstring,
                         input_mode: cstring,
                         direction: cstring,
                         dropout: float32,
                         seed: int64): CudnnRNNBackpropV2[oT] {.header:"generated.h", importcpp:"CudnnRNNBackpropV2(*#, #, #, #, #, #, #, #, #, #, #, #, #, #, tensorflow::string(#), tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc cudnnRNNBackpropV2*[oT: CudnnRNNBackpropV2T](scope: Scope,
                         input: oT,
                         input_h: oT,
                         input_c: oT,
                         params: oT,
                         output: oT,
                         output_h: oT,
                         output_c: oT,
                         output_backprop: oT,
                         output_h_backprop: oT,
                         output_c_backprop: oT,
                         reserve_space: oT,
                         host_reserved: oint8,
                         seed2: int64 = 0,
                         rnn_mode: cstring = "lstm",
                         input_mode: cstring = "linear_input",
                         direction: cstring = "unidirectional",
                         dropout: float32 = 0.0.float32,
                         seed: int64 = 0): CudnnRNNBackpropV2[oT] =
  return iicudnnRNNBackpropV2(scope,
                              input,
                              input_h,
                              input_c,
                              params,
                              output,
                              output_h,
                              output_c,
                              output_backprop,
                              output_h_backprop,
                              output_c_backprop,
                              reserve_space,
                              host_reserved,
                              seed2,
                              rnn_mode,
                              input_mode,
                              direction,
                              dropout,
                              seed)

converter cudnnRNNBackpropV2ToOut*[oT: CudnnRNNBackpropV2T](op: CudnnRNNBackpropV2[oT]): oT = return op.output

type InvertPermutationT = oint32 | oint64

type InvertPermutation*[oT:InvertPermutationT] {.header:"generated.h", importcpp:"InvertPermutation/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiinvertPermutation[oT: InvertPermutationT](scope: Scope,
                        x: oT): InvertPermutation[oT] {.header:"generated.h", importcpp:"InvertPermutation(*#, #)", constructor.}

proc invertPermutation*[oT: InvertPermutationT](scope: Scope,
                        x: oT): InvertPermutation[oT] =
  return iiinvertPermutation(scope,
                             x)

converter invertPermutationToOut*[oT: InvertPermutationT](op: InvertPermutation[oT]): oT = return op.output


type ReaderReset*{.header:"generated.h", importcpp:"ReaderReset/*'0*/".} = object
  operation: Operation[oinvalid]


proc iireaderReset(scope: Scope,
                  reader_handle: ostring): ReaderReset {.header:"generated.h", importcpp:"ReaderReset(*#, #)", constructor.}

proc readerReset*(scope: Scope,
                  reader_handle: ostring): ReaderReset =
  return iireaderReset(scope,
                       reader_handle)



type StopGradientT = oall

type StopGradient*[oT:StopGradientT] {.header:"generated.h", importcpp:"StopGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistopGradient[oT: StopGradientT](scope: Scope,
                   input: oT): StopGradient[oT] {.header:"generated.h", importcpp:"StopGradient(*#, #)", constructor.}

proc stopGradient*[oT: StopGradientT](scope: Scope,
                   input: oT): StopGradient[oT] =
  return iistopGradient(scope,
                        input)

converter stopGradientToOut*[oT: StopGradientT](op: StopGradient[oT]): oT = return op.output

type ResourceScatterSubTindices = oint32 | oint64
type ResourceScatterSubdtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceScatterSub*{.header:"generated.h", importcpp:"ResourceScatterSub/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterSub(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterSubTindices,
                         updates: ResourceScatterSubdtype,
                         dtype: DType): ResourceScatterSub {.header:"generated.h", importcpp:"ResourceScatterSub(*#, #, #, #, #)", constructor.}

proc resourceScatterSub*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterSubTindices,
                         updates: ResourceScatterSubdtype,
                         dtype: DType = DT_INVALID): ResourceScatterSub =
  return iiresourceScatterSub(scope,
                              resource,
                              indices,
                              updates,
                              dtype)




type TensorForestTreeSize*[oT:oint32] {.header:"generated.h", importcpp:"TensorForestTreeSize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorForestTreeSize[oT: oint32](scope: Scope,
                           tree_handle: oresource): TensorForestTreeSize[oT] {.header:"generated.h", importcpp:"TensorForestTreeSize(*#, #)", constructor.}

proc tensorForestTreeSize*[oT: oint32](scope: Scope,
                           tree_handle: oresource): TensorForestTreeSize[oT] =
  return iitensorForestTreeSize(scope,
                                tree_handle)

converter tensorForestTreeSizeToOut*[oT: oint32](op: TensorForestTreeSize[oT]): oT = return op.output

type RintT = obfloat16 | ohalf | ofloat | odouble

type Rint*[oT:RintT] {.header:"generated.h", importcpp:"Rint/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirint[oT: RintT](scope: Scope,
           x: oT): Rint[oT] {.header:"generated.h", importcpp:"Rint(*#, #)", constructor.}

proc rint*[oT: RintT](scope: Scope,
           x: oT): Rint[oT] =
  return iirint(scope,
                x)

converter rintToOut*[oT: RintT](op: Rint[oT]): oT = return op.output


type Abort*{.header:"generated.h", importcpp:"Abort/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiabort(scope: Scope,
            error_msg: cstring,
            exit_without_error: bool): Abort {.header:"generated.h", importcpp:"Abort(*#, tensorflow::string(#), #)", constructor.}

proc abort*(scope: Scope,
            error_msg: cstring,
            exit_without_error: bool = false): Abort =
  return iiabort(scope,
                 error_msg,
                 exit_without_error)




type MutableHashTableOfTensorsV2*[oT:oresource] {.header:"generated.h", importcpp:"MutableHashTableOfTensorsV2/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimutableHashTableOfTensorsV2[oT: oresource](scope: Scope,
                                  container: cstring,
                                  shared_name: cstring,
                                  use_node_name_sharing: bool,
                                  key_dtype: DType,
                                  value_dtype: DType,
                                  value_shape: TensorShape): MutableHashTableOfTensorsV2[oT] {.header:"generated.h", importcpp:"MutableHashTableOfTensorsV2(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #)", constructor.}

proc mutableHashTableOfTensorsV2*[oT: oresource](scope: Scope,
                                  container: cstring,
                                  shared_name: cstring,
                                  use_node_name_sharing: bool = false,
                                  key_dtype: DType = DT_INVALID,
                                  value_dtype: DType = DT_INVALID,
                                  value_shape: TensorShape = [].shape): MutableHashTableOfTensorsV2[oT] =
  return iimutableHashTableOfTensorsV2(scope,
                                       container,
                                       shared_name,
                                       use_node_name_sharing,
                                       key_dtype,
                                       value_dtype,
                                       value_shape)

converter mutableHashTableOfTensorsV2ToOut*[oT: oresource](op: MutableHashTableOfTensorsV2[oT]): oT = return op.output


type TensorListConcatLists*[oT:ovariant] {.header:"generated.h", importcpp:"TensorListConcatLists/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListConcatLists[oT: ovariant](scope: Scope,
                            input_a: oT,
                            input_b: oT,
                            element_dtype: DType): TensorListConcatLists[oT] {.header:"generated.h", importcpp:"TensorListConcatLists(*#, #, #, #)", constructor.}

proc tensorListConcatLists*[oT: ovariant](scope: Scope,
                            input_a: oT,
                            input_b: oT,
                            element_dtype: DType = DT_INVALID): TensorListConcatLists[oT] =
  return iitensorListConcatLists(scope,
                                 input_a,
                                 input_b,
                                 element_dtype)

converter tensorListConcatListsToOut*[oT: ovariant](op: TensorListConcatLists[oT]): oT = return op.output

type OneHotTI = ouint8 | oint32 | oint64
type OneHotT = oall

type OneHot*[oT:OneHotT] {.header:"generated.h", importcpp:"OneHot/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioneHot[oT: OneHotT](scope: Scope,
             indices: OneHotTI,
             depth: oint32,
             on_value: oT,
             off_value: oT,
             axis: int64): OneHot[oT] {.header:"generated.h", importcpp:"OneHot(*#, #, #, #, #, #)", constructor.}

proc oneHot*[oT: OneHotT](scope: Scope,
             indices: OneHotTI,
             depth: oint32,
             on_value: oT,
             off_value: oT,
             axis: int64 = -1): OneHot[oT] =
  return iioneHot(scope,
                  indices,
                  depth,
                  on_value,
                  off_value,
                  axis)

converter oneHotToOut*[oT: OneHotT](op: OneHot[oT]): oT = return op.output

type ReverseT = ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | obool | ohalf | ofloat | odouble | ocomplex64 | ocomplex128 | ostring

type Reverse*[oT:ReverseT] {.header:"generated.h", importcpp:"Reverse/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iireverse[oT: ReverseT](scope: Scope,
              tensor: oT,
              dims: obool): Reverse[oT] {.header:"generated.h", importcpp:"Reverse(*#, #, #)", constructor.}

proc reverse*[oT: ReverseT](scope: Scope,
              tensor: oT,
              dims: obool): Reverse[oT] =
  return iireverse(scope,
                   tensor,
                   dims)

converter reverseToOut*[oT: ReverseT](op: Reverse[oT]): oT = return op.output


type BoostedTreesCreateQuantileStreamResource*{.header:"generated.h", importcpp:"BoostedTreesCreateQuantileStreamResource/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiboostedTreesCreateQuantileStreamResource(scope: Scope,
                                               quantile_stream_resource_handle: oresource,
                                               epsilon: ofloat,
                                               num_streams: oint64,
                                               max_elements: int64): BoostedTreesCreateQuantileStreamResource {.header:"generated.h", importcpp:"BoostedTreesCreateQuantileStreamResource(*#, #, #, #, #)", constructor.}

proc boostedTreesCreateQuantileStreamResource*(scope: Scope,
                                               quantile_stream_resource_handle: oresource,
                                               epsilon: ofloat,
                                               num_streams: oint64,
                                               max_elements: int64 = 1099511627776): BoostedTreesCreateQuantileStreamResource =
  return iiboostedTreesCreateQuantileStreamResource(scope,
                                                    quantile_stream_resource_handle,
                                                    epsilon,
                                                    num_streams,
                                                    max_elements)




type ParseSingleExample*[oT:oint64] {.header:"generated.h", importcpp:"ParseSingleExample/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiparseSingleExample[oT: oint64](scope: Scope,
                         serialized: ostring,
                         dense_defaults: oinvalid,
                         sparse_keys: ArraySlice[cstring],
                         dense_keys: ArraySlice[cstring],
                         sparse_types: ArraySlice[DType],
                         Tdense: ArraySlice[DType],
                         dense_shapes: ArraySlice[TensorShape],
                         num_sparse: int64): ParseSingleExample[oT] {.header:"generated.h", importcpp:"ParseSingleExample(*#, #, #, #, #, #, #, #, #)", constructor.}

proc parseSingleExample*[oT: oint64](scope: Scope,
                         serialized: ostring,
                         dense_defaults: oinvalid,
                         sparse_keys: openArray[cstring],
                         dense_keys: openArray[cstring],
                         sparse_types: openArray[DType],
                         Tdense: openArray[DType],
                         dense_shapes: openArray[TensorShape],
                         num_sparse: int64 = 0): ParseSingleExample[oT] =
  return iiparseSingleExample(scope,
                              serialized,
                              dense_defaults,
                              newArraySlice(sparse_keys),
                              newArraySlice(dense_keys),
                              newArraySlice(sparse_types),
                              newArraySlice(Tdense),
                              newArraySlice(dense_shapes),
                              num_sparse)

converter parseSingleExampleToOut*[oT: oint64](op: ParseSingleExample[oT]): oT = return op.output

type GuaranteeConstT = oall

type GuaranteeConst*[oT:GuaranteeConstT] {.header:"generated.h", importcpp:"GuaranteeConst/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiguaranteeConst[oT: GuaranteeConstT](scope: Scope,
                     input: oT): GuaranteeConst[oT] {.header:"generated.h", importcpp:"GuaranteeConst(*#, #)", constructor.}

proc guaranteeConst*[oT: GuaranteeConstT](scope: Scope,
                     input: oT): GuaranteeConst[oT] =
  return iiguaranteeConst(scope,
                          input)

converter guaranteeConstToOut*[oT: GuaranteeConstT](op: GuaranteeConst[oT]): oT = return op.output


type QueueEnqueueV2*{.header:"generated.h", importcpp:"QueueEnqueueV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiqueueEnqueueV2(scope: Scope,
                     handle: oresource,
                     components: oinvalid,
                     Tcomponents: ArraySlice[DType],
                     timeout_ms: int64): QueueEnqueueV2 {.header:"generated.h", importcpp:"QueueEnqueueV2(*#, #, #, #, #)", constructor.}

proc queueEnqueueV2*(scope: Scope,
                     handle: oresource,
                     components: oinvalid,
                     Tcomponents: openArray[DType],
                     timeout_ms: int64 = -1): QueueEnqueueV2 =
  return iiqueueEnqueueV2(scope,
                          handle,
                          components,
                          newArraySlice(Tcomponents),
                          timeout_ms)



type IScopedAllocatorConcatT = oall

type IScopedAllocatorConcat*[oT:IScopedAllocatorConcatT] {.header:"generated.h", importcpp:"_ScopedAllocatorConcat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiScopedAllocatorConcat[oT: IScopedAllocatorConcatT](scope: Scope,
                             backing: oT,
                             inputs: oT,
                             sa_name: cstring,
                             shape: TensorShape,
                             id: int64,
                             reshape: bool): IScopedAllocatorConcat[oT] {.header:"generated.h", importcpp:"_ScopedAllocatorConcat(*#, #, #, tensorflow::string(#), #, #, #)", constructor.}

proc iScopedAllocatorConcat*[oT: IScopedAllocatorConcatT](scope: Scope,
                             backing: oT,
                             inputs: oT,
                             sa_name: cstring,
                             shape: TensorShape = [].shape,
                             id: int64 = 0,
                             reshape: bool = false): IScopedAllocatorConcat[oT] =
  return iiiScopedAllocatorConcat(scope,
                                  backing,
                                  inputs,
                                  sa_name,
                                  shape,
                                  id,
                                  reshape)

converter iScopedAllocatorConcatToOut*[oT: IScopedAllocatorConcatT](op: IScopedAllocatorConcat[oT]): oT = return op.output


type BoostedTreesQuantileStreamResourceHandleOp*[oT:oresource] {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceHandleOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesQuantileStreamResourceHandleOp[oT: oresource](scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring): BoostedTreesQuantileStreamResourceHandleOp[oT] {.header:"generated.h", importcpp:"BoostedTreesQuantileStreamResourceHandleOp(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc boostedTreesQuantileStreamResourceHandleOp*[oT: oresource](scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring): BoostedTreesQuantileStreamResourceHandleOp[oT] =
  return iiboostedTreesQuantileStreamResourceHandleOp(scope,
                                                      container,
                                                      shared_name)

converter boostedTreesQuantileStreamResourceHandleOpToOut*[oT: oresource](op: BoostedTreesQuantileStreamResourceHandleOp[oT]): oT = return op.output

type StatelessTruncatedNormalT = oint32 | oint64
type StatelessTruncatedNormalTseed = oint32 | oint64
type StatelessTruncatedNormaldtype = ohalf | obfloat16 | ofloat | odouble

type StatelessTruncatedNormal*[oT:StatelessTruncatedNormaldtype] {.header:"generated.h", importcpp:"StatelessTruncatedNormal/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistatelessTruncatedNormal[oT: StatelessTruncatedNormaldtype](scope: Scope,
                               shape: StatelessTruncatedNormalT,
                               seed: StatelessTruncatedNormalTseed,
                               dtype: DType): StatelessTruncatedNormal[oT] {.header:"generated.h", importcpp:"StatelessTruncatedNormal(*#, #, #, #)", constructor.}

proc statelessTruncatedNormal*[oT: StatelessTruncatedNormaldtype](scope: Scope,
                               shape: StatelessTruncatedNormalT,
                               seed: StatelessTruncatedNormalTseed,
                               dtype: DType = oT[].oTF): StatelessTruncatedNormal[oT] =
  return iistatelessTruncatedNormal(scope,
                                    shape,
                                    seed,
                                    dtype)

converter statelessTruncatedNormalToOut*[oT: StatelessTruncatedNormaldtype](op: StatelessTruncatedNormal[oT]): oT = return op.output

type MatrixDiagT = oall

type MatrixDiag*[oT:MatrixDiagT] {.header:"generated.h", importcpp:"MatrixDiag/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixDiag[oT: MatrixDiagT](scope: Scope,
                 diagonal: oT): MatrixDiag[oT] {.header:"generated.h", importcpp:"MatrixDiag(*#, #)", constructor.}

proc matrixDiag*[oT: MatrixDiagT](scope: Scope,
                 diagonal: oT): MatrixDiag[oT] =
  return iimatrixDiag(scope,
                      diagonal)

converter matrixDiagToOut*[oT: MatrixDiagT](op: MatrixDiag[oT]): oT = return op.output

type TensorScatterSubT = oall
type TensorScatterSubTindices = oint32 | oint64

type TensorScatterSub*[oT:TensorScatterSubT] {.header:"generated.h", importcpp:"TensorScatterSub/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorScatterSub[oT: TensorScatterSubT](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterSubTindices,
                       updates: oT): TensorScatterSub[oT] {.header:"generated.h", importcpp:"TensorScatterSub(*#, #, #, #)", constructor.}

proc tensorScatterSub*[oT: TensorScatterSubT](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterSubTindices,
                       updates: oT): TensorScatterSub[oT] =
  return iitensorScatterSub(scope,
                            tensor,
                            indices,
                            updates)

converter tensorScatterSubToOut*[oT: TensorScatterSubT](op: TensorScatterSub[oT]): oT = return op.output

type FloorDivT = obfloat16 | ohalf | ofloat | odouble | ouint8 | oint8 | ouint16 | oint16 | oint32 | oint64 | ocomplex64 | ocomplex128

type FloorDiv*[oT:FloorDivT] {.header:"generated.h", importcpp:"FloorDiv/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifloorDiv[oT: FloorDivT](scope: Scope,
               x: oT,
               y: oT): FloorDiv[oT] {.header:"generated.h", importcpp:"FloorDiv(*#, #, #)", constructor.}

proc floorDiv*[oT: FloorDivT](scope: Scope,
               x: oT,
               y: oT): FloorDiv[oT] =
  return iifloorDiv(scope,
                    x,
                    y)

converter floorDivToOut*[oT: FloorDivT](op: FloorDiv[oT]): oT = return op.output

type StridedSliceT = oall
type StridedSliceIndex = oint32 | oint64

type StridedSlice*[oT:StridedSliceT] {.header:"generated.h", importcpp:"StridedSlice/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iistridedSlice[oT: StridedSliceT](scope: Scope,
                   input: oT,
                   begin: StridedSliceIndex,
                   nend: StridedSliceIndex,
                   strides: StridedSliceIndex,
                   shrink_axis_mask: int64,
                   new_axis_mask: int64,
                   begin_mask: int64,
                   end_mask: int64,
                   ellipsis_mask: int64): StridedSlice[oT] {.header:"generated.h", importcpp:"StridedSlice(*#, #, #, #, #, #, #, #, #, #)", constructor.}

proc stridedSlice*[oT: StridedSliceT](scope: Scope,
                   input: oT,
                   begin: StridedSliceIndex,
                   nend: StridedSliceIndex,
                   strides: StridedSliceIndex,
                   shrink_axis_mask: int64 = 0,
                   new_axis_mask: int64 = 0,
                   begin_mask: int64 = 0,
                   end_mask: int64 = 0,
                   ellipsis_mask: int64 = 0): StridedSlice[oT] =
  return iistridedSlice(scope,
                        input,
                        begin,
                        nend,
                        strides,
                        shrink_axis_mask,
                        new_axis_mask,
                        begin_mask,
                        end_mask,
                        ellipsis_mask)

converter stridedSliceToOut*[oT: StridedSliceT](op: StridedSlice[oT]): oT = return op.output

type PreventGradientT = oall

type PreventGradient*[oT:PreventGradientT] {.header:"generated.h", importcpp:"PreventGradient/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iipreventGradient[oT: PreventGradientT](scope: Scope,
                      input: oT,
                      message: cstring): PreventGradient[oT] {.header:"generated.h", importcpp:"PreventGradient(*#, #, tensorflow::string(#))", constructor.}

proc preventGradient*[oT: PreventGradientT](scope: Scope,
                      input: oT,
                      message: cstring): PreventGradient[oT] =
  return iipreventGradient(scope,
                           input,
                           message)

converter preventGradientToOut*[oT: PreventGradientT](op: PreventGradient[oT]): oT = return op.output

type SparseDenseCwiseMulT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type SparseDenseCwiseMul*[oT:SparseDenseCwiseMulT] {.header:"generated.h", importcpp:"SparseDenseCwiseMul/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisparseDenseCwiseMul[oT: SparseDenseCwiseMulT](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseMul[oT] {.header:"generated.h", importcpp:"SparseDenseCwiseMul(*#, #, #, #, #)", constructor.}

proc sparseDenseCwiseMul*[oT: SparseDenseCwiseMulT](scope: Scope,
                          sp_indices: oint64,
                          sp_values: oT,
                          sp_shape: oint64,
                          dense: oT): SparseDenseCwiseMul[oT] =
  return iisparseDenseCwiseMul(scope,
                               sp_indices,
                               sp_values,
                               sp_shape,
                               dense)

converter sparseDenseCwiseMulToOut*[oT: SparseDenseCwiseMulT](op: SparseDenseCwiseMul[oT]): oT = return op.output

type FusedPadConv2DT = ohalf | ofloat | odouble

type FusedPadConv2D*[oT:FusedPadConv2DT] {.header:"generated.h", importcpp:"FusedPadConv2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifusedPadConv2D[oT: FusedPadConv2DT](scope: Scope,
                     input: oT,
                     paddings: oint32,
                     filter: oT,
                     mode: cstring,
                     strides: ArraySlice[int],
                     padding: cstring): FusedPadConv2D[oT] {.header:"generated.h", importcpp:"FusedPadConv2D(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc fusedPadConv2D*[oT: FusedPadConv2DT](scope: Scope,
                     input: oT,
                     paddings: oint32,
                     filter: oT,
                     mode: cstring,
                     strides: openArray[int],
                     padding: cstring): FusedPadConv2D[oT] =
  return iifusedPadConv2D(scope,
                          input,
                          paddings,
                          filter,
                          mode,
                          newArraySlice(strides),
                          padding)

converter fusedPadConv2DToOut*[oT: FusedPadConv2DT](op: FusedPadConv2D[oT]): oT = return op.output

type LookupTableInsertV2Tin = oall
type LookupTableInsertV2Tout = oall

type LookupTableInsertV2*{.header:"generated.h", importcpp:"LookupTableInsertV2/*'0*/".} = object
  operation: Operation[oinvalid]


proc iilookupTableInsertV2(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableInsertV2Tin,
                          values: LookupTableInsertV2Tout): LookupTableInsertV2 {.header:"generated.h", importcpp:"LookupTableInsertV2(*#, #, #, #)", constructor.}

proc lookupTableInsertV2*(scope: Scope,
                          table_handle: oresource,
                          keys: LookupTableInsertV2Tin,
                          values: LookupTableInsertV2Tout): LookupTableInsertV2 =
  return iilookupTableInsertV2(scope,
                               table_handle,
                               keys,
                               values)



type BarrierInsertManyT = oall

type BarrierInsertMany*{.header:"generated.h", importcpp:"BarrierInsertMany/*'0*/".} = object
  operation: Operation[oinvalid]


proc iibarrierInsertMany(scope: Scope,
                        handle: ostring,
                        keys: ostring,
                        values: BarrierInsertManyT,
                        component_index: int64): BarrierInsertMany {.header:"generated.h", importcpp:"BarrierInsertMany(*#, #, #, #, #)", constructor.}

proc barrierInsertMany*(scope: Scope,
                        handle: ostring,
                        keys: ostring,
                        values: BarrierInsertManyT,
                        component_index: int64 = 0): BarrierInsertMany =
  return iibarrierInsertMany(scope,
                             handle,
                             keys,
                             values,
                             component_index)



type SplitVT = oall
type SplitVTlen = oint32 | oint64

type SplitV*[oT:SplitVT] {.header:"generated.h", importcpp:"SplitV/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisplitV[oT: SplitVT](scope: Scope,
             value: oT,
             size_splits: SplitVTlen,
             split_dim: oint32,
             num_split: int64): SplitV[oT] {.header:"generated.h", importcpp:"SplitV(*#, #, #, #, #)", constructor.}

proc splitV*[oT: SplitVT](scope: Scope,
             value: oT,
             size_splits: SplitVTlen,
             split_dim: oint32,
             num_split: int64 = 0): SplitV[oT] =
  return iisplitV(scope,
                  value,
                  size_splits,
                  split_dim,
                  num_split)

converter splitVToOut*[oT: SplitVT](op: SplitV[oT]): oT = return op.output

type BatchMatrixDiagT = oall

type BatchMatrixDiag*[oT:BatchMatrixDiagT] {.header:"generated.h", importcpp:"BatchMatrixDiag/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchMatrixDiag[oT: BatchMatrixDiagT](scope: Scope,
                      diagonal: oT): BatchMatrixDiag[oT] {.header:"generated.h", importcpp:"BatchMatrixDiag(*#, #)", constructor.}

proc batchMatrixDiag*[oT: BatchMatrixDiagT](scope: Scope,
                      diagonal: oT): BatchMatrixDiag[oT] =
  return iibatchMatrixDiag(scope,
                           diagonal)

converter batchMatrixDiagToOut*[oT: BatchMatrixDiagT](op: BatchMatrixDiag[oT]): oT = return op.output

type BucketizeT = oint32 | oint64 | ofloat | odouble

type Bucketize*[oT:oint32] {.header:"generated.h", importcpp:"Bucketize/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibucketize[oT: oint32](scope: Scope,
                input: BucketizeT,
                boundaries: ArraySlice[float32]): Bucketize[oT] {.header:"generated.h", importcpp:"Bucketize(*#, #, #)", constructor.}

proc bucketize*[oT: oint32](scope: Scope,
                input: BucketizeT,
                boundaries: openArray[float32]): Bucketize[oT] =
  return iibucketize(scope,
                     input,
                     newArraySlice(boundaries))

converter bucketizeToOut*[oT: oint32](op: Bucketize[oT]): oT = return op.output

type DrawBoundingBoxesT = ofloat | ohalf

type DrawBoundingBoxes*[oT:DrawBoundingBoxesT] {.header:"generated.h", importcpp:"DrawBoundingBoxes/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidrawBoundingBoxes[oT: DrawBoundingBoxesT](scope: Scope,
                        images: oT,
                        boxes: ofloat): DrawBoundingBoxes[oT] {.header:"generated.h", importcpp:"DrawBoundingBoxes(*#, #, #)", constructor.}

proc drawBoundingBoxes*[oT: DrawBoundingBoxesT](scope: Scope,
                        images: oT,
                        boxes: ofloat): DrawBoundingBoxes[oT] =
  return iidrawBoundingBoxes(scope,
                             images,
                             boxes)

converter drawBoundingBoxesToOut*[oT: DrawBoundingBoxesT](op: DrawBoundingBoxes[oT]): oT = return op.output

type ZerosLikeT = oall

type ZerosLike*[oT:ZerosLikeT] {.header:"generated.h", importcpp:"ZerosLike/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iizerosLike[oT: ZerosLikeT](scope: Scope,
                x: oT): ZerosLike[oT] {.header:"generated.h", importcpp:"ZerosLike(*#, #)", constructor.}

proc zerosLike*[oT: ZerosLikeT](scope: Scope,
                x: oT): ZerosLike[oT] =
  return iizerosLike(scope,
                     x)

converter zerosLikeToOut*[oT: ZerosLikeT](op: ZerosLike[oT]): oT = return op.output

type ImageSummaryT = ouint8 | ofloat | ohalf | odouble

type ImageSummary*[oT:ostring] {.header:"generated.h", importcpp:"ImageSummary/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiimageSummary[oT: ostring](scope: Scope,
                   tag: oT,
                   tensor: ImageSummaryT,
                   max_images: int64,
                   bad_color: Tensor[ostring]): ImageSummary[oT] {.header:"generated.h", importcpp:"ImageSummary(*#, #, #, #, *#)", constructor.}

proc imageSummary*[oT: ostring](scope: Scope,
                   tag: oT,
                   tensor: ImageSummaryT,
                   max_images: int64 = 3,
                   bad_color: Tensor[ostring] = tensor([255, 0, 0, 255], uint8)): ImageSummary[oT] =
  return iiimageSummary(scope,
                        tag,
                        tensor,
                        max_images,
                        bad_color)

converter imageSummaryToOut*[oT: ostring](op: ImageSummary[oT]): oT = return op.output

type ShapeNT = oall
type ShapeNout_type = oint32 | oint64

type ShapeN*[oT:ShapeNout_type] {.header:"generated.h", importcpp:"ShapeN/*'0*/".} = object
  operation: Operation[oT]
  output: olist[oT]

proc iishapeN[oT: ShapeNout_type](scope: Scope,
             input: ShapeNT): ShapeN[oT] {.header:"generated.h", importcpp:"ShapeN(*#, #)", constructor.}

proc shapeN*[oT: ShapeNout_type](scope: Scope,
             input: ShapeNT): ShapeN[oT] =
  return iishapeN(scope,
                  input)

converter shapeNToOutList*[oT: ShapeNout_type](op: ShapeN[oT]): olist[oT] = return op.output

type HostConstdtype = oall

type HostConst*[oT:HostConstdtype] {.header:"generated.h", importcpp:"HostConst/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iihostConst[oT: HostConstdtype](scope: Scope,
                value: Tensor[oT],
                dtype: DType): HostConst[oT] {.header:"generated.h", importcpp:"HostConst(*#, *#, #)", constructor.}

proc hostConst*[oT: HostConstdtype](scope: Scope,
                value: Tensor[oT],
                dtype: DType = oT[].oTF): HostConst[oT] =
  return iihostConst(scope,
                     value,
                     dtype)

converter hostConstToOut*[oT: HostConstdtype](op: HostConst[oT]): oT = return op.output

type Emptydtype = oall

type Empty*[oT:Emptydtype] {.header:"generated.h", importcpp:"Empty/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiempty[oT: Emptydtype](scope: Scope,
            shape: oint32,
            dtype: DType,
            init: bool): Empty[oT] {.header:"generated.h", importcpp:"Empty(*#, #, #, #)", constructor.}

proc empty*[oT: Emptydtype](scope: Scope,
            shape: oint32,
            dtype: DType = oT[].oTF,
            init: bool = false): Empty[oT] =
  return iiempty(scope,
                 shape,
                 dtype,
                 init)

converter emptyToOut*[oT: Emptydtype](op: Empty[oT]): oT = return op.output

type SplitT = oall

type Split*[oT:SplitT] {.header:"generated.h", importcpp:"Split/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisplit[oT: SplitT](scope: Scope,
            split_dim: oint32,
            value: oT,
            num_split: int64): Split[oT] {.header:"generated.h", importcpp:"Split(*#, #, #, #)", constructor.}

proc split*[oT: SplitT](scope: Scope,
            split_dim: oint32,
            value: oT,
            num_split: int64 = 0): Split[oT] =
  return iisplit(scope,
                 split_dim,
                 value,
                 num_split)

converter splitToOut*[oT: SplitT](op: Split[oT]): oT = return op.output

type Conv3DBackpropInputT = ohalf | ofloat | odouble

type Conv3DBackpropInput*[oT:Conv3DBackpropInputT] {.header:"generated.h", importcpp:"Conv3DBackpropInput/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconv3DBackpropInput[oT: Conv3DBackpropInputT](scope: Scope,
                          input: oT,
                          filter: oT,
                          out_backprop: oT,
                          strides: ArraySlice[int],
                          padding: cstring,
                          dilations: ArraySlice[int]): Conv3DBackpropInput[oT] {.header:"generated.h", importcpp:"Conv3DBackpropInput(*#, #, #, #, #, tensorflow::string(#), #)", constructor.}

proc conv3DBackpropInput*[oT: Conv3DBackpropInputT](scope: Scope,
                          input: oT,
                          filter: oT,
                          out_backprop: oT,
                          strides: openArray[int],
                          padding: cstring,
                          dilations: openArray[int] = [1, 1, 1, 1, 1]): Conv3DBackpropInput[oT] =
  return iiconv3DBackpropInput(scope,
                               input,
                               filter,
                               out_backprop,
                               newArraySlice(strides),
                               padding,
                               newArraySlice(dilations))

converter conv3DBackpropInputToOut*[oT: Conv3DBackpropInputT](op: Conv3DBackpropInput[oT]): oT = return op.output

type DepthwiseConv2dNativeT = ohalf | obfloat16 | ofloat | odouble

type DepthwiseConv2dNative*[oT:DepthwiseConv2dNativeT] {.header:"generated.h", importcpp:"DepthwiseConv2dNative/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidepthwiseConv2dNative[oT: DepthwiseConv2dNativeT](scope: Scope,
                            input: oT,
                            filter: oT,
                            strides: ArraySlice[int],
                            padding: cstring,
                            dilations: ArraySlice[int],
                            data_format: cstring): DepthwiseConv2dNative[oT] {.header:"generated.h", importcpp:"DepthwiseConv2dNative(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#))", constructor.}

proc depthwiseConv2dNative*[oT: DepthwiseConv2dNativeT](scope: Scope,
                            input: oT,
                            filter: oT,
                            strides: openArray[int],
                            padding: cstring,
                            dilations: openArray[int] = [1, 1, 1, 1],
                            data_format: cstring = "NHWC"): DepthwiseConv2dNative[oT] =
  return iidepthwiseConv2dNative(scope,
                                 input,
                                 filter,
                                 newArraySlice(strides),
                                 padding,
                                 newArraySlice(dilations),
                                 data_format)

converter depthwiseConv2dNativeToOut*[oT: DepthwiseConv2dNativeT](op: DepthwiseConv2dNative[oT]): oT = return op.output


type LearnedUnigramCandidateSampler*[oT:oint64] {.header:"generated.h", importcpp:"LearnedUnigramCandidateSampler/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilearnedUnigramCandidateSampler[oT: oint64](scope: Scope,
                                     true_classes: oT,
                                     num_true: int64,
                                     num_sampled: int64,
                                     unique: bool,
                                     range_max: int64,
                                     seed: int64,
                                     seed2: int64): LearnedUnigramCandidateSampler[oT] {.header:"generated.h", importcpp:"LearnedUnigramCandidateSampler(*#, #, #, #, #, #, #, #)", constructor.}

proc learnedUnigramCandidateSampler*[oT: oint64](scope: Scope,
                                     true_classes: oT,
                                     num_true: int64 = 0,
                                     num_sampled: int64 = 0,
                                     unique: bool = false,
                                     range_max: int64 = 0,
                                     seed: int64 = 0,
                                     seed2: int64 = 0): LearnedUnigramCandidateSampler[oT] =
  return iilearnedUnigramCandidateSampler(scope,
                                          true_classes,
                                          num_true,
                                          num_sampled,
                                          unique,
                                          range_max,
                                          seed,
                                          seed2)

converter learnedUnigramCandidateSamplerToOut*[oT: oint64](op: LearnedUnigramCandidateSampler[oT]): oT = return op.output

type DebugNanCountT = oall

type DebugNanCount*[oT:oint64] {.header:"generated.h", importcpp:"DebugNanCount/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidebugNanCount[oT: oint64](scope: Scope,
                    input: DebugNanCountT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: ArraySlice[cstring],
                    gated_grpc: bool): DebugNanCount[oT] {.header:"generated.h", importcpp:"DebugNanCount(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc debugNanCount*[oT: oint64](scope: Scope,
                    input: DebugNanCountT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: openArray[cstring],
                    gated_grpc: bool = false): DebugNanCount[oT] =
  return iidebugNanCount(scope,
                         input,
                         device_name,
                         tensor_name,
                         newArraySlice(debug_urls),
                         gated_grpc)

converter debugNanCountToOut*[oT: oint64](op: DebugNanCount[oT]): oT = return op.output


type UnicodeScript*[oT:oint32] {.header:"generated.h", importcpp:"UnicodeScript/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunicodeScript[oT: oint32](scope: Scope,
                    input: oT): UnicodeScript[oT] {.header:"generated.h", importcpp:"UnicodeScript(*#, #)", constructor.}

proc unicodeScript*[oT: oint32](scope: Scope,
                    input: oT): UnicodeScript[oT] =
  return iiunicodeScript(scope,
                         input)

converter unicodeScriptToOut*[oT: oint32](op: UnicodeScript[oT]): oT = return op.output


type OptionalGetValue*[oT:oinvalid] {.header:"generated.h", importcpp:"OptionalGetValue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioptionalGetValue[oT: oinvalid](scope: Scope,
                       optional: ovariant,
                       output_types: ArraySlice[DType],
                       output_shapes: ArraySlice[TensorShape]): OptionalGetValue[oT] {.header:"generated.h", importcpp:"OptionalGetValue(*#, #, #, #)", constructor.}

proc optionalGetValue*[oT: oinvalid](scope: Scope,
                       optional: ovariant,
                       output_types: openArray[DType],
                       output_shapes: openArray[TensorShape]): OptionalGetValue[oT] =
  return iioptionalGetValue(scope,
                            optional,
                            newArraySlice(output_types),
                            newArraySlice(output_shapes))

converter optionalGetValueToOut*[oT: oinvalid](op: OptionalGetValue[oT]): oT = return op.output

type TensorListGetItemelement_dtype = oall

type TensorListGetItem*[oT:TensorListGetItemelement_dtype] {.header:"generated.h", importcpp:"TensorListGetItem/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorListGetItem[oT: TensorListGetItemelement_dtype](scope: Scope,
                        input_handle: ovariant,
                        index: oint32): TensorListGetItem[oT] {.header:"generated.h", importcpp:"TensorListGetItem(*#, #, #)", constructor.}

proc tensorListGetItem*[oT: TensorListGetItemelement_dtype](scope: Scope,
                        input_handle: ovariant,
                        index: oint32): TensorListGetItem[oT] =
  return iitensorListGetItem(scope,
                             input_handle,
                             index)

converter tensorListGetItemToOut*[oT: TensorListGetItemelement_dtype](op: TensorListGetItem[oT]): oT = return op.output

type DiagT = obfloat16 | ohalf | ofloat | odouble | oint32 | oint64 | ocomplex64 | ocomplex128

type Diag*[oT:DiagT] {.header:"generated.h", importcpp:"Diag/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidiag[oT: DiagT](scope: Scope,
           diagonal: oT): Diag[oT] {.header:"generated.h", importcpp:"Diag(*#, #)", constructor.}

proc diag*[oT: DiagT](scope: Scope,
           diagonal: oT): Diag[oT] =
  return iidiag(scope,
                diagonal)

converter diagToOut*[oT: DiagT](op: Diag[oT]): oT = return op.output


type OneShotIterator*[oT:oresource] {.header:"generated.h", importcpp:"OneShotIterator/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioneShotIterator[oT: oresource](scope: Scope,
                      dataset_factory: NameAttrList,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape],
                      container: cstring,
                      shared_name: cstring): OneShotIterator[oT] {.header:"generated.h", importcpp:"OneShotIterator(*#, #, #, #, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc oneShotIterator*[oT: oresource](scope: Scope,
                      dataset_factory: NameAttrList,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape],
                      container: cstring,
                      shared_name: cstring): OneShotIterator[oT] =
  return iioneShotIterator(scope,
                           dataset_factory,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes),
                           container,
                           shared_name)

converter oneShotIteratorToOut*[oT: oresource](op: OneShotIterator[oT]): oT = return op.output

type ResourceApplyPowerSignT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceApplyPowerSign*{.header:"generated.h", importcpp:"ResourceApplyPowerSign/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceApplyPowerSign(scope: Scope,
                             nvar: oresource,
                             m: oresource,
                             lr: ResourceApplyPowerSignT,
                             logbase: ResourceApplyPowerSignT,
                             sign_decay: ResourceApplyPowerSignT,
                             beta: ResourceApplyPowerSignT,
                             grad: ResourceApplyPowerSignT,
                             use_locking: bool): ResourceApplyPowerSign {.header:"generated.h", importcpp:"ResourceApplyPowerSign(*#, #, #, #, #, #, #, #, #)", constructor.}

proc resourceApplyPowerSign*(scope: Scope,
                             nvar: oresource,
                             m: oresource,
                             lr: ResourceApplyPowerSignT,
                             logbase: ResourceApplyPowerSignT,
                             sign_decay: ResourceApplyPowerSignT,
                             beta: ResourceApplyPowerSignT,
                             grad: ResourceApplyPowerSignT,
                             use_locking: bool = false): ResourceApplyPowerSign =
  return iiresourceApplyPowerSign(scope,
                                  nvar,
                                  m,
                                  lr,
                                  logbase,
                                  sign_decay,
                                  beta,
                                  grad,
                                  use_locking)



type ConcatT = oall

type Concat*[oT:ConcatT] {.header:"generated.h", importcpp:"Concat/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiconcat[oT: ConcatT](scope: Scope,
             concat_dim: oint32,
             values: oT): Concat[oT] {.header:"generated.h", importcpp:"Concat(*#, #, #)", constructor.}

proc concat*[oT: ConcatT](scope: Scope,
             concat_dim: oint32,
             values: oT): Concat[oT] =
  return iiconcat(scope,
                  concat_dim,
                  values)

converter concatToOut*[oT: ConcatT](op: Concat[oT]): oT = return op.output


type TextLineReader*[oT:ostring] {.header:"generated.h", importcpp:"TextLineReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitextLineReader[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     skip_header_lines: int64): TextLineReader[oT] {.header:"generated.h", importcpp:"TextLineReader(*#, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc textLineReader*[oT: ostring](scope: Scope,
                     container: cstring,
                     shared_name: cstring,
                     skip_header_lines: int64 = 0): TextLineReader[oT] =
  return iitextLineReader(scope,
                          container,
                          shared_name,
                          skip_header_lines)

converter textLineReaderToOut*[oT: ostring](op: TextLineReader[oT]): oT = return op.output


type RecordInput*[oT:ostring] {.header:"generated.h", importcpp:"RecordInput/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iirecordInput[oT: ostring](scope: Scope,
                  file_pattern: cstring,
                  compression_type: cstring,
                  file_random_seed: int64,
                  file_shuffle_shift_ratio: float32,
                  file_buffer_size: int64,
                  file_parallelism: int64,
                  batch_size: int64): RecordInput[oT] {.header:"generated.h", importcpp:"RecordInput(*#, tensorflow::string(#), tensorflow::string(#), #, #, #, #, #)", constructor.}

proc recordInput*[oT: ostring](scope: Scope,
                  file_pattern: cstring,
                  compression_type: cstring,
                  file_random_seed: int64 = 301,
                  file_shuffle_shift_ratio: float32 = 0.0.float32,
                  file_buffer_size: int64 = 10000,
                  file_parallelism: int64 = 16,
                  batch_size: int64 = 32): RecordInput[oT] =
  return iirecordInput(scope,
                       file_pattern,
                       compression_type,
                       file_random_seed,
                       file_shuffle_shift_ratio,
                       file_buffer_size,
                       file_parallelism,
                       batch_size)

converter recordInputToOut*[oT: ostring](op: RecordInput[oT]): oT = return op.output

type ApplyAddSignT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ApplyAddSign*[oT:ApplyAddSignT] {.header:"generated.h", importcpp:"ApplyAddSign/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiapplyAddSign[oT: ApplyAddSignT](scope: Scope,
                   nvar: oT,
                   m: oT,
                   lr: oT,
                   alpha: oT,
                   sign_decay: oT,
                   beta: oT,
                   grad: oT,
                   use_locking: bool): ApplyAddSign[oT] {.header:"generated.h", importcpp:"ApplyAddSign(*#, #, #, #, #, #, #, #, #)", constructor.}

proc applyAddSign*[oT: ApplyAddSignT](scope: Scope,
                   nvar: oT,
                   m: oT,
                   lr: oT,
                   alpha: oT,
                   sign_decay: oT,
                   beta: oT,
                   grad: oT,
                   use_locking: bool = false): ApplyAddSign[oT] =
  return iiapplyAddSign(scope,
                        nvar,
                        m,
                        lr,
                        alpha,
                        sign_decay,
                        beta,
                        grad,
                        use_locking)

converter applyAddSignToOut*[oT: ApplyAddSignT](op: ApplyAddSign[oT]): oT = return op.output

type BitwiseAndT = oint8 | oint16 | oint32 | oint64 | ouint8 | ouint16 | ouint32 | ouint64

type BitwiseAnd*[oT:BitwiseAndT] {.header:"generated.h", importcpp:"BitwiseAnd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibitwiseAnd[oT: BitwiseAndT](scope: Scope,
                 x: oT,
                 y: oT): BitwiseAnd[oT] {.header:"generated.h", importcpp:"BitwiseAnd(*#, #, #)", constructor.}

proc bitwiseAnd*[oT: BitwiseAndT](scope: Scope,
                 x: oT,
                 y: oT): BitwiseAnd[oT] =
  return iibitwiseAnd(scope,
                      x,
                      y)

converter bitwiseAndToOut*[oT: BitwiseAndT](op: BitwiseAnd[oT]): oT = return op.output

type MatrixSetDiagT = oall

type MatrixSetDiag*[oT:MatrixSetDiagT] {.header:"generated.h", importcpp:"MatrixSetDiag/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimatrixSetDiag[oT: MatrixSetDiagT](scope: Scope,
                    input: oT,
                    diagonal: oT): MatrixSetDiag[oT] {.header:"generated.h", importcpp:"MatrixSetDiag(*#, #, #)", constructor.}

proc matrixSetDiag*[oT: MatrixSetDiagT](scope: Scope,
                    input: oT,
                    diagonal: oT): MatrixSetDiag[oT] =
  return iimatrixSetDiag(scope,
                         input,
                         diagonal)

converter matrixSetDiagToOut*[oT: MatrixSetDiagT](op: MatrixSetDiag[oT]): oT = return op.output

type IFusedConv2DT = ofloat | odouble

type IFusedConv2D*[oT:IFusedConv2DT] {.header:"generated.h", importcpp:"_FusedConv2D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiiFusedConv2D[oT: IFusedConv2DT](scope: Scope,
                   input: oT,
                   filter: oT,
                   args: oT,
                   strides: ArraySlice[int],
                   padding: cstring,
                   fused_ops: ArraySlice[cstring],
                   epsilon: float32,
                   num_args: int64,
                   data_format: cstring,
                   dilations: ArraySlice[int]): IFusedConv2D[oT] {.header:"generated.h", importcpp:"_FusedConv2D(*#, #, #, #, #, tensorflow::string(#), #, #, #, tensorflow::string(#), #)", constructor.}

proc iFusedConv2D*[oT: IFusedConv2DT](scope: Scope,
                   input: oT,
                   filter: oT,
                   args: oT,
                   strides: openArray[int],
                   padding: cstring,
                   fused_ops: openArray[cstring],
                   epsilon: float32 = 9.999999747378752e-05.float32,
                   num_args: int64 = 0,
                   data_format: cstring = "NHWC",
                   dilations: openArray[int] = [1, 1, 1, 1]): IFusedConv2D[oT] =
  return iiiFusedConv2D(scope,
                        input,
                        filter,
                        args,
                        newArraySlice(strides),
                        padding,
                        newArraySlice(fused_ops),
                        epsilon,
                        num_args,
                        data_format,
                        newArraySlice(dilations))

converter iFusedConv2DToOut*[oT: IFusedConv2DT](op: IFusedConv2D[oT]): oT = return op.output


type BatchFFT3D*[oT:ocomplex64] {.header:"generated.h", importcpp:"BatchFFT3D/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibatchFFT3D[oT: ocomplex64](scope: Scope,
                 input: oT): BatchFFT3D[oT] {.header:"generated.h", importcpp:"BatchFFT3D(*#, #)", constructor.}

proc batchFFT3D*[oT: ocomplex64](scope: Scope,
                 input: oT): BatchFFT3D[oT] =
  return iibatchFFT3D(scope,
                      input)

converter batchFFT3DToOut*[oT: ocomplex64](op: BatchFFT3D[oT]): oT = return op.output


type AdjustHue*[oT:ofloat] {.header:"generated.h", importcpp:"AdjustHue/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiadjustHue[oT: ofloat](scope: Scope,
                images: oT,
                delta: oT): AdjustHue[oT] {.header:"generated.h", importcpp:"AdjustHue(*#, #, #)", constructor.}

proc adjustHue*[oT: ofloat](scope: Scope,
                images: oT,
                delta: oT): AdjustHue[oT] =
  return iiadjustHue(scope,
                     images,
                     delta)

converter adjustHueToOut*[oT: ofloat](op: AdjustHue[oT]): oT = return op.output

type SpaceToBatchNDT = oall
type SpaceToBatchNDTblock_shape = oint32 | oint64
type SpaceToBatchNDTpaddings = oint32 | oint64

type SpaceToBatchND*[oT:SpaceToBatchNDT] {.header:"generated.h", importcpp:"SpaceToBatchND/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iispaceToBatchND[oT: SpaceToBatchNDT](scope: Scope,
                     input: oT,
                     block_shape: SpaceToBatchNDTblock_shape,
                     paddings: SpaceToBatchNDTpaddings): SpaceToBatchND[oT] {.header:"generated.h", importcpp:"SpaceToBatchND(*#, #, #, #)", constructor.}

proc spaceToBatchND*[oT: SpaceToBatchNDT](scope: Scope,
                     input: oT,
                     block_shape: SpaceToBatchNDTblock_shape,
                     paddings: SpaceToBatchNDTpaddings): SpaceToBatchND[oT] =
  return iispaceToBatchND(scope,
                          input,
                          block_shape,
                          paddings)

converter spaceToBatchNDToOut*[oT: SpaceToBatchNDT](op: SpaceToBatchND[oT]): oT = return op.output

type QuantizedMaxPoolT = oqint8 | oquint8 | oqint32 | oqint16 | oquint16

type QuantizedMaxPool*[oT:QuantizedMaxPoolT] {.header:"generated.h", importcpp:"QuantizedMaxPool/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiquantizedMaxPool[oT: QuantizedMaxPoolT](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: ArraySlice[int],
                       strides: ArraySlice[int],
                       padding: cstring): QuantizedMaxPool[oT] {.header:"generated.h", importcpp:"QuantizedMaxPool(*#, #, #, #, #, #, tensorflow::string(#))", constructor.}

proc quantizedMaxPool*[oT: QuantizedMaxPoolT](scope: Scope,
                       input: oT,
                       min_input: ofloat,
                       max_input: ofloat,
                       ksize: openArray[int],
                       strides: openArray[int],
                       padding: cstring): QuantizedMaxPool[oT] =
  return iiquantizedMaxPool(scope,
                            input,
                            min_input,
                            max_input,
                            newArraySlice(ksize),
                            newArraySlice(strides),
                            padding)

converter quantizedMaxPoolToOut*[oT: QuantizedMaxPoolT](op: QuantizedMaxPool[oT]): oT = return op.output

type MirrorPadGradT = oall
type MirrorPadGradTpaddings = oint32 | oint64

type MirrorPadGrad*[oT:MirrorPadGradT] {.header:"generated.h", importcpp:"MirrorPadGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimirrorPadGrad[oT: MirrorPadGradT](scope: Scope,
                    input: oT,
                    paddings: MirrorPadGradTpaddings,
                    mode: cstring): MirrorPadGrad[oT] {.header:"generated.h", importcpp:"MirrorPadGrad(*#, #, #, tensorflow::string(#))", constructor.}

proc mirrorPadGrad*[oT: MirrorPadGradT](scope: Scope,
                    input: oT,
                    paddings: MirrorPadGradTpaddings,
                    mode: cstring): MirrorPadGrad[oT] =
  return iimirrorPadGrad(scope,
                         input,
                         paddings,
                         mode)

converter mirrorPadGradToOut*[oT: MirrorPadGradT](op: MirrorPadGrad[oT]): oT = return op.output


type CTCGreedyDecoder*[oT:oint64] {.header:"generated.h", importcpp:"CTCGreedyDecoder/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicTCGreedyDecoder[oT: oint64](scope: Scope,
                       inputs: ofloat,
                       sequence_length: oint32,
                       merge_repeated: bool): CTCGreedyDecoder[oT] {.header:"generated.h", importcpp:"CTCGreedyDecoder(*#, #, #, #)", constructor.}

proc cTCGreedyDecoder*[oT: oint64](scope: Scope,
                       inputs: ofloat,
                       sequence_length: oint32,
                       merge_repeated: bool = false): CTCGreedyDecoder[oT] =
  return iicTCGreedyDecoder(scope,
                            inputs,
                            sequence_length,
                            merge_repeated)

converter cTCGreedyDecoderToOut*[oT: oint64](op: CTCGreedyDecoder[oT]): oT = return op.output

type CopyHostT = oall

type CopyHost*[oT:CopyHostT] {.header:"generated.h", importcpp:"CopyHost/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicopyHost[oT: CopyHostT](scope: Scope,
               input: oT,
               tensor_name: cstring,
               debug_ops_spec: ArraySlice[cstring]): CopyHost[oT] {.header:"generated.h", importcpp:"CopyHost(*#, #, tensorflow::string(#), #)", constructor.}

proc copyHost*[oT: CopyHostT](scope: Scope,
               input: oT,
               tensor_name: cstring,
               debug_ops_spec: openArray[cstring]): CopyHost[oT] =
  return iicopyHost(scope,
                    input,
                    tensor_name,
                    newArraySlice(debug_ops_spec))

converter copyHostToOut*[oT: CopyHostT](op: CopyHost[oT]): oT = return op.output


type MapUnstageNoKey*[oT:oint64] {.header:"generated.h", importcpp:"MapUnstageNoKey/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iimapUnstageNoKey[oT: oint64](scope: Scope,
                      indices: oint32,
                      dtypes: ArraySlice[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64,
                      memory_limit: int64): MapUnstageNoKey[oT] {.header:"generated.h", importcpp:"MapUnstageNoKey(*#, #, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc mapUnstageNoKey*[oT: oint64](scope: Scope,
                      indices: oint32,
                      dtypes: openArray[DType],
                      container: cstring,
                      shared_name: cstring,
                      capacity: int64 = 0,
                      memory_limit: int64 = 0): MapUnstageNoKey[oT] =
  return iimapUnstageNoKey(scope,
                           indices,
                           newArraySlice(dtypes),
                           container,
                           shared_name,
                           capacity,
                           memory_limit)

converter mapUnstageNoKeyToOut*[oT: oint64](op: MapUnstageNoKey[oT]): oT = return op.output

type TensorScatterAddT = oall
type TensorScatterAddTindices = oint32 | oint64

type TensorScatterAdd*[oT:TensorScatterAddT] {.header:"generated.h", importcpp:"TensorScatterAdd/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorScatterAdd[oT: TensorScatterAddT](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterAddTindices,
                       updates: oT): TensorScatterAdd[oT] {.header:"generated.h", importcpp:"TensorScatterAdd(*#, #, #, #)", constructor.}

proc tensorScatterAdd*[oT: TensorScatterAddT](scope: Scope,
                       tensor: oT,
                       indices: TensorScatterAddTindices,
                       updates: oT): TensorScatterAdd[oT] =
  return iitensorScatterAdd(scope,
                            tensor,
                            indices,
                            updates)

converter tensorScatterAddToOut*[oT: TensorScatterAddT](op: TensorScatterAdd[oT]): oT = return op.output


type ExperimentalMaterializedIndexDatasetHandle*[oT:oresource] {.header:"generated.h", importcpp:"ExperimentalMaterializedIndexDatasetHandle/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalMaterializedIndexDatasetHandle[oT: oresource](scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring,
                                                 output_types: ArraySlice[DType],
                                                 output_shapes: ArraySlice[TensorShape]): ExperimentalMaterializedIndexDatasetHandle[oT] {.header:"generated.h", importcpp:"ExperimentalMaterializedIndexDatasetHandle(*#, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc experimentalMaterializedIndexDatasetHandle*[oT: oresource](scope: Scope,
                                                 container: cstring,
                                                 shared_name: cstring,
                                                 output_types: openArray[DType],
                                                 output_shapes: openArray[TensorShape]): ExperimentalMaterializedIndexDatasetHandle[oT] =
  return iiexperimentalMaterializedIndexDatasetHandle(scope,
                                                      container,
                                                      shared_name,
                                                      newArraySlice(output_types),
                                                      newArraySlice(output_shapes))

converter experimentalMaterializedIndexDatasetHandleToOut*[oT: oresource](op: ExperimentalMaterializedIndexDatasetHandle[oT]): oT = return op.output


type BoostedTreesEnsembleResourceHandleOp*[oT:oresource] {.header:"generated.h", importcpp:"BoostedTreesEnsembleResourceHandleOp/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesEnsembleResourceHandleOp[oT: oresource](scope: Scope,
                                           container: cstring,
                                           shared_name: cstring): BoostedTreesEnsembleResourceHandleOp[oT] {.header:"generated.h", importcpp:"BoostedTreesEnsembleResourceHandleOp(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc boostedTreesEnsembleResourceHandleOp*[oT: oresource](scope: Scope,
                                           container: cstring,
                                           shared_name: cstring): BoostedTreesEnsembleResourceHandleOp[oT] =
  return iiboostedTreesEnsembleResourceHandleOp(scope,
                                                container,
                                                shared_name)

converter boostedTreesEnsembleResourceHandleOpToOut*[oT: oresource](op: BoostedTreesEnsembleResourceHandleOp[oT]): oT = return op.output

type SegmentMeanT = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64
type SegmentMeanTindices = oint32 | oint64

type SegmentMean*[oT:SegmentMeanT] {.header:"generated.h", importcpp:"SegmentMean/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iisegmentMean[oT: SegmentMeanT](scope: Scope,
                  data: oT,
                  segment_ids: SegmentMeanTindices): SegmentMean[oT] {.header:"generated.h", importcpp:"SegmentMean(*#, #, #)", constructor.}

proc segmentMean*[oT: SegmentMeanT](scope: Scope,
                  data: oT,
                  segment_ids: SegmentMeanTindices): SegmentMean[oT] =
  return iisegmentMean(scope,
                       data,
                       segment_ids)

converter segmentMeanToOut*[oT: SegmentMeanT](op: SegmentMean[oT]): oT = return op.output


type OptimizeDataset*[oT:ovariant] {.header:"generated.h", importcpp:"OptimizeDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioptimizeDataset[oT: ovariant](scope: Scope,
                      input_dataset: oT,
                      optimizations: ostring,
                      output_types: ArraySlice[DType],
                      output_shapes: ArraySlice[TensorShape]): OptimizeDataset[oT] {.header:"generated.h", importcpp:"OptimizeDataset(*#, #, #, #, #)", constructor.}

proc optimizeDataset*[oT: ovariant](scope: Scope,
                      input_dataset: oT,
                      optimizations: ostring,
                      output_types: openArray[DType],
                      output_shapes: openArray[TensorShape]): OptimizeDataset[oT] =
  return iioptimizeDataset(scope,
                           input_dataset,
                           optimizations,
                           newArraySlice(output_types),
                           newArraySlice(output_shapes))

converter optimizeDatasetToOut*[oT: ovariant](op: OptimizeDataset[oT]): oT = return op.output

type DebugIdentityT = oall

type DebugIdentity*[oT:DebugIdentityT] {.header:"generated.h", importcpp:"DebugIdentity/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidebugIdentity[oT: DebugIdentityT](scope: Scope,
                    input: oT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: ArraySlice[cstring],
                    gated_grpc: bool): DebugIdentity[oT] {.header:"generated.h", importcpp:"DebugIdentity(*#, #, tensorflow::string(#), tensorflow::string(#), #, #)", constructor.}

proc debugIdentity*[oT: DebugIdentityT](scope: Scope,
                    input: oT,
                    device_name: cstring,
                    tensor_name: cstring,
                    debug_urls: openArray[cstring],
                    gated_grpc: bool = false): DebugIdentity[oT] =
  return iidebugIdentity(scope,
                         input,
                         device_name,
                         tensor_name,
                         newArraySlice(debug_urls),
                         gated_grpc)

converter debugIdentityToOut*[oT: DebugIdentityT](op: DebugIdentity[oT]): oT = return op.output

type BroadcastArgsT = oint32 | oint64

type BroadcastArgs*[oT:BroadcastArgsT] {.header:"generated.h", importcpp:"BroadcastArgs/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iibroadcastArgs[oT: BroadcastArgsT](scope: Scope,
                    s0: oT,
                    s1: oT): BroadcastArgs[oT] {.header:"generated.h", importcpp:"BroadcastArgs(*#, #, #)", constructor.}

proc broadcastArgs*[oT: BroadcastArgsT](scope: Scope,
                    s0: oT,
                    s1: oT): BroadcastArgs[oT] =
  return iibroadcastArgs(scope,
                         s0,
                         s1)

converter broadcastArgsToOut*[oT: BroadcastArgsT](op: BroadcastArgs[oT]): oT = return op.output


type DecodeCSV*[oT:oinvalid] {.header:"generated.h", importcpp:"DecodeCSV/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidecodeCSV[oT: oinvalid](scope: Scope,
                records: ostring,
                record_defaults: oT,
                OUT_TYPE: ArraySlice[DType],
                na_value: cstring,
                select_cols: ArraySlice[int],
                field_delim: cstring,
                use_quote_delim: bool): DecodeCSV[oT] {.header:"generated.h", importcpp:"DecodeCSV(*#, #, #, #, tensorflow::string(#), #, tensorflow::string(#), #)", constructor.}

proc decodeCSV*[oT: oinvalid](scope: Scope,
                records: ostring,
                record_defaults: oT,
                OUT_TYPE: openArray[DType],
                na_value: cstring,
                select_cols: openArray[int],
                field_delim: cstring = ",",
                use_quote_delim: bool = true): DecodeCSV[oT] =
  return iidecodeCSV(scope,
                     records,
                     record_defaults,
                     newArraySlice(OUT_TYPE),
                     na_value,
                     newArraySlice(select_cols),
                     field_delim,
                     use_quote_delim)

converter decodeCSVToOut*[oT: oinvalid](op: DecodeCSV[oT]): oT = return op.output


type ExperimentalLMDBDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalLMDBDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalLMDBDataset[oT: ovariant](scope: Scope,
                              filenames: ostring,
                              output_types: ArraySlice[DType],
                              output_shapes: ArraySlice[TensorShape]): ExperimentalLMDBDataset[oT] {.header:"generated.h", importcpp:"ExperimentalLMDBDataset(*#, #, #, #)", constructor.}

proc experimentalLMDBDataset*[oT: ovariant](scope: Scope,
                              filenames: ostring,
                              output_types: openArray[DType],
                              output_shapes: openArray[TensorShape]): ExperimentalLMDBDataset[oT] =
  return iiexperimentalLMDBDataset(scope,
                                   filenames,
                                   newArraySlice(output_types),
                                   newArraySlice(output_shapes))

converter experimentalLMDBDatasetToOut*[oT: ovariant](op: ExperimentalLMDBDataset[oT]): oT = return op.output


type OptionalNone*[oT:ovariant] {.header:"generated.h", importcpp:"OptionalNone/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iioptionalNone[oT: ovariant](scope: Scope): OptionalNone[oT] {.header:"generated.h", importcpp:"OptionalNone(*#)", constructor.}

proc optionalNone*[oT: ovariant](scope: Scope): OptionalNone[oT] =
  return iioptionalNone(scope)

converter optionalNoneToOut*[oT: ovariant](op: OptionalNone[oT]): oT = return op.output


type ExperimentalNumaMapAndBatchDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalNumaMapAndBatchDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalNumaMapAndBatchDataset[oT: ovariant](scope: Scope,
                                         input_dataset: oT,
                                         other_arguments: oinvalid,
                                         batch_size: oint64,
                                         num_parallel_calls: oint64,
                                         drop_remainder: obool,
                                         f: NameAttrList,
                                         Targuments: ArraySlice[DType],
                                         output_types: ArraySlice[DType],
                                         output_shapes: ArraySlice[TensorShape],
                                         preserve_cardinality: bool): ExperimentalNumaMapAndBatchDataset[oT] {.header:"generated.h", importcpp:"ExperimentalNumaMapAndBatchDataset(*#, #, #, #, #, #, #, #, #, #, #)", constructor.}

proc experimentalNumaMapAndBatchDataset*[oT: ovariant](scope: Scope,
                                         input_dataset: oT,
                                         other_arguments: oinvalid,
                                         batch_size: oint64,
                                         num_parallel_calls: oint64,
                                         drop_remainder: obool,
                                         f: NameAttrList,
                                         Targuments: openArray[DType],
                                         output_types: openArray[DType],
                                         output_shapes: openArray[TensorShape],
                                         preserve_cardinality: bool = false): ExperimentalNumaMapAndBatchDataset[oT] =
  return iiexperimentalNumaMapAndBatchDataset(scope,
                                              input_dataset,
                                              other_arguments,
                                              batch_size,
                                              num_parallel_calls,
                                              drop_remainder,
                                              f,
                                              newArraySlice(Targuments),
                                              newArraySlice(output_types),
                                              newArraySlice(output_shapes),
                                              preserve_cardinality)

converter experimentalNumaMapAndBatchDatasetToOut*[oT: ovariant](op: ExperimentalNumaMapAndBatchDataset[oT]): oT = return op.output

type DynamicPartitionT = oall

type DynamicPartition*[oT:DynamicPartitionT] {.header:"generated.h", importcpp:"DynamicPartition/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidynamicPartition[oT: DynamicPartitionT](scope: Scope,
                       data: oT,
                       partitions: oint32,
                       num_partitions: int64): DynamicPartition[oT] {.header:"generated.h", importcpp:"DynamicPartition(*#, #, #, #)", constructor.}

proc dynamicPartition*[oT: DynamicPartitionT](scope: Scope,
                       data: oT,
                       partitions: oint32,
                       num_partitions: int64 = 0): DynamicPartition[oT] =
  return iidynamicPartition(scope,
                            data,
                            partitions,
                            num_partitions)

converter dynamicPartitionToOut*[oT: DynamicPartitionT](op: DynamicPartition[oT]): oT = return op.output

type LinSpaceT = obfloat16 | ofloat | odouble
type LinSpaceTidx = oint32 | oint64

type LinSpace*[oT:LinSpaceT] {.header:"generated.h", importcpp:"LinSpace/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iilinSpace[oT: LinSpaceT](scope: Scope,
               start: oT,
               stop: oT,
               num: LinSpaceTidx): LinSpace[oT] {.header:"generated.h", importcpp:"LinSpace(*#, #, #, #)", constructor.}

proc linSpace*[oT: LinSpaceT](scope: Scope,
               start: oT,
               stop: oT,
               num: LinSpaceTidx): LinSpace[oT] =
  return iilinSpace(scope,
                    start,
                    stop,
                    num)

converter linSpaceToOut*[oT: LinSpaceT](op: LinSpace[oT]): oT = return op.output


type FixedLengthRecordDataset*[oT:ovariant] {.header:"generated.h", importcpp:"FixedLengthRecordDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifixedLengthRecordDataset[oT: ovariant](scope: Scope,
                               filenames: ostring,
                               header_bytes: oint64,
                               record_bytes: oint64,
                               footer_bytes: oint64,
                               buffer_size: oint64): FixedLengthRecordDataset[oT] {.header:"generated.h", importcpp:"FixedLengthRecordDataset(*#, #, #, #, #, #)", constructor.}

proc fixedLengthRecordDataset*[oT: ovariant](scope: Scope,
                               filenames: ostring,
                               header_bytes: oint64,
                               record_bytes: oint64,
                               footer_bytes: oint64,
                               buffer_size: oint64): FixedLengthRecordDataset[oT] =
  return iifixedLengthRecordDataset(scope,
                                    filenames,
                                    header_bytes,
                                    record_bytes,
                                    footer_bytes,
                                    buffer_size)

converter fixedLengthRecordDatasetToOut*[oT: ovariant](op: FixedLengthRecordDataset[oT]): oT = return op.output


type CTCLoss*[oT:ofloat] {.header:"generated.h", importcpp:"CTCLoss/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iicTCLoss[oT: ofloat](scope: Scope,
              inputs: oT,
              labels_indices: oint64,
              labels_values: oint32,
              sequence_length: oint32,
              preprocess_collapse_repeated: bool,
              ctc_merge_repeated: bool,
              ignore_longer_outputs_than_inputs: bool): CTCLoss[oT] {.header:"generated.h", importcpp:"CTCLoss(*#, #, #, #, #, #, #, #)", constructor.}

proc cTCLoss*[oT: ofloat](scope: Scope,
              inputs: oT,
              labels_indices: oint64,
              labels_values: oint32,
              sequence_length: oint32,
              preprocess_collapse_repeated: bool = false,
              ctc_merge_repeated: bool = true,
              ignore_longer_outputs_than_inputs: bool = false): CTCLoss[oT] =
  return iicTCLoss(scope,
                   inputs,
                   labels_indices,
                   labels_values,
                   sequence_length,
                   preprocess_collapse_repeated,
                   ctc_merge_repeated,
                   ignore_longer_outputs_than_inputs)

converter cTCLossToOut*[oT: ofloat](op: CTCLoss[oT]): oT = return op.output

type DebugGradientIdentityT = oall

type DebugGradientIdentity*[oT:DebugGradientIdentityT] {.header:"generated.h", importcpp:"DebugGradientIdentity/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iidebugGradientIdentity[oT: DebugGradientIdentityT](scope: Scope,
                            input: oT): DebugGradientIdentity[oT] {.header:"generated.h", importcpp:"DebugGradientIdentity(*#, #)", constructor.}

proc debugGradientIdentity*[oT: DebugGradientIdentityT](scope: Scope,
                            input: oT): DebugGradientIdentity[oT] =
  return iidebugGradientIdentity(scope,
                                 input)

converter debugGradientIdentityToOut*[oT: DebugGradientIdentityT](op: DebugGradientIdentity[oT]): oT = return op.output

type TensorArraySplitT = oall

type TensorArraySplit*[oT:ofloat] {.header:"generated.h", importcpp:"TensorArraySplit/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitensorArraySplit[oT: ofloat](scope: Scope,
                       handle: ostring,
                       value: TensorArraySplitT,
                       lengths: oint64,
                       flow_in: oT): TensorArraySplit[oT] {.header:"generated.h", importcpp:"TensorArraySplit(*#, #, #, #, #)", constructor.}

proc tensorArraySplit*[oT: ofloat](scope: Scope,
                       handle: ostring,
                       value: TensorArraySplitT,
                       lengths: oint64,
                       flow_in: oT): TensorArraySplit[oT] =
  return iitensorArraySplit(scope,
                            handle,
                            value,
                            lengths,
                            flow_in)

converter tensorArraySplitToOut*[oT: ofloat](op: TensorArraySplit[oT]): oT = return op.output


type UnicodeEncode*[oT:ostring] {.header:"generated.h", importcpp:"UnicodeEncode/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiunicodeEncode[oT: ostring](scope: Scope,
                    input_values: oint32,
                    input_splits: oint64,
                    output_encoding: cstring,
                    errors: cstring,
                    replacement_char: int64): UnicodeEncode[oT] {.header:"generated.h", importcpp:"UnicodeEncode(*#, #, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc unicodeEncode*[oT: ostring](scope: Scope,
                    input_values: oint32,
                    input_splits: oint64,
                    output_encoding: cstring,
                    errors: cstring = "replace",
                    replacement_char: int64 = 65533): UnicodeEncode[oT] =
  return iiunicodeEncode(scope,
                         input_values,
                         input_splits,
                         output_encoding,
                         errors,
                         replacement_char)

converter unicodeEncodeToOut*[oT: ostring](op: UnicodeEncode[oT]): oT = return op.output

type SwitchT = oall

type Switch*[oT:SwitchT] {.header:"generated.h", importcpp:"Switch/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiswitch[oT: SwitchT](scope: Scope,
             data: oT,
             pred: obool): Switch[oT] {.header:"generated.h", importcpp:"Switch(*#, #, #)", constructor.}

proc switch*[oT: SwitchT](scope: Scope,
             data: oT,
             pred: obool): Switch[oT] =
  return iiswitch(scope,
                  data,
                  pred)

converter switchToOut*[oT: SwitchT](op: Switch[oT]): oT = return op.output

type ResourceScatterMulTindices = oint32 | oint64
type ResourceScatterMuldtype = ofloat | odouble | oint32 | ouint8 | oint16 | oint8 | ocomplex64 | oint64 | oqint8 | oquint8 | oqint32 | obfloat16 | ouint16 | ocomplex128 | ohalf | ouint32 | ouint64

type ResourceScatterMul*{.header:"generated.h", importcpp:"ResourceScatterMul/*'0*/".} = object
  operation: Operation[oinvalid]


proc iiresourceScatterMul(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMulTindices,
                         updates: ResourceScatterMuldtype,
                         dtype: DType): ResourceScatterMul {.header:"generated.h", importcpp:"ResourceScatterMul(*#, #, #, #, #)", constructor.}

proc resourceScatterMul*(scope: Scope,
                         resource: oresource,
                         indices: ResourceScatterMulTindices,
                         updates: ResourceScatterMuldtype,
                         dtype: DType = DT_INVALID): ResourceScatterMul =
  return iiresourceScatterMul(scope,
                              resource,
                              indices,
                              updates,
                              dtype)




type WholeFileReader*[oT:ostring] {.header:"generated.h", importcpp:"WholeFileReader/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiwholeFileReader[oT: ostring](scope: Scope,
                      container: cstring,
                      shared_name: cstring): WholeFileReader[oT] {.header:"generated.h", importcpp:"WholeFileReader(*#, tensorflow::string(#), tensorflow::string(#))", constructor.}

proc wholeFileReader*[oT: ostring](scope: Scope,
                      container: cstring,
                      shared_name: cstring): WholeFileReader[oT] =
  return iiwholeFileReader(scope,
                           container,
                           shared_name)

converter wholeFileReaderToOut*[oT: ostring](op: WholeFileReader[oT]): oT = return op.output


type ExperimentalSlidingWindowDataset*[oT:ovariant] {.header:"generated.h", importcpp:"ExperimentalSlidingWindowDataset/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiexperimentalSlidingWindowDataset[oT: ovariant](scope: Scope,
                                       input_dataset: oT,
                                       window_size: oint64,
                                       window_shift: oint64,
                                       window_stride: oint64,
                                       output_types: ArraySlice[DType],
                                       output_shapes: ArraySlice[TensorShape]): ExperimentalSlidingWindowDataset[oT] {.header:"generated.h", importcpp:"ExperimentalSlidingWindowDataset(*#, #, #, #, #, #, #)", constructor.}

proc experimentalSlidingWindowDataset*[oT: ovariant](scope: Scope,
                                       input_dataset: oT,
                                       window_size: oint64,
                                       window_shift: oint64,
                                       window_stride: oint64,
                                       output_types: openArray[DType],
                                       output_shapes: openArray[TensorShape]): ExperimentalSlidingWindowDataset[oT] =
  return iiexperimentalSlidingWindowDataset(scope,
                                            input_dataset,
                                            window_size,
                                            window_shift,
                                            window_stride,
                                            newArraySlice(output_types),
                                            newArraySlice(output_shapes))

converter experimentalSlidingWindowDatasetToOut*[oT: ovariant](op: ExperimentalSlidingWindowDataset[oT]): oT = return op.output


type TakeManySparseFromTensorsMap*[oT:oint64] {.header:"generated.h", importcpp:"TakeManySparseFromTensorsMap/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iitakeManySparseFromTensorsMap[oT: oint64](scope: Scope,
                                   sparse_handles: oT,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: DType): TakeManySparseFromTensorsMap[oT] {.header:"generated.h", importcpp:"TakeManySparseFromTensorsMap(*#, #, tensorflow::string(#), tensorflow::string(#), #)", constructor.}

proc takeManySparseFromTensorsMap*[oT: oint64](scope: Scope,
                                   sparse_handles: oT,
                                   container: cstring,
                                   shared_name: cstring,
                                   dtype: DType = oT[].oTF): TakeManySparseFromTensorsMap[oT] =
  return iitakeManySparseFromTensorsMap(scope,
                                        sparse_handles,
                                        container,
                                        shared_name,
                                        dtype)

converter takeManySparseFromTensorsMapToOut*[oT: oint64](op: TakeManySparseFromTensorsMap[oT]): oT = return op.output


type BoostedTreesMakeQuantileSummaries*[oT:ofloat] {.header:"generated.h", importcpp:"BoostedTreesMakeQuantileSummaries/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iiboostedTreesMakeQuantileSummaries[oT: ofloat](scope: Scope,
                                        float_values: oT,
                                        example_weights: oT,
                                        epsilon: oT,
                                        num_features: int64): BoostedTreesMakeQuantileSummaries[oT] {.header:"generated.h", importcpp:"BoostedTreesMakeQuantileSummaries(*#, #, #, #, #)", constructor.}

proc boostedTreesMakeQuantileSummaries*[oT: ofloat](scope: Scope,
                                        float_values: oT,
                                        example_weights: oT,
                                        epsilon: oT,
                                        num_features: int64 = 0): BoostedTreesMakeQuantileSummaries[oT] =
  return iiboostedTreesMakeQuantileSummaries(scope,
                                             float_values,
                                             example_weights,
                                             epsilon,
                                             num_features)

converter boostedTreesMakeQuantileSummariesToOut*[oT: ofloat](op: BoostedTreesMakeQuantileSummaries[oT]): oT = return op.output

type FractionalMaxPoolGradT = ofloat | odouble | oint32 | oint64

type FractionalMaxPoolGrad*[oT:FractionalMaxPoolGradT] {.header:"generated.h", importcpp:"FractionalMaxPoolGrad/*'0*/".} = object
  operation: Operation[oT]
  output: oT

proc iifractionalMaxPoolGrad[oT: FractionalMaxPoolGradT](scope: Scope,
                            orig_input: oT,
                            orig_output: oT,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool): FractionalMaxPoolGrad[oT] {.header:"generated.h", importcpp:"FractionalMaxPoolGrad(*#, #, #, #, #, #, #)", constructor.}

proc fractionalMaxPoolGrad*[oT: FractionalMaxPoolGradT](scope: Scope,
                            orig_input: oT,
                            orig_output: oT,
                            out_backprop: oT,
                            row_pooling_sequence: oint64,
                            col_pooling_sequence: oint64,
                            overlapping: bool = false): FractionalMaxPoolGrad[oT] =
  return iifractionalMaxPoolGrad(scope,
                                 orig_input,
                                 orig_output,
                                 out_backprop,
                                 row_pooling_sequence,
                                 col_pooling_sequence,
                                 overlapping)

converter fractionalMaxPoolGradToOut*[oT: FractionalMaxPoolGradT](op: FractionalMaxPoolGrad[oT]): oT = return op.output

